- rank: 1
  id: google.adk.runners.InMemoryRunner
  name: InMemoryRunner
  file_path: src/google/adk/runners.py
  type: CLASS
  group: Seed
  usage_score: 40
  docstring: "An in-memory Runner for testing and development.\n\nThis runner uses in-memory implementations for artifact, session, and memory\nservices, providing a lightweight and self-contained environment for agent\nexecution.\n\nAttributes:\n    agent: The root agent to run.\n    app_name: The application name of the runner. Defaults to\n      'InMemoryRunner'."
  constructor_signature: 'def __init__(self, agent: typing.Optional[google.adk.agents.base_agent.BaseAgent], *, app_name: typing.Optional[str]=None, plugins: typing.Optional[list[google.adk.plugins.base_plugin.BasePlugin]]=None, app: typing.Optional[google.adk.apps.app.App]=None, plugin_close_timeout: float=5.0):'
  inherited_methods:
    Runner:
    - signature: 'def run(self, *, user_id: str, session_id: str, new_message: google.genai.types.Content, run_config: typing.Optional[google.adk.agents.run_config.RunConfig]=None) -> typing.Generator[google.adk.events.event.Event, None, None]:'
      docstring: "Runs the agent.\n\nNOTE:\n  This sync interface is only for local testing and convenience purpose.\n  Consider using `run_async` for production usage.\n\nIf event compaction is enabled in the App configuration, it will be\nperformed after all agent events for the current invocation have been\nyielded. The generator will only finish iterating after event\ncompaction is complete.\n\nArgs:\n  user_id: The user ID of the session.\n  session_id: The session ID of the session.\n  new_message: A new message to append to the session.\n  run_config: The run config for the agent.\n\nYields:\n  The events generated by the agent."
    - signature: 'def run_async(self, *, user_id: str, session_id: str, invocation_id: typing.Optional[str]=None, new_message: typing.Optional[google.genai.types.Content]=None, state_delta: typing.Optional[dict[str, typing.Any]]=None, run_config: typing.Optional[google.adk.agents.run_config.RunConfig]=None) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
      docstring: "Main entry method to run the agent in this runner.\n\nIf event compaction is enabled in the App configuration, it will be\nperformed after all agent events for the current invocation have been\nyielded. The async generator will only finish iterating after event\ncompaction is complete. However, this does not block new `run_async`\ncalls for subsequent user queries, which can be started concurrently.\n\nArgs:\n  user_id: The user ID of the session.\n  session_id: The session ID of the session.\n  invocation_id: The invocation ID of the session, set this to resume an\n    interrupted invocation.\n  new_message: A new message to append to the session.\n  state_delta: Optional state changes to apply to the session.\n  run_config: The run config for the agent.\n\nYields:\n  The events generated by the agent.\n\nRaises:\n  ValueError: If the session is not found; If both invocation_id and\n    new_message are None."
    - signature: 'def rewind_async(self, *, user_id: str, session_id: str, rewind_before_invocation_id: str) -> None:'
      docstring: Rewinds the session to before the specified invocation.
    - signature: 'def run_live(self, *, user_id: typing.Optional[str]=None, session_id: typing.Optional[str]=None, live_request_queue: google.adk.agents.live_request_queue.LiveRequestQueue, run_config: typing.Optional[google.adk.agents.run_config.RunConfig]=None, session: typing.Optional[google.adk.sessions.session.Session]=None) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
      docstring: "Runs the agent in live mode (experimental feature).\n\nThe `run_live` method yields a stream of `Event` objects, but not all\nyielded events are saved to the session. Here's a breakdown:\n\n**Events Yielded to Callers:**\n*   **Live Model Audio Events with Inline Data:** Events containing raw\n    audio `Blob` data(`inline_data`).\n*   **Live Model Audio Events with File Data:** Both input and ouput audio\n    data are aggregated into an audio file saved into artifacts. The\n    reference to the file is saved in the event as `file_data`.\n*   **Usage Metadata:** Events containing token usage.\n*   **Transcription Events:** Both partial and non-partial transcription\n    events are yielded.\n*   **Function Call and Response Events:** Always saved.\n*   **Other Control Events:** Most control events are saved.\n\n**Events Saved to the Session:**\n*   **Live Model Audio Events with File Data:** Both input and ouput audio\n    data are aggregated into an audio file saved into\
        \ artifacts. The\n    reference to the file is saved as event in the `file_data` to session\n    if RunConfig.save_live_model_audio_to_session is True.\n*   **Usage Metadata Events:** Saved to the session.\n*   **Non-Partial Transcription Events:** Non-partial transcription events\n    are saved.\n*   **Function Call and Response Events:** Always saved.\n*   **Other Control Events:** Most control events are saved.\n\n**Events Not Saved to the Session:**\n*   **Live Model Audio Events with Inline Data:** Events containing raw\n    audio `Blob` data are **not** saved to the session.\n\nArgs:\n    user_id: The user ID for the session. Required if `session` is None.\n    session_id: The session ID for the session. Required if `session` is\n      None.\n    live_request_queue: The queue for live requests.\n    run_config: The run config for the agent.\n    session: The session to use. This parameter is deprecated, please use\n      `user_id` and `session_id` instead.\n\nYields:\n    AsyncGenerator[Event,\
        \ None]: An asynchronous generator that yields\n    `Event`\n    objects as they are produced by the agent during its live execution.\n\n.. warning::\n    This feature is **experimental** and its API or behavior may change\n    in future releases.\n\n.. NOTE::\n    Either `session` or both `user_id` and `session_id` must be provided."
    - signature: 'def run_debug(self, user_messages: str | list[str], *, user_id: str=''debug_user_id'', session_id: str=''debug_session_id'', run_config: RunConfig | None=None, quiet: bool=False, verbose: bool=False) -> list[google.adk.events.event.Event]:'
      docstring: "Debug helper for quick agent experimentation and testing.\n\nThis convenience method is designed for developers getting started with ADK\nwho want to quickly test agents without dealing with session management,\ncontent formatting, or event streaming. It automatically handles common\nboilerplate while hiding complexity.\n\nIMPORTANT: This is for debugging and experimentation only. For production\nuse, please use the standard run_async() method which provides full control\nover session management, event streaming, and error handling.\n\nArgs:\n    user_messages: Message(s) to send to the agent. Can be: - Single string:\n      \"What is 2+2?\" - List of strings: [\"Hello!\", \"What's my name?\"]\n    user_id: User identifier. Defaults to \"debug_user_id\".\n    session_id: Session identifier for conversation persistence. Defaults to\n      \"debug_session_id\". Reuse the same ID to continue a conversation.\n    run_config: Optional configuration for the agent execution.\n\
        \    quiet: If True, suppresses console output. Defaults to False (output\n      shown).\n    verbose: If True, shows detailed tool calls and responses. Defaults to\n      False for cleaner output showing only final agent responses.\n\nReturns:\n    list[Event]: All events from all messages.\n\nRaises:\n    ValueError: If session creation/retrieval fails.\n\nExamples:\n    Quick debugging:\n    >>> runner = InMemoryRunner(agent=my_agent)\n    >>> await runner.run_debug(\"What is 2+2?\")\n\n    Multiple queries in conversation:\n    >>> await runner.run_debug([\"Hello!\", \"What's my name?\"])\n\n    Continue a debug session:\n    >>> await runner.run_debug(\"What did we discuss?\")  # Continues default\n    session\n\n    Separate debug sessions:\n    >>> await runner.run_debug(\"Hi\", user_id=\"alice\", session_id=\"debug1\")\n    >>> await runner.run_debug(\"Hi\", user_id=\"bob\", session_id=\"debug2\")\n\n    Capture events for inspection:\n    >>> events = await runner.run_debug(\"\
        Analyze this\")\n    >>> for event in events:\n    ...     inspect_event(event)\n\nNote:\n    For production applications requiring:\n    - Custom session/memory services (Spanner, Cloud SQL, etc.)\n    - Fine-grained event processing and streaming\n    - Error recovery and resumability\n    - Performance optimization\n    Please use run_async() with proper configuration."
    - signature: 'def close(self):'
      docstring: Closes the runner.
  inherited_properties:
    Runner:
    - signature: 'app_name: str'
      docstring: The app name of the runner.
    - signature: 'agent: google.adk.agents.base_agent.BaseAgent'
      docstring: The root agent to run.
    - signature: 'artifact_service: typing.Optional[google.adk.artifacts.base_artifact_service.BaseArtifactService]'
      docstring: The artifact service for the runner.
    - signature: 'plugin_manager: google.adk.plugins.plugin_manager.PluginManager'
      docstring: The plugin manager for the runner.
    - signature: 'session_service: google.adk.sessions.base_session_service.BaseSessionService'
      docstring: The session service for the runner.
    - signature: 'memory_service: typing.Optional[google.adk.memory.base_memory_service.BaseMemoryService]'
      docstring: The memory service for the runner.
    - signature: 'credential_service: typing.Optional[google.adk.auth.credential_service.base_credential_service.BaseCredentialService]'
      docstring: The credential service for the runner.
    - signature: 'context_cache_config: typing.Optional[google.adk.agents.context_cache_config.ContextCacheConfig]'
      docstring: The context cache config for the runner.
    - signature: 'resumability_config: typing.Optional[google.adk.apps.app.ResumabilityConfig]'
      docstring: The resumability config for the application.
    - signature: 'Self: str'
- rank: 2
  id: google.adk.tools.agent_tool.AgentTool
  name: AgentTool
  file_path: src/google/adk/tools/agent_tool.py
  type: CLASS
  group: Seed
  usage_score: 30
  docstring: "A tool that wraps an agent.\n\nThis tool allows an agent to be called as a tool within a larger application.\nThe agent's input schema is used to define the tool's input parameters, and\nthe agent's output is returned as the tool's result.\n\nAttributes:\n  agent: The agent to wrap.\n  skip_summarization: Whether to skip summarization of the agent output.\n  include_plugins: Whether to propagate plugins from the parent runner context\n    to the agent's runner. When True (default), the agent will inherit all\n    plugins from its parent. Set to False to run the agent with an isolated\n    plugin environment.\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, agent: google.adk.agents.base_agent.BaseAgent, skip_summarization: bool, *, include_plugins: bool=True):'
  aliases:
  - google.adk.tools.AgentTool
  methods:
  - signature: 'def populate_name(cls, data: typing.Any) -> typing.Any:'
  - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
  - signature: 'def from_config(cls, config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.agent_tool.AgentTool:'
  inherited_methods:
    BaseTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
      docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
      docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  inherited_properties:
    BaseTool:
    - signature: 'name: str'
      docstring: The name of the tool.
    - signature: 'description: str'
      docstring: The description of the tool.
    - signature: 'is_long_running: bool'
      docstring: 'Whether the tool is a long running operation, which typically returns a

        resource id first and finishes the operation later.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the BaseTool.


        An optional key-value pair for storing and retrieving tool-specific metadata,

        such as tool manifests, etc.


        NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 3
  id: google.adk.agents.llm_agent.LlmAgent
  name: LlmAgent
  file_path: src/google/adk/agents/llm_agent.py
  type: CLASS
  group: Seed
  usage_score: 27
  docstring: 'LLM-based Agent.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, name: str, description: str = '''', sub_agents: list[google.adk.agents.base_agent.BaseAgent] = list(), before_agent_callback: typing.Optional[google.adk.agents.base_agent.BeforeAgentCallback] = None, after_agent_callback: typing.Optional[google.adk.agents.base_agent.AfterAgentCallback] = None, model: typing.Union[str, google.adk.models.base_llm.BaseLlm] = '''', instruction: typing.Union[str, google.adk.agents.llm_agent.InstructionProvider] = '''', global_instruction: typing.Union[str, google.adk.agents.llm_agent.InstructionProvider] = '''', static_instruction: typing.Optional[google.genai.types.ContentUnion] = None, tools: list[google.adk.agents.llm_agent.ToolUnion] = list(), generate_content_config: typing.Optional[google.genai.types.GenerateContentConfig] = None, disallow_transfer_to_parent: bool = False, disallow_transfer_to_peers: bool = False, include_contents: typing.Literal[default, none] = ''default'', input_schema: typing.Optional[type[pydantic.BaseModel]]
    = None, output_schema: typing.Optional[type[pydantic.BaseModel]] = None, output_key: typing.Optional[str] = None, planner: typing.Optional[google.adk.planners.base_planner.BasePlanner] = None, code_executor: typing.Optional[google.adk.code_executors.base_code_executor.BaseCodeExecutor] = None, before_model_callback: typing.Optional[google.adk.agents.llm_agent.BeforeModelCallback] = None, after_model_callback: typing.Optional[google.adk.agents.llm_agent.AfterModelCallback] = None, on_model_error_callback: typing.Optional[google.adk.agents.llm_agent.OnModelErrorCallback] = None, before_tool_callback: typing.Optional[google.adk.agents.llm_agent.BeforeToolCallback] = None, after_tool_callback: typing.Optional[google.adk.agents.llm_agent.AfterToolCallback] = None, on_tool_error_callback: typing.Optional[google.adk.agents.llm_agent.OnToolErrorCallback] = None):'
  methods:
  - signature: 'def _run_async_impl(self, ctx: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
  - signature: 'def set_default_model(cls, model: typing.Union[str, google.adk.models.base_llm.BaseLlm]) -> None:'
    docstring: Overrides the default model used when an agent has no model set.
  - signature: 'def validate_generate_content_config(cls, generate_content_config: typing.Optional[google.genai.types.GenerateContentConfig]) -> google.genai.types.GenerateContentConfig:'
  - signature: 'def model_post_init(self, __context: typing.Any) -> None:'
    docstring: Provides a warning if multiple thinking configurations are found.
  properties:
  - signature: 'DEFAULT_MODEL: typing.ClassVar[str]'
    docstring: System default model used when no model is set on an agent.
  - signature: 'model: typing.Union[str, google.adk.models.base_llm.BaseLlm]'
    docstring: 'The model to use for the agent.


      When not set, the agent will inherit the model from its ancestor. If no

      ancestor provides a model, the agent uses the default model configured via

      LlmAgent.set_default_model. The built-in default is gemini-2.5-flash.'
  - signature: 'config_type: typing.ClassVar[typing.Type[google.adk.agents.base_agent_config.BaseAgentConfig]]'
    docstring: The config type for this agent.
  - signature: 'instruction: typing.Union[str, google.adk.agents.llm_agent.InstructionProvider]'
    docstring: 'Dynamic instructions for the LLM model, guiding the agent''s behavior.


      These instructions can contain placeholders like {variable_name} that will be

      resolved at runtime using session state and context.


      **Behavior depends on static_instruction:**

      - If static_instruction is None: instruction goes to system_instruction

      - If static_instruction is set: instruction goes to user content in the request


      This allows for context caching optimization where static content (static_instruction)

      comes first in the prompt, followed by dynamic content (instruction).'
  - signature: 'global_instruction: typing.Union[str, google.adk.agents.llm_agent.InstructionProvider]'
    docstring: 'Instructions for all the agents in the entire agent tree.


      DEPRECATED: This field is deprecated and will be removed in a future version.

      Use GlobalInstructionPlugin instead, which provides the same functionality

      at the App level. See migration guide for details.


      ONLY the global_instruction in root agent will take effect.


      For example: use global_instruction to make all agents have a stable identity

      or personality.'
  - signature: 'static_instruction: typing.Optional[google.genai.types.ContentUnion]'
    docstring: "Static instruction content sent literally as system instruction at the beginning.\n\nThis field is for content that never changes and doesn't contain placeholders.\nIt's sent directly to the model without any processing or variable substitution.\n\nThis field is primarily for context caching optimization. Static instructions\nare sent as system instruction at the beginning of the request, allowing\nfor improved performance when the static portion remains unchanged. Live API\nhas its own cache mechanism, thus this field doesn't work with Live API.\n\n**Impact on instruction field:**\n- When static_instruction is None: instruction \u2192 system_instruction\n- When static_instruction is set: instruction \u2192 user content (after static content)\n\n**Context Caching:**\n- **Implicit Cache**: Automatic caching by model providers (no config needed)\n- **Explicit Cache**: Cache explicitly created by user for instructions, tools and contents\n\nSee below for more information of\
      \ Implicit Cache and Explicit Cache\nGemini API: https://ai.google.dev/gemini-api/docs/caching?lang=python\nVertex API: https://cloud.google.com/vertex-ai/generative-ai/docs/context-cache/context-cache-overview\n\nSetting static_instruction alone does NOT enable caching automatically.\nFor explicit caching control, configure context_cache_config at App level.\n\n**Content Support:**\nAccepts types.ContentUnion which includes:\n- str: Simple text instruction\n- types.Content: Rich content object\n- types.Part: Single part (text, inline_data, file_data, etc.)\n- PIL.Image.Image: Image object\n- types.File: File reference\n- list[PartUnion]: List of parts\n\n**Examples:**\n```python\n# Simple string instruction\nstatic_instruction = \"You are a helpful assistant.\"\n\n# Rich content with files\nstatic_instruction = types.Content(\n    role='user',\n    parts=[\n        types.Part(text='You are a helpful assistant.'),\n        types.Part(file_data=types.FileData(...))\n    ]\n)\n```"
  - signature: 'tools: list[google.adk.agents.llm_agent.ToolUnion]'
    docstring: Tools available to this agent.
  - signature: 'generate_content_config: typing.Optional[google.genai.types.GenerateContentConfig]'
    docstring: 'The additional content generation configurations.


      NOTE: not all fields are usable, e.g. tools must be configured via `tools`,

      thinking_config can be configured here or via the `planner`. If both are set, the planner''s configuration takes precedence.


      For example: use this config to adjust model temperature, configure safety

      settings, etc.'
  - signature: 'disallow_transfer_to_parent: bool'
    docstring: 'Disallows LLM-controlled transferring to the parent agent.


      NOTE: Setting this as True also prevents this agent from continuing to reply

      to the end-user, and will transfer control back to the parent agent in the

      next turn. This behavior prevents one-way transfer, in which end-user may be

      stuck with one agent that cannot transfer to other agents in the agent tree.'
  - signature: 'disallow_transfer_to_peers: bool'
    docstring: Disallows LLM-controlled transferring to the peer agents.
  - signature: 'include_contents: typing.Literal[default, none]'
    docstring: "Controls content inclusion in model requests.\n\nOptions:\n  default: Model receives relevant conversation history\n  none: Model receives no prior history, operates solely on current\n  instruction and input"
  - signature: 'input_schema: typing.Optional[type[pydantic.BaseModel]]'
    docstring: The input schema when agent is used as a tool.
  - signature: 'output_schema: typing.Optional[type[pydantic.BaseModel]]'
    docstring: "The output schema when agent replies.\n\nNOTE:\n  When this is set, agent can ONLY reply and CANNOT use any tools, such as\n  function tools, RAGs, agent transfer, etc."
  - signature: 'output_key: typing.Optional[str]'
    docstring: 'The key in session state to store the output of the agent.


      Typically use cases:

      - Extracts agent reply for later use, such as in tools, callbacks, etc.

      - Connects agents to coordinate with each other.'
  - signature: 'planner: typing.Optional[google.adk.planners.base_planner.BasePlanner]'
    docstring: "Instructs the agent to make a plan and execute it step by step.\n\nNOTE:\n  To use model's built-in thinking features, set the `thinking_config`\n  field in `google.adk.planners.built_in_planner`."
  - signature: 'code_executor: typing.Optional[google.adk.code_executors.base_code_executor.BaseCodeExecutor]'
    docstring: "Allow agent to execute code blocks from model responses using the provided\nCodeExecutor.\n\nCheck out available code executions in `google.adk.code_executor` package.\n\nNOTE:\n  To use model's built-in code executor, use the `BuiltInCodeExecutor`."
  - signature: 'before_model_callback: typing.Optional[google.adk.agents.llm_agent.BeforeModelCallback]'
    docstring: "Callback or list of callbacks to be called before calling the LLM.\n\nWhen a list of callbacks is provided, the callbacks will be called in the\norder they are listed until a callback does not return None.\n\nArgs:\n  callback_context: CallbackContext,\n  llm_request: LlmRequest, The raw model request. Callback can mutate the\n  request.\n\nReturns:\n  The content to return to the user. When present, the model call will be\n  skipped and the provided content will be returned to user."
  - signature: 'after_model_callback: typing.Optional[google.adk.agents.llm_agent.AfterModelCallback]'
    docstring: "Callback or list of callbacks to be called after calling the LLM.\n\nWhen a list of callbacks is provided, the callbacks will be called in the\norder they are listed until a callback does not return None.\n\nArgs:\n  callback_context: CallbackContext,\n  llm_response: LlmResponse, the actual model response.\n\nReturns:\n  The content to return to the user. When present, the actual model response\n  will be ignored and the provided content will be returned to user."
  - signature: 'on_model_error_callback: typing.Optional[google.adk.agents.llm_agent.OnModelErrorCallback]'
    docstring: "Callback or list of callbacks to be called when a model call encounters an error.\n\nWhen a list of callbacks is provided, the callbacks will be called in the\norder they are listed until a callback does not return None.\n\nArgs:\n  callback_context: CallbackContext,\n  llm_request: LlmRequest, The raw model request.\n  error: The error from the model call.\n\nReturns:\n  The content to return to the user. When present, the error will be\n  ignored and the provided content will be returned to user."
  - signature: 'before_tool_callback: typing.Optional[google.adk.agents.llm_agent.BeforeToolCallback]'
    docstring: "Callback or list of callbacks to be called before calling the tool.\n\nWhen a list of callbacks is provided, the callbacks will be called in the\norder they are listed until a callback does not return None.\n\nArgs:\n  tool: The tool to be called.\n  args: The arguments to the tool.\n  tool_context: ToolContext,\n\nReturns:\n  The tool response. When present, the returned tool response will be used and\n  the framework will skip calling the actual tool."
  - signature: 'after_tool_callback: typing.Optional[google.adk.agents.llm_agent.AfterToolCallback]'
    docstring: "Callback or list of callbacks to be called after calling the tool.\n\nWhen a list of callbacks is provided, the callbacks will be called in the\norder they are listed until a callback does not return None.\n\nArgs:\n  tool: The tool to be called.\n  args: The arguments to the tool.\n  tool_context: ToolContext,\n  tool_response: The response from the tool.\n\nReturns:\n  When present, the returned dict will be used as tool result."
  - signature: 'on_tool_error_callback: typing.Optional[google.adk.agents.llm_agent.OnToolErrorCallback]'
    docstring: "Callback or list of callbacks to be called when a tool call encounters an error.\n\nWhen a list of callbacks is provided, the callbacks will be called in the\norder they are listed until a callback does not return None.\n\nArgs:\n  tool: The tool to be called.\n  args: The arguments to the tool.\n  tool_context: ToolContext,\n  error: The error from the tool call.\n\nReturns:\n  When present, the returned dict will be used as tool result."
  inherited_methods:
    BaseAgent:
    - signature: 'def clone(self: google.adk.agents.base_agent.SelfAgent, update: Mapping[str, Any] | None) -> google.adk.agents.base_agent.SelfAgent:'
      docstring: "Creates a copy of this agent instance.\n\nArgs:\n  update: Optional mapping of new values for the fields of the cloned agent.\n    The keys of the mapping are the names of the fields to be updated, and\n    the values are the new values for those fields.\n    For example: {\"name\": \"cloned_agent\"}\n\nReturns:\n  A new agent instance with identical configuration as the original\n  agent except for the fields specified in the update."
    - signature: 'def run_async(self, parent_context: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
      docstring: "Entry method to run an agent via text-based conversation.\n\nArgs:\n  parent_context: InvocationContext, the invocation context of the parent\n    agent.\n\nYields:\n  Event: the events generated by the agent."
    - signature: 'def run_live(self, parent_context: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
      docstring: "Entry method to run an agent via video/audio-based conversation.\n\nArgs:\n  parent_context: InvocationContext, the invocation context of the parent\n    agent.\n\nYields:\n  Event: the events generated by the agent."
    - signature: 'def _run_async_impl(self, ctx: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
      docstring: "Core logic to run this agent via text-based conversation.\n\nArgs:\n  ctx: InvocationContext, the invocation context for this agent.\n\nYields:\n  Event: the events generated by the agent."
    - signature: 'def root_agent(self) -> google.adk.agents.base_agent.BaseAgent:'
      docstring: Gets the root agent of this agent.
    - signature: 'def find_agent(self, name: str) -> typing.Optional[google.adk.agents.base_agent.BaseAgent]:'
      docstring: "Finds the agent with the given name in this agent and its descendants.\n\nArgs:\n  name: The name of the agent to find.\n\nReturns:\n  The agent with the matching name, or None if no such agent is found."
    - signature: 'def find_sub_agent(self, name: str) -> typing.Optional[google.adk.agents.base_agent.BaseAgent]:'
      docstring: "Finds the agent with the given name in this agent's descendants.\n\nArgs:\n  name: The name of the agent to find.\n\nReturns:\n  The agent with the matching name, or None if no such agent is found."
    - signature: 'def model_post_init(self, __context: typing.Any) -> None:'
    - signature: 'def validate_name(cls, value: str):'
    - signature: 'def validate_sub_agents_unique_names(cls, value: list[google.adk.agents.base_agent.BaseAgent]) -> list[google.adk.agents.base_agent.BaseAgent]:'
      docstring: "Validates that all sub-agents have unique names.\n\nArgs:\n  value: The list of sub-agents to validate.\n\nReturns:\n  The validated list of sub-agents."
    - signature: 'def from_config(cls: typing.Type[google.adk.agents.base_agent.SelfAgent], config: google.adk.agents.base_agent_config.BaseAgentConfig, config_abs_path: str) -> google.adk.agents.base_agent.SelfAgent:'
      docstring: "Creates an agent from a config.\n\nIf sub-classes uses a custom agent config, override `_from_config_kwargs`\nmethod to return an updated kwargs for agent constructor.\n\nArgs:\n  config: The config to create the agent from.\n  config_abs_path: The absolute path to the config file that contains the\n    agent config.\n\nReturns:\n  The created agent."
  inherited_properties:
    BaseAgent:
    - signature: 'model_config: pydantic.ConfigDict'
      docstring: The pydantic model config.
    - signature: 'config_type: typing.ClassVar[type[google.adk.agents.base_agent_config.BaseAgentConfig]]'
      docstring: "The config type for this agent.\n\nSub-classes should override this to specify their own config type.\n\nExample:\n\n```\nclass MyAgentConfig(BaseAgentConfig):\n  my_field: str = ''\n\nclass MyAgent(BaseAgent):\n  config_type: ClassVar[type[BaseAgentConfig]] = MyAgentConfig\n```"
    - signature: 'name: str'
      docstring: 'The agent''s name.


        Agent name must be a Python identifier and unique within the agent tree.

        Agent name cannot be "user", since it''s reserved for end-user''s input.'
    - signature: 'description: str'
      docstring: 'Description about the agent''s capability.


        The model uses this to determine whether to delegate control to the agent.

        One-line description is enough and preferred.'
    - signature: 'parent_agent: typing.Optional[google.adk.agents.base_agent.BaseAgent]'
      docstring: 'The parent agent of this agent.


        Note that an agent can ONLY be added as sub-agent once.


        If you want to add one agent twice as sub-agent, consider to create two agent

        instances with identical config, but with different name and add them to the

        agent tree.'
    - signature: 'sub_agents: list[google.adk.agents.base_agent.BaseAgent]'
      docstring: The sub-agents of this agent.
    - signature: 'before_agent_callback: typing.Optional[google.adk.agents.base_agent.BeforeAgentCallback]'
      docstring: "Callback or list of callbacks to be invoked before the agent run.\n\nWhen a list of callbacks is provided, the callbacks will be called in the\norder they are listed until a callback does not return None.\n\nArgs:\n  callback_context: MUST be named 'callback_context' (enforced).\n\nReturns:\n  Optional[types.Content]: The content to return to the user.\n    When the content is present, the agent run will be skipped and the\n    provided content will be returned to user."
    - signature: 'after_agent_callback: typing.Optional[google.adk.agents.base_agent.AfterAgentCallback]'
      docstring: "Callback or list of callbacks to be invoked after the agent run.\n\nWhen a list of callbacks is provided, the callbacks will be called in the\norder they are listed until a callback does not return None.\n\nArgs:\n  callback_context: MUST be named 'callback_context' (enforced).\n\nReturns:\n  Optional[types.Content]: The content to return to the user.\n    When the content is present, an additional event with the provided content\n    will be appended to event history as an additional agent response."
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 4
  id: google.adk.cli.utils.logs.log_to_tmp_folder
  name: log_to_tmp_folder
  file_path: src/google/adk/cli/utils/logs.py
  type: METHOD
  group: Seed
  usage_score: 18
  docstring: "Logs to system temp folder, instead of logging to stderr.\n\nArgs\n  sub_folder: str = 'agents_log',\n  log_file_prefix: str = 'agent',\n  log_file_timestamp: str = time.strftime('%Y%m%d_%H%M%S'),\n\nReturns\n  the log file path."
  signature: 'def log_to_tmp_folder(level, *, sub_folder: str=''agents_log'', log_file_prefix: str=''agent'', log_file_timestamp: str=time.strftime(''%Y%m%d_%H%M%S'')):'
- rank: 5
  id: google.adk.agents.run_config.RunConfig
  name: RunConfig
  file_path: src/google/adk/agents/run_config.py
  type: CLASS
  group: Seed
  usage_score: 16
  docstring: 'Configs for runtime behavior of agents.


    The configs here will be overridden by agent-specific configurations.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, speech_config: typing.Optional[google.genai.types.SpeechConfig] = None, response_modalities: typing.Optional[list[str]] = None, save_input_blobs_as_artifacts: bool = False, support_cfc: bool = False, streaming_mode: google.adk.agents.run_config.StreamingMode = StreamingMode.NONE, output_audio_transcription: typing.Optional[google.genai.types.AudioTranscriptionConfig] = Factory(types.AudioTranscriptionConfig), input_audio_transcription: typing.Optional[google.genai.types.AudioTranscriptionConfig] = Factory(types.AudioTranscriptionConfig), realtime_input_config: typing.Optional[google.genai.types.RealtimeInputConfig] = None, enable_affective_dialog: typing.Optional[bool] = None, proactivity: typing.Optional[google.genai.types.ProactivityConfig] = None, session_resumption: typing.Optional[google.genai.types.SessionResumptionConfig] = None, context_window_compression: typing.Optional[google.genai.types.ContextWindowCompressionConfig] = None, save_live_blob:
    bool = False, tool_thread_pool_config: typing.Optional[google.adk.agents.run_config.ToolThreadPoolConfig] = None, save_live_audio: bool = False, max_llm_calls: int = 500, custom_metadata: typing.Optional[dict[str, typing.Any]] = None):'
  methods:
  - signature: 'def check_for_deprecated_save_live_audio(cls, data: typing.Any) -> typing.Any:'
    docstring: If save_live_audio is passed, use it to set save_live_blob.
  - signature: 'def validate_max_llm_calls(cls, value: int) -> int:'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
    docstring: The pydantic model config.
  - signature: 'speech_config: typing.Optional[google.genai.types.SpeechConfig]'
    docstring: Speech configuration for the live agent.
  - signature: 'response_modalities: typing.Optional[list[str]]'
    docstring: The output modalities. If not set, it's default to AUDIO.
  - signature: 'save_input_blobs_as_artifacts: bool'
  - signature: 'support_cfc: bool'
    docstring: "Whether to support CFC (Compositional Function Calling). Only applicable for\nStreamingMode.SSE. If it's true. the LIVE API will be invoked. Since only LIVE\nAPI supports CFC\n\n.. warning::\n    This feature is **experimental** and its API or behavior may change\n    in future releases."
  - signature: 'streaming_mode: google.adk.agents.run_config.StreamingMode'
    docstring: Streaming mode, None or StreamingMode.SSE or StreamingMode.BIDI.
  - signature: 'output_audio_transcription: typing.Optional[google.genai.types.AudioTranscriptionConfig]'
    docstring: Output transcription for live agents with audio response.
  - signature: 'input_audio_transcription: typing.Optional[google.genai.types.AudioTranscriptionConfig]'
    docstring: Input transcription for live agents with audio input from user.
  - signature: 'realtime_input_config: typing.Optional[google.genai.types.RealtimeInputConfig]'
    docstring: Realtime input config for live agents with audio input from user.
  - signature: 'enable_affective_dialog: typing.Optional[bool]'
    docstring: If enabled, the model will detect emotions and adapt its responses accordingly.
  - signature: 'proactivity: typing.Optional[google.genai.types.ProactivityConfig]'
    docstring: Configures the proactivity of the model. This allows the model to respond proactively to the input and to ignore irrelevant input.
  - signature: 'session_resumption: typing.Optional[google.genai.types.SessionResumptionConfig]'
    docstring: Configures session resumption mechanism. Only support transparent session resumption mode now.
  - signature: 'context_window_compression: typing.Optional[google.genai.types.ContextWindowCompressionConfig]'
    docstring: Configuration for context window compression. If set, this will enable context window compression for LLM input.
  - signature: 'save_live_blob: bool'
    docstring: Saves live video and audio data to session and artifact service.
  - signature: 'tool_thread_pool_config: typing.Optional[google.adk.agents.run_config.ToolThreadPoolConfig]'
    docstring: "Configuration for running tools in a thread pool for live mode.\n\nWhen set, tool executions will run in a separate thread pool executor\ninstead of the main event loop. When None (default), tools run in the\nmain event loop.\n\nThis helps keep the event loop responsive for:\n- User interruptions to be processed immediately\n- Model responses to continue being received\n\nBoth sync and async tools are supported. Async tools are run in a new event\nloop within the background thread, which helps catch blocking I/O mistakenly\nused inside async functions.\n\nIMPORTANT - GIL (Global Interpreter Lock) Considerations:\n\nThread pool HELPS with (GIL is released):\n- Blocking I/O: time.sleep(), network calls, file I/O, database queries\n- C extensions: numpy, hashlib, image processing libraries\n- Async functions containing blocking I/O (common user mistake)\n\nThread pool does NOT help with (GIL is held):\n- Pure Python CPU-bound code: loops, calculations, recursive algorithms\n\
      - The GIL prevents true parallel execution for Python bytecode\n\nFor CPU-intensive Python code, consider alternatives:\n- Use C extensions that release the GIL\n- Break work into chunks with periodic `await asyncio.sleep(0)`\n- Use multiprocessing (ProcessPoolExecutor) for true parallelism\n\nExample:\n  ```python\n  from google.adk.agents.run_config import RunConfig, ToolThreadPoolConfig\n\n  # Enable thread pool with default settings\n  run_config = RunConfig(\n      tool_thread_pool_config=ToolThreadPoolConfig(),\n  )\n\n  # Enable thread pool with custom max_workers\n  run_config = RunConfig(\n      tool_thread_pool_config=ToolThreadPoolConfig(max_workers=8),\n  )\n  ```"
  - signature: 'save_live_audio: bool'
  - signature: 'max_llm_calls: int'
    docstring: "A limit on the total number of llm calls for a given run.\n\nValid Values:\n  - More than 0 and less than sys.maxsize: The bound on the number of llm\n    calls is enforced, if the value is set in this range.\n  - Less than or equal to 0: This allows for unbounded number of llm calls."
  - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
    docstring: Custom metadata for the current invocation.
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 6
  id: google.adk.agents.loop_agent.LoopAgent
  name: LoopAgent
  file_path: src/google/adk/agents/loop_agent.py
  type: CLASS
  group: Seed
  usage_score: 16
  docstring: 'A shell agent that run its sub-agents in a loop.


    When sub-agent generates an event with escalate or max_iterations are

    reached, the loop agent will stop.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, name: str, description: str = '''', sub_agents: list[google.adk.agents.base_agent.BaseAgent] = list(), before_agent_callback: typing.Optional[google.adk.agents.base_agent.BeforeAgentCallback] = None, after_agent_callback: typing.Optional[google.adk.agents.base_agent.AfterAgentCallback] = None, max_iterations: typing.Optional[int] = None):'
  methods:
  - signature: 'def _run_async_impl(self, ctx: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
  properties:
  - signature: 'config_type: typing.ClassVar[type[google.adk.agents.base_agent_config.BaseAgentConfig]]'
    docstring: The config type for this agent.
  - signature: 'max_iterations: typing.Optional[int]'
    docstring: 'The maximum number of iterations to run the loop agent.


      If not set, the loop agent will run indefinitely until a sub-agent

      escalates.'
  inherited_methods:
    BaseAgent:
    - signature: 'def clone(self: google.adk.agents.base_agent.SelfAgent, update: Mapping[str, Any] | None) -> google.adk.agents.base_agent.SelfAgent:'
      docstring: "Creates a copy of this agent instance.\n\nArgs:\n  update: Optional mapping of new values for the fields of the cloned agent.\n    The keys of the mapping are the names of the fields to be updated, and\n    the values are the new values for those fields.\n    For example: {\"name\": \"cloned_agent\"}\n\nReturns:\n  A new agent instance with identical configuration as the original\n  agent except for the fields specified in the update."
    - signature: 'def run_async(self, parent_context: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
      docstring: "Entry method to run an agent via text-based conversation.\n\nArgs:\n  parent_context: InvocationContext, the invocation context of the parent\n    agent.\n\nYields:\n  Event: the events generated by the agent."
    - signature: 'def run_live(self, parent_context: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
      docstring: "Entry method to run an agent via video/audio-based conversation.\n\nArgs:\n  parent_context: InvocationContext, the invocation context of the parent\n    agent.\n\nYields:\n  Event: the events generated by the agent."
    - signature: 'def _run_async_impl(self, ctx: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
      docstring: "Core logic to run this agent via text-based conversation.\n\nArgs:\n  ctx: InvocationContext, the invocation context for this agent.\n\nYields:\n  Event: the events generated by the agent."
    - signature: 'def root_agent(self) -> google.adk.agents.base_agent.BaseAgent:'
      docstring: Gets the root agent of this agent.
    - signature: 'def find_agent(self, name: str) -> typing.Optional[google.adk.agents.base_agent.BaseAgent]:'
      docstring: "Finds the agent with the given name in this agent and its descendants.\n\nArgs:\n  name: The name of the agent to find.\n\nReturns:\n  The agent with the matching name, or None if no such agent is found."
    - signature: 'def find_sub_agent(self, name: str) -> typing.Optional[google.adk.agents.base_agent.BaseAgent]:'
      docstring: "Finds the agent with the given name in this agent's descendants.\n\nArgs:\n  name: The name of the agent to find.\n\nReturns:\n  The agent with the matching name, or None if no such agent is found."
    - signature: 'def model_post_init(self, __context: typing.Any) -> None:'
    - signature: 'def validate_name(cls, value: str):'
    - signature: 'def validate_sub_agents_unique_names(cls, value: list[google.adk.agents.base_agent.BaseAgent]) -> list[google.adk.agents.base_agent.BaseAgent]:'
      docstring: "Validates that all sub-agents have unique names.\n\nArgs:\n  value: The list of sub-agents to validate.\n\nReturns:\n  The validated list of sub-agents."
    - signature: 'def from_config(cls: typing.Type[google.adk.agents.base_agent.SelfAgent], config: google.adk.agents.base_agent_config.BaseAgentConfig, config_abs_path: str) -> google.adk.agents.base_agent.SelfAgent:'
      docstring: "Creates an agent from a config.\n\nIf sub-classes uses a custom agent config, override `_from_config_kwargs`\nmethod to return an updated kwargs for agent constructor.\n\nArgs:\n  config: The config to create the agent from.\n  config_abs_path: The absolute path to the config file that contains the\n    agent config.\n\nReturns:\n  The created agent."
  inherited_properties:
    BaseAgent:
    - signature: 'model_config: pydantic.ConfigDict'
      docstring: The pydantic model config.
    - signature: 'config_type: typing.ClassVar[type[google.adk.agents.base_agent_config.BaseAgentConfig]]'
      docstring: "The config type for this agent.\n\nSub-classes should override this to specify their own config type.\n\nExample:\n\n```\nclass MyAgentConfig(BaseAgentConfig):\n  my_field: str = ''\n\nclass MyAgent(BaseAgent):\n  config_type: ClassVar[type[BaseAgentConfig]] = MyAgentConfig\n```"
    - signature: 'name: str'
      docstring: 'The agent''s name.


        Agent name must be a Python identifier and unique within the agent tree.

        Agent name cannot be "user", since it''s reserved for end-user''s input.'
    - signature: 'description: str'
      docstring: 'Description about the agent''s capability.


        The model uses this to determine whether to delegate control to the agent.

        One-line description is enough and preferred.'
    - signature: 'parent_agent: typing.Optional[google.adk.agents.base_agent.BaseAgent]'
      docstring: 'The parent agent of this agent.


        Note that an agent can ONLY be added as sub-agent once.


        If you want to add one agent twice as sub-agent, consider to create two agent

        instances with identical config, but with different name and add them to the

        agent tree.'
    - signature: 'sub_agents: list[google.adk.agents.base_agent.BaseAgent]'
      docstring: The sub-agents of this agent.
    - signature: 'before_agent_callback: typing.Optional[google.adk.agents.base_agent.BeforeAgentCallback]'
      docstring: "Callback or list of callbacks to be invoked before the agent run.\n\nWhen a list of callbacks is provided, the callbacks will be called in the\norder they are listed until a callback does not return None.\n\nArgs:\n  callback_context: MUST be named 'callback_context' (enforced).\n\nReturns:\n  Optional[types.Content]: The content to return to the user.\n    When the content is present, the agent run will be skipped and the\n    provided content will be returned to user."
    - signature: 'after_agent_callback: typing.Optional[google.adk.agents.base_agent.AfterAgentCallback]'
      docstring: "Callback or list of callbacks to be invoked after the agent run.\n\nWhen a list of callbacks is provided, the callbacks will be called in the\norder they are listed until a callback does not return None.\n\nArgs:\n  callback_context: MUST be named 'callback_context' (enforced).\n\nReturns:\n  Optional[types.Content]: The content to return to the user.\n    When the content is present, an additional event with the provided content\n    will be appended to event history as an additional agent response."
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 7
  id: google.adk.models.llm_response.LlmResponse
  name: LlmResponse
  file_path: src/google/adk/models/llm_response.py
  type: CLASS
  group: Seed
  usage_score: 16
  docstring: "LLM response class that provides the first candidate response from the\n\nmodel if available. Otherwise, returns error code and message.\n\nAttributes:\n  content: The content of the response.\n  grounding_metadata: The grounding metadata of the response.\n  partial: Indicates whether the text content is part of an unfinished text\n    stream. Only used for streaming mode and when the content is plain text.\n  turn_complete: Indicates whether the response from the model is complete.\n    Only used for streaming mode.\n  error_code: Error code if the response is an error. Code varies by model.\n  error_message: Error message if the response is an error.\n  interrupted: Flag indicating that LLM was interrupted when generating the\n    content. Usually it's due to user interruption during a bidi streaming.\n  custom_metadata: The custom metadata of the LlmResponse.\n  input_transcription: Audio transcription of user input.\n  output_transcription: Audio transcription of model\
    \ output.\n  avg_logprobs: Average log probability of the generated tokens.\n  logprobs_result: Detailed log probabilities for chosen and top candidate tokens.\n\n[Note: Inherited members from pydantic.BaseModel are omitted.]"
  constructor_signature: 'def __init__(self, *, model_version: typing.Optional[str] = None, content: typing.Optional[google.genai.types.Content] = None, grounding_metadata: typing.Optional[google.genai.types.GroundingMetadata] = None, partial: typing.Optional[bool] = None, turn_complete: typing.Optional[bool] = None, finish_reason: typing.Optional[google.genai.types.FinishReason] = None, error_code: typing.Optional[str] = None, error_message: typing.Optional[str] = None, interrupted: typing.Optional[bool] = None, custom_metadata: typing.Optional[dict[str, typing.Any]] = None, usage_metadata: typing.Optional[google.genai.types.GenerateContentResponseUsageMetadata] = None, live_session_resumption_update: typing.Optional[google.genai.types.LiveServerSessionResumptionUpdate] = None, input_transcription: typing.Optional[google.genai.types.Transcription] = None, output_transcription: typing.Optional[google.genai.types.Transcription] = None, avg_logprobs: typing.Optional[float] = None, logprobs_result:
    typing.Optional[google.genai.types.LogprobsResult] = None, cache_metadata: typing.Optional[google.adk.models.cache_metadata.CacheMetadata] = None, citation_metadata: typing.Optional[google.genai.types.CitationMetadata] = None, interaction_id: typing.Optional[str] = None):'
  methods:
  - signature: 'def create(generate_content_response: google.genai.types.GenerateContentResponse) -> google.adk.models.llm_response.LlmResponse:'
    docstring: "Creates an LlmResponse from a GenerateContentResponse.\n\nArgs:\n  generate_content_response: The GenerateContentResponse to create the\n    LlmResponse from.\n\nReturns:\n  The LlmResponse."
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
    docstring: The pydantic model config.
  - signature: 'model_version: typing.Optional[str]'
    docstring: Output only. The model version used to generate the response.
  - signature: 'content: typing.Optional[google.genai.types.Content]'
    docstring: 'The generative content of the response.


      This should only contain content from the user or the model, and not any

      framework or system-generated data.'
  - signature: 'grounding_metadata: typing.Optional[google.genai.types.GroundingMetadata]'
    docstring: The grounding metadata of the response.
  - signature: 'partial: typing.Optional[bool]'
    docstring: 'Indicates whether the text content is part of an unfinished text stream.


      Only used for streaming mode and when the content is plain text.'
  - signature: 'turn_complete: typing.Optional[bool]'
    docstring: 'Indicates whether the response from the model is complete.


      Only used for streaming mode.'
  - signature: 'finish_reason: typing.Optional[google.genai.types.FinishReason]'
    docstring: The finish reason of the response.
  - signature: 'error_code: typing.Optional[str]'
    docstring: Error code if the response is an error. Code varies by model.
  - signature: 'error_message: typing.Optional[str]'
    docstring: Error message if the response is an error.
  - signature: 'interrupted: typing.Optional[bool]'
    docstring: 'Flag indicating that LLM was interrupted when generating the content.

      Usually it''s due to user interruption during a bidi streaming.'
  - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
    docstring: 'The custom metadata of the LlmResponse.


      An optional key-value pair to label an LlmResponse.


      NOTE: the entire dict must be JSON serializable.'
  - signature: 'usage_metadata: typing.Optional[google.genai.types.GenerateContentResponseUsageMetadata]'
    docstring: The usage metadata of the LlmResponse
  - signature: 'live_session_resumption_update: typing.Optional[google.genai.types.LiveServerSessionResumptionUpdate]'
    docstring: The session resumption update of the LlmResponse
  - signature: 'input_transcription: typing.Optional[google.genai.types.Transcription]'
    docstring: Audio transcription of user input.
  - signature: 'output_transcription: typing.Optional[google.genai.types.Transcription]'
    docstring: Audio transcription of model output.
  - signature: 'avg_logprobs: typing.Optional[float]'
    docstring: Average log probability of the generated tokens.
  - signature: 'logprobs_result: typing.Optional[google.genai.types.LogprobsResult]'
    docstring: Detailed log probabilities for chosen and top candidate tokens.
  - signature: 'cache_metadata: typing.Optional[google.adk.models.cache_metadata.CacheMetadata]'
    docstring: 'Context cache metadata if caching was used for this response.


      Contains cache identification, usage tracking, and lifecycle information.

      This field is automatically populated when context caching is enabled.'
  - signature: 'citation_metadata: typing.Optional[google.genai.types.CitationMetadata]'
    docstring: 'Citation metadata for the response.


      This field is automatically populated when citation is enabled.'
  - signature: 'interaction_id: typing.Optional[str]'
    docstring: 'The interaction ID from the interactions API.


      This field is populated when using the interactions API for model invocation.

      It can be used to identify and chain interactions for stateful conversations.'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 8
  id: google.adk.cli.utils.logs.setup_adk_logger
  name: setup_adk_logger
  file_path: src/google/adk/cli/utils/logs.py
  type: METHOD
  group: Seed
  usage_score: 14
  signature: 'def setup_adk_logger(level):'
- rank: 9
  id: google.adk.evaluation.agent_evaluator.AgentEvaluator.evaluate
  name: evaluate
  file_path: src/google/adk/evaluation/agent_evaluator.py
  type: METHOD
  group: Seed
  usage_score: 14
  docstring: "Evaluates an Agent given eval data.\n\nArgs:\n  agent_module: The path to python module that contains the definition of\n    the agent. There is convention in place here, where the code is going to\n    look for 'root_agent' or 'get_agent_async' in the loaded module.\n  eval_dataset_file_path_or_dir: The eval data set. This can be either a\n    string representing full path to the file containing eval dataset, or a\n    directory that is recursively explored for all files that have a\n    `.test.json` suffix.\n  num_runs: Number of times all entries in the eval dataset should be\n    assessed.\n  agent_name: The name of the agent.\n  initial_session_file: File that contains initial session state that is\n    needed by all the evals in the eval dataset.\n  print_detailed_results: Whether to print detailed results for each metric\n    evaluation."
  signature: 'def evaluate(agent_module: str, eval_dataset_file_path_or_dir: str, num_runs: int, agent_name: typing.Optional[str], initial_session_file: typing.Optional[str], print_detailed_results: bool):'
- rank: 10
  id: google.adk.events.event.Event
  name: Event
  file_path: src/google/adk/events/event.py
  type: CLASS
  group: Seed
  usage_score: 14
  docstring: 'Represents an event in a conversation between agents and users.


    It is used to store the content of the conversation, as well as the actions

    taken by the agents like function calls, etc.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, model_version: typing.Optional[str] = None, content: typing.Optional[google.genai.types.Content] = None, grounding_metadata: typing.Optional[google.genai.types.GroundingMetadata] = None, partial: typing.Optional[bool] = None, turn_complete: typing.Optional[bool] = None, finish_reason: typing.Optional[google.genai.types.FinishReason] = None, error_code: typing.Optional[str] = None, error_message: typing.Optional[str] = None, interrupted: typing.Optional[bool] = None, custom_metadata: typing.Optional[dict[str, typing.Any]] = None, usage_metadata: typing.Optional[google.genai.types.GenerateContentResponseUsageMetadata] = None, live_session_resumption_update: typing.Optional[google.genai.types.LiveServerSessionResumptionUpdate] = None, input_transcription: typing.Optional[google.genai.types.Transcription] = None, output_transcription: typing.Optional[google.genai.types.Transcription] = None, avg_logprobs: typing.Optional[float] = None, logprobs_result:
    typing.Optional[google.genai.types.LogprobsResult] = None, cache_metadata: typing.Optional[google.adk.models.cache_metadata.CacheMetadata] = None, citation_metadata: typing.Optional[google.genai.types.CitationMetadata] = None, interaction_id: typing.Optional[str] = None, author: str, actions: google.adk.events.event_actions.EventActions = Factory(EventActions), long_running_tool_ids: typing.Optional[set[str]] = None, branch: typing.Optional[str] = None, id: str = '''', timestamp: float = Factory(lambda: datetime.now().timestamp())):'
  aliases:
  - google.adk.events.Event
  methods:
  - signature: 'def model_post_init(self, __context):'
    docstring: Post initialization logic for the event.
  - signature: 'def is_final_response(self) -> bool:'
    docstring: 'Returns whether the event is the final response of an agent.


      NOTE: This method is ONLY for use by Agent Development Kit.


      Note that when multiple agents participate in one invocation, there could be

      one event has `is_final_response()` as True for each participating agent.'
  - signature: 'def get_function_calls(self) -> list[google.genai.types.FunctionCall]:'
    docstring: Returns the function calls in the event.
  - signature: 'def get_function_responses(self) -> list[google.genai.types.FunctionResponse]:'
    docstring: Returns the function responses in the event.
  - signature: 'def has_trailing_code_execution_result(self) -> bool:'
    docstring: Returns whether the event has a trailing code execution result.
  - signature: 'def new_id():'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
    docstring: The pydantic model config.
  - signature: 'invocation_id: str'
    docstring: The invocation ID of the event. Should be non-empty before appending to a session.
  - signature: 'author: str'
    docstring: '''user'' or the name of the agent, indicating who appended the event to the

      session.'
  - signature: 'actions: google.adk.events.event_actions.EventActions'
    docstring: The actions taken by the agent.
  - signature: 'long_running_tool_ids: typing.Optional[set[str]]'
    docstring: 'Set of ids of the long running function calls.

      Agent client will know from this field about which function call is long running.

      only valid for function call event'
  - signature: 'branch: typing.Optional[str]'
    docstring: 'The branch of the event.


      The format is like agent_1.agent_2.agent_3, where agent_1 is the parent of

      agent_2, and agent_2 is the parent of agent_3.


      Branch is used when multiple sub-agent shouldn''t see their peer agents''

      conversation history.'
  - signature: 'id: str'
    docstring: The unique identifier of the event.
  - signature: 'timestamp: float'
    docstring: The timestamp of the event.
  inherited_methods:
    LlmResponse:
    - signature: 'def create(generate_content_response: google.genai.types.GenerateContentResponse) -> google.adk.models.llm_response.LlmResponse:'
      docstring: "Creates an LlmResponse from a GenerateContentResponse.\n\nArgs:\n  generate_content_response: The GenerateContentResponse to create the\n    LlmResponse from.\n\nReturns:\n  The LlmResponse."
  inherited_properties:
    LlmResponse:
    - signature: 'model_config: pydantic.ConfigDict'
      docstring: The pydantic model config.
    - signature: 'model_version: typing.Optional[str]'
      docstring: Output only. The model version used to generate the response.
    - signature: 'content: typing.Optional[google.genai.types.Content]'
      docstring: 'The generative content of the response.


        This should only contain content from the user or the model, and not any

        framework or system-generated data.'
    - signature: 'grounding_metadata: typing.Optional[google.genai.types.GroundingMetadata]'
      docstring: The grounding metadata of the response.
    - signature: 'partial: typing.Optional[bool]'
      docstring: 'Indicates whether the text content is part of an unfinished text stream.


        Only used for streaming mode and when the content is plain text.'
    - signature: 'turn_complete: typing.Optional[bool]'
      docstring: 'Indicates whether the response from the model is complete.


        Only used for streaming mode.'
    - signature: 'finish_reason: typing.Optional[google.genai.types.FinishReason]'
      docstring: The finish reason of the response.
    - signature: 'error_code: typing.Optional[str]'
      docstring: Error code if the response is an error. Code varies by model.
    - signature: 'error_message: typing.Optional[str]'
      docstring: Error message if the response is an error.
    - signature: 'interrupted: typing.Optional[bool]'
      docstring: 'Flag indicating that LLM was interrupted when generating the content.

        Usually it''s due to user interruption during a bidi streaming.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the LlmResponse.


        An optional key-value pair to label an LlmResponse.


        NOTE: the entire dict must be JSON serializable.'
    - signature: 'usage_metadata: typing.Optional[google.genai.types.GenerateContentResponseUsageMetadata]'
      docstring: The usage metadata of the LlmResponse
    - signature: 'live_session_resumption_update: typing.Optional[google.genai.types.LiveServerSessionResumptionUpdate]'
      docstring: The session resumption update of the LlmResponse
    - signature: 'input_transcription: typing.Optional[google.genai.types.Transcription]'
      docstring: Audio transcription of user input.
    - signature: 'output_transcription: typing.Optional[google.genai.types.Transcription]'
      docstring: Audio transcription of model output.
    - signature: 'avg_logprobs: typing.Optional[float]'
      docstring: Average log probability of the generated tokens.
    - signature: 'logprobs_result: typing.Optional[google.genai.types.LogprobsResult]'
      docstring: Detailed log probabilities for chosen and top candidate tokens.
    - signature: 'cache_metadata: typing.Optional[google.adk.models.cache_metadata.CacheMetadata]'
      docstring: 'Context cache metadata if caching was used for this response.


        Contains cache identification, usage tracking, and lifecycle information.

        This field is automatically populated when context caching is enabled.'
    - signature: 'citation_metadata: typing.Optional[google.genai.types.CitationMetadata]'
      docstring: 'Citation metadata for the response.


        This field is automatically populated when citation is enabled.'
    - signature: 'interaction_id: typing.Optional[str]'
      docstring: 'The interaction ID from the interactions API.


        This field is populated when using the interactions API for model invocation.

        It can be used to identify and chain interactions for stateful conversations.'
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 11
  id: google.adk.artifacts.in_memory_artifact_service.InMemoryArtifactService
  name: InMemoryArtifactService
  file_path: src/google/adk/artifacts/in_memory_artifact_service.py
  type: CLASS
  group: Seed
  usage_score: 12
  docstring: 'An in-memory implementation of the artifact service.


    It is not suitable for multi-threaded production environments. Use it for

    testing and development only.


    [Note: Inherited members from ABC, pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, artifacts: dict[str, list[google.adk.artifacts.in_memory_artifact_service._ArtifactEntry]] = dict()):'
  methods:
  - signature: 'def save_artifact(self, *, app_name: str, user_id: str, filename: str, artifact: google.genai.types.Part, session_id: typing.Optional[str]=None, custom_metadata: typing.Optional[dict[str, typing.Any]]=None) -> int:'
  - signature: 'def load_artifact(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None, version: typing.Optional[int]=None) -> typing.Optional[google.genai.types.Part]:'
  - signature: 'def list_artifact_keys(self, *, app_name: str, user_id: str, session_id: typing.Optional[str]=None) -> list[str]:'
  - signature: 'def delete_artifact(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> None:'
  - signature: 'def list_versions(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> list[int]:'
  - signature: 'def list_artifact_versions(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> list[google.adk.artifacts.base_artifact_service.ArtifactVersion]:'
  - signature: 'def get_artifact_version(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None, version: typing.Optional[int]=None) -> typing.Optional[google.adk.artifacts.base_artifact_service.ArtifactVersion]:'
  properties:
  - signature: 'artifacts: dict[str, list[google.adk.artifacts.in_memory_artifact_service._ArtifactEntry]]'
  inherited_methods:
    BaseArtifactService:
    - signature: 'def save_artifact(self, *, app_name: str, user_id: str, filename: str, artifact: google.genai.types.Part, session_id: typing.Optional[str]=None, custom_metadata: typing.Optional[dict[str, typing.Any]]=None) -> int:'
      docstring: "Saves an artifact to the artifact service storage.\n\nThe artifact is a file identified by the app name, user ID, session ID, and\nfilename. After saving the artifact, a revision ID is returned to identify\nthe artifact version.\n\nArgs:\n  app_name: The app name.\n  user_id: The user ID.\n  filename: The filename of the artifact.\n  artifact: The artifact to save. If the artifact consists of `file_data`,\n    the artifact service assumes its content has been uploaded separately,\n    and this method will associate the `file_data` with the artifact if\n    necessary.\n  session_id: The session ID. If `None`, the artifact is user-scoped.\n  custom_metadata: custom metadata to associate with the artifact.\n\nReturns:\n  The revision ID. The first version of the artifact has a revision ID of 0.\n  This is incremented by 1 after each successful save."
    - signature: 'def load_artifact(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None, version: typing.Optional[int]=None) -> typing.Optional[google.genai.types.Part]:'
      docstring: "Gets an artifact from the artifact service storage.\n\nThe artifact is a file identified by the app name, user ID, session ID, and\nfilename.\n\nArgs:\n  app_name: The app name.\n  user_id: The user ID.\n  filename: The filename of the artifact.\n  session_id: The session ID. If `None`, load the user-scoped artifact.\n  version: The version of the artifact. If None, the latest version will be\n    returned.\n\nReturns:\n  The artifact or None if not found."
    - signature: 'def list_artifact_keys(self, *, app_name: str, user_id: str, session_id: typing.Optional[str]=None) -> list[str]:'
      docstring: "Lists all the artifact filenames within a session.\n\nArgs:\n    app_name: The name of the application.\n    user_id: The ID of the user.\n    session_id: The ID of the session.\n\nReturns:\n    A list of artifact filenames. If `session_id` is provided, returns\n    both session-scoped and user-scoped artifact filenames. If `session_id`\n    is `None`, returns\n    user-scoped artifact filenames."
    - signature: 'def delete_artifact(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> None:'
      docstring: "Deletes an artifact.\n\nArgs:\n    app_name: The name of the application.\n    user_id: The ID of the user.\n    filename: The name of the artifact file.\n    session_id: The ID of the session. If `None`, delete the user-scoped\n      artifact."
    - signature: 'def list_versions(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> list[int]:'
      docstring: "Lists all versions of an artifact.\n\nArgs:\n    app_name: The name of the application.\n    user_id: The ID of the user.\n    filename: The name of the artifact file.\n    session_id: The ID of the session. If `None`, only list the user-scoped\n      artifacts versions.\n\nReturns:\n    A list of all available versions of the artifact."
    - signature: 'def list_artifact_versions(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> list[google.adk.artifacts.base_artifact_service.ArtifactVersion]:'
      docstring: "Lists all versions and their metadata for a specific artifact.\n\nArgs:\n  app_name: The name of the application.\n  user_id: The ID of the user.\n  filename: The name of the artifact file.\n  session_id: The ID of the session. If `None`, lists versions of the\n    user-scoped artifact. Otherwise, lists versions of the artifact within\n    the specified session.\n\nReturns:\n  A list of ArtifactVersion objects, each representing a version of the\n  artifact and its associated metadata."
    - signature: 'def get_artifact_version(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None, version: typing.Optional[int]=None) -> typing.Optional[google.adk.artifacts.base_artifact_service.ArtifactVersion]:'
      docstring: "Gets the metadata for a specific version of an artifact.\n\nArgs:\n  app_name: The name of the application.\n  user_id: The ID of the user.\n  filename: The name of the artifact file.\n  session_id: The ID of the session. If `None`, the artifact will be fetched\n    from the user-scoped artifacts. Otherwise, it will be fetched from the\n    specified session.\n  version: The version number of the artifact to retrieve. If `None`, the\n    latest version will be returned.\n\nReturns:\n  An ArtifactVersion object containing the metadata of the specified\n  artifact version, or `None` if the artifact version is not found."
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
  - ABC
- rank: 12
  id: google.adk.sessions.in_memory_session_service.InMemorySessionService
  name: InMemorySessionService
  file_path: src/google/adk/sessions/in_memory_session_service.py
  type: CLASS
  group: Seed
  usage_score: 11
  docstring: 'An in-memory implementation of the session service.


    It is not suitable for multi-threaded production environments. Use it for

    testing and development only.


    [Note: Inherited members from abc.ABC are omitted.]'
  constructor_signature: 'def __init__(self):'
  methods:
  - signature: 'def create_session(self, *, app_name: str, user_id: str, state: typing.Optional[dict[str, typing.Any]]=None, session_id: typing.Optional[str]=None) -> google.adk.sessions.session.Session:'
  - signature: 'def create_session_sync(self, *, app_name: str, user_id: str, state: typing.Optional[dict[str, typing.Any]]=None, session_id: typing.Optional[str]=None) -> google.adk.sessions.session.Session:'
  - signature: 'def get_session(self, *, app_name: str, user_id: str, session_id: str, config: typing.Optional[google.adk.sessions.base_session_service.GetSessionConfig]=None) -> typing.Optional[google.adk.sessions.session.Session]:'
  - signature: 'def get_session_sync(self, *, app_name: str, user_id: str, session_id: str, config: typing.Optional[google.adk.sessions.base_session_service.GetSessionConfig]=None) -> typing.Optional[google.adk.sessions.session.Session]:'
  - signature: 'def list_sessions(self, *, app_name: str, user_id: typing.Optional[str]=None) -> google.adk.sessions.base_session_service.ListSessionsResponse:'
  - signature: 'def list_sessions_sync(self, *, app_name: str, user_id: typing.Optional[str]=None) -> google.adk.sessions.base_session_service.ListSessionsResponse:'
  - signature: 'def delete_session(self, *, app_name: str, user_id: str, session_id: str) -> None:'
  - signature: 'def delete_session_sync(self, *, app_name: str, user_id: str, session_id: str) -> None:'
  - signature: 'def append_event(self, session: google.adk.sessions.session.Session, event: google.adk.events.event.Event) -> google.adk.events.event.Event:'
  inherited_methods:
    BaseSessionService:
    - signature: 'def create_session(self, *, app_name: str, user_id: str, state: typing.Optional[dict[str, typing.Any]]=None, session_id: typing.Optional[str]=None) -> google.adk.sessions.session.Session:'
      docstring: "Creates a new session.\n\nArgs:\n  app_name: the name of the app.\n  user_id: the id of the user.\n  state: the initial state of the session.\n  session_id: the client-provided id of the session. If not provided, a\n    generated ID will be used.\n\nReturns:\n  session: The newly created session instance."
    - signature: 'def get_session(self, *, app_name: str, user_id: str, session_id: str, config: typing.Optional[google.adk.sessions.base_session_service.GetSessionConfig]=None) -> typing.Optional[google.adk.sessions.session.Session]:'
      docstring: Gets a session.
    - signature: 'def list_sessions(self, *, app_name: str, user_id: typing.Optional[str]=None) -> google.adk.sessions.base_session_service.ListSessionsResponse:'
      docstring: "Lists all the sessions for a user.\n\nArgs:\n  app_name: The name of the app.\n  user_id: The ID of the user. If not provided, lists all sessions for all\n    users.\n\nReturns:\n  A ListSessionsResponse containing the sessions."
    - signature: 'def delete_session(self, *, app_name: str, user_id: str, session_id: str) -> None:'
      docstring: Deletes a session.
    - signature: 'def append_event(self, session: google.adk.sessions.session.Session, event: google.adk.events.event.Event) -> google.adk.events.event.Event:'
      docstring: Appends an event to a session object.
  omitted_inherited_members_from:
  - abc.ABC
- rank: 13
  id: google.adk.models.lite_llm.LiteLlm
  name: LiteLlm
  file_path: src/google/adk/models/lite_llm.py
  type: CLASS
  group: Seed
  usage_score: 10
  docstring: "Wrapper around litellm.\n\nThis wrapper can be used with any of the models supported by litellm. The\nenvironment variable(s) needed for authenticating with the model endpoint must\nbe set prior to instantiating this class.\n\nExample usage:\n```\nos.environ[\"VERTEXAI_PROJECT\"] = \"your-gcp-project-id\"\nos.environ[\"VERTEXAI_LOCATION\"] = \"your-gcp-location\"\n\nagent = Agent(\n    model=LiteLlm(model=\"vertex_ai/claude-3-7-sonnet@20250219\"),\n    ...\n)\n```\n\nAttributes:\n  model: The name of the LiteLlm model.\n  llm_client: The LLM client to use for the model.\n\n[Note: Inherited members from pydantic.BaseModel are omitted.]"
  constructor_signature: 'def __init__(self, model: str):'
  methods:
  - signature: 'def generate_content_async(self, llm_request: google.adk.models.llm_request.LlmRequest, stream: bool) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
    docstring: "Generates content asynchronously.\n\nArgs:\n  llm_request: LlmRequest, the request to send to the LiteLlm model.\n  stream: bool = False, whether to do streaming call.\n\nYields:\n  LlmResponse: The model response."
  - signature: 'def supported_models(cls) -> list[str]:'
    docstring: "Provides the list of supported models.\n\nThis registers common provider prefixes. LiteLlm can handle many more,\nbut these patterns activate the integration for the most common use cases.\nSee https://docs.litellm.ai/docs/providers for a full list.\n\nReturns:\n  A list of supported models."
  properties:
  - signature: 'llm_client: google.adk.models.lite_llm.LiteLLMClient'
    docstring: The LLM client to use for the model.
  inherited_methods:
    BaseLlm:
    - signature: 'def supported_models(cls) -> list[str]:'
      docstring: Returns a list of supported models in regex for LlmRegistry.
    - signature: 'def generate_content_async(self, llm_request: google.adk.models.llm_request.LlmRequest, stream: bool) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
      docstring: "Generates content for a single model turn.\n\n    This method handles Server-Sent Events (SSE) streaming for unidirectional\n    content generation. For bidirectional streaming (e.g., Gemini Live API),\n    use the `connect()` method instead.\n\n    Args:\n      llm_request: LlmRequest, the request to send to the LLM.\n      stream: bool = False, whether to enable SSE streaming mode.\n\n    Yields:\n      LlmResponse objects representing the model's response for one turn.\n\n      **Non-streaming mode (stream=False):**\n\n        Yields exactly one LlmResponse containing the complete model output\n        (text, function calls, bytes, etc.). This response has `partial=False`.\n\n      **Streaming mode (stream=True):**\n\n        Yields multiple LlmResponse objects as chunks arrive:\n\n        - Intermediate chunks: `partial=True` (progressive updates)\n        - Final chunk: `partial=False` (aggregated content from entire turn,\n          identical to stream=False output)\n\
        \        - Text consolidation: Consecutive text parts of the same type\n          (thought/non-thought) SHOULD merge without separator, but client\n          code must not rely on this - unconsolidated parts are unusual but also\n          valid\n\n      **Common content in partial chunks:**\n\n        All intermediate chunks have `partial=True` regardless of content type.\n        Common examples include:\n\n        - Text: Streams incrementally as tokens arrive\n        - Function calls: May arrive in separate chunks\n        - Bytes (e.g., images): Typically arrive as single chunk, interleaved\n          with text\n        - Thoughts: Stream incrementally when thinking_config is enabled\n\n      **Examples:**\n\n      1. Simple text streaming::\n\n           LlmResponse(partial=True,  parts=[\"The weather\"])\n           LlmResponse(partial=True,  parts=[\" in Tokyo is\"])\n           LlmResponse(partial=True,  parts=[\" sunny.\"])\n           LlmResponse(partial=False, parts=[\"\
        The weather in Tokyo is sunny.\"])\n\n      2. Text + function call::\n\n           LlmResponse(partial=True,  parts=[Text(\"Let me check...\")])\n           LlmResponse(partial=True,  parts=[FunctionCall(\"get_weather\", ...)])\n           LlmResponse(partial=False, parts=[Text(\"Let me check...\"),\n                                             FunctionCall(\"get_weather\", ...)])\n\n      3. Parallel function calls across chunks::\n\n           LlmResponse(partial=True,  parts=[Text(\"Checking both cities...\")])\n           LlmResponse(partial=True,  parts=[FunctionCall(\"get_weather\", Tokyo)])\n           LlmResponse(partial=True,  parts=[FunctionCall(\"get_weather\", NYC)])\n           LlmResponse(partial=False, parts=[Text(\"Checking both cities...\"),\n                                             FunctionCall(\"get_weather\", Tokyo),\n                                             FunctionCall(\"get_weather\", NYC)])\n\n      4. Text + bytes (image generation with gemini-2.5-flash-image)::\n\
        \n           LlmResponse(partial=True,  parts=[Text(\"Here's an image of a dog.\")])\n           LlmResponse(partial=True,  parts=[Text(\"\n\")])\n           LlmResponse(partial=True,  parts=[Blob(image/png, 1.6MB)])\n           LlmResponse(partial=True,  parts=[Text(\"It carries a bone\")])\n           LlmResponse(partial=True,  parts=[Text(\" and running around.\")])\n           LlmResponse(partial=False, parts=[Text(\"Here's an image of a dog.\n\"),\n                                             Blob(image/png, 1.6MB),\n                                             Text(\"It carries a bone and running around.\")])\n\n         Note: Consecutive text parts before and after blob merge separately.\n\n      5. Text with thinking (gemini-2.5-flash with thinking_config)::\n\n           LlmResponse(partial=True,  parts=[Thought(\"Let me analyze...\")])\n           LlmResponse(partial=True,  parts=[Thought(\"The user wants...\")])\n           LlmResponse(partial=True,  parts=[Text(\"Based\
        \ on my analysis,\")])\n           LlmResponse(partial=True,  parts=[Text(\" the answer is 42.\")])\n           LlmResponse(partial=False, parts=[Thought(\"Let me analyze...The user wants...\"),\n                                             Text(\"Based on my analysis, the answer is 42.\")])\n\n         Note: Consecutive parts of same type merge (thoughts\u2192thought, text\u2192text).\n\n      **Important:** All yielded responses represent one logical model turn.\n      The final response with `partial=False` should be identical to the\n      response that would be received with `stream=False`.\n    "
    - signature: 'def connect(self, llm_request: google.adk.models.llm_request.LlmRequest) -> google.adk.models.base_llm_connection.BaseLlmConnection:'
      docstring: "Creates a live connection to the LLM.\n\nArgs:\n  llm_request: LlmRequest, the request to send to the LLM.\n\nReturns:\n  BaseLlmConnection, the connection to the LLM."
  inherited_properties:
    BaseLlm:
    - signature: 'model_config: pydantic.ConfigDict'
      docstring: The pydantic model config.
    - signature: 'model: str'
      docstring: The name of the LLM, e.g. gemini-2.5-flash or gemini-2.5-pro.
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 14
  id: google.adk.runners.Runner
  name: Runner
  file_path: src/google/adk/runners.py
  type: CLASS
  group: Seed
  usage_score: 8
  docstring: "The Runner class is used to run agents.\n\nIt manages the execution of an agent within a session, handling message\nprocessing, event generation, and interaction with various services like\nartifact storage, session management, and memory.\n\nAttributes:\n    app_name: The application name of the runner.\n    agent: The root agent to run.\n    artifact_service: The artifact service for the runner.\n    plugin_manager: The plugin manager for the runner.\n    session_service: The session service for the runner.\n    memory_service: The memory service for the runner.\n    credential_service: The credential service for the runner.\n    context_cache_config: The context cache config for the runner.\n    resumability_config: The resumability config for the application."
  constructor_signature: 'def __init__(self, *, app: typing.Optional[google.adk.apps.app.App]=None, app_name: typing.Optional[str]=None, agent: typing.Optional[google.adk.agents.base_agent.BaseAgent]=None, plugins: typing.Optional[typing.List[google.adk.plugins.base_plugin.BasePlugin]]=None, artifact_service: typing.Optional[google.adk.artifacts.base_artifact_service.BaseArtifactService]=None, session_service: google.adk.sessions.base_session_service.BaseSessionService, memory_service: typing.Optional[google.adk.memory.base_memory_service.BaseMemoryService]=None, credential_service: typing.Optional[google.adk.auth.credential_service.base_credential_service.BaseCredentialService]=None, plugin_close_timeout: float=5.0, auto_create_session: bool=False):'
  methods:
  - signature: 'def run(self, *, user_id: str, session_id: str, new_message: google.genai.types.Content, run_config: typing.Optional[google.adk.agents.run_config.RunConfig]=None) -> typing.Generator[google.adk.events.event.Event, None, None]:'
    docstring: "Runs the agent.\n\nNOTE:\n  This sync interface is only for local testing and convenience purpose.\n  Consider using `run_async` for production usage.\n\nIf event compaction is enabled in the App configuration, it will be\nperformed after all agent events for the current invocation have been\nyielded. The generator will only finish iterating after event\ncompaction is complete.\n\nArgs:\n  user_id: The user ID of the session.\n  session_id: The session ID of the session.\n  new_message: A new message to append to the session.\n  run_config: The run config for the agent.\n\nYields:\n  The events generated by the agent."
  - signature: 'def run_async(self, *, user_id: str, session_id: str, invocation_id: typing.Optional[str]=None, new_message: typing.Optional[google.genai.types.Content]=None, state_delta: typing.Optional[dict[str, typing.Any]]=None, run_config: typing.Optional[google.adk.agents.run_config.RunConfig]=None) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
    docstring: "Main entry method to run the agent in this runner.\n\nIf event compaction is enabled in the App configuration, it will be\nperformed after all agent events for the current invocation have been\nyielded. The async generator will only finish iterating after event\ncompaction is complete. However, this does not block new `run_async`\ncalls for subsequent user queries, which can be started concurrently.\n\nArgs:\n  user_id: The user ID of the session.\n  session_id: The session ID of the session.\n  invocation_id: The invocation ID of the session, set this to resume an\n    interrupted invocation.\n  new_message: A new message to append to the session.\n  state_delta: Optional state changes to apply to the session.\n  run_config: The run config for the agent.\n\nYields:\n  The events generated by the agent.\n\nRaises:\n  ValueError: If the session is not found; If both invocation_id and\n    new_message are None."
  - signature: 'def rewind_async(self, *, user_id: str, session_id: str, rewind_before_invocation_id: str) -> None:'
    docstring: Rewinds the session to before the specified invocation.
  - signature: 'def run_live(self, *, user_id: typing.Optional[str]=None, session_id: typing.Optional[str]=None, live_request_queue: google.adk.agents.live_request_queue.LiveRequestQueue, run_config: typing.Optional[google.adk.agents.run_config.RunConfig]=None, session: typing.Optional[google.adk.sessions.session.Session]=None) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
    docstring: "Runs the agent in live mode (experimental feature).\n\nThe `run_live` method yields a stream of `Event` objects, but not all\nyielded events are saved to the session. Here's a breakdown:\n\n**Events Yielded to Callers:**\n*   **Live Model Audio Events with Inline Data:** Events containing raw\n    audio `Blob` data(`inline_data`).\n*   **Live Model Audio Events with File Data:** Both input and ouput audio\n    data are aggregated into an audio file saved into artifacts. The\n    reference to the file is saved in the event as `file_data`.\n*   **Usage Metadata:** Events containing token usage.\n*   **Transcription Events:** Both partial and non-partial transcription\n    events are yielded.\n*   **Function Call and Response Events:** Always saved.\n*   **Other Control Events:** Most control events are saved.\n\n**Events Saved to the Session:**\n*   **Live Model Audio Events with File Data:** Both input and ouput audio\n    data are aggregated into an audio file saved into\
      \ artifacts. The\n    reference to the file is saved as event in the `file_data` to session\n    if RunConfig.save_live_model_audio_to_session is True.\n*   **Usage Metadata Events:** Saved to the session.\n*   **Non-Partial Transcription Events:** Non-partial transcription events\n    are saved.\n*   **Function Call and Response Events:** Always saved.\n*   **Other Control Events:** Most control events are saved.\n\n**Events Not Saved to the Session:**\n*   **Live Model Audio Events with Inline Data:** Events containing raw\n    audio `Blob` data are **not** saved to the session.\n\nArgs:\n    user_id: The user ID for the session. Required if `session` is None.\n    session_id: The session ID for the session. Required if `session` is\n      None.\n    live_request_queue: The queue for live requests.\n    run_config: The run config for the agent.\n    session: The session to use. This parameter is deprecated, please use\n      `user_id` and `session_id` instead.\n\nYields:\n    AsyncGenerator[Event,\
      \ None]: An asynchronous generator that yields\n    `Event`\n    objects as they are produced by the agent during its live execution.\n\n.. warning::\n    This feature is **experimental** and its API or behavior may change\n    in future releases.\n\n.. NOTE::\n    Either `session` or both `user_id` and `session_id` must be provided."
  - signature: 'def run_debug(self, user_messages: str | list[str], *, user_id: str=''debug_user_id'', session_id: str=''debug_session_id'', run_config: RunConfig | None=None, quiet: bool=False, verbose: bool=False) -> list[google.adk.events.event.Event]:'
    docstring: "Debug helper for quick agent experimentation and testing.\n\nThis convenience method is designed for developers getting started with ADK\nwho want to quickly test agents without dealing with session management,\ncontent formatting, or event streaming. It automatically handles common\nboilerplate while hiding complexity.\n\nIMPORTANT: This is for debugging and experimentation only. For production\nuse, please use the standard run_async() method which provides full control\nover session management, event streaming, and error handling.\n\nArgs:\n    user_messages: Message(s) to send to the agent. Can be: - Single string:\n      \"What is 2+2?\" - List of strings: [\"Hello!\", \"What's my name?\"]\n    user_id: User identifier. Defaults to \"debug_user_id\".\n    session_id: Session identifier for conversation persistence. Defaults to\n      \"debug_session_id\". Reuse the same ID to continue a conversation.\n    run_config: Optional configuration for the agent execution.\n \
      \   quiet: If True, suppresses console output. Defaults to False (output\n      shown).\n    verbose: If True, shows detailed tool calls and responses. Defaults to\n      False for cleaner output showing only final agent responses.\n\nReturns:\n    list[Event]: All events from all messages.\n\nRaises:\n    ValueError: If session creation/retrieval fails.\n\nExamples:\n    Quick debugging:\n    >>> runner = InMemoryRunner(agent=my_agent)\n    >>> await runner.run_debug(\"What is 2+2?\")\n\n    Multiple queries in conversation:\n    >>> await runner.run_debug([\"Hello!\", \"What's my name?\"])\n\n    Continue a debug session:\n    >>> await runner.run_debug(\"What did we discuss?\")  # Continues default\n    session\n\n    Separate debug sessions:\n    >>> await runner.run_debug(\"Hi\", user_id=\"alice\", session_id=\"debug1\")\n    >>> await runner.run_debug(\"Hi\", user_id=\"bob\", session_id=\"debug2\")\n\n    Capture events for inspection:\n    >>> events = await runner.run_debug(\"\
      Analyze this\")\n    >>> for event in events:\n    ...     inspect_event(event)\n\nNote:\n    For production applications requiring:\n    - Custom session/memory services (Spanner, Cloud SQL, etc.)\n    - Fine-grained event processing and streaming\n    - Error recovery and resumability\n    - Performance optimization\n    Please use run_async() with proper configuration."
  - signature: 'def close(self):'
    docstring: Closes the runner.
  properties:
  - signature: 'app_name: str'
    docstring: The app name of the runner.
  - signature: 'agent: google.adk.agents.base_agent.BaseAgent'
    docstring: The root agent to run.
  - signature: 'artifact_service: typing.Optional[google.adk.artifacts.base_artifact_service.BaseArtifactService]'
    docstring: The artifact service for the runner.
  - signature: 'plugin_manager: google.adk.plugins.plugin_manager.PluginManager'
    docstring: The plugin manager for the runner.
  - signature: 'session_service: google.adk.sessions.base_session_service.BaseSessionService'
    docstring: The session service for the runner.
  - signature: 'memory_service: typing.Optional[google.adk.memory.base_memory_service.BaseMemoryService]'
    docstring: The memory service for the runner.
  - signature: 'credential_service: typing.Optional[google.adk.auth.credential_service.base_credential_service.BaseCredentialService]'
    docstring: The credential service for the runner.
  - signature: 'context_cache_config: typing.Optional[google.adk.agents.context_cache_config.ContextCacheConfig]'
    docstring: The context cache config for the runner.
  - signature: 'resumability_config: typing.Optional[google.adk.apps.app.ResumabilityConfig]'
    docstring: The resumability config for the application.
  - signature: 'Self: str'
- rank: 15
  id: google.adk.agents.sequential_agent.SequentialAgent
  name: SequentialAgent
  file_path: src/google/adk/agents/sequential_agent.py
  type: CLASS
  group: Seed
  usage_score: 7
  docstring: 'A shell agent that runs its sub-agents in sequence.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, name: str, description: str = '''', sub_agents: list[google.adk.agents.base_agent.BaseAgent] = list(), before_agent_callback: typing.Optional[google.adk.agents.base_agent.BeforeAgentCallback] = None, after_agent_callback: typing.Optional[google.adk.agents.base_agent.AfterAgentCallback] = None):'
  aliases:
  - google.adk.agents.SequentialAgent
  methods:
  - signature: 'def _run_async_impl(self, ctx: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
  properties:
  - signature: 'config_type: typing.ClassVar[typing.Type[google.adk.agents.base_agent_config.BaseAgentConfig]]'
    docstring: The config type for this agent.
  inherited_methods:
    BaseAgent:
    - signature: 'def clone(self: google.adk.agents.base_agent.SelfAgent, update: Mapping[str, Any] | None) -> google.adk.agents.base_agent.SelfAgent:'
      docstring: "Creates a copy of this agent instance.\n\nArgs:\n  update: Optional mapping of new values for the fields of the cloned agent.\n    The keys of the mapping are the names of the fields to be updated, and\n    the values are the new values for those fields.\n    For example: {\"name\": \"cloned_agent\"}\n\nReturns:\n  A new agent instance with identical configuration as the original\n  agent except for the fields specified in the update."
    - signature: 'def run_async(self, parent_context: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
      docstring: "Entry method to run an agent via text-based conversation.\n\nArgs:\n  parent_context: InvocationContext, the invocation context of the parent\n    agent.\n\nYields:\n  Event: the events generated by the agent."
    - signature: 'def run_live(self, parent_context: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
      docstring: "Entry method to run an agent via video/audio-based conversation.\n\nArgs:\n  parent_context: InvocationContext, the invocation context of the parent\n    agent.\n\nYields:\n  Event: the events generated by the agent."
    - signature: 'def _run_async_impl(self, ctx: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
      docstring: "Core logic to run this agent via text-based conversation.\n\nArgs:\n  ctx: InvocationContext, the invocation context for this agent.\n\nYields:\n  Event: the events generated by the agent."
    - signature: 'def root_agent(self) -> google.adk.agents.base_agent.BaseAgent:'
      docstring: Gets the root agent of this agent.
    - signature: 'def find_agent(self, name: str) -> typing.Optional[google.adk.agents.base_agent.BaseAgent]:'
      docstring: "Finds the agent with the given name in this agent and its descendants.\n\nArgs:\n  name: The name of the agent to find.\n\nReturns:\n  The agent with the matching name, or None if no such agent is found."
    - signature: 'def find_sub_agent(self, name: str) -> typing.Optional[google.adk.agents.base_agent.BaseAgent]:'
      docstring: "Finds the agent with the given name in this agent's descendants.\n\nArgs:\n  name: The name of the agent to find.\n\nReturns:\n  The agent with the matching name, or None if no such agent is found."
    - signature: 'def model_post_init(self, __context: typing.Any) -> None:'
    - signature: 'def validate_name(cls, value: str):'
    - signature: 'def validate_sub_agents_unique_names(cls, value: list[google.adk.agents.base_agent.BaseAgent]) -> list[google.adk.agents.base_agent.BaseAgent]:'
      docstring: "Validates that all sub-agents have unique names.\n\nArgs:\n  value: The list of sub-agents to validate.\n\nReturns:\n  The validated list of sub-agents."
    - signature: 'def from_config(cls: typing.Type[google.adk.agents.base_agent.SelfAgent], config: google.adk.agents.base_agent_config.BaseAgentConfig, config_abs_path: str) -> google.adk.agents.base_agent.SelfAgent:'
      docstring: "Creates an agent from a config.\n\nIf sub-classes uses a custom agent config, override `_from_config_kwargs`\nmethod to return an updated kwargs for agent constructor.\n\nArgs:\n  config: The config to create the agent from.\n  config_abs_path: The absolute path to the config file that contains the\n    agent config.\n\nReturns:\n  The created agent."
  inherited_properties:
    BaseAgent:
    - signature: 'model_config: pydantic.ConfigDict'
      docstring: The pydantic model config.
    - signature: 'config_type: typing.ClassVar[type[google.adk.agents.base_agent_config.BaseAgentConfig]]'
      docstring: "The config type for this agent.\n\nSub-classes should override this to specify their own config type.\n\nExample:\n\n```\nclass MyAgentConfig(BaseAgentConfig):\n  my_field: str = ''\n\nclass MyAgent(BaseAgent):\n  config_type: ClassVar[type[BaseAgentConfig]] = MyAgentConfig\n```"
    - signature: 'name: str'
      docstring: 'The agent''s name.


        Agent name must be a Python identifier and unique within the agent tree.

        Agent name cannot be "user", since it''s reserved for end-user''s input.'
    - signature: 'description: str'
      docstring: 'Description about the agent''s capability.


        The model uses this to determine whether to delegate control to the agent.

        One-line description is enough and preferred.'
    - signature: 'parent_agent: typing.Optional[google.adk.agents.base_agent.BaseAgent]'
      docstring: 'The parent agent of this agent.


        Note that an agent can ONLY be added as sub-agent once.


        If you want to add one agent twice as sub-agent, consider to create two agent

        instances with identical config, but with different name and add them to the

        agent tree.'
    - signature: 'sub_agents: list[google.adk.agents.base_agent.BaseAgent]'
      docstring: The sub-agents of this agent.
    - signature: 'before_agent_callback: typing.Optional[google.adk.agents.base_agent.BeforeAgentCallback]'
      docstring: "Callback or list of callbacks to be invoked before the agent run.\n\nWhen a list of callbacks is provided, the callbacks will be called in the\norder they are listed until a callback does not return None.\n\nArgs:\n  callback_context: MUST be named 'callback_context' (enforced).\n\nReturns:\n  Optional[types.Content]: The content to return to the user.\n    When the content is present, the agent run will be skipped and the\n    provided content will be returned to user."
    - signature: 'after_agent_callback: typing.Optional[google.adk.agents.base_agent.AfterAgentCallback]'
      docstring: "Callback or list of callbacks to be invoked after the agent run.\n\nWhen a list of callbacks is provided, the callbacks will be called in the\norder they are listed until a callback does not return None.\n\nArgs:\n  callback_context: MUST be named 'callback_context' (enforced).\n\nReturns:\n  Optional[types.Content]: The content to return to the user.\n    When the content is present, an additional event with the provided content\n    will be appended to event history as an additional agent response."
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 16
  id: google.adk.tools.spanner.spanner_credentials.SpannerCredentialsConfig
  name: SpannerCredentialsConfig
  file_path: src/google/adk/tools/spanner/spanner_credentials.py
  type: CLASS
  group: Seed
  usage_score: 6
  docstring: 'Spanner Credentials Configuration for Google API tools (Experimental).


    Please do not use this in production, as it may be deprecated later.


    [Note: Inherited members from BaseGoogleCredentialsConfig are omitted.]'
  omitted_inherited_members_from:
  - BaseGoogleCredentialsConfig
- rank: 17
  id: google.adk.tools.mcp_tool.mcp_toolset.MCPToolset
  name: MCPToolset
  file_path: src/google/adk/tools/mcp_tool/mcp_toolset.py
  type: CLASS
  group: Seed
  usage_score: 6
  docstring: 'Deprecated name, use `McpToolset` instead.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self):'
  inherited_methods:
    McpToolset:
    - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> typing.List[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools in the toolset based on the provided context.\n\nArgs:\n    readonly_context: Context used to filter tools available to the agent.\n      If None, all tools in the toolset are returned.\n\nReturns:\n    List[BaseTool]: A list of tools available under the specified context."
    - signature: 'def read_resource(self, name: str, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> typing.Any:'
      docstring: "Fetches and returns a list of contents of the named resource.\n\nArgs:\n  name: The name of the resource to fetch.\n  readonly_context: Context used to provide headers for the MCP session.\n\nReturns:\n  List of contents of the resource."
    - signature: 'def list_resources(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[str]:'
      docstring: Returns a list of resource names available on the MCP server.
    - signature: 'def get_resource_info(self, name: str, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> dict[str, typing.Any]:'
      docstring: Returns metadata about a specific resource (name, MIME type, etc.).
    - signature: 'def close(self) -> None:'
      docstring: 'Performs cleanup and releases resources held by the toolset.


        This method closes the MCP session and cleans up all associated resources.

        It''s designed to be safe to call multiple times and handles cleanup errors

        gracefully to avoid blocking application shutdown.'
    - signature: 'def get_auth_config(self) -> typing.Optional[google.adk.auth.auth_tool.AuthConfig]:'
      docstring: 'Returns the auth config for this toolset.


        ADK will populate exchanged_auth_credential on this config before calling

        get_tools(). The toolset can then access the ready-to-use credential via

        self._auth_config.exchanged_auth_credential.'
    - signature: 'def from_config(cls: type[google.adk.tools.mcp_tool.mcp_toolset.McpToolset], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.mcp_tool.mcp_toolset.McpToolset:'
      docstring: Creates an McpToolset from a configuration object.
    BaseToolset:
    - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools in the toolset based on the provided context.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools available under the specified context."
    - signature: 'def get_tools_with_prefix(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools with optional prefix applied to tool names.\n\nThis method calls get_tools() and applies prefixing if tool_name_prefix is provided.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools with prefixed names if tool_name_prefix is provided."
    - signature: 'def close(self) -> None:'
      docstring: "Performs cleanup and releases resources held by the toolset.\n\nNOTE:\n  This method is invoked, for example, at the end of an agent server's\n  lifecycle or when the toolset is no longer needed. Implementations\n  should ensure that any open connections, files, or other managed\n  resources are properly released to prevent leaks."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_toolset.SelfToolset], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_toolset.SelfToolset:'
      docstring: "Creates a toolset instance from a config.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The toolset instance."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this toolset. This method will be\ncalled before each tool processes the llm request.\n\nUse cases:\n- Instead of let each tool process the llm request, we can let the toolset\n  process the llm request. e.g. ComputerUseToolset can add computer use\n  tool to the llm request.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def get_auth_config(self) -> typing.Optional[google.adk.auth.auth_tool.AuthConfig]:'
      docstring: "Returns the auth config for this toolset. ADK will make sure the\n'exchanged_auth_credential' field in the config is populated with\nready-to-use credential (e.g. oauth token for OAuth flow) before calling\nget_tools method or execute any tools returned by this toolset. Thus toolset\ncan use this credential either for tool listing or tool calling. If tool\ncalling needs a different credential from ADK client, call\ntool_context.request_credential in the tool.\n\nToolsets that support authentication should override this method to return\nan AuthConfig constructed from their auth_scheme, auth_credential, and\noptional credential_key parameters.\n\nReturns:\n  AuthConfig if the toolset has authentication configured, None otherwise."
  omitted_inherited_members_from:
  - ABC
- rank: 18
  id: google.adk.sessions.vertex_ai_session_service.VertexAiSessionService
  name: VertexAiSessionService
  file_path: src/google/adk/sessions/vertex_ai_session_service.py
  type: CLASS
  group: Seed
  usage_score: 6
  docstring: 'Connects to the Vertex AI Agent Engine Session Service using Agent Engine SDK.


    https://cloud.google.com/vertex-ai/generative-ai/docs/agent-engine/sessions/overview


    [Note: Inherited members from abc.ABC are omitted.]'
  constructor_signature: 'def __init__(self, project: typing.Optional[str], location: typing.Optional[str], agent_engine_id: typing.Optional[str], *, express_mode_api_key: typing.Optional[str]=None):'
  methods:
  - signature: 'def create_session(self, *, app_name: str, user_id: str, state: typing.Optional[dict[str, typing.Any]]=None, session_id: typing.Optional[str]=None) -> google.adk.sessions.session.Session:'
    docstring: "Creates a new session.\n\nArgs:\n  app_name: The name of the application.\n  user_id: The ID of the user.\n  state: The initial state of the session.\n  session_id: The ID of the session.\n  **kwargs: Additional arguments to pass to the session creation. E.g. set\n    expire_time='2025-10-01T00:00:00Z' to set the session expiration time.\n    See https://cloud.google.com/vertex-ai/generative-ai/docs/reference/rest/v1beta1/projects.locations.reasoningEngines.sessions\n    for more details.\nReturns:\n  The created session."
  - signature: 'def get_session(self, *, app_name: str, user_id: str, session_id: str, config: typing.Optional[google.adk.sessions.base_session_service.GetSessionConfig]=None) -> typing.Optional[google.adk.sessions.session.Session]:'
  - signature: 'def list_sessions(self, *, app_name: str, user_id: typing.Optional[str]=None) -> google.adk.sessions.base_session_service.ListSessionsResponse:'
  - signature: 'def delete_session(self, *, app_name: str, user_id: str, session_id: str) -> None:'
  - signature: 'def append_event(self, session: google.adk.sessions.session.Session, event: google.adk.events.event.Event) -> google.adk.events.event.Event:'
  inherited_methods:
    BaseSessionService:
    - signature: 'def create_session(self, *, app_name: str, user_id: str, state: typing.Optional[dict[str, typing.Any]]=None, session_id: typing.Optional[str]=None) -> google.adk.sessions.session.Session:'
      docstring: "Creates a new session.\n\nArgs:\n  app_name: the name of the app.\n  user_id: the id of the user.\n  state: the initial state of the session.\n  session_id: the client-provided id of the session. If not provided, a\n    generated ID will be used.\n\nReturns:\n  session: The newly created session instance."
    - signature: 'def get_session(self, *, app_name: str, user_id: str, session_id: str, config: typing.Optional[google.adk.sessions.base_session_service.GetSessionConfig]=None) -> typing.Optional[google.adk.sessions.session.Session]:'
      docstring: Gets a session.
    - signature: 'def list_sessions(self, *, app_name: str, user_id: typing.Optional[str]=None) -> google.adk.sessions.base_session_service.ListSessionsResponse:'
      docstring: "Lists all the sessions for a user.\n\nArgs:\n  app_name: The name of the app.\n  user_id: The ID of the user. If not provided, lists all sessions for all\n    users.\n\nReturns:\n  A ListSessionsResponse containing the sessions."
    - signature: 'def delete_session(self, *, app_name: str, user_id: str, session_id: str) -> None:'
      docstring: Deletes a session.
    - signature: 'def append_event(self, session: google.adk.sessions.session.Session, event: google.adk.events.event.Event) -> google.adk.events.event.Event:'
      docstring: Appends an event to a session object.
  omitted_inherited_members_from:
  - abc.ABC
- rank: 19
  id: google.adk.examples.example.Example
  name: Example
  file_path: src/google/adk/examples/example.py
  type: CLASS
  group: Seed
  usage_score: 6
  docstring: "A few-shot example.\n\nAttributes:\n  input: The input content for the example.\n  output: The expected output content for the example.\n\n[Note: Inherited members from pydantic.BaseModel are omitted.]"
  constructor_signature: 'def __init__(self, *, input: google.genai.types.Content, output: list[google.genai.types.Content]):'
  properties:
  - signature: 'input: google.genai.types.Content'
  - signature: 'output: list[google.genai.types.Content]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 20
  id: google.adk.tools.langchain_tool.LangchainTool
  name: LangchainTool
  file_path: src/google/adk/tools/langchain_tool.py
  type: CLASS
  group: Seed
  usage_score: 5
  docstring: "Adapter class that wraps a Langchain tool for use with ADK.\n\nThis adapter converts Langchain tools into a format compatible with Google's\ngenerative AI function calling interface. It preserves the tool's name,\ndescription, and functionality while adapting its schema.\n\nThe original tool's name and description can be overridden if needed.\n\nArgs:\n    tool: A Langchain tool to wrap (BaseTool or a tool with a .run method)\n    name: Optional override for the tool's name\n    description: Optional override for the tool's description\n\nExamples::\n\n    from langchain.tools import DuckDuckGoSearchTool\n    from google.genai.tools import LangchainTool\n\n    search_tool = DuckDuckGoSearchTool()\n    wrapped_tool = LangchainTool(search_tool)\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, tool: typing.Union[langchain_core.tools.BaseTool, object], name: typing.Optional[str], description: typing.Optional[str]):'
  methods:
  - signature: 'def from_config(cls: type[google.adk.tools.langchain_tool.LangchainTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.langchain_tool.LangchainTool:'
  inherited_methods:
    FunctionTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
    BaseTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
      docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
      docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  inherited_properties:
    BaseTool:
    - signature: 'name: str'
      docstring: The name of the tool.
    - signature: 'description: str'
      docstring: The description of the tool.
    - signature: 'is_long_running: bool'
      docstring: 'Whether the tool is a long running operation, which typically returns a

        resource id first and finishes the operation later.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the BaseTool.


        An optional key-value pair for storing and retrieving tool-specific metadata,

        such as tool manifests, etc.


        NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 21
  id: google.adk.tools.bigquery.client.get_bigquery_client
  name: get_bigquery_client
  file_path: src/google/adk/tools/bigquery/client.py
  type: METHOD
  group: Seed
  usage_score: 5
  docstring: "Get a BigQuery client.\n\nArgs:\n  project: The GCP project ID.\n  credentials: The credentials to use for the request.\n  location: The location of the BigQuery client.\n  user_agent: The user agent to use for the request.\n\nReturns:\n  A BigQuery client."
  signature: 'def get_bigquery_client(*, project: typing.Optional[str], credentials: google.auth.credentials.Credentials, location: typing.Optional[str]=None, user_agent: typing.Optional[typing.Union[str, typing.List[str]]]=None) -> google.cloud.bigquery.Client:'
- rank: 22
  id: google.adk.models.google_llm.Gemini
  name: Gemini
  file_path: src/google/adk/models/google_llm.py
  type: CLASS
  group: Seed
  usage_score: 5
  docstring: "Integration for Gemini models.\n\nAttributes:\n  model: The name of the Gemini model.\n  use_interactions_api: Whether to use the interactions API for model\n    invocation.\n\n[Note: Inherited members from pydantic.BaseModel are omitted.]"
  constructor_signature: 'def __init__(self, *, model: str, speech_config: typing.Optional[google.genai.types.SpeechConfig] = None, use_interactions_api: bool = False, retry_options: typing.Optional[google.genai.types.HttpRetryOptions] = None):'
  methods:
  - signature: 'def supported_models(cls) -> list[str]:'
    docstring: "Provides the list of supported models.\n\nReturns:\n  A list of supported models."
  - signature: 'def generate_content_async(self, llm_request: google.adk.models.llm_request.LlmRequest, stream: bool) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
    docstring: "Sends a request to the Gemini model.\n\nArgs:\n  llm_request: LlmRequest, the request to send to the Gemini model.\n  stream: bool = False, whether to do streaming call.\n\nYields:\n  LlmResponse: The model response."
  - signature: 'def api_client(self) -> google.genai.Client:'
    docstring: "Provides the api client.\n\nReturns:\n  The api client."
  - signature: 'def connect(self, llm_request: google.adk.models.llm_request.LlmRequest) -> google.adk.models.base_llm_connection.BaseLlmConnection:'
    docstring: "Connects to the Gemini model and returns an llm connection.\n\nArgs:\n  llm_request: LlmRequest, the request to send to the Gemini model.\n\nYields:\n  BaseLlmConnection, the connection to the Gemini model."
  properties:
  - signature: 'model: str'
  - signature: 'speech_config: typing.Optional[google.genai.types.SpeechConfig]'
  - signature: 'use_interactions_api: bool'
    docstring: "Whether to use the interactions API for model invocation.\n\nWhen enabled, uses the interactions API (client.aio.interactions.create())\ninstead of the traditional generate_content API. The interactions API\nprovides stateful conversation capabilities, allowing you to chain\ninteractions using previous_interaction_id instead of sending full history.\nThe response format will be converted to match the existing LlmResponse\nstructure for compatibility.\n\nSample:\n```python\nagent = Agent(\n  model=Gemini(use_interactions_api=True)\n)\n```"
  - signature: 'retry_options: typing.Optional[google.genai.types.HttpRetryOptions]'
    docstring: "Allow Gemini to retry failed responses.\n\nSample:\n```python\nfrom google.genai import types\n\n# ...\n\nagent = Agent(\n  model=Gemini(\n    retry_options=types.HttpRetryOptions(initial_delay=1, attempts=2),\n  )\n)\n```"
  inherited_methods:
    BaseLlm:
    - signature: 'def supported_models(cls) -> list[str]:'
      docstring: Returns a list of supported models in regex for LlmRegistry.
    - signature: 'def generate_content_async(self, llm_request: google.adk.models.llm_request.LlmRequest, stream: bool) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
      docstring: "Generates content for a single model turn.\n\n    This method handles Server-Sent Events (SSE) streaming for unidirectional\n    content generation. For bidirectional streaming (e.g., Gemini Live API),\n    use the `connect()` method instead.\n\n    Args:\n      llm_request: LlmRequest, the request to send to the LLM.\n      stream: bool = False, whether to enable SSE streaming mode.\n\n    Yields:\n      LlmResponse objects representing the model's response for one turn.\n\n      **Non-streaming mode (stream=False):**\n\n        Yields exactly one LlmResponse containing the complete model output\n        (text, function calls, bytes, etc.). This response has `partial=False`.\n\n      **Streaming mode (stream=True):**\n\n        Yields multiple LlmResponse objects as chunks arrive:\n\n        - Intermediate chunks: `partial=True` (progressive updates)\n        - Final chunk: `partial=False` (aggregated content from entire turn,\n          identical to stream=False output)\n\
        \        - Text consolidation: Consecutive text parts of the same type\n          (thought/non-thought) SHOULD merge without separator, but client\n          code must not rely on this - unconsolidated parts are unusual but also\n          valid\n\n      **Common content in partial chunks:**\n\n        All intermediate chunks have `partial=True` regardless of content type.\n        Common examples include:\n\n        - Text: Streams incrementally as tokens arrive\n        - Function calls: May arrive in separate chunks\n        - Bytes (e.g., images): Typically arrive as single chunk, interleaved\n          with text\n        - Thoughts: Stream incrementally when thinking_config is enabled\n\n      **Examples:**\n\n      1. Simple text streaming::\n\n           LlmResponse(partial=True,  parts=[\"The weather\"])\n           LlmResponse(partial=True,  parts=[\" in Tokyo is\"])\n           LlmResponse(partial=True,  parts=[\" sunny.\"])\n           LlmResponse(partial=False, parts=[\"\
        The weather in Tokyo is sunny.\"])\n\n      2. Text + function call::\n\n           LlmResponse(partial=True,  parts=[Text(\"Let me check...\")])\n           LlmResponse(partial=True,  parts=[FunctionCall(\"get_weather\", ...)])\n           LlmResponse(partial=False, parts=[Text(\"Let me check...\"),\n                                             FunctionCall(\"get_weather\", ...)])\n\n      3. Parallel function calls across chunks::\n\n           LlmResponse(partial=True,  parts=[Text(\"Checking both cities...\")])\n           LlmResponse(partial=True,  parts=[FunctionCall(\"get_weather\", Tokyo)])\n           LlmResponse(partial=True,  parts=[FunctionCall(\"get_weather\", NYC)])\n           LlmResponse(partial=False, parts=[Text(\"Checking both cities...\"),\n                                             FunctionCall(\"get_weather\", Tokyo),\n                                             FunctionCall(\"get_weather\", NYC)])\n\n      4. Text + bytes (image generation with gemini-2.5-flash-image)::\n\
        \n           LlmResponse(partial=True,  parts=[Text(\"Here's an image of a dog.\")])\n           LlmResponse(partial=True,  parts=[Text(\"\n\")])\n           LlmResponse(partial=True,  parts=[Blob(image/png, 1.6MB)])\n           LlmResponse(partial=True,  parts=[Text(\"It carries a bone\")])\n           LlmResponse(partial=True,  parts=[Text(\" and running around.\")])\n           LlmResponse(partial=False, parts=[Text(\"Here's an image of a dog.\n\"),\n                                             Blob(image/png, 1.6MB),\n                                             Text(\"It carries a bone and running around.\")])\n\n         Note: Consecutive text parts before and after blob merge separately.\n\n      5. Text with thinking (gemini-2.5-flash with thinking_config)::\n\n           LlmResponse(partial=True,  parts=[Thought(\"Let me analyze...\")])\n           LlmResponse(partial=True,  parts=[Thought(\"The user wants...\")])\n           LlmResponse(partial=True,  parts=[Text(\"Based\
        \ on my analysis,\")])\n           LlmResponse(partial=True,  parts=[Text(\" the answer is 42.\")])\n           LlmResponse(partial=False, parts=[Thought(\"Let me analyze...The user wants...\"),\n                                             Text(\"Based on my analysis, the answer is 42.\")])\n\n         Note: Consecutive parts of same type merge (thoughts\u2192thought, text\u2192text).\n\n      **Important:** All yielded responses represent one logical model turn.\n      The final response with `partial=False` should be identical to the\n      response that would be received with `stream=False`.\n    "
    - signature: 'def connect(self, llm_request: google.adk.models.llm_request.LlmRequest) -> google.adk.models.base_llm_connection.BaseLlmConnection:'
      docstring: "Creates a live connection to the LLM.\n\nArgs:\n  llm_request: LlmRequest, the request to send to the LLM.\n\nReturns:\n  BaseLlmConnection, the connection to the LLM."
  inherited_properties:
    BaseLlm:
    - signature: 'model_config: pydantic.ConfigDict'
      docstring: The pydantic model config.
    - signature: 'model: str'
      docstring: The name of the LLM, e.g. gemini-2.5-flash or gemini-2.5-pro.
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 23
  id: google.adk.apps.app.App
  name: App
  file_path: src/google/adk/apps/app.py
  type: CLASS
  group: Seed
  usage_score: 5
  docstring: 'Represents an LLM-backed agentic application.


    An `App` is the top-level container for an agentic system powered by LLMs.

    It manages a root agent (`root_agent`), which serves as the root of an agent

    tree, enabling coordination and communication across all agents in the

    hierarchy.

    The `plugins` are application-wide components that provide shared capabilities

    and services to the entire system.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, name: str, root_agent: google.adk.agents.base_agent.BaseAgent, plugins: list[google.adk.plugins.base_plugin.BasePlugin] = list(), events_compaction_config: typing.Optional[google.adk.apps.app.EventsCompactionConfig] = None, context_cache_config: typing.Optional[google.adk.agents.context_cache_config.ContextCacheConfig] = None, resumability_config: typing.Optional[google.adk.apps.app.ResumabilityConfig] = None):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'name: str'
    docstring: The name of the application.
  - signature: 'root_agent: google.adk.agents.base_agent.BaseAgent'
    docstring: The root agent in the application. One app can only have one root agent.
  - signature: 'plugins: list[google.adk.plugins.base_plugin.BasePlugin]'
    docstring: The plugins in the application.
  - signature: 'events_compaction_config: typing.Optional[google.adk.apps.app.EventsCompactionConfig]'
    docstring: The config of event compaction for the application.
  - signature: 'context_cache_config: typing.Optional[google.adk.agents.context_cache_config.ContextCacheConfig]'
    docstring: Context cache configuration that applies to all LLM agents in the app.
  - signature: 'resumability_config: typing.Optional[google.adk.apps.app.ResumabilityConfig]'
    docstring: 'The config of the resumability for the application.

      If configured, will be applied to all agents in the app.'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 24
  id: google.adk.tools.function_tool.FunctionTool
  name: FunctionTool
  file_path: src/google/adk/tools/function_tool.py
  type: CLASS
  group: Seed
  usage_score: 4
  docstring: "A tool that wraps a user-defined Python function.\n\nAttributes:\n  func: The function to wrap.\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, func: typing.Callable[Ellipsis, typing.Any], *, require_confirmation: typing.Union[bool, typing.Callable[Ellipsis, bool]]=False):'
  methods:
  - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
  inherited_methods:
    BaseTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
      docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
      docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  inherited_properties:
    BaseTool:
    - signature: 'name: str'
      docstring: The name of the tool.
    - signature: 'description: str'
      docstring: The description of the tool.
    - signature: 'is_long_running: bool'
      docstring: 'Whether the tool is a long running operation, which typically returns a

        resource id first and finishes the operation later.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the BaseTool.


        An optional key-value pair for storing and retrieving tool-specific metadata,

        such as tool manifests, etc.


        NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 25
  id: google.adk.tools.bigquery.config.BigQueryToolConfig
  name: BigQueryToolConfig
  file_path: src/google/adk/tools/bigquery/config.py
  type: CLASS
  group: Seed
  usage_score: 4
  docstring: 'Configuration for BigQuery tools.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, write_mode: google.adk.tools.bigquery.config.WriteMode = WriteMode.BLOCKED, maximum_bytes_billed: typing.Optional[int] = None, max_query_result_rows: int = 50, application_name: typing.Optional[str] = None, compute_project_id: typing.Optional[str] = None, location: typing.Optional[str] = None, job_labels: typing.Optional[dict[str, str]] = None):'
  methods:
  - signature: 'def validate_maximum_bytes_billed(cls, v):'
    docstring: Validate the maximum bytes billed.
  - signature: 'def validate_application_name(cls, v):'
    docstring: Validate the application name.
  - signature: 'def validate_job_labels(cls, v):'
    docstring: Validate that job_labels keys are not empty.
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'write_mode: google.adk.tools.bigquery.config.WriteMode'
    docstring: 'Write mode for BigQuery tools.


      By default, the tool will allow only read operations. This behaviour may

      change in future versions.'
  - signature: 'maximum_bytes_billed: typing.Optional[int]'
    docstring: 'Maximum number of bytes to bill for a query.


      In BigQuery on-demand pricing, charges are rounded up to the nearest MB, with

      a minimum 10 MB data processed per table referenced by the query, and with a

      minimum 10 MB data processed per query. So this value must be set >=10485760.'
  - signature: 'max_query_result_rows: int'
    docstring: 'Maximum number of rows to return from a query.


      By default, the query result will be limited to 50 rows.'
  - signature: 'application_name: typing.Optional[str]'
    docstring: 'Name of the application using the BigQuery tools.


      By default, no particular application name will be set in the BigQuery

      interaction. But if the tool user (agent builder) wants to differentiate

      their application/agent for tracking or support purpose, they can set this

      field. If set, this value will be added to the user_agent in BigQuery API calls, and also to the BigQuery job labels with the key

      "adk-bigquery-application-name".'
  - signature: 'compute_project_id: typing.Optional[str]'
    docstring: 'GCP project ID to use for the BigQuery compute operations.


      This can be set as a guardrail to ensure that the tools perform the compute

      operations (such as query execution) in a specific project.'
  - signature: 'location: typing.Optional[str]'
    docstring: 'BigQuery location to use for the data and compute.


      This can be set if the BigQuery tools are expected to process data in a

      particular BigQuery location. If not set, then location would be automatically

      determined based on the data location in the query. For all supported

      locations, see https://cloud.google.com/bigquery/docs/locations.'
  - signature: 'job_labels: typing.Optional[dict[str, str]]'
    docstring: "Labels to apply to BigQuery jobs for tracking and monitoring.\n\nThese labels will be added to all BigQuery jobs executed by the tools.\nLabels must be key-value pairs where both keys and values are strings.\nLabels can be used for billing, monitoring, and resource organization.\nFor more information about labels, see \nhttps://cloud.google.com/bigquery/docs/labels-intro."
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 26
  id: google.adk.tools.apihub_tool.apihub_toolset.APIHubToolset
  name: APIHubToolset
  file_path: src/google/adk/tools/apihub_tool/apihub_toolset.py
  type: CLASS
  group: Seed
  usage_score: 4
  docstring: "APIHubTool generates tools from a given API Hub resource.\n\nExamples::\n\n  apihub_toolset = APIHubToolset(\n      apihub_resource_name=\"projects/test-project/locations/us-central1/apis/test-api\",\n      service_account_json=\"...\",\n      tool_filter=lambda tool, ctx=None: tool.name in ('my_tool',\n      'my_other_tool')\n  )\n\n  # Get all available tools\n  agent = LlmAgent(tools=apihub_toolset)\n\n**apihub_resource_name** is the resource name from API Hub. It must include\nAPI name, and can optionally include API version and spec name.\n\n- If apihub_resource_name includes a spec resource name, the content of that\n  spec will be used for generating the tools.\n- If apihub_resource_name includes only an api or a version name, the\n  first spec of the first version of that API will be used.\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, *, apihub_resource_name: str, access_token: typing.Optional[str]=None, service_account_json: typing.Optional[str]=None, name: str='''', description: str='''', lazy_load_spec=False, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme]=None, auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]=None, apihub_client: typing.Optional[google.adk.tools.apihub_tool.clients.apihub_client.APIHubClient]=None, tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]]=None):'
  methods:
  - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> typing.List[google.adk.tools.openapi_tool.openapi_spec_parser.rest_api_tool.RestApiTool]:'
    docstring: "Retrieves all available tools.\n\nReturns:\n    A list of all available RestApiTool objects."
  - signature: 'def close(self):'
  - signature: 'def get_auth_config(self) -> typing.Optional[google.adk.auth.auth_tool.AuthConfig]:'
    docstring: 'Returns the auth config for this toolset.


      ADK will populate exchanged_auth_credential on this config before calling

      get_tools(). The toolset can then access the ready-to-use credential via

      self._auth_config.exchanged_auth_credential.'
  inherited_methods:
    BaseToolset:
    - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools in the toolset based on the provided context.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools available under the specified context."
    - signature: 'def get_tools_with_prefix(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools with optional prefix applied to tool names.\n\nThis method calls get_tools() and applies prefixing if tool_name_prefix is provided.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools with prefixed names if tool_name_prefix is provided."
    - signature: 'def close(self) -> None:'
      docstring: "Performs cleanup and releases resources held by the toolset.\n\nNOTE:\n  This method is invoked, for example, at the end of an agent server's\n  lifecycle or when the toolset is no longer needed. Implementations\n  should ensure that any open connections, files, or other managed\n  resources are properly released to prevent leaks."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_toolset.SelfToolset], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_toolset.SelfToolset:'
      docstring: "Creates a toolset instance from a config.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The toolset instance."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this toolset. This method will be\ncalled before each tool processes the llm request.\n\nUse cases:\n- Instead of let each tool process the llm request, we can let the toolset\n  process the llm request. e.g. ComputerUseToolset can add computer use\n  tool to the llm request.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def get_auth_config(self) -> typing.Optional[google.adk.auth.auth_tool.AuthConfig]:'
      docstring: "Returns the auth config for this toolset. ADK will make sure the\n'exchanged_auth_credential' field in the config is populated with\nready-to-use credential (e.g. oauth token for OAuth flow) before calling\nget_tools method or execute any tools returned by this toolset. Thus toolset\ncan use this credential either for tool listing or tool calling. If tool\ncalling needs a different credential from ADK client, call\ntool_context.request_credential in the tool.\n\nToolsets that support authentication should override this method to return\nan AuthConfig constructed from their auth_scheme, auth_credential, and\noptional credential_key parameters.\n\nReturns:\n  AuthConfig if the toolset has authentication configured, None otherwise."
  omitted_inherited_members_from:
  - ABC
- rank: 27
  id: google.adk.auth.auth_credential.AuthCredential
  name: AuthCredential
  file_path: src/google/adk/auth/auth_credential.py
  type: CLASS
  group: Seed
  usage_score: 4
  docstring: "Data class representing an authentication credential.\n\nTo exchange for the actual credential, please use\nCredentialExchanger.exchange_credential().\n\nExamples: API Key Auth\nAuthCredential(\n    auth_type=AuthCredentialTypes.API_KEY,\n    api_key=\"1234\",\n)\n\nExample: HTTP Auth\nAuthCredential(\n    auth_type=AuthCredentialTypes.HTTP,\n    http=HttpAuth(\n        scheme=\"basic\",\n        credentials=HttpCredentials(username=\"user\", password=\"password\"),\n    ),\n)\n\nExample: OAuth2 Bearer Token in HTTP Header\nAuthCredential(\n    auth_type=AuthCredentialTypes.HTTP,\n    http=HttpAuth(\n        scheme=\"bearer\",\n        credentials=HttpCredentials(token=\"eyAkaknabna....\"),\n    ),\n)\n\nExample: OAuth2 Auth with Authorization Code Flow\nAuthCredential(\n    auth_type=AuthCredentialTypes.OAUTH2,\n    oauth2=OAuth2Auth(\n        client_id=\"1234\",\n        client_secret=\"secret\",\n    ),\n)\n\nExample: OpenID Connect Auth\nAuthCredential(\n    auth_type=AuthCredentialTypes.OPEN_ID_CONNECT,\n\
    \    oauth2=OAuth2Auth(\n        client_id=\"1234\",\n        client_secret=\"secret\",\n        redirect_uri=\"https://example.com\",\n        scopes=[\"scope1\", \"scope2\"],\n    ),\n)\n\nExample: Auth with resource reference\nAuthCredential(\n    auth_type=AuthCredentialTypes.API_KEY,\n    resource_ref=\"projects/1234/locations/us-central1/resources/resource1\",\n)\n\n[Note: Inherited members from pydantic.BaseModel are omitted.]"
  constructor_signature: 'def __init__(self, *, auth_type: google.adk.auth.auth_credential.AuthCredentialTypes, resource_ref: typing.Optional[str] = None, api_key: typing.Optional[str] = None, http: typing.Optional[google.adk.auth.auth_credential.HttpAuth] = None, service_account: typing.Optional[google.adk.auth.auth_credential.ServiceAccount] = None, oauth2: typing.Optional[google.adk.auth.auth_credential.OAuth2Auth] = None):'
  properties:
  - signature: 'auth_type: google.adk.auth.auth_credential.AuthCredentialTypes'
  - signature: 'resource_ref: typing.Optional[str]'
  - signature: 'api_key: typing.Optional[str]'
  - signature: 'http: typing.Optional[google.adk.auth.auth_credential.HttpAuth]'
  - signature: 'service_account: typing.Optional[google.adk.auth.auth_credential.ServiceAccount]'
  - signature: 'oauth2: typing.Optional[google.adk.auth.auth_credential.OAuth2Auth]'
  inherited_properties:
    BaseModelWithConfig:
    - signature: 'model_config: pydantic.ConfigDict'
      docstring: The pydantic model config.
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 28
  id: google.adk.agents.remote_a2a_agent.RemoteA2aAgent
  name: RemoteA2aAgent
  file_path: src/google/adk/agents/remote_a2a_agent.py
  type: CLASS
  group: Seed
  usage_score: 4
  docstring: 'Agent that communicates with a remote A2A agent via A2A client.


    This agent supports multiple ways to specify the remote agent:

    1. Direct AgentCard object

    2. URL to agent card JSON

    3. File path to agent card JSON


    The agent handles:

    - Agent card resolution and validation

    - HTTP client management with proper resource cleanup

    - A2A message conversion and error handling

    - Session state management across requests


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, name: str, agent_card: typing.Union[a2a.types.AgentCard, str], *, description: str='''', httpx_client: typing.Optional[httpx.AsyncClient]=None, timeout: float=DEFAULT_TIMEOUT, genai_part_converter: google.adk.a2a.converters.part_converter.GenAIPartToA2APartConverter=convert_genai_part_to_a2a_part, a2a_part_converter: google.adk.a2a.converters.part_converter.A2APartToGenAIPartConverter=convert_a2a_part_to_genai_part, a2a_client_factory: typing.Optional[a2a.client.client_factory.ClientFactory]=None, a2a_request_meta_provider: typing.Optional[typing.Callable[[InvocationContext, A2AMessage], dict[str, typing.Any]]]=None, full_history_when_stateless: bool=False) -> None:'
  methods:
  - signature: 'def _run_async_impl(self, ctx: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
    docstring: Core implementation for async agent execution.
  - signature: 'def cleanup(self) -> None:'
    docstring: Clean up resources, especially the HTTP client if owned by this agent.
  inherited_methods:
    BaseAgent:
    - signature: 'def clone(self: google.adk.agents.base_agent.SelfAgent, update: Mapping[str, Any] | None) -> google.adk.agents.base_agent.SelfAgent:'
      docstring: "Creates a copy of this agent instance.\n\nArgs:\n  update: Optional mapping of new values for the fields of the cloned agent.\n    The keys of the mapping are the names of the fields to be updated, and\n    the values are the new values for those fields.\n    For example: {\"name\": \"cloned_agent\"}\n\nReturns:\n  A new agent instance with identical configuration as the original\n  agent except for the fields specified in the update."
    - signature: 'def run_async(self, parent_context: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
      docstring: "Entry method to run an agent via text-based conversation.\n\nArgs:\n  parent_context: InvocationContext, the invocation context of the parent\n    agent.\n\nYields:\n  Event: the events generated by the agent."
    - signature: 'def run_live(self, parent_context: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
      docstring: "Entry method to run an agent via video/audio-based conversation.\n\nArgs:\n  parent_context: InvocationContext, the invocation context of the parent\n    agent.\n\nYields:\n  Event: the events generated by the agent."
    - signature: 'def _run_async_impl(self, ctx: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
      docstring: "Core logic to run this agent via text-based conversation.\n\nArgs:\n  ctx: InvocationContext, the invocation context for this agent.\n\nYields:\n  Event: the events generated by the agent."
    - signature: 'def root_agent(self) -> google.adk.agents.base_agent.BaseAgent:'
      docstring: Gets the root agent of this agent.
    - signature: 'def find_agent(self, name: str) -> typing.Optional[google.adk.agents.base_agent.BaseAgent]:'
      docstring: "Finds the agent with the given name in this agent and its descendants.\n\nArgs:\n  name: The name of the agent to find.\n\nReturns:\n  The agent with the matching name, or None if no such agent is found."
    - signature: 'def find_sub_agent(self, name: str) -> typing.Optional[google.adk.agents.base_agent.BaseAgent]:'
      docstring: "Finds the agent with the given name in this agent's descendants.\n\nArgs:\n  name: The name of the agent to find.\n\nReturns:\n  The agent with the matching name, or None if no such agent is found."
    - signature: 'def model_post_init(self, __context: typing.Any) -> None:'
    - signature: 'def validate_name(cls, value: str):'
    - signature: 'def validate_sub_agents_unique_names(cls, value: list[google.adk.agents.base_agent.BaseAgent]) -> list[google.adk.agents.base_agent.BaseAgent]:'
      docstring: "Validates that all sub-agents have unique names.\n\nArgs:\n  value: The list of sub-agents to validate.\n\nReturns:\n  The validated list of sub-agents."
    - signature: 'def from_config(cls: typing.Type[google.adk.agents.base_agent.SelfAgent], config: google.adk.agents.base_agent_config.BaseAgentConfig, config_abs_path: str) -> google.adk.agents.base_agent.SelfAgent:'
      docstring: "Creates an agent from a config.\n\nIf sub-classes uses a custom agent config, override `_from_config_kwargs`\nmethod to return an updated kwargs for agent constructor.\n\nArgs:\n  config: The config to create the agent from.\n  config_abs_path: The absolute path to the config file that contains the\n    agent config.\n\nReturns:\n  The created agent."
  inherited_properties:
    BaseAgent:
    - signature: 'model_config: pydantic.ConfigDict'
      docstring: The pydantic model config.
    - signature: 'config_type: typing.ClassVar[type[google.adk.agents.base_agent_config.BaseAgentConfig]]'
      docstring: "The config type for this agent.\n\nSub-classes should override this to specify their own config type.\n\nExample:\n\n```\nclass MyAgentConfig(BaseAgentConfig):\n  my_field: str = ''\n\nclass MyAgent(BaseAgent):\n  config_type: ClassVar[type[BaseAgentConfig]] = MyAgentConfig\n```"
    - signature: 'name: str'
      docstring: 'The agent''s name.


        Agent name must be a Python identifier and unique within the agent tree.

        Agent name cannot be "user", since it''s reserved for end-user''s input.'
    - signature: 'description: str'
      docstring: 'Description about the agent''s capability.


        The model uses this to determine whether to delegate control to the agent.

        One-line description is enough and preferred.'
    - signature: 'parent_agent: typing.Optional[google.adk.agents.base_agent.BaseAgent]'
      docstring: 'The parent agent of this agent.


        Note that an agent can ONLY be added as sub-agent once.


        If you want to add one agent twice as sub-agent, consider to create two agent

        instances with identical config, but with different name and add them to the

        agent tree.'
    - signature: 'sub_agents: list[google.adk.agents.base_agent.BaseAgent]'
      docstring: The sub-agents of this agent.
    - signature: 'before_agent_callback: typing.Optional[google.adk.agents.base_agent.BeforeAgentCallback]'
      docstring: "Callback or list of callbacks to be invoked before the agent run.\n\nWhen a list of callbacks is provided, the callbacks will be called in the\norder they are listed until a callback does not return None.\n\nArgs:\n  callback_context: MUST be named 'callback_context' (enforced).\n\nReturns:\n  Optional[types.Content]: The content to return to the user.\n    When the content is present, the agent run will be skipped and the\n    provided content will be returned to user."
    - signature: 'after_agent_callback: typing.Optional[google.adk.agents.base_agent.AfterAgentCallback]'
      docstring: "Callback or list of callbacks to be invoked after the agent run.\n\nWhen a list of callbacks is provided, the callbacks will be called in the\norder they are listed until a callback does not return None.\n\nArgs:\n  callback_context: MUST be named 'callback_context' (enforced).\n\nReturns:\n  Optional[types.Content]: The content to return to the user.\n    When the content is present, an additional event with the provided content\n    will be appended to event history as an additional agent response."
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 29
  id: google.adk.events.event_actions.EventActions
  name: EventActions
  file_path: src/google/adk/events/event_actions.py
  type: CLASS
  group: Seed
  usage_score: 4
  docstring: 'Represents the actions attached to an event.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, skip_summarization: typing.Optional[bool] = None, state_delta: dict[str, object] = dict(), artifact_delta: dict[str, int] = dict(), transfer_to_agent: typing.Optional[str] = None, escalate: typing.Optional[bool] = None, requested_auth_configs: dict[str, google.adk.auth.auth_tool.AuthConfig] = dict(), requested_tool_confirmations: dict[str, google.adk.tools.tool_confirmation.ToolConfirmation] = dict(), compaction: typing.Optional[google.adk.events.event_actions.EventCompaction] = None, end_of_agent: typing.Optional[bool] = None, agent_state: typing.Optional[dict[str, typing.Any]] = None, rewind_before_invocation_id: typing.Optional[str] = None):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
    docstring: The pydantic model config.
  - signature: 'skip_summarization: typing.Optional[bool]'
    docstring: 'If true, it won''t call model to summarize function response.


      Only used for function_response event.'
  - signature: 'state_delta: dict[str, object]'
    docstring: Indicates that the event is updating the state with the given delta.
  - signature: 'artifact_delta: dict[str, int]'
    docstring: 'Indicates that the event is updating an artifact. key is the filename,

      value is the version.'
  - signature: 'transfer_to_agent: typing.Optional[str]'
    docstring: If set, the event transfers to the specified agent.
  - signature: 'escalate: typing.Optional[bool]'
    docstring: The agent is escalating to a higher level agent.
  - signature: 'requested_auth_configs: dict[str, google.adk.auth.auth_tool.AuthConfig]'
    docstring: 'Authentication configurations requested by tool responses.


      This field will only be set by a tool response event indicating tool request

      auth credential.

      - Keys: The function call id. Since one function response event could contain

      multiple function responses that correspond to multiple function calls. Each

      function call could request different auth configs. This id is used to

      identify the function call.

      - Values: The requested auth config.'
  - signature: 'requested_tool_confirmations: dict[str, google.adk.tools.tool_confirmation.ToolConfirmation]'
    docstring: 'A dict of tool confirmation requested by this event, keyed by

      function call id.'
  - signature: 'compaction: typing.Optional[google.adk.events.event_actions.EventCompaction]'
    docstring: The compaction of the events.
  - signature: 'end_of_agent: typing.Optional[bool]'
    docstring: 'If true, the current agent has finished its current run. Note that there

      can be multiple events with end_of_agent=True for the same agent within one

      invocation when there is a loop. This should only be set by ADK workflow.'
  - signature: 'agent_state: typing.Optional[dict[str, typing.Any]]'
    docstring: 'The agent state at the current event, used for checkpoint and resume. This

      should only be set by ADK workflow.'
  - signature: 'rewind_before_invocation_id: typing.Optional[str]'
    docstring: The invocation id to rewind to. This is only set for rewind event.
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 30
  id: google.adk.tools.vertex_ai_search_tool.VertexAiSearchTool
  name: VertexAiSearchTool
  file_path: src/google/adk/tools/vertex_ai_search_tool.py
  type: CLASS
  group: Seed
  usage_score: 3
  docstring: "A built-in tool using Vertex AI Search.\n\nAttributes:\n  data_store_id: The Vertex AI search data store resource ID.\n  search_engine_id: The Vertex AI search engine resource ID.\n\nTo dynamically customize the search configuration at runtime (e.g., set\nfilter based on user context), subclass this tool and override the\n`_build_vertex_ai_search_config` method.\n\nExample:\n  ```python\n  class DynamicFilterSearchTool(VertexAiSearchTool):\n    def _build_vertex_ai_search_config(\n        self, ctx: ReadonlyContext\n    ) -> types.VertexAISearch:\n      user_id = ctx.state.get('user_id')\n      return types.VertexAISearch(\n          datastore=self.data_store_id,\n          engine=self.search_engine_id,\n          filter=f\"user_id = '{user_id}'\",\n          max_results=self.max_results,\n      )\n  ```\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, *, data_store_id: typing.Optional[str]=None, data_store_specs: typing.Optional[list[google.genai.types.VertexAISearchDataStoreSpec]]=None, search_engine_id: typing.Optional[str]=None, filter: typing.Optional[str]=None, max_results: typing.Optional[int]=None, bypass_multi_tools_limit: bool=False):'
  methods:
  - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.LlmRequest) -> None:'
  inherited_methods:
    BaseTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
      docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
      docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  inherited_properties:
    BaseTool:
    - signature: 'name: str'
      docstring: The name of the tool.
    - signature: 'description: str'
      docstring: The description of the tool.
    - signature: 'is_long_running: bool'
      docstring: 'Whether the tool is a long running operation, which typically returns a

        resource id first and finishes the operation later.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the BaseTool.


        An optional key-value pair for storing and retrieving tool-specific metadata,

        such as tool manifests, etc.


        NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 31
  id: google.adk.tools.example_tool.ExampleTool
  name: ExampleTool
  file_path: src/google/adk/tools/example_tool.py
  type: CLASS
  group: Seed
  usage_score: 3
  docstring: "A tool that adds (few-shot) examples to the LLM request.\n\nAttributes:\n  examples: The examples to add to the LLM request.\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, examples: typing.Union[list[google.adk.examples.example.Example], google.adk.examples.base_example_provider.BaseExampleProvider]):'
  methods:
  - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
  - signature: 'def from_config(cls: type[google.adk.tools.example_tool.ExampleTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.example_tool.ExampleTool:'
  inherited_methods:
    BaseTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
      docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
      docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  inherited_properties:
    BaseTool:
    - signature: 'name: str'
      docstring: The name of the tool.
    - signature: 'description: str'
      docstring: The description of the tool.
    - signature: 'is_long_running: bool'
      docstring: 'Whether the tool is a long running operation, which typically returns a

        resource id first and finishes the operation later.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the BaseTool.


        An optional key-value pair for storing and retrieving tool-specific metadata,

        such as tool manifests, etc.


        NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 32
  id: google.adk.tools.bigtable.bigtable_credentials.BigtableCredentialsConfig
  name: BigtableCredentialsConfig
  file_path: src/google/adk/tools/bigtable/bigtable_credentials.py
  type: CLASS
  group: Seed
  usage_score: 3
  docstring: 'Bigtable Credentials Configuration for Google API tools (Experimental).


    Please do not use this in production, as it may be deprecated later.


    [Note: Inherited members from BaseGoogleCredentialsConfig are omitted.]'
  omitted_inherited_members_from:
  - BaseGoogleCredentialsConfig
- rank: 33
  id: google.adk.tools.bigquery.bigquery_credentials.BigQueryCredentialsConfig
  name: BigQueryCredentialsConfig
  file_path: src/google/adk/tools/bigquery/bigquery_credentials.py
  type: CLASS
  group: Seed
  usage_score: 3
  docstring: 'BigQuery Credentials Configuration for Google API tools (Experimental).


    Please do not use this in production, as it may be deprecated later.


    [Note: Inherited members from BaseGoogleCredentialsConfig are omitted.]'
  omitted_inherited_members_from:
  - BaseGoogleCredentialsConfig
- rank: 34
  id: google.adk.tools.bigquery.bigquery_toolset.BigQueryToolset
  name: BigQueryToolset
  file_path: src/google/adk/tools/bigquery/bigquery_toolset.py
  type: CLASS
  group: Seed
  usage_score: 3
  docstring: 'BigQuery Toolset contains tools for interacting with BigQuery data and metadata.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, *, tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]]=None, credentials_config: typing.Optional[google.adk.tools.bigquery.bigquery_credentials.BigQueryCredentialsConfig]=None, bigquery_tool_config: typing.Optional[google.adk.tools.bigquery.config.BigQueryToolConfig]=None):'
  methods:
  - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> typing.List[google.adk.tools.base_tool.BaseTool]:'
    docstring: Get tools from the toolset.
  - signature: 'def close(self):'
  inherited_methods:
    BaseToolset:
    - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools in the toolset based on the provided context.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools available under the specified context."
    - signature: 'def get_tools_with_prefix(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools with optional prefix applied to tool names.\n\nThis method calls get_tools() and applies prefixing if tool_name_prefix is provided.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools with prefixed names if tool_name_prefix is provided."
    - signature: 'def close(self) -> None:'
      docstring: "Performs cleanup and releases resources held by the toolset.\n\nNOTE:\n  This method is invoked, for example, at the end of an agent server's\n  lifecycle or when the toolset is no longer needed. Implementations\n  should ensure that any open connections, files, or other managed\n  resources are properly released to prevent leaks."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_toolset.SelfToolset], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_toolset.SelfToolset:'
      docstring: "Creates a toolset instance from a config.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The toolset instance."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this toolset. This method will be\ncalled before each tool processes the llm request.\n\nUse cases:\n- Instead of let each tool process the llm request, we can let the toolset\n  process the llm request. e.g. ComputerUseToolset can add computer use\n  tool to the llm request.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def get_auth_config(self) -> typing.Optional[google.adk.auth.auth_tool.AuthConfig]:'
      docstring: "Returns the auth config for this toolset. ADK will make sure the\n'exchanged_auth_credential' field in the config is populated with\nready-to-use credential (e.g. oauth token for OAuth flow) before calling\nget_tools method or execute any tools returned by this toolset. Thus toolset\ncan use this credential either for tool listing or tool calling. If tool\ncalling needs a different credential from ADK client, call\ntool_context.request_credential in the tool.\n\nToolsets that support authentication should override this method to return\nan AuthConfig constructed from their auth_scheme, auth_credential, and\noptional credential_key parameters.\n\nReturns:\n  AuthConfig if the toolset has authentication configured, None otherwise."
  omitted_inherited_members_from:
  - ABC
- rank: 35
  id: google.adk.tools.pubsub.pubsub_credentials.PubSubCredentialsConfig
  name: PubSubCredentialsConfig
  file_path: src/google/adk/tools/pubsub/pubsub_credentials.py
  type: CLASS
  group: Seed
  usage_score: 3
  docstring: 'Pub/Sub Credentials Configuration for Google API tools (Experimental).


    Please do not use this in production, as it may be deprecated later.


    [Note: Inherited members from BaseGoogleCredentialsConfig are omitted.]'
  aliases:
  - google.adk.tools.pubsub.PubSubCredentialsConfig
  omitted_inherited_members_from:
  - BaseGoogleCredentialsConfig
- rank: 36
  id: google.adk.auth.auth_credential.OAuth2Auth
  name: OAuth2Auth
  file_path: src/google/adk/auth/auth_credential.py
  type: CLASS
  group: Seed
  usage_score: 3
  docstring: 'Represents credential value and its metadata for a OAuth2 credential.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, client_id: typing.Optional[str] = None, client_secret: typing.Optional[str] = None, auth_uri: typing.Optional[str] = None, state: typing.Optional[str] = None, redirect_uri: typing.Optional[str] = None, auth_response_uri: typing.Optional[str] = None, auth_code: typing.Optional[str] = None, access_token: typing.Optional[str] = None, refresh_token: typing.Optional[str] = None, expires_at: typing.Optional[int] = None, expires_in: typing.Optional[int] = None, audience: typing.Optional[str] = None, token_endpoint_auth_method: typing.Optional[typing.Literal[client_secret_basic, client_secret_post, client_secret_jwt, private_key_jwt]] = ''client_secret_basic''):'
  properties:
  - signature: 'client_id: typing.Optional[str]'
  - signature: 'client_secret: typing.Optional[str]'
  - signature: 'auth_uri: typing.Optional[str]'
  - signature: 'state: typing.Optional[str]'
  - signature: 'redirect_uri: typing.Optional[str]'
  - signature: 'auth_response_uri: typing.Optional[str]'
  - signature: 'auth_code: typing.Optional[str]'
  - signature: 'access_token: typing.Optional[str]'
  - signature: 'refresh_token: typing.Optional[str]'
  - signature: 'expires_at: typing.Optional[int]'
  - signature: 'expires_in: typing.Optional[int]'
  - signature: 'audience: typing.Optional[str]'
  - signature: 'token_endpoint_auth_method: typing.Optional[typing.Literal[client_secret_basic, client_secret_post, client_secret_jwt, private_key_jwt]]'
  inherited_properties:
    BaseModelWithConfig:
    - signature: 'model_config: pydantic.ConfigDict'
      docstring: The pydantic model config.
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 37
  id: google.adk.agents.parallel_agent.ParallelAgent
  name: ParallelAgent
  file_path: src/google/adk/agents/parallel_agent.py
  type: CLASS
  group: Seed
  usage_score: 3
  docstring: 'A shell agent that runs its sub-agents in parallel in an isolated manner.


    This approach is beneficial for scenarios requiring multiple perspectives or

    attempts on a single task, such as:


    - Running different algorithms simultaneously.

    - Generating multiple responses for review by a subsequent evaluation agent.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, name: str, description: str = '''', sub_agents: list[google.adk.agents.base_agent.BaseAgent] = list(), before_agent_callback: typing.Optional[google.adk.agents.base_agent.BeforeAgentCallback] = None, after_agent_callback: typing.Optional[google.adk.agents.base_agent.AfterAgentCallback] = None):'
  methods:
  - signature: 'def _run_async_impl(self, ctx: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
  properties:
  - signature: 'config_type: typing.ClassVar[type[google.adk.agents.base_agent_config.BaseAgentConfig]]'
    docstring: The config type for this agent.
  inherited_methods:
    BaseAgent:
    - signature: 'def clone(self: google.adk.agents.base_agent.SelfAgent, update: Mapping[str, Any] | None) -> google.adk.agents.base_agent.SelfAgent:'
      docstring: "Creates a copy of this agent instance.\n\nArgs:\n  update: Optional mapping of new values for the fields of the cloned agent.\n    The keys of the mapping are the names of the fields to be updated, and\n    the values are the new values for those fields.\n    For example: {\"name\": \"cloned_agent\"}\n\nReturns:\n  A new agent instance with identical configuration as the original\n  agent except for the fields specified in the update."
    - signature: 'def run_async(self, parent_context: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
      docstring: "Entry method to run an agent via text-based conversation.\n\nArgs:\n  parent_context: InvocationContext, the invocation context of the parent\n    agent.\n\nYields:\n  Event: the events generated by the agent."
    - signature: 'def run_live(self, parent_context: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
      docstring: "Entry method to run an agent via video/audio-based conversation.\n\nArgs:\n  parent_context: InvocationContext, the invocation context of the parent\n    agent.\n\nYields:\n  Event: the events generated by the agent."
    - signature: 'def _run_async_impl(self, ctx: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
      docstring: "Core logic to run this agent via text-based conversation.\n\nArgs:\n  ctx: InvocationContext, the invocation context for this agent.\n\nYields:\n  Event: the events generated by the agent."
    - signature: 'def root_agent(self) -> google.adk.agents.base_agent.BaseAgent:'
      docstring: Gets the root agent of this agent.
    - signature: 'def find_agent(self, name: str) -> typing.Optional[google.adk.agents.base_agent.BaseAgent]:'
      docstring: "Finds the agent with the given name in this agent and its descendants.\n\nArgs:\n  name: The name of the agent to find.\n\nReturns:\n  The agent with the matching name, or None if no such agent is found."
    - signature: 'def find_sub_agent(self, name: str) -> typing.Optional[google.adk.agents.base_agent.BaseAgent]:'
      docstring: "Finds the agent with the given name in this agent's descendants.\n\nArgs:\n  name: The name of the agent to find.\n\nReturns:\n  The agent with the matching name, or None if no such agent is found."
    - signature: 'def model_post_init(self, __context: typing.Any) -> None:'
    - signature: 'def validate_name(cls, value: str):'
    - signature: 'def validate_sub_agents_unique_names(cls, value: list[google.adk.agents.base_agent.BaseAgent]) -> list[google.adk.agents.base_agent.BaseAgent]:'
      docstring: "Validates that all sub-agents have unique names.\n\nArgs:\n  value: The list of sub-agents to validate.\n\nReturns:\n  The validated list of sub-agents."
    - signature: 'def from_config(cls: typing.Type[google.adk.agents.base_agent.SelfAgent], config: google.adk.agents.base_agent_config.BaseAgentConfig, config_abs_path: str) -> google.adk.agents.base_agent.SelfAgent:'
      docstring: "Creates an agent from a config.\n\nIf sub-classes uses a custom agent config, override `_from_config_kwargs`\nmethod to return an updated kwargs for agent constructor.\n\nArgs:\n  config: The config to create the agent from.\n  config_abs_path: The absolute path to the config file that contains the\n    agent config.\n\nReturns:\n  The created agent."
  inherited_properties:
    BaseAgent:
    - signature: 'model_config: pydantic.ConfigDict'
      docstring: The pydantic model config.
    - signature: 'config_type: typing.ClassVar[type[google.adk.agents.base_agent_config.BaseAgentConfig]]'
      docstring: "The config type for this agent.\n\nSub-classes should override this to specify their own config type.\n\nExample:\n\n```\nclass MyAgentConfig(BaseAgentConfig):\n  my_field: str = ''\n\nclass MyAgent(BaseAgent):\n  config_type: ClassVar[type[BaseAgentConfig]] = MyAgentConfig\n```"
    - signature: 'name: str'
      docstring: 'The agent''s name.


        Agent name must be a Python identifier and unique within the agent tree.

        Agent name cannot be "user", since it''s reserved for end-user''s input.'
    - signature: 'description: str'
      docstring: 'Description about the agent''s capability.


        The model uses this to determine whether to delegate control to the agent.

        One-line description is enough and preferred.'
    - signature: 'parent_agent: typing.Optional[google.adk.agents.base_agent.BaseAgent]'
      docstring: 'The parent agent of this agent.


        Note that an agent can ONLY be added as sub-agent once.


        If you want to add one agent twice as sub-agent, consider to create two agent

        instances with identical config, but with different name and add them to the

        agent tree.'
    - signature: 'sub_agents: list[google.adk.agents.base_agent.BaseAgent]'
      docstring: The sub-agents of this agent.
    - signature: 'before_agent_callback: typing.Optional[google.adk.agents.base_agent.BeforeAgentCallback]'
      docstring: "Callback or list of callbacks to be invoked before the agent run.\n\nWhen a list of callbacks is provided, the callbacks will be called in the\norder they are listed until a callback does not return None.\n\nArgs:\n  callback_context: MUST be named 'callback_context' (enforced).\n\nReturns:\n  Optional[types.Content]: The content to return to the user.\n    When the content is present, the agent run will be skipped and the\n    provided content will be returned to user."
    - signature: 'after_agent_callback: typing.Optional[google.adk.agents.base_agent.AfterAgentCallback]'
      docstring: "Callback or list of callbacks to be invoked after the agent run.\n\nWhen a list of callbacks is provided, the callbacks will be called in the\norder they are listed until a callback does not return None.\n\nArgs:\n  callback_context: MUST be named 'callback_context' (enforced).\n\nReturns:\n  Optional[types.Content]: The content to return to the user.\n    When the content is present, an additional event with the provided content\n    will be appended to event history as an additional agent response."
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 38
  id: google.adk.tools.google_search_tool.GoogleSearchTool
  name: GoogleSearchTool
  file_path: src/google/adk/tools/google_search_tool.py
  type: CLASS
  group: Seed
  usage_score: 2
  docstring: 'A built-in tool that is automatically invoked by Gemini 2 models to retrieve search results from Google Search.


    This tool operates internally within the model and does not require or perform

    local code execution.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, *, bypass_multi_tools_limit: bool=False, model: str | None=None):'
  methods:
  - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.LlmRequest) -> None:'
  inherited_methods:
    BaseTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
      docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
      docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  inherited_properties:
    BaseTool:
    - signature: 'name: str'
      docstring: The name of the tool.
    - signature: 'description: str'
      docstring: The description of the tool.
    - signature: 'is_long_running: bool'
      docstring: 'Whether the tool is a long running operation, which typically returns a

        resource id first and finishes the operation later.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the BaseTool.


        An optional key-value pair for storing and retrieving tool-specific metadata,

        such as tool manifests, etc.


        NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 39
  id: google.adk.tools.authenticated_function_tool.AuthenticatedFunctionTool
  name: AuthenticatedFunctionTool
  file_path: src/google/adk/tools/authenticated_function_tool.py
  type: CLASS
  group: Seed
  usage_score: 2
  docstring: 'A FunctionTool that handles authentication before the actual tool logic

    gets called. Functions can accept a special `credential` argument which is the

    credential ready for use.(Experimental)


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, *, func: typing.Callable[Ellipsis, typing.Any], auth_config: google.adk.auth.auth_tool.AuthConfig=None, response_for_auth_required: typing.Optional[typing.Union[dict[str, typing.Any], str]]=None):'
  methods:
  - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
  - signature: 'def _run_async_impl(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, credential: google.adk.auth.auth_credential.AuthCredential) -> typing.Any:'
  inherited_methods:
    FunctionTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
    BaseTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
      docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
      docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  inherited_properties:
    BaseTool:
    - signature: 'name: str'
      docstring: The name of the tool.
    - signature: 'description: str'
      docstring: The description of the tool.
    - signature: 'is_long_running: bool'
      docstring: 'Whether the tool is a long running operation, which typically returns a

        resource id first and finishes the operation later.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the BaseTool.


        An optional key-value pair for storing and retrieving tool-specific metadata,

        such as tool manifests, etc.


        NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 40
  id: google.adk.tools.long_running_tool.LongRunningFunctionTool
  name: LongRunningFunctionTool
  file_path: src/google/adk/tools/long_running_tool.py
  type: CLASS
  group: Seed
  usage_score: 2
  docstring: "A function tool that returns the result asynchronously.\n\nThis tool is used for long-running operations that may take a significant\namount of time to complete. The framework will call the function. Once the\nfunction returns, the response will be returned asynchronously to the\nframework which is identified by the function_call_id.\n\nExample:\n```python\ntool = LongRunningFunctionTool(a_long_running_function)\n```\n\nAttributes:\n  is_long_running: Whether the tool is a long running operation.\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, func: typing.Callable):'
  inherited_methods:
    FunctionTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
    BaseTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
      docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
      docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  inherited_properties:
    BaseTool:
    - signature: 'name: str'
      docstring: The name of the tool.
    - signature: 'description: str'
      docstring: The description of the tool.
    - signature: 'is_long_running: bool'
      docstring: 'Whether the tool is a long running operation, which typically returns a

        resource id first and finishes the operation later.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the BaseTool.


        An optional key-value pair for storing and retrieving tool-specific metadata,

        such as tool manifests, etc.


        NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 41
  id: google.adk.tools.retrieval.vertex_ai_rag_retrieval.VertexAiRagRetrieval
  name: VertexAiRagRetrieval
  file_path: src/google/adk/tools/retrieval/vertex_ai_rag_retrieval.py
  type: CLASS
  group: Seed
  usage_score: 2
  docstring: 'A retrieval tool that uses Vertex AI RAG (Retrieval-Augmented Generation) to retrieve data.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, *, name: str, description: str, rag_corpora: list[str]=None, rag_resources: list[google.adk.dependencies.vertexai.rag.RagResource]=None, similarity_top_k: int=None, vector_distance_threshold: float=None):'
  methods:
  - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.LlmRequest) -> None:'
  - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
  inherited_methods:
    BaseTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
      docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
      docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  inherited_properties:
    BaseTool:
    - signature: 'name: str'
      docstring: The name of the tool.
    - signature: 'description: str'
      docstring: The description of the tool.
    - signature: 'is_long_running: bool'
      docstring: 'Whether the tool is a long running operation, which typically returns a

        resource id first and finishes the operation later.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the BaseTool.


        An optional key-value pair for storing and retrieving tool-specific metadata,

        such as tool manifests, etc.


        NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 42
  id: google.adk.tools.spanner.spanner_toolset.SpannerToolset
  name: SpannerToolset
  file_path: src/google/adk/tools/spanner/spanner_toolset.py
  type: CLASS
  group: Seed
  usage_score: 2
  docstring: "Spanner Toolset contains tools for interacting with Spanner data, database and table information.\n\nThe tool names are:\n  - spanner_list_table_names\n  - spanner_list_table_indexes\n  - spanner_list_table_index_columns\n  - spanner_list_named_schemas\n  - spanner_get_table_schema\n  - spanner_execute_sql\n  - spanner_similarity_search\n  - spanner_vector_store_similarity_search\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, *, tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]]=None, credentials_config: typing.Optional[google.adk.tools.spanner.spanner_credentials.SpannerCredentialsConfig]=None, spanner_tool_settings: typing.Optional[google.adk.tools.spanner.settings.SpannerToolSettings]=None):'
  aliases:
  - google.adk.tools.spanner.SpannerToolset
  methods:
  - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> typing.List[google.adk.tools.base_tool.BaseTool]:'
    docstring: Get tools from the toolset.
  - signature: 'def close(self):'
  inherited_methods:
    BaseToolset:
    - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools in the toolset based on the provided context.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools available under the specified context."
    - signature: 'def get_tools_with_prefix(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools with optional prefix applied to tool names.\n\nThis method calls get_tools() and applies prefixing if tool_name_prefix is provided.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools with prefixed names if tool_name_prefix is provided."
    - signature: 'def close(self) -> None:'
      docstring: "Performs cleanup and releases resources held by the toolset.\n\nNOTE:\n  This method is invoked, for example, at the end of an agent server's\n  lifecycle or when the toolset is no longer needed. Implementations\n  should ensure that any open connections, files, or other managed\n  resources are properly released to prevent leaks."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_toolset.SelfToolset], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_toolset.SelfToolset:'
      docstring: "Creates a toolset instance from a config.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The toolset instance."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this toolset. This method will be\ncalled before each tool processes the llm request.\n\nUse cases:\n- Instead of let each tool process the llm request, we can let the toolset\n  process the llm request. e.g. ComputerUseToolset can add computer use\n  tool to the llm request.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def get_auth_config(self) -> typing.Optional[google.adk.auth.auth_tool.AuthConfig]:'
      docstring: "Returns the auth config for this toolset. ADK will make sure the\n'exchanged_auth_credential' field in the config is populated with\nready-to-use credential (e.g. oauth token for OAuth flow) before calling\nget_tools method or execute any tools returned by this toolset. Thus toolset\ncan use this credential either for tool listing or tool calling. If tool\ncalling needs a different credential from ADK client, call\ntool_context.request_credential in the tool.\n\nToolsets that support authentication should override this method to return\nan AuthConfig constructed from their auth_scheme, auth_credential, and\noptional credential_key parameters.\n\nReturns:\n  AuthConfig if the toolset has authentication configured, None otherwise."
  omitted_inherited_members_from:
  - ABC
- rank: 43
  id: google.adk.tools.spanner.utils.execute_sql
  name: execute_sql
  file_path: src/google/adk/tools/spanner/utils.py
  type: METHOD
  group: Seed
  usage_score: 2
  docstring: "Utility function to run a Spanner Read-Only query in the spanner database and return the result.\n\nArgs:\n    project_id (str): The GCP project id in which the spanner database\n      resides.\n    instance_id (str): The instance id of the spanner database.\n    database_id (str): The database id of the spanner database.\n    query (str): The Spanner SQL query to be executed.\n    credentials (Credentials): The credentials to use for the request.\n    settings (SpannerToolSettings): The settings for the tool.\n    tool_context (ToolContext): The context for the tool.\n    params (dict): values for parameter replacement.  Keys must match the\n      names used in ``query``.\n    params_types (dict): maps explicit types for one or more param values.\n\nReturns:\n    dict: Dictionary with the result of the query.\n          If the result contains the key \"result_is_likely_truncated\" with\n          value True, it means that there may be additional rows matching the\n       \
    \   query not returned in the result."
  signature: 'def execute_sql(project_id: str, instance_id: str, database_id: str, query: str, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.spanner.settings.SpannerToolSettings, tool_context: google.adk.tools.tool_context.ToolContext, params: typing.Optional[dict], params_types: typing.Optional[dict]) -> dict:'
- rank: 44
  id: google.adk.tools.spanner.settings.SpannerToolSettings
  name: SpannerToolSettings
  file_path: src/google/adk/tools/spanner/settings.py
  type: CLASS
  group: Seed
  usage_score: 2
  docstring: 'Settings for Spanner tools.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, capabilities: typing.List[google.adk.tools.spanner.settings.Capabilities] = [Capabilities.DATA_READ], max_executed_query_result_rows: int = 50, query_result_mode: google.adk.tools.spanner.settings.QueryResultMode = QueryResultMode.DEFAULT, vector_store_settings: typing.Optional[google.adk.tools.spanner.settings.SpannerVectorStoreSettings] = None):'
  properties:
  - signature: 'capabilities: typing.List[google.adk.tools.spanner.settings.Capabilities]'
    docstring: 'Allowed capabilities for Spanner tools.


      By default, the tool will allow only read operations. This behaviour may

      change in future versions.'
  - signature: 'max_executed_query_result_rows: int'
    docstring: Maximum number of rows to return from a query result.
  - signature: 'query_result_mode: google.adk.tools.spanner.settings.QueryResultMode'
    docstring: Mode for Spanner execute sql query result.
  - signature: 'vector_store_settings: typing.Optional[google.adk.tools.spanner.settings.SpannerVectorStoreSettings]'
    docstring: Settings for Spanner vector store and vector similarity search.
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 45
  id: google.adk.tools.application_integration_tool.application_integration_toolset.ApplicationIntegrationToolset
  name: ApplicationIntegrationToolset
  file_path: src/google/adk/tools/application_integration_tool/application_integration_toolset.py
  type: CLASS
  group: Seed
  usage_score: 2
  docstring: "ApplicationIntegrationToolset generates tools from a given Application\nIntegration or Integration Connector resource.\n\nExample Usage::\n\n  # Get all available tools for an integration with api trigger\n  application_integration_toolset = ApplicationIntegrationToolset(\n      project=\"test-project\",\n      location=\"us-central1\"\n      integration=\"test-integration\",\n      triggers=[\"api_trigger/test_trigger\"],\n      service_account_credentials={...},\n  )\n\n  # Get all available tools for a connection using entity operations and\n  # actions\n  # Note: Find the list of supported entity operations and actions for a\n  # connection using integration connector apis:\n  # https://cloud.google.com/integration-connectors/docs/reference/rest/v1/projects.locations.connections.connectionSchemaMetadata\n  application_integration_toolset = ApplicationIntegrationToolset(\n      project=\"test-project\",\n      location=\"us-central1\"\n      connection=\"test-connection\"\
    ,\n      entity_operations=[\"EntityId1\": [\"LIST\",\"CREATE\"], \"EntityId2\": []],\n      #empty list for actions means all operations on the entity are supported\n      actions=[\"action1\"],\n      service_account_credentials={...},\n  )\n\n  # Feed the toolset to agent\n  agent = LlmAgent(tools=[\n      ...,\n      application_integration_toolset,\n  ])\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, project: str, location: str, connection_template_override: typing.Optional[str], integration: typing.Optional[str], triggers: typing.Optional[typing.List[str]], connection: typing.Optional[str], entity_operations: typing.Optional[str], actions: typing.Optional[list[str]], tool_name_prefix: typing.Optional[str], tool_instructions: typing.Optional[str], service_account_json: typing.Optional[str], auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme], auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential], tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]]):'
  aliases:
  - google.adk.tools.application_integration_tool.ApplicationIntegrationToolset
  methods:
  - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> typing.List[google.adk.tools.openapi_tool.openapi_spec_parser.rest_api_tool.RestApiTool]:'
  - signature: 'def close(self) -> None:'
  - signature: 'def get_auth_config(self) -> typing.Optional[google.adk.auth.auth_tool.AuthConfig]:'
    docstring: 'Returns the auth config for this toolset.


      ADK will populate exchanged_auth_credential on this config before calling

      get_tools(). The toolset can then access the ready-to-use credential via

      self._auth_config.exchanged_auth_credential.'
  inherited_methods:
    BaseToolset:
    - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools in the toolset based on the provided context.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools available under the specified context."
    - signature: 'def get_tools_with_prefix(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools with optional prefix applied to tool names.\n\nThis method calls get_tools() and applies prefixing if tool_name_prefix is provided.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools with prefixed names if tool_name_prefix is provided."
    - signature: 'def close(self) -> None:'
      docstring: "Performs cleanup and releases resources held by the toolset.\n\nNOTE:\n  This method is invoked, for example, at the end of an agent server's\n  lifecycle or when the toolset is no longer needed. Implementations\n  should ensure that any open connections, files, or other managed\n  resources are properly released to prevent leaks."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_toolset.SelfToolset], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_toolset.SelfToolset:'
      docstring: "Creates a toolset instance from a config.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The toolset instance."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this toolset. This method will be\ncalled before each tool processes the llm request.\n\nUse cases:\n- Instead of let each tool process the llm request, we can let the toolset\n  process the llm request. e.g. ComputerUseToolset can add computer use\n  tool to the llm request.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def get_auth_config(self) -> typing.Optional[google.adk.auth.auth_tool.AuthConfig]:'
      docstring: "Returns the auth config for this toolset. ADK will make sure the\n'exchanged_auth_credential' field in the config is populated with\nready-to-use credential (e.g. oauth token for OAuth flow) before calling\nget_tools method or execute any tools returned by this toolset. Thus toolset\ncan use this credential either for tool listing or tool calling. If tool\ncalling needs a different credential from ADK client, call\ntool_context.request_credential in the tool.\n\nToolsets that support authentication should override this method to return\nan AuthConfig constructed from their auth_scheme, auth_credential, and\noptional credential_key parameters.\n\nReturns:\n  AuthConfig if the toolset has authentication configured, None otherwise."
  omitted_inherited_members_from:
  - ABC
- rank: 46
  id: google.adk.tools.mcp_tool.mcp_session_manager.StdioConnectionParams
  name: StdioConnectionParams
  file_path: src/google/adk/tools/mcp_tool/mcp_session_manager.py
  type: CLASS
  group: Seed
  usage_score: 2
  docstring: "Parameters for the MCP Stdio connection.\n\nAttributes:\n    server_params: Parameters for the MCP Stdio server.\n    timeout: Timeout in seconds for establishing the connection to the MCP\n      stdio server.\n\n[Note: Inherited members from pydantic.BaseModel are omitted.]"
  constructor_signature: 'def __init__(self, *, server_params: mcp.StdioServerParameters, timeout: float = 5.0):'
  properties:
  - signature: 'server_params: mcp.StdioServerParameters'
  - signature: 'timeout: float'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 47
  id: google.adk.tools.mcp_tool.mcp_session_manager.SseConnectionParams
  name: SseConnectionParams
  file_path: src/google/adk/tools/mcp_tool/mcp_session_manager.py
  type: CLASS
  group: Seed
  usage_score: 2
  docstring: "Parameters for the MCP SSE connection.\n\nSee MCP SSE Client documentation for more details.\nhttps://github.com/modelcontextprotocol/python-sdk/blob/main/src/mcp/client/sse.py\n\nAttributes:\n    url: URL for the MCP SSE server.\n    headers: Headers for the MCP SSE connection.\n    timeout: Timeout in seconds for establishing the connection to the MCP SSE\n      server.\n    sse_read_timeout: Timeout in seconds for reading data from the MCP SSE\n      server.\n\n[Note: Inherited members from pydantic.BaseModel are omitted.]"
  constructor_signature: 'def __init__(self, *, url: str, headers: dict[str, Any] | None = None, timeout: float = 5.0, sse_read_timeout: float = 60 * 5.0):'
  properties:
  - signature: 'url: str'
  - signature: 'headers: dict[str, Any] | None'
  - signature: 'timeout: float'
  - signature: 'sse_read_timeout: float'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 48
  id: google.adk.tools.mcp_tool.mcp_session_manager.StreamableHTTPConnectionParams
  name: StreamableHTTPConnectionParams
  file_path: src/google/adk/tools/mcp_tool/mcp_session_manager.py
  type: CLASS
  group: Seed
  usage_score: 2
  docstring: "Parameters for the MCP Streamable HTTP connection.\n\nSee MCP Streamable HTTP Client documentation for more details.\nhttps://github.com/modelcontextprotocol/python-sdk/blob/main/src/mcp/client/streamable_http.py\n\nAttributes:\n    url: URL for the MCP Streamable HTTP server.\n    headers: Headers for the MCP Streamable HTTP connection.\n    timeout: Timeout in seconds for establishing the connection to the MCP\n      Streamable HTTP server.\n    sse_read_timeout: Timeout in seconds for reading data from the MCP\n      Streamable HTTP server.\n    terminate_on_close: Whether to terminate the MCP Streamable HTTP server\n      when the connection is closed.\n    httpx_client_factory: Factory function to create a custom HTTPX client. If\n      not provided, a default factory will be used.\n\n[Note: Inherited members from pydantic.BaseModel are omitted.]"
  constructor_signature: 'def __init__(self, *, url: str, headers: dict[str, Any] | None = None, timeout: float = 5.0, sse_read_timeout: float = 60 * 5.0, terminate_on_close: bool = True, httpx_client_factory: google.adk.tools.mcp_tool.mcp_session_manager.CheckableMcpHttpClientFactory = create_mcp_http_client):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'url: str'
  - signature: 'headers: dict[str, Any] | None'
  - signature: 'timeout: float'
  - signature: 'sse_read_timeout: float'
  - signature: 'terminate_on_close: bool'
  - signature: 'httpx_client_factory: google.adk.tools.mcp_tool.mcp_session_manager.CheckableMcpHttpClientFactory'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 49
  id: google.adk.tools.mcp_tool.mcp_toolset.McpToolset
  name: McpToolset
  file_path: src/google/adk/tools/mcp_tool/mcp_toolset.py
  type: CLASS
  group: Seed
  usage_score: 2
  docstring: "Connects to a MCP Server, and retrieves MCP Tools into ADK Tools.\n\nThis toolset manages the connection to an MCP server and provides tools\nthat can be used by an agent. It properly implements the BaseToolset\ninterface for easy integration with the agent framework.\n\nUsage::\n\n  toolset = McpToolset(\n      connection_params=StdioServerParameters(\n          command='npx',\n          args=[\"-y\", \"@modelcontextprotocol/server-filesystem\"],\n      ),\n      tool_filter=['read_file', 'list_directory']  # Optional: filter specific\n      tools\n  )\n\n  # Use in an agent\n  agent = LlmAgent(\n      model='gemini-2.0-flash',\n      name='enterprise_assistant',\n      instruction='Help user accessing their file systems',\n      tools=[toolset],\n  )\n\n  # Cleanup is handled automatically by the agent framework\n  # But you can also manually close if needed:\n  # await toolset.close()\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, *, connection_params: typing.Union[mcp.StdioServerParameters, google.adk.tools.mcp_tool.mcp_session_manager.StdioConnectionParams, google.adk.tools.mcp_tool.mcp_session_manager.SseConnectionParams, google.adk.tools.mcp_tool.mcp_session_manager.StreamableHTTPConnectionParams], tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]]=None, tool_name_prefix: typing.Optional[str]=None, errlog: typing.TextIO=sys.stderr, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme]=None, auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]=None, require_confirmation: typing.Union[bool, typing.Callable[Ellipsis, bool]]=False, header_provider: typing.Optional[typing.Callable[[ReadonlyContext], typing.Dict[str, str]]]=None, progress_callback: typing.Optional[typing.Union[mcp.shared.session.ProgressFnT, google.adk.tools.mcp_tool.mcp_tool.ProgressCallbackFactory]]=None):'
  methods:
  - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> typing.List[google.adk.tools.base_tool.BaseTool]:'
    docstring: "Return all tools in the toolset based on the provided context.\n\nArgs:\n    readonly_context: Context used to filter tools available to the agent.\n      If None, all tools in the toolset are returned.\n\nReturns:\n    List[BaseTool]: A list of tools available under the specified context."
  - signature: 'def read_resource(self, name: str, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> typing.Any:'
    docstring: "Fetches and returns a list of contents of the named resource.\n\nArgs:\n  name: The name of the resource to fetch.\n  readonly_context: Context used to provide headers for the MCP session.\n\nReturns:\n  List of contents of the resource."
  - signature: 'def list_resources(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[str]:'
    docstring: Returns a list of resource names available on the MCP server.
  - signature: 'def get_resource_info(self, name: str, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> dict[str, typing.Any]:'
    docstring: Returns metadata about a specific resource (name, MIME type, etc.).
  - signature: 'def close(self) -> None:'
    docstring: 'Performs cleanup and releases resources held by the toolset.


      This method closes the MCP session and cleans up all associated resources.

      It''s designed to be safe to call multiple times and handles cleanup errors

      gracefully to avoid blocking application shutdown.'
  - signature: 'def get_auth_config(self) -> typing.Optional[google.adk.auth.auth_tool.AuthConfig]:'
    docstring: 'Returns the auth config for this toolset.


      ADK will populate exchanged_auth_credential on this config before calling

      get_tools(). The toolset can then access the ready-to-use credential via

      self._auth_config.exchanged_auth_credential.'
  - signature: 'def from_config(cls: type[google.adk.tools.mcp_tool.mcp_toolset.McpToolset], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.mcp_tool.mcp_toolset.McpToolset:'
    docstring: Creates an McpToolset from a configuration object.
  inherited_methods:
    BaseToolset:
    - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools in the toolset based on the provided context.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools available under the specified context."
    - signature: 'def get_tools_with_prefix(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools with optional prefix applied to tool names.\n\nThis method calls get_tools() and applies prefixing if tool_name_prefix is provided.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools with prefixed names if tool_name_prefix is provided."
    - signature: 'def close(self) -> None:'
      docstring: "Performs cleanup and releases resources held by the toolset.\n\nNOTE:\n  This method is invoked, for example, at the end of an agent server's\n  lifecycle or when the toolset is no longer needed. Implementations\n  should ensure that any open connections, files, or other managed\n  resources are properly released to prevent leaks."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_toolset.SelfToolset], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_toolset.SelfToolset:'
      docstring: "Creates a toolset instance from a config.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The toolset instance."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this toolset. This method will be\ncalled before each tool processes the llm request.\n\nUse cases:\n- Instead of let each tool process the llm request, we can let the toolset\n  process the llm request. e.g. ComputerUseToolset can add computer use\n  tool to the llm request.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def get_auth_config(self) -> typing.Optional[google.adk.auth.auth_tool.AuthConfig]:'
      docstring: "Returns the auth config for this toolset. ADK will make sure the\n'exchanged_auth_credential' field in the config is populated with\nready-to-use credential (e.g. oauth token for OAuth flow) before calling\nget_tools method or execute any tools returned by this toolset. Thus toolset\ncan use this credential either for tool listing or tool calling. If tool\ncalling needs a different credential from ADK client, call\ntool_context.request_credential in the tool.\n\nToolsets that support authentication should override this method to return\nan AuthConfig constructed from their auth_scheme, auth_credential, and\noptional credential_key parameters.\n\nReturns:\n  AuthConfig if the toolset has authentication configured, None otherwise."
  omitted_inherited_members_from:
  - ABC
- rank: 50
  id: google.adk.memory.base_memory_service.SearchMemoryResponse
  name: SearchMemoryResponse
  file_path: src/google/adk/memory/base_memory_service.py
  type: CLASS
  group: Seed
  usage_score: 2
  docstring: "Represents the response from a memory search.\n\nAttributes:\n    memories: A list of memory entries that relate to the search query.\n\n[Note: Inherited members from pydantic.BaseModel are omitted.]"
  constructor_signature: 'def __init__(self, *, memories: list[google.adk.memory.memory_entry.MemoryEntry] = list()):'
  properties:
  - signature: 'memories: list[google.adk.memory.memory_entry.MemoryEntry]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 51
  id: google.adk.memory.memory_entry.MemoryEntry
  name: MemoryEntry
  file_path: src/google/adk/memory/memory_entry.py
  type: CLASS
  group: Seed
  usage_score: 2
  docstring: 'Represent one memory entry.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, content: google.genai.types.Content, custom_metadata: dict[str, typing.Any] = dict(), id: typing.Optional[str] = None, author: typing.Optional[str] = None, timestamp: typing.Optional[str] = None):'
  properties:
  - signature: 'content: google.genai.types.Content'
    docstring: The main content of the memory.
  - signature: 'custom_metadata: dict[str, typing.Any]'
    docstring: Optional custom metadata associated with the memory.
  - signature: 'id: typing.Optional[str]'
    docstring: The unique identifier of the memory.
  - signature: 'author: typing.Optional[str]'
    docstring: The author of the memory.
  - signature: 'timestamp: typing.Optional[str]'
    docstring: 'The timestamp when the original content of this memory happened.


      This string will be forwarded to LLM. Preferred format is ISO 8601 format.'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 52
  id: google.adk.auth.auth_tool.AuthConfig
  name: AuthConfig
  file_path: src/google/adk/auth/auth_tool.py
  type: CLASS
  group: Seed
  usage_score: 2
  docstring: 'The auth config sent by tool asking client to collect auth credentials and


    adk and client will help to fill in the response


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self):'
  methods:
  - signature: 'def get_credential_key(self):'
    docstring: 'Builds a stable key based on auth_scheme and raw_auth_credential.


      This is used to save/load credentials to/from a credential service when

      `credential_key` is not explicitly provided.'
  properties:
  - signature: 'auth_scheme: google.adk.auth.auth_schemes.AuthScheme'
    docstring: The auth scheme used to collect credentials
  - signature: 'raw_auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]'
    docstring: 'The raw auth credential used to collect credentials. The raw auth

      credentials are used in some auth scheme that needs to exchange auth

      credentials. e.g. OAuth2 and OIDC. For other auth scheme, it could be None.'
  - signature: 'exchanged_auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]'
    docstring: 'The exchanged auth credential used to collect credentials. adk and client

      will work together to fill it. For those auth scheme that doesn''t need to

      exchange auth credentials, e.g. API key, service account etc. It''s filled by

      client directly. For those auth scheme that need to exchange auth credentials,

      e.g. OAuth2 and OIDC, it''s first filled by adk. If the raw credentials

      passed by tool only has client id and client credential, adk will help to

      generate the corresponding authorization uri and state and store the processed

      credential in this field. If the raw credentials passed by tool already has

      authorization uri, state, etc. then it''s copied to this field. Client will use

      this field to guide the user through the OAuth2 flow and fill auth response in

      this field'
  - signature: 'credential_key: typing.Optional[str]'
    docstring: 'A user specified key used to load and save this credential in a credential

      service.'
  inherited_properties:
    BaseModelWithConfig:
    - signature: 'model_config: pydantic.ConfigDict'
      docstring: The pydantic model config.
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 53
  id: google.adk.agents.context_cache_config.ContextCacheConfig
  name: ContextCacheConfig
  file_path: src/google/adk/agents/context_cache_config.py
  type: CLASS
  group: Seed
  usage_score: 2
  docstring: "Configuration for context caching across all agents in an app.\n\nThis configuration enables and controls context caching behavior for\nall LLM agents in an app. When this config is present on an app, context\ncaching is enabled for all agents. When absent (None), context caching\nis disabled.\n\nContext caching can significantly reduce costs and improve response times\nby reusing previously processed context across multiple requests.\n\nAttributes:\n    cache_intervals: Maximum number of invocations to reuse the same cache before refreshing it\n    ttl_seconds: Time-to-live for cache in seconds\n    min_tokens: Minimum tokens required to enable caching\n\n[Note: Inherited members from pydantic.BaseModel are omitted.]"
  constructor_signature: 'def __init__(self, *, cache_intervals: int = 10, ttl_seconds: int = 1800, min_tokens: int = 0):'
  methods:
  - signature: 'def ttl_string(self) -> str:'
    docstring: Get TTL as string format for cache creation.
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'cache_intervals: int'
  - signature: 'ttl_seconds: int'
  - signature: 'min_tokens: int'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 54
  id: google.adk.utils.cache_performance_analyzer.CachePerformanceAnalyzer
  name: CachePerformanceAnalyzer
  file_path: src/google/adk/utils/cache_performance_analyzer.py
  type: CLASS
  group: Seed
  usage_score: 2
  docstring: Analyzes cache performance through event history.
  constructor_signature: 'def __init__(self, session_service: google.adk.sessions.base_session_service.BaseSessionService):'
  methods:
  - signature: 'def analyze_agent_cache_performance(self, session_id: str, user_id: str, app_name: str, agent_name: str) -> typing.Dict[str, typing.Any]:'
    docstring: "Analyze cache performance for agent.\n\nArgs:\n    session_id: Session to analyze\n    user_id: User ID for session lookup\n    app_name: App name for session lookup\n    agent_name: Agent to analyze\n\nReturns:\n    Performance analysis dictionary containing:\n    - status: \"active\" if cache data found, \"no_cache_data\" if none\n    - requests_with_cache: Number of requests that used caching\n    - avg_invocations_used: Average number of invocations each cache was used\n    - latest_cache: Resource name of most recent cache used\n    - cache_refreshes: Number of unique cache instances created\n    - total_invocations: Total number of invocations across all caches\n    - total_prompt_tokens: Total prompt tokens across all requests\n    - total_cached_tokens: Total cached content tokens across all requests\n    - cache_hit_ratio_percent: Percentage of tokens served from cache\n    - cache_utilization_ratio_percent: Percentage of requests with cache hits\n    - avg_cached_tokens_per_request:\
      \ Average cached tokens per request\n    - total_requests: Total number of requests processed\n    - requests_with_cache_hits: Number of requests that had cache hits"
- rank: 55
  id: google.adk.utils.variant_utils.get_google_llm_variant
  name: get_google_llm_variant
  file_path: src/google/adk/utils/variant_utils.py
  type: METHOD
  group: Seed
  usage_score: 2
  signature: 'def get_google_llm_variant() -> google.adk.utils.variant_utils.GoogleLLMVariant:'
- rank: 56
  id: google.adk.models.anthropic_llm.Claude
  name: Claude
  file_path: src/google/adk/models/anthropic_llm.py
  type: CLASS
  group: Seed
  usage_score: 2
  docstring: "Integration with Claude models served from Vertex AI.\n\nAttributes:\n  model: The name of the Claude model.\n  max_tokens: The maximum number of tokens to generate.\n\n[Note: Inherited members from pydantic.BaseModel are omitted.]"
  constructor_signature: 'def __init__(self, *, model: str, max_tokens: int = 8192):'
  properties:
  - signature: 'model: str'
  inherited_methods:
    AnthropicLlm:
    - signature: 'def supported_models(cls) -> list[str]:'
    - signature: 'def generate_content_async(self, llm_request: google.adk.models.llm_request.LlmRequest, stream: bool) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
    BaseLlm:
    - signature: 'def supported_models(cls) -> list[str]:'
      docstring: Returns a list of supported models in regex for LlmRegistry.
    - signature: 'def generate_content_async(self, llm_request: google.adk.models.llm_request.LlmRequest, stream: bool) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
      docstring: "Generates content for a single model turn.\n\n    This method handles Server-Sent Events (SSE) streaming for unidirectional\n    content generation. For bidirectional streaming (e.g., Gemini Live API),\n    use the `connect()` method instead.\n\n    Args:\n      llm_request: LlmRequest, the request to send to the LLM.\n      stream: bool = False, whether to enable SSE streaming mode.\n\n    Yields:\n      LlmResponse objects representing the model's response for one turn.\n\n      **Non-streaming mode (stream=False):**\n\n        Yields exactly one LlmResponse containing the complete model output\n        (text, function calls, bytes, etc.). This response has `partial=False`.\n\n      **Streaming mode (stream=True):**\n\n        Yields multiple LlmResponse objects as chunks arrive:\n\n        - Intermediate chunks: `partial=True` (progressive updates)\n        - Final chunk: `partial=False` (aggregated content from entire turn,\n          identical to stream=False output)\n\
        \        - Text consolidation: Consecutive text parts of the same type\n          (thought/non-thought) SHOULD merge without separator, but client\n          code must not rely on this - unconsolidated parts are unusual but also\n          valid\n\n      **Common content in partial chunks:**\n\n        All intermediate chunks have `partial=True` regardless of content type.\n        Common examples include:\n\n        - Text: Streams incrementally as tokens arrive\n        - Function calls: May arrive in separate chunks\n        - Bytes (e.g., images): Typically arrive as single chunk, interleaved\n          with text\n        - Thoughts: Stream incrementally when thinking_config is enabled\n\n      **Examples:**\n\n      1. Simple text streaming::\n\n           LlmResponse(partial=True,  parts=[\"The weather\"])\n           LlmResponse(partial=True,  parts=[\" in Tokyo is\"])\n           LlmResponse(partial=True,  parts=[\" sunny.\"])\n           LlmResponse(partial=False, parts=[\"\
        The weather in Tokyo is sunny.\"])\n\n      2. Text + function call::\n\n           LlmResponse(partial=True,  parts=[Text(\"Let me check...\")])\n           LlmResponse(partial=True,  parts=[FunctionCall(\"get_weather\", ...)])\n           LlmResponse(partial=False, parts=[Text(\"Let me check...\"),\n                                             FunctionCall(\"get_weather\", ...)])\n\n      3. Parallel function calls across chunks::\n\n           LlmResponse(partial=True,  parts=[Text(\"Checking both cities...\")])\n           LlmResponse(partial=True,  parts=[FunctionCall(\"get_weather\", Tokyo)])\n           LlmResponse(partial=True,  parts=[FunctionCall(\"get_weather\", NYC)])\n           LlmResponse(partial=False, parts=[Text(\"Checking both cities...\"),\n                                             FunctionCall(\"get_weather\", Tokyo),\n                                             FunctionCall(\"get_weather\", NYC)])\n\n      4. Text + bytes (image generation with gemini-2.5-flash-image)::\n\
        \n           LlmResponse(partial=True,  parts=[Text(\"Here's an image of a dog.\")])\n           LlmResponse(partial=True,  parts=[Text(\"\n\")])\n           LlmResponse(partial=True,  parts=[Blob(image/png, 1.6MB)])\n           LlmResponse(partial=True,  parts=[Text(\"It carries a bone\")])\n           LlmResponse(partial=True,  parts=[Text(\" and running around.\")])\n           LlmResponse(partial=False, parts=[Text(\"Here's an image of a dog.\n\"),\n                                             Blob(image/png, 1.6MB),\n                                             Text(\"It carries a bone and running around.\")])\n\n         Note: Consecutive text parts before and after blob merge separately.\n\n      5. Text with thinking (gemini-2.5-flash with thinking_config)::\n\n           LlmResponse(partial=True,  parts=[Thought(\"Let me analyze...\")])\n           LlmResponse(partial=True,  parts=[Thought(\"The user wants...\")])\n           LlmResponse(partial=True,  parts=[Text(\"Based\
        \ on my analysis,\")])\n           LlmResponse(partial=True,  parts=[Text(\" the answer is 42.\")])\n           LlmResponse(partial=False, parts=[Thought(\"Let me analyze...The user wants...\"),\n                                             Text(\"Based on my analysis, the answer is 42.\")])\n\n         Note: Consecutive parts of same type merge (thoughts\u2192thought, text\u2192text).\n\n      **Important:** All yielded responses represent one logical model turn.\n      The final response with `partial=False` should be identical to the\n      response that would be received with `stream=False`.\n    "
    - signature: 'def connect(self, llm_request: google.adk.models.llm_request.LlmRequest) -> google.adk.models.base_llm_connection.BaseLlmConnection:'
      docstring: "Creates a live connection to the LLM.\n\nArgs:\n  llm_request: LlmRequest, the request to send to the LLM.\n\nReturns:\n  BaseLlmConnection, the connection to the LLM."
  inherited_properties:
    AnthropicLlm:
    - signature: 'model: str'
    - signature: 'max_tokens: int'
    BaseLlm:
    - signature: 'model_config: pydantic.ConfigDict'
      docstring: The pydantic model config.
    - signature: 'model: str'
      docstring: The name of the LLM, e.g. gemini-2.5-flash or gemini-2.5-pro.
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 57
  id: google.adk.planners.built_in_planner.BuiltInPlanner
  name: BuiltInPlanner
  file_path: src/google/adk/planners/built_in_planner.py
  type: CLASS
  group: Seed
  usage_score: 2
  docstring: "The built-in planner that uses model's built-in thinking features.\n\nAttributes:\n    thinking_config: Config for model built-in thinking features. An error\n      will be returned if this field is set for models that don't support\n      thinking.\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, *, thinking_config: google.genai.types.ThinkingConfig):'
  methods:
  - signature: 'def apply_thinking_config(self, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
    docstring: "Applies the thinking config to the LLM request.\n\nArgs:\n  llm_request: The LLM request to apply the thinking config to."
  - signature: 'def build_planning_instruction(self, readonly_context: google.adk.agents.readonly_context.ReadonlyContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[str]:'
  - signature: 'def process_planning_response(self, callback_context: google.adk.agents.callback_context.CallbackContext, response_parts: typing.List[google.genai.types.Part]) -> typing.Optional[typing.List[google.genai.types.Part]]:'
  properties:
  - signature: 'thinking_config: google.genai.types.ThinkingConfig'
    docstring: 'Config for model built-in thinking features. An error will be returned if this

      field is set for models that don''t support thinking.'
  inherited_methods:
    BasePlanner:
    - signature: 'def build_planning_instruction(self, readonly_context: google.adk.agents.readonly_context.ReadonlyContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[str]:'
      docstring: "Builds the system instruction to be appended to the LLM request for planning.\n\nArgs:\n    readonly_context: The readonly context of the invocation.\n    llm_request: The LLM request. Readonly.\n\nReturns:\n    The planning system instruction, or None if no instruction is needed."
    - signature: 'def process_planning_response(self, callback_context: google.adk.agents.callback_context.CallbackContext, response_parts: typing.List[google.genai.types.Part]) -> typing.Optional[typing.List[google.genai.types.Part]]:'
      docstring: "Processes the LLM response for planning.\n\nArgs:\n    callback_context: The callback context of the invocation.\n    response_parts: The LLM response parts. Readonly.\n\nReturns:\n    The processed response parts, or None if no processing is needed."
  omitted_inherited_members_from:
  - ABC
- rank: 58
  id: google.adk
  name: adk
  file_path: src/google/adk/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: '__version__: Any'
  - signature: '__all__: Any'
- rank: 59
  id: google.adk.a2a
  name: a2a
  file_path: src/google/adk/a2a/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 60
  id: google.adk.a2a.converters
  name: converters
  file_path: src/google/adk/a2a/converters/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 61
  id: google.adk.a2a.converters.event_converter
  name: event_converter
  file_path: src/google/adk/a2a/converters/event_converter.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def convert_a2a_task_to_event(a2a_task: a2a.types.Task, author: typing.Optional[str], invocation_context: typing.Optional[google.adk.agents.invocation_context.InvocationContext], part_converter: google.adk.a2a.converters.part_converter.A2APartToGenAIPartConverter) -> google.adk.events.event.Event:'
    docstring: "Converts an A2A task to an ADK event.\n\nArgs:\n  a2a_task: The A2A task to convert. Must not be None.\n  author: The author of the event. Defaults to \"a2a agent\" if not provided.\n  invocation_context: The invocation context containing session information.\n    If provided, the branch will be set from the context.\n  part_converter: The function to convert A2A part to GenAI part.\n\nReturns:\n  An ADK Event object representing the converted task.\n\nRaises:\n  ValueError: If a2a_task is None.\n  RuntimeError: If conversion of the underlying message fails."
  - signature: 'def convert_a2a_message_to_event(a2a_message: a2a.types.Message, author: typing.Optional[str], invocation_context: typing.Optional[google.adk.agents.invocation_context.InvocationContext], part_converter: google.adk.a2a.converters.part_converter.A2APartToGenAIPartConverter) -> google.adk.events.event.Event:'
    docstring: "Converts an A2A message to an ADK event.\n\nArgs:\n  a2a_message: The A2A message to convert. Must not be None.\n  author: The author of the event. Defaults to \"a2a agent\" if not provided.\n  invocation_context: The invocation context containing session information.\n    If provided, the branch will be set from the context.\n  part_converter: The function to convert A2A part to GenAI part.\n\nReturns:\n  An ADK Event object with converted content and long-running tool metadata.\n\nRaises:\n  ValueError: If a2a_message is None.\n  RuntimeError: If conversion of message parts fails."
  - signature: 'def convert_event_to_a2a_message(event: google.adk.events.event.Event, invocation_context: google.adk.agents.invocation_context.InvocationContext, role: a2a.types.Role, part_converter: google.adk.a2a.converters.part_converter.GenAIPartToA2APartConverter) -> typing.Optional[a2a.types.Message]:'
    docstring: "Converts an ADK event to an A2A message.\n\nArgs:\n  event: The ADK event to convert.\n  invocation_context: The invocation context.\n  role: The role of the message.\n  part_converter: The function to convert GenAI part to A2A part.\n\nReturns:\n  An A2A Message if the event has content, None otherwise.\n\nRaises:\n  ValueError: If required parameters are invalid."
  - signature: 'def convert_event_to_a2a_events(event: google.adk.events.event.Event, invocation_context: google.adk.agents.invocation_context.InvocationContext, task_id: typing.Optional[str], context_id: typing.Optional[str], part_converter: google.adk.a2a.converters.part_converter.GenAIPartToA2APartConverter) -> typing.List[a2a.server.events.Event]:'
    docstring: "Converts a GenAI event to a list of A2A events.\n\nArgs:\n  event: The ADK event to convert.\n  invocation_context: The invocation context.\n  task_id: Optional task ID to use for generated events.\n  context_id: Optional Context ID to use for generated events.\n  part_converter: The function to convert GenAI part to A2A part.\n\nReturns:\n  A list of A2A events representing the converted ADK event.\n\nRaises:\n  ValueError: If required parameters are invalid."
  properties:
  - signature: 'ARTIFACT_ID_SEPARATOR: str'
  - signature: 'DEFAULT_ERROR_MESSAGE: str'
  - signature: 'logger: logging.getLogger'
  - signature: 'AdkEventToA2AEventsConverter: Any'
- rank: 62
  id: google.adk.a2a.converters.event_converter.convert_a2a_message_to_event
  name: convert_a2a_message_to_event
  file_path: src/google/adk/a2a/converters/event_converter.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Converts an A2A message to an ADK event.\n\nArgs:\n  a2a_message: The A2A message to convert. Must not be None.\n  author: The author of the event. Defaults to \"a2a agent\" if not provided.\n  invocation_context: The invocation context containing session information.\n    If provided, the branch will be set from the context.\n  part_converter: The function to convert A2A part to GenAI part.\n\nReturns:\n  An ADK Event object with converted content and long-running tool metadata.\n\nRaises:\n  ValueError: If a2a_message is None.\n  RuntimeError: If conversion of message parts fails."
  signature: 'def convert_a2a_message_to_event(a2a_message: a2a.types.Message, author: typing.Optional[str], invocation_context: typing.Optional[google.adk.agents.invocation_context.InvocationContext], part_converter: google.adk.a2a.converters.part_converter.A2APartToGenAIPartConverter) -> google.adk.events.event.Event:'
- rank: 63
  id: google.adk.a2a.converters.event_converter.convert_a2a_task_to_event
  name: convert_a2a_task_to_event
  file_path: src/google/adk/a2a/converters/event_converter.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Converts an A2A task to an ADK event.\n\nArgs:\n  a2a_task: The A2A task to convert. Must not be None.\n  author: The author of the event. Defaults to \"a2a agent\" if not provided.\n  invocation_context: The invocation context containing session information.\n    If provided, the branch will be set from the context.\n  part_converter: The function to convert A2A part to GenAI part.\n\nReturns:\n  An ADK Event object representing the converted task.\n\nRaises:\n  ValueError: If a2a_task is None.\n  RuntimeError: If conversion of the underlying message fails."
  signature: 'def convert_a2a_task_to_event(a2a_task: a2a.types.Task, author: typing.Optional[str], invocation_context: typing.Optional[google.adk.agents.invocation_context.InvocationContext], part_converter: google.adk.a2a.converters.part_converter.A2APartToGenAIPartConverter) -> google.adk.events.event.Event:'
- rank: 64
  id: google.adk.a2a.converters.event_converter.convert_event_to_a2a_events
  name: convert_event_to_a2a_events
  file_path: src/google/adk/a2a/converters/event_converter.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Converts a GenAI event to a list of A2A events.\n\nArgs:\n  event: The ADK event to convert.\n  invocation_context: The invocation context.\n  task_id: Optional task ID to use for generated events.\n  context_id: Optional Context ID to use for generated events.\n  part_converter: The function to convert GenAI part to A2A part.\n\nReturns:\n  A list of A2A events representing the converted ADK event.\n\nRaises:\n  ValueError: If required parameters are invalid."
  signature: 'def convert_event_to_a2a_events(event: google.adk.events.event.Event, invocation_context: google.adk.agents.invocation_context.InvocationContext, task_id: typing.Optional[str], context_id: typing.Optional[str], part_converter: google.adk.a2a.converters.part_converter.GenAIPartToA2APartConverter) -> typing.List[a2a.server.events.Event]:'
- rank: 65
  id: google.adk.a2a.converters.event_converter.convert_event_to_a2a_message
  name: convert_event_to_a2a_message
  file_path: src/google/adk/a2a/converters/event_converter.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Converts an ADK event to an A2A message.\n\nArgs:\n  event: The ADK event to convert.\n  invocation_context: The invocation context.\n  role: The role of the message.\n  part_converter: The function to convert GenAI part to A2A part.\n\nReturns:\n  An A2A Message if the event has content, None otherwise.\n\nRaises:\n  ValueError: If required parameters are invalid."
  signature: 'def convert_event_to_a2a_message(event: google.adk.events.event.Event, invocation_context: google.adk.agents.invocation_context.InvocationContext, role: a2a.types.Role, part_converter: google.adk.a2a.converters.part_converter.GenAIPartToA2APartConverter) -> typing.Optional[a2a.types.Message]:'
- rank: 66
  id: google.adk.a2a.converters.part_converter
  name: part_converter
  file_path: src/google/adk/a2a/converters/part_converter.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: module containing utilities for conversion between A2A Part and Google GenAI Part
  methods:
  - signature: 'def convert_a2a_part_to_genai_part(a2a_part: a2a.types.Part) -> typing.Optional[google.genai.types.Part]:'
    docstring: Convert an A2A Part to a Google GenAI Part.
  - signature: 'def convert_genai_part_to_a2a_part(part: google.genai.types.Part) -> typing.Optional[a2a.types.Part]:'
    docstring: Convert a Google GenAI Part to an A2A Part.
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: 'A2A_DATA_PART_METADATA_TYPE_KEY: str'
  - signature: 'A2A_DATA_PART_METADATA_IS_LONG_RUNNING_KEY: str'
  - signature: 'A2A_DATA_PART_METADATA_TYPE_FUNCTION_CALL: str'
  - signature: 'A2A_DATA_PART_METADATA_TYPE_FUNCTION_RESPONSE: str'
  - signature: 'A2A_DATA_PART_METADATA_TYPE_CODE_EXECUTION_RESULT: str'
  - signature: 'A2A_DATA_PART_METADATA_TYPE_EXECUTABLE_CODE: str'
  - signature: 'A2A_DATA_PART_TEXT_MIME_TYPE: str'
  - signature: 'A2A_DATA_PART_START_TAG: bytes'
  - signature: 'A2A_DATA_PART_END_TAG: bytes'
  - signature: 'A2APartToGenAIPartConverter: Any'
  - signature: 'GenAIPartToA2APartConverter: Any'
- rank: 67
  id: google.adk.a2a.converters.part_converter.convert_a2a_part_to_genai_part
  name: convert_a2a_part_to_genai_part
  file_path: src/google/adk/a2a/converters/part_converter.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Convert an A2A Part to a Google GenAI Part.
  signature: 'def convert_a2a_part_to_genai_part(a2a_part: a2a.types.Part) -> typing.Optional[google.genai.types.Part]:'
- rank: 68
  id: google.adk.a2a.converters.part_converter.convert_genai_part_to_a2a_part
  name: convert_genai_part_to_a2a_part
  file_path: src/google/adk/a2a/converters/part_converter.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Convert a Google GenAI Part to an A2A Part.
  signature: 'def convert_genai_part_to_a2a_part(part: google.genai.types.Part) -> typing.Optional[a2a.types.Part]:'
- rank: 69
  id: google.adk.a2a.converters.request_converter
  name: request_converter
  file_path: src/google/adk/a2a/converters/request_converter.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def convert_a2a_request_to_agent_run_request(request: a2a.server.agent_execution.RequestContext, part_converter: google.adk.a2a.converters.part_converter.A2APartToGenAIPartConverter) -> google.adk.a2a.converters.request_converter.AgentRunRequest:'
    docstring: "Converts an A2A RequestContext to an AgentRunRequest model.\n\nArgs:\n  request: The incoming request context from the A2A server.\n  part_converter: A function to convert A2A content parts to GenAI parts.\n\nReturns:\n  A AgentRunRequest object ready to be used as arguments for the ADK runner.\n\nRaises:\n  ValueError: If the request message is None."
  properties:
  - signature: 'A2ARequestToAgentRunRequestConverter: Any'
- rank: 70
  id: google.adk.a2a.converters.request_converter.AgentRunRequest
  name: AgentRunRequest
  file_path: src/google/adk/a2a/converters/request_converter.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Data model for arguments passed to the ADK runner.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, user_id: typing.Optional[str] = None, session_id: typing.Optional[str] = None, new_message: typing.Optional[google.genai.types.Content] = None, state_delta: typing.Optional[dict[str, typing.Any]] = None, run_config: typing.Optional[google.adk.runners.RunConfig] = None):'
  properties:
  - signature: 'user_id: typing.Optional[str]'
  - signature: 'session_id: typing.Optional[str]'
  - signature: 'invocation_id: typing.Optional[str]'
  - signature: 'new_message: typing.Optional[google.genai.types.Content]'
  - signature: 'state_delta: typing.Optional[dict[str, typing.Any]]'
  - signature: 'run_config: typing.Optional[google.adk.runners.RunConfig]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 71
  id: google.adk.a2a.converters.request_converter.convert_a2a_request_to_agent_run_request
  name: convert_a2a_request_to_agent_run_request
  file_path: src/google/adk/a2a/converters/request_converter.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Converts an A2A RequestContext to an AgentRunRequest model.\n\nArgs:\n  request: The incoming request context from the A2A server.\n  part_converter: A function to convert A2A content parts to GenAI parts.\n\nReturns:\n  A AgentRunRequest object ready to be used as arguments for the ADK runner.\n\nRaises:\n  ValueError: If the request message is None."
  signature: 'def convert_a2a_request_to_agent_run_request(request: a2a.server.agent_execution.RequestContext, part_converter: google.adk.a2a.converters.part_converter.A2APartToGenAIPartConverter) -> google.adk.a2a.converters.request_converter.AgentRunRequest:'
- rank: 72
  id: google.adk.a2a.converters.utils
  name: utils
  file_path: src/google/adk/a2a/converters/utils.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'ADK_METADATA_KEY_PREFIX: str'
  - signature: 'ADK_CONTEXT_ID_PREFIX: str'
  - signature: 'ADK_CONTEXT_ID_SEPARATOR: str'
- rank: 73
  id: google.adk.a2a.executor
  name: executor
  file_path: src/google/adk/a2a/executor/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 74
  id: google.adk.a2a.executor.a2a_agent_executor
  name: a2a_agent_executor
  file_path: src/google/adk/a2a/executor/a2a_agent_executor.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 75
  id: google.adk.a2a.executor.a2a_agent_executor.A2aAgentExecutor
  name: A2aAgentExecutor
  file_path: src/google/adk/a2a/executor/a2a_agent_executor.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'An AgentExecutor that runs an ADK Agent against an A2A request and


    publishes updates to an event queue.


    [Note: Inherited members from AgentExecutor are omitted.]'
  constructor_signature: 'def __init__(self, *, runner: Runner | Callable[..., Runner | Awaitable[Runner]], config: typing.Optional[google.adk.a2a.executor.a2a_agent_executor.A2aAgentExecutorConfig]=None):'
  methods:
  - signature: 'def cancel(self, context: a2a.server.agent_execution.context.RequestContext, event_queue: a2a.server.events.event_queue.EventQueue):'
    docstring: Cancel the execution.
  - signature: 'def execute(self, context: a2a.server.agent_execution.context.RequestContext, event_queue: a2a.server.events.event_queue.EventQueue):'
    docstring: 'Executes an A2A request and publishes updates to the event queue

      specified. It runs as following:

      * Takes the input from the A2A request

      * Convert the input to ADK input content, and runs the ADK agent

      * Collects output events of the underlying ADK Agent

      * Converts the ADK output events into A2A task updates

      * Publishes the updates back to A2A server via event queue'
  omitted_inherited_members_from:
  - AgentExecutor
- rank: 76
  id: google.adk.a2a.executor.a2a_agent_executor.A2aAgentExecutor.__init__
  name: __init__
  file_path: src/google/adk/a2a/executor/a2a_agent_executor.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, *, runner: Runner | Callable[..., Runner | Awaitable[Runner]], config: typing.Optional[google.adk.a2a.executor.a2a_agent_executor.A2aAgentExecutorConfig]=None):'
- rank: 77
  id: google.adk.a2a.executor.a2a_agent_executor.A2aAgentExecutor.cancel
  name: cancel
  file_path: src/google/adk/a2a/executor/a2a_agent_executor.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Cancel the execution.
  signature: 'def cancel(self, context: a2a.server.agent_execution.context.RequestContext, event_queue: a2a.server.events.event_queue.EventQueue):'
- rank: 78
  id: google.adk.a2a.executor.a2a_agent_executor.A2aAgentExecutor.execute
  name: execute
  file_path: src/google/adk/a2a/executor/a2a_agent_executor.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Executes an A2A request and publishes updates to the event queue

    specified. It runs as following:

    * Takes the input from the A2A request

    * Convert the input to ADK input content, and runs the ADK agent

    * Collects output events of the underlying ADK Agent

    * Converts the ADK output events into A2A task updates

    * Publishes the updates back to A2A server via event queue'
  signature: 'def execute(self, context: a2a.server.agent_execution.context.RequestContext, event_queue: a2a.server.events.event_queue.EventQueue):'
- rank: 79
  id: google.adk.a2a.executor.a2a_agent_executor.A2aAgentExecutorConfig
  name: A2aAgentExecutorConfig
  file_path: src/google/adk/a2a/executor/a2a_agent_executor.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Configuration for the A2aAgentExecutor.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, a2a_part_converter: google.adk.a2a.converters.part_converter.A2APartToGenAIPartConverter = convert_a2a_part_to_genai_part, gen_ai_part_converter: google.adk.a2a.converters.part_converter.GenAIPartToA2APartConverter = convert_genai_part_to_a2a_part, request_converter: google.adk.a2a.converters.request_converter.A2ARequestToAgentRunRequestConverter = convert_a2a_request_to_agent_run_request, event_converter: google.adk.a2a.converters.event_converter.AdkEventToA2AEventsConverter = convert_event_to_a2a_events):'
  properties:
  - signature: 'a2a_part_converter: google.adk.a2a.converters.part_converter.A2APartToGenAIPartConverter'
  - signature: 'gen_ai_part_converter: google.adk.a2a.converters.part_converter.GenAIPartToA2APartConverter'
  - signature: 'request_converter: google.adk.a2a.converters.request_converter.A2ARequestToAgentRunRequestConverter'
  - signature: 'event_converter: google.adk.a2a.converters.event_converter.AdkEventToA2AEventsConverter'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 80
  id: google.adk.a2a.executor.task_result_aggregator
  name: task_result_aggregator
  file_path: src/google/adk/a2a/executor/task_result_aggregator.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 81
  id: google.adk.a2a.executor.task_result_aggregator.TaskResultAggregator
  name: TaskResultAggregator
  file_path: src/google/adk/a2a/executor/task_result_aggregator.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Aggregates the task status updates and provides the final task state.
  constructor_signature: 'def __init__(self):'
  methods:
  - signature: 'def process_event(self, event: a2a.server.events.Event):'
    docstring: 'Process an event from the agent run and detect signals about the task status.

      Priority of task state:

      - failed

      - auth_required

      - input_required

      - working'
  - signature: 'def task_state(self) -> a2a.types.TaskState:'
  - signature: 'def task_status_message(self) -> Message | None:'
- rank: 82
  id: google.adk.a2a.executor.task_result_aggregator.TaskResultAggregator.process_event
  name: process_event
  file_path: src/google/adk/a2a/executor/task_result_aggregator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Process an event from the agent run and detect signals about the task status.

    Priority of task state:

    - failed

    - auth_required

    - input_required

    - working'
  signature: 'def process_event(self, event: a2a.server.events.Event):'
- rank: 83
  id: google.adk.a2a.experimental
  name: experimental
  file_path: src/google/adk/a2a/experimental.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: A2A specific experimental decorator with custom warning message.
  properties:
  - signature: 'a2a_experimental: google.adk.utils.feature_decorator._make_feature_decorator'
- rank: 84
  id: google.adk.a2a.logs
  name: logs
  file_path: src/google/adk/a2a/logs/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 85
  id: google.adk.a2a.logs.log_utils
  name: log_utils
  file_path: src/google/adk/a2a/logs/log_utils.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Utility functions for structured A2A request and response logging.
  methods:
  - signature: 'def build_message_part_log(part: a2a.types.Part) -> str:'
    docstring: "Builds a log representation of an A2A message part.\n\nArgs:\n  part: The A2A message part to log.\n\nReturns:\n  A string representation of the part."
  - signature: 'def build_a2a_request_log(req: a2a.types.Message) -> str:'
    docstring: "Builds a structured log representation of an A2A request.\n\nArgs:\n  req: The A2A SendMessageRequest to log.\n\nReturns:\n  A formatted string representation of the request."
  - signature: 'def build_a2a_response_log(resp: A2AClientEvent | A2AMessage) -> str:'
    docstring: "Builds a structured log representation of an A2A response.\n\nArgs:\n  resp: The A2A SendMessage Response to log.\n\nReturns:\n  A formatted string representation of the response."
  properties:
  - signature: '_NEW_LINE: str'
  - signature: '_EXCLUDED_PART_FIELD: Any'
- rank: 86
  id: google.adk.a2a.logs.log_utils.build_a2a_request_log
  name: build_a2a_request_log
  file_path: src/google/adk/a2a/logs/log_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Builds a structured log representation of an A2A request.\n\nArgs:\n  req: The A2A SendMessageRequest to log.\n\nReturns:\n  A formatted string representation of the request."
  signature: 'def build_a2a_request_log(req: a2a.types.Message) -> str:'
- rank: 87
  id: google.adk.a2a.logs.log_utils.build_a2a_response_log
  name: build_a2a_response_log
  file_path: src/google/adk/a2a/logs/log_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Builds a structured log representation of an A2A response.\n\nArgs:\n  resp: The A2A SendMessage Response to log.\n\nReturns:\n  A formatted string representation of the response."
  signature: 'def build_a2a_response_log(resp: A2AClientEvent | A2AMessage) -> str:'
- rank: 88
  id: google.adk.a2a.logs.log_utils.build_message_part_log
  name: build_message_part_log
  file_path: src/google/adk/a2a/logs/log_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Builds a log representation of an A2A message part.\n\nArgs:\n  part: The A2A message part to log.\n\nReturns:\n  A string representation of the part."
  signature: 'def build_message_part_log(part: a2a.types.Part) -> str:'
- rank: 89
  id: google.adk.a2a.utils
  name: utils
  file_path: src/google/adk/a2a/utils/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 90
  id: google.adk.a2a.utils.agent_card_builder
  name: agent_card_builder
  file_path: src/google/adk/a2a/utils/agent_card_builder.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 91
  id: google.adk.a2a.utils.agent_card_builder.AgentCardBuilder
  name: AgentCardBuilder
  file_path: src/google/adk/a2a/utils/agent_card_builder.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Builder class for creating agent cards from ADK agents.


    This class provides functionality to convert ADK agents into A2A agent cards,

    including extracting skills, capabilities, and metadata from various agent

    types.'
  constructor_signature: 'def __init__(self, *, agent: google.adk.agents.base_agent.BaseAgent, rpc_url: typing.Optional[str]=None, capabilities: typing.Optional[a2a.types.AgentCapabilities]=None, doc_url: typing.Optional[str]=None, provider: typing.Optional[a2a.types.AgentProvider]=None, agent_version: typing.Optional[str]=None, security_schemes: typing.Optional[typing.Dict[str, a2a.types.SecurityScheme]]=None):'
  methods:
  - signature: 'def build(self) -> a2a.types.AgentCard:'
    docstring: Build and return the complete agent card.
- rank: 92
  id: google.adk.a2a.utils.agent_card_builder.AgentCardBuilder.__init__
  name: __init__
  file_path: src/google/adk/a2a/utils/agent_card_builder.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, *, agent: google.adk.agents.base_agent.BaseAgent, rpc_url: typing.Optional[str]=None, capabilities: typing.Optional[a2a.types.AgentCapabilities]=None, doc_url: typing.Optional[str]=None, provider: typing.Optional[a2a.types.AgentProvider]=None, agent_version: typing.Optional[str]=None, security_schemes: typing.Optional[typing.Dict[str, a2a.types.SecurityScheme]]=None):'
- rank: 93
  id: google.adk.a2a.utils.agent_card_builder.AgentCardBuilder.build
  name: build
  file_path: src/google/adk/a2a/utils/agent_card_builder.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Build and return the complete agent card.
  signature: 'def build(self) -> a2a.types.AgentCard:'
- rank: 94
  id: google.adk.a2a.utils.agent_to_a2a
  name: agent_to_a2a
  file_path: src/google/adk/a2a/utils/agent_to_a2a.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def to_a2a(agent: google.adk.agents.base_agent.BaseAgent, *, host: str=''localhost'', port: int=8000, protocol: str=''http'', agent_card: typing.Optional[typing.Union[a2a.types.AgentCard, str]]=None, runner: typing.Optional[google.adk.runners.Runner]=None) -> starlette.applications.Starlette:'
    docstring: "Convert an ADK agent to a A2A Starlette application.\n\nArgs:\n    agent: The ADK agent to convert\n    host: The host for the A2A RPC URL (default: \"localhost\")\n    port: The port for the A2A RPC URL (default: 8000)\n    protocol: The protocol for the A2A RPC URL (default: \"http\")\n    agent_card: Optional pre-built AgentCard object or path to agent card\n                JSON. If not provided, will be built automatically from the\n                agent.\n    runner: Optional pre-built Runner object. If not provided, a default\n            runner will be created using in-memory services.\n\nReturns:\n    A Starlette application that can be run with uvicorn\n\nExample:\n    agent = MyAgent()\n    app = to_a2a(agent, host=\"localhost\", port=8000, protocol=\"http\")\n    # Then run with: uvicorn module:app --host localhost --port 8000\n\n    # Or with custom agent card:\n    app = to_a2a(agent, agent_card=my_custom_agent_card)"
- rank: 95
  id: google.adk.a2a.utils.agent_to_a2a.to_a2a
  name: to_a2a
  file_path: src/google/adk/a2a/utils/agent_to_a2a.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Convert an ADK agent to a A2A Starlette application.\n\nArgs:\n    agent: The ADK agent to convert\n    host: The host for the A2A RPC URL (default: \"localhost\")\n    port: The port for the A2A RPC URL (default: 8000)\n    protocol: The protocol for the A2A RPC URL (default: \"http\")\n    agent_card: Optional pre-built AgentCard object or path to agent card\n                JSON. If not provided, will be built automatically from the\n                agent.\n    runner: Optional pre-built Runner object. If not provided, a default\n            runner will be created using in-memory services.\n\nReturns:\n    A Starlette application that can be run with uvicorn\n\nExample:\n    agent = MyAgent()\n    app = to_a2a(agent, host=\"localhost\", port=8000, protocol=\"http\")\n    # Then run with: uvicorn module:app --host localhost --port 8000\n\n    # Or with custom agent card:\n    app = to_a2a(agent, agent_card=my_custom_agent_card)"
  signature: 'def to_a2a(agent: google.adk.agents.base_agent.BaseAgent, *, host: str=''localhost'', port: int=8000, protocol: str=''http'', agent_card: typing.Optional[typing.Union[a2a.types.AgentCard, str]]=None, runner: typing.Optional[google.adk.runners.Runner]=None) -> starlette.applications.Starlette:'
- rank: 96
  id: google.adk.agents
  name: agents
  file_path: src/google/adk/agents/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: '__all__: Any'
- rank: 97
  id: google.adk.agents.active_streaming_tool
  name: active_streaming_tool
  file_path: src/google/adk/agents/active_streaming_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 98
  id: google.adk.agents.active_streaming_tool.ActiveStreamingTool
  name: ActiveStreamingTool
  file_path: src/google/adk/agents/active_streaming_tool.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Manages streaming tool related resources during invocation.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, task: typing.Optional[asyncio.Task] = None, stream: typing.Optional[google.adk.agents.live_request_queue.LiveRequestQueue] = None):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
    docstring: The pydantic model config.
  - signature: 'task: typing.Optional[asyncio.Task]'
    docstring: The active task of this streaming tool.
  - signature: 'stream: typing.Optional[google.adk.agents.live_request_queue.LiveRequestQueue]'
    docstring: The active (input) streams of this streaming tool.
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 99
  id: google.adk.agents.agent_config
  name: agent_config
  file_path: src/google/adk/agents/agent_config.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def agent_config_discriminator(v: typing.Any) -> str:'
    docstring: Discriminator function that returns the tag name for Pydantic.
  properties:
  - signature: '_ADK_AGENT_CLASSES: set[str]'
  - signature: 'ConfigsUnion: Any'
- rank: 100
  id: google.adk.agents.agent_config.AgentConfig
  name: AgentConfig
  file_path: src/google/adk/agents/agent_config.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: The config for the YAML schema to create an agent.
- rank: 101
  id: google.adk.agents.agent_config.agent_config_discriminator
  name: agent_config_discriminator
  file_path: src/google/adk/agents/agent_config.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Discriminator function that returns the tag name for Pydantic.
  signature: 'def agent_config_discriminator(v: typing.Any) -> str:'
- rank: 102
  id: google.adk.agents.base_agent
  name: base_agent
  file_path: src/google/adk/agents/base_agent.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '_SingleAgentCallback: typing_extensions.TypeAlias'
  - signature: 'BeforeAgentCallback: typing_extensions.TypeAlias'
  - signature: 'AfterAgentCallback: typing_extensions.TypeAlias'
  - signature: 'SelfAgent: typing.TypeVar'
  - signature: 'AgentState: typing.TypeVar'
- rank: 103
  id: google.adk.agents.base_agent.BaseAgent
  name: BaseAgent
  file_path: src/google/adk/agents/base_agent.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Base class for all agents in Agent Development Kit.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, name: str, description: str = '''', sub_agents: list[google.adk.agents.base_agent.BaseAgent] = list(), before_agent_callback: typing.Optional[google.adk.agents.base_agent.BeforeAgentCallback] = None, after_agent_callback: typing.Optional[google.adk.agents.base_agent.AfterAgentCallback] = None):'
  aliases:
  - google.adk.agents.BaseAgent
  methods:
  - signature: 'def clone(self: google.adk.agents.base_agent.SelfAgent, update: Mapping[str, Any] | None) -> google.adk.agents.base_agent.SelfAgent:'
    docstring: "Creates a copy of this agent instance.\n\nArgs:\n  update: Optional mapping of new values for the fields of the cloned agent.\n    The keys of the mapping are the names of the fields to be updated, and\n    the values are the new values for those fields.\n    For example: {\"name\": \"cloned_agent\"}\n\nReturns:\n  A new agent instance with identical configuration as the original\n  agent except for the fields specified in the update."
  - signature: 'def run_async(self, parent_context: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
    docstring: "Entry method to run an agent via text-based conversation.\n\nArgs:\n  parent_context: InvocationContext, the invocation context of the parent\n    agent.\n\nYields:\n  Event: the events generated by the agent."
  - signature: 'def run_live(self, parent_context: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
    docstring: "Entry method to run an agent via video/audio-based conversation.\n\nArgs:\n  parent_context: InvocationContext, the invocation context of the parent\n    agent.\n\nYields:\n  Event: the events generated by the agent."
  - signature: 'def _run_async_impl(self, ctx: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
    docstring: "Core logic to run this agent via text-based conversation.\n\nArgs:\n  ctx: InvocationContext, the invocation context for this agent.\n\nYields:\n  Event: the events generated by the agent."
  - signature: 'def root_agent(self) -> google.adk.agents.base_agent.BaseAgent:'
    docstring: Gets the root agent of this agent.
  - signature: 'def find_agent(self, name: str) -> typing.Optional[google.adk.agents.base_agent.BaseAgent]:'
    docstring: "Finds the agent with the given name in this agent and its descendants.\n\nArgs:\n  name: The name of the agent to find.\n\nReturns:\n  The agent with the matching name, or None if no such agent is found."
  - signature: 'def find_sub_agent(self, name: str) -> typing.Optional[google.adk.agents.base_agent.BaseAgent]:'
    docstring: "Finds the agent with the given name in this agent's descendants.\n\nArgs:\n  name: The name of the agent to find.\n\nReturns:\n  The agent with the matching name, or None if no such agent is found."
  - signature: 'def model_post_init(self, __context: typing.Any) -> None:'
  - signature: 'def validate_name(cls, value: str):'
  - signature: 'def validate_sub_agents_unique_names(cls, value: list[google.adk.agents.base_agent.BaseAgent]) -> list[google.adk.agents.base_agent.BaseAgent]:'
    docstring: "Validates that all sub-agents have unique names.\n\nArgs:\n  value: The list of sub-agents to validate.\n\nReturns:\n  The validated list of sub-agents."
  - signature: 'def from_config(cls: typing.Type[google.adk.agents.base_agent.SelfAgent], config: google.adk.agents.base_agent_config.BaseAgentConfig, config_abs_path: str) -> google.adk.agents.base_agent.SelfAgent:'
    docstring: "Creates an agent from a config.\n\nIf sub-classes uses a custom agent config, override `_from_config_kwargs`\nmethod to return an updated kwargs for agent constructor.\n\nArgs:\n  config: The config to create the agent from.\n  config_abs_path: The absolute path to the config file that contains the\n    agent config.\n\nReturns:\n  The created agent."
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
    docstring: The pydantic model config.
  - signature: 'config_type: typing.ClassVar[type[google.adk.agents.base_agent_config.BaseAgentConfig]]'
    docstring: "The config type for this agent.\n\nSub-classes should override this to specify their own config type.\n\nExample:\n\n```\nclass MyAgentConfig(BaseAgentConfig):\n  my_field: str = ''\n\nclass MyAgent(BaseAgent):\n  config_type: ClassVar[type[BaseAgentConfig]] = MyAgentConfig\n```"
  - signature: 'name: str'
    docstring: 'The agent''s name.


      Agent name must be a Python identifier and unique within the agent tree.

      Agent name cannot be "user", since it''s reserved for end-user''s input.'
  - signature: 'description: str'
    docstring: 'Description about the agent''s capability.


      The model uses this to determine whether to delegate control to the agent.

      One-line description is enough and preferred.'
  - signature: 'parent_agent: typing.Optional[google.adk.agents.base_agent.BaseAgent]'
    docstring: 'The parent agent of this agent.


      Note that an agent can ONLY be added as sub-agent once.


      If you want to add one agent twice as sub-agent, consider to create two agent

      instances with identical config, but with different name and add them to the

      agent tree.'
  - signature: 'sub_agents: list[google.adk.agents.base_agent.BaseAgent]'
    docstring: The sub-agents of this agent.
  - signature: 'before_agent_callback: typing.Optional[google.adk.agents.base_agent.BeforeAgentCallback]'
    docstring: "Callback or list of callbacks to be invoked before the agent run.\n\nWhen a list of callbacks is provided, the callbacks will be called in the\norder they are listed until a callback does not return None.\n\nArgs:\n  callback_context: MUST be named 'callback_context' (enforced).\n\nReturns:\n  Optional[types.Content]: The content to return to the user.\n    When the content is present, the agent run will be skipped and the\n    provided content will be returned to user."
  - signature: 'after_agent_callback: typing.Optional[google.adk.agents.base_agent.AfterAgentCallback]'
    docstring: "Callback or list of callbacks to be invoked after the agent run.\n\nWhen a list of callbacks is provided, the callbacks will be called in the\norder they are listed until a callback does not return None.\n\nArgs:\n  callback_context: MUST be named 'callback_context' (enforced).\n\nReturns:\n  Optional[types.Content]: The content to return to the user.\n    When the content is present, an additional event with the provided content\n    will be appended to event history as an additional agent response."
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 104
  id: google.adk.agents.base_agent.BaseAgent._run_async_impl
  name: _run_async_impl
  file_path: src/google/adk/agents/base_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Core logic to run this agent via text-based conversation.\n\nArgs:\n  ctx: InvocationContext, the invocation context for this agent.\n\nYields:\n  Event: the events generated by the agent."
  signature: 'def _run_async_impl(self, ctx: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
- rank: 105
  id: google.adk.agents.base_agent.BaseAgent.canonical_after_agent_callbacks
  name: canonical_after_agent_callbacks
  file_path: src/google/adk/agents/base_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'The resolved self.after_agent_callback field as a list of _SingleAgentCallback.


    This method is only for use by Agent Development Kit.'
  signature: 'def canonical_after_agent_callbacks(self) -> list[google.adk.agents.base_agent._SingleAgentCallback]:'
- rank: 106
  id: google.adk.agents.base_agent.BaseAgent.canonical_before_agent_callbacks
  name: canonical_before_agent_callbacks
  file_path: src/google/adk/agents/base_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'The resolved self.before_agent_callback field as a list of _SingleAgentCallback.


    This method is only for use by Agent Development Kit.'
  signature: 'def canonical_before_agent_callbacks(self) -> list[google.adk.agents.base_agent._SingleAgentCallback]:'
- rank: 107
  id: google.adk.agents.base_agent.BaseAgent.clone
  name: clone
  file_path: src/google/adk/agents/base_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Creates a copy of this agent instance.\n\nArgs:\n  update: Optional mapping of new values for the fields of the cloned agent.\n    The keys of the mapping are the names of the fields to be updated, and\n    the values are the new values for those fields.\n    For example: {\"name\": \"cloned_agent\"}\n\nReturns:\n  A new agent instance with identical configuration as the original\n  agent except for the fields specified in the update."
  signature: 'def clone(self: google.adk.agents.base_agent.SelfAgent, update: Mapping[str, Any] | None) -> google.adk.agents.base_agent.SelfAgent:'
- rank: 108
  id: google.adk.agents.base_agent.BaseAgent.find_agent
  name: find_agent
  file_path: src/google/adk/agents/base_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Finds the agent with the given name in this agent and its descendants.\n\nArgs:\n  name: The name of the agent to find.\n\nReturns:\n  The agent with the matching name, or None if no such agent is found."
  signature: 'def find_agent(self, name: str) -> typing.Optional[google.adk.agents.base_agent.BaseAgent]:'
- rank: 109
  id: google.adk.agents.base_agent.BaseAgent.find_sub_agent
  name: find_sub_agent
  file_path: src/google/adk/agents/base_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Finds the agent with the given name in this agent's descendants.\n\nArgs:\n  name: The name of the agent to find.\n\nReturns:\n  The agent with the matching name, or None if no such agent is found."
  signature: 'def find_sub_agent(self, name: str) -> typing.Optional[google.adk.agents.base_agent.BaseAgent]:'
- rank: 110
  id: google.adk.agents.base_agent.BaseAgent.from_config
  name: from_config
  file_path: src/google/adk/agents/base_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Creates an agent from a config.\n\nIf sub-classes uses a custom agent config, override `_from_config_kwargs`\nmethod to return an updated kwargs for agent constructor.\n\nArgs:\n  config: The config to create the agent from.\n  config_abs_path: The absolute path to the config file that contains the\n    agent config.\n\nReturns:\n  The created agent."
  signature: 'def from_config(cls: typing.Type[google.adk.agents.base_agent.SelfAgent], config: google.adk.agents.base_agent_config.BaseAgentConfig, config_abs_path: str) -> google.adk.agents.base_agent.SelfAgent:'
- rank: 111
  id: google.adk.agents.base_agent.BaseAgent.root_agent
  name: root_agent
  file_path: src/google/adk/agents/base_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Gets the root agent of this agent.
  signature: 'def root_agent(self) -> google.adk.agents.base_agent.BaseAgent:'
- rank: 112
  id: google.adk.agents.base_agent.BaseAgent.run_async
  name: run_async
  file_path: src/google/adk/agents/base_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Entry method to run an agent via text-based conversation.\n\nArgs:\n  parent_context: InvocationContext, the invocation context of the parent\n    agent.\n\nYields:\n  Event: the events generated by the agent."
  signature: 'def run_async(self, parent_context: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
- rank: 113
  id: google.adk.agents.base_agent.BaseAgent.run_live
  name: run_live
  file_path: src/google/adk/agents/base_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Entry method to run an agent via video/audio-based conversation.\n\nArgs:\n  parent_context: InvocationContext, the invocation context of the parent\n    agent.\n\nYields:\n  Event: the events generated by the agent."
  signature: 'def run_live(self, parent_context: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
- rank: 114
  id: google.adk.agents.base_agent.BaseAgent.validate_name
  name: validate_name
  file_path: src/google/adk/agents/base_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def validate_name(cls, value: str):'
- rank: 115
  id: google.adk.agents.base_agent.BaseAgent.validate_sub_agents_unique_names
  name: validate_sub_agents_unique_names
  file_path: src/google/adk/agents/base_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Validates that all sub-agents have unique names.\n\nArgs:\n  value: The list of sub-agents to validate.\n\nReturns:\n  The validated list of sub-agents."
  signature: 'def validate_sub_agents_unique_names(cls, value: list[google.adk.agents.base_agent.BaseAgent]) -> list[google.adk.agents.base_agent.BaseAgent]:'
- rank: 116
  id: google.adk.agents.base_agent.BaseAgentState
  name: BaseAgentState
  file_path: src/google/adk/agents/base_agent.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Base class for all agent states.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 117
  id: google.adk.agents.base_agent_config
  name: base_agent_config
  file_path: src/google/adk/agents/base_agent_config.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'TBaseAgentConfig: typing.TypeVar'
- rank: 118
  id: google.adk.agents.base_agent_config.BaseAgentConfig
  name: BaseAgentConfig
  file_path: src/google/adk/agents/base_agent_config.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'The config for the YAML schema of a BaseAgent.


    Do not use this class directly. It''s the base class for all agent configs.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, agent_class: typing.Union[typing.Literal[BaseAgent], str] = ''BaseAgent'', name: str, description: str = '''', sub_agents: typing.Optional[typing.List[google.adk.agents.common_configs.AgentRefConfig]] = None, before_agent_callbacks: typing.Optional[typing.List[google.adk.agents.common_configs.CodeConfig]] = None, after_agent_callbacks: typing.Optional[typing.List[google.adk.agents.common_configs.CodeConfig]] = None):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'agent_class: typing.Union[typing.Literal[BaseAgent], str]'
  - signature: 'name: str'
  - signature: 'description: str'
  - signature: 'sub_agents: typing.Optional[typing.List[google.adk.agents.common_configs.AgentRefConfig]]'
  - signature: 'before_agent_callbacks: typing.Optional[typing.List[google.adk.agents.common_configs.CodeConfig]]'
  - signature: 'after_agent_callbacks: typing.Optional[typing.List[google.adk.agents.common_configs.CodeConfig]]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 119
  id: google.adk.agents.callback_context
  name: callback_context
  file_path: src/google/adk/agents/callback_context.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 120
  id: google.adk.agents.callback_context.CallbackContext
  name: CallbackContext
  file_path: src/google/adk/agents/callback_context.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: The context of various callbacks within an agent run.
  constructor_signature: 'def __init__(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, *, event_actions: typing.Optional[google.adk.events.event_actions.EventActions]=None) -> None:'
  methods:
  - signature: 'def state(self) -> google.adk.sessions.state.State:'
    docstring: 'The delta-aware state of the current session.


      For any state change, you can mutate this object directly,

      e.g. `ctx.state[''foo''] = ''bar''`'
  - signature: 'def load_artifact(self, filename: str, version: typing.Optional[int]) -> typing.Optional[google.genai.types.Part]:'
    docstring: "Loads an artifact attached to the current session.\n\nArgs:\n  filename: The filename of the artifact.\n  version: The version of the artifact. If None, the latest version will be\n    returned.\n\nReturns:\n  The artifact."
  - signature: 'def save_artifact(self, filename: str, artifact: google.genai.types.Part, custom_metadata: typing.Optional[dict[str, typing.Any]]) -> int:'
    docstring: "Saves an artifact and records it as delta for the current session.\n\nArgs:\n  filename: The filename of the artifact.\n  artifact: The artifact to save.\n  custom_metadata: Custom metadata to associate with the artifact.\n\nReturns:\n The version of the artifact."
  - signature: 'def get_artifact_version(self, filename: str, version: typing.Optional[int]) -> typing.Optional[google.adk.artifacts.base_artifact_service.ArtifactVersion]:'
    docstring: "Gets artifact version info.\n\nArgs:\n  filename: The filename of the artifact.\n  version: The version of the artifact. If None, the latest version will be\n    returned.\n\nReturns:\n  The artifact version info."
  - signature: 'def list_artifacts(self) -> list[str]:'
    docstring: Lists the filenames of the artifacts attached to the current session.
  - signature: 'def save_credential(self, auth_config: google.adk.auth.auth_tool.AuthConfig) -> None:'
    docstring: "Saves a credential to the credential service.\n\nArgs:\n  auth_config: The authentication configuration containing the credential."
  - signature: 'def load_credential(self, auth_config: google.adk.auth.auth_tool.AuthConfig) -> typing.Optional[google.adk.auth.auth_credential.AuthCredential]:'
    docstring: "Loads a credential from the credential service.\n\nArgs:\n  auth_config: The authentication configuration for the credential.\n\nReturns:\n  The loaded credential, or None if not found."
  - signature: 'def get_auth_response(self, auth_config: google.adk.auth.auth_tool.AuthConfig) -> typing.Optional[google.adk.auth.auth_credential.AuthCredential]:'
    docstring: "Gets the auth response credential from session state.\n\nThis method retrieves an authentication credential that was previously\nstored in session state after a user completed an OAuth flow or other\nauthentication process.\n\nArgs:\n  auth_config: The authentication configuration for the credential.\n\nReturns:\n  The auth credential from the auth response, or None if not found."
  - signature: 'def add_session_to_memory(self) -> None:'
    docstring: "Triggers memory generation for the current session.\n\nThis method saves the current session's events to the memory service,\nenabling the agent to recall information from past interactions.\n\nRaises:\n  ValueError: If memory service is not available.\n\nExample:\n  ```python\n  async def my_after_agent_callback(callback_context: CallbackContext):\n      # Save conversation to memory at the end of each interaction\n      await callback_context.add_session_to_memory()\n  ```"
  inherited_methods:
    ReadonlyContext:
    - signature: 'def user_content(self) -> typing.Optional[google.genai.types.Content]:'
      docstring: The user content that started this invocation. READONLY field.
    - signature: 'def invocation_id(self) -> str:'
      docstring: The current invocation id.
    - signature: 'def agent_name(self) -> str:'
      docstring: The name of the agent that is currently running.
    - signature: 'def state(self) -> types.MappingProxyType[str, typing.Any]:'
      docstring: The state of the current session. READONLY field.
    - signature: 'def session(self) -> google.adk.sessions.session.Session:'
      docstring: The current session for this invocation.
    - signature: 'def user_id(self) -> str:'
      docstring: The id of the user. READONLY field.
    - signature: 'def run_config(self) -> typing.Optional[google.adk.agents.run_config.RunConfig]:'
      docstring: The run config of the current invocation. READONLY field.
- rank: 121
  id: google.adk.agents.callback_context.CallbackContext.__init__
  name: __init__
  file_path: src/google/adk/agents/callback_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, *, event_actions: typing.Optional[google.adk.events.event_actions.EventActions]=None) -> None:'
- rank: 122
  id: google.adk.agents.callback_context.CallbackContext.add_session_to_memory
  name: add_session_to_memory
  file_path: src/google/adk/agents/callback_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Triggers memory generation for the current session.\n\nThis method saves the current session's events to the memory service,\nenabling the agent to recall information from past interactions.\n\nRaises:\n  ValueError: If memory service is not available.\n\nExample:\n  ```python\n  async def my_after_agent_callback(callback_context: CallbackContext):\n      # Save conversation to memory at the end of each interaction\n      await callback_context.add_session_to_memory()\n  ```"
  signature: 'def add_session_to_memory(self) -> None:'
- rank: 123
  id: google.adk.agents.callback_context.CallbackContext.get_artifact_version
  name: get_artifact_version
  file_path: src/google/adk/agents/callback_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Gets artifact version info.\n\nArgs:\n  filename: The filename of the artifact.\n  version: The version of the artifact. If None, the latest version will be\n    returned.\n\nReturns:\n  The artifact version info."
  signature: 'def get_artifact_version(self, filename: str, version: typing.Optional[int]) -> typing.Optional[google.adk.artifacts.base_artifact_service.ArtifactVersion]:'
- rank: 124
  id: google.adk.agents.callback_context.CallbackContext.get_auth_response
  name: get_auth_response
  file_path: src/google/adk/agents/callback_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Gets the auth response credential from session state.\n\nThis method retrieves an authentication credential that was previously\nstored in session state after a user completed an OAuth flow or other\nauthentication process.\n\nArgs:\n  auth_config: The authentication configuration for the credential.\n\nReturns:\n  The auth credential from the auth response, or None if not found."
  signature: 'def get_auth_response(self, auth_config: google.adk.auth.auth_tool.AuthConfig) -> typing.Optional[google.adk.auth.auth_credential.AuthCredential]:'
- rank: 125
  id: google.adk.agents.callback_context.CallbackContext.list_artifacts
  name: list_artifacts
  file_path: src/google/adk/agents/callback_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Lists the filenames of the artifacts attached to the current session.
  signature: 'def list_artifacts(self) -> list[str]:'
- rank: 126
  id: google.adk.agents.callback_context.CallbackContext.load_artifact
  name: load_artifact
  file_path: src/google/adk/agents/callback_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Loads an artifact attached to the current session.\n\nArgs:\n  filename: The filename of the artifact.\n  version: The version of the artifact. If None, the latest version will be\n    returned.\n\nReturns:\n  The artifact."
  signature: 'def load_artifact(self, filename: str, version: typing.Optional[int]) -> typing.Optional[google.genai.types.Part]:'
- rank: 127
  id: google.adk.agents.callback_context.CallbackContext.load_credential
  name: load_credential
  file_path: src/google/adk/agents/callback_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Loads a credential from the credential service.\n\nArgs:\n  auth_config: The authentication configuration for the credential.\n\nReturns:\n  The loaded credential, or None if not found."
  signature: 'def load_credential(self, auth_config: google.adk.auth.auth_tool.AuthConfig) -> typing.Optional[google.adk.auth.auth_credential.AuthCredential]:'
- rank: 128
  id: google.adk.agents.callback_context.CallbackContext.save_artifact
  name: save_artifact
  file_path: src/google/adk/agents/callback_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Saves an artifact and records it as delta for the current session.\n\nArgs:\n  filename: The filename of the artifact.\n  artifact: The artifact to save.\n  custom_metadata: Custom metadata to associate with the artifact.\n\nReturns:\n The version of the artifact."
  signature: 'def save_artifact(self, filename: str, artifact: google.genai.types.Part, custom_metadata: typing.Optional[dict[str, typing.Any]]) -> int:'
- rank: 129
  id: google.adk.agents.callback_context.CallbackContext.save_credential
  name: save_credential
  file_path: src/google/adk/agents/callback_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Saves a credential to the credential service.\n\nArgs:\n  auth_config: The authentication configuration containing the credential."
  signature: 'def save_credential(self, auth_config: google.adk.auth.auth_tool.AuthConfig) -> None:'
- rank: 130
  id: google.adk.agents.callback_context.CallbackContext.state
  name: state
  file_path: src/google/adk/agents/callback_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'The delta-aware state of the current session.


    For any state change, you can mutate this object directly,

    e.g. `ctx.state[''foo''] = ''bar''`'
  signature: 'def state(self) -> google.adk.sessions.state.State:'
- rank: 131
  id: google.adk.agents.common_configs
  name: common_configs
  file_path: src/google/adk/agents/common_configs.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Common configuration classes for agent YAML configs.
- rank: 132
  id: google.adk.agents.common_configs.AgentRefConfig
  name: AgentRefConfig
  file_path: src/google/adk/agents/common_configs.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'The config for the reference to another agent.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, config_path: typing.Optional[str] = None, code: typing.Optional[str] = None):'
  methods:
  - signature: 'def validate_exactly_one_field(self) -> google.adk.agents.common_configs.AgentRefConfig:'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'config_path: typing.Optional[str]'
    docstring: "The YAML config file path of the sub-agent.\n\nOnly one of `config_path` or `code` can be set.\n\nExample:\n\n  ```\n  sub_agents:\n    - config_path: search_agent.yaml\n    - config_path: my_library/my_custom_agent.yaml\n  ```"
  - signature: 'code: typing.Optional[str]'
    docstring: "The agent instance defined in the code.\n\nOnly one of `config` or `code` can be set.\n\nExample:\n\n  For the following agent defined in Python code:\n\n  ```\n  # my_library/custom_agents.py\n  from google.adk.agents.llm_agent import LlmAgent\n\n  my_custom_agent = LlmAgent(\n      name=\"my_custom_agent\",\n      instruction=\"You are a helpful custom agent.\",\n      model=\"gemini-2.0-flash\",\n  )\n  ```\n\n  The yaml config should be:\n\n  ```\n  sub_agents:\n    - code: my_library.custom_agents.my_custom_agent\n  ```\n  "
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 133
  id: google.adk.agents.common_configs.AgentRefConfig.validate_exactly_one_field
  name: validate_exactly_one_field
  file_path: src/google/adk/agents/common_configs.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def validate_exactly_one_field(self) -> google.adk.agents.common_configs.AgentRefConfig:'
- rank: 134
  id: google.adk.agents.common_configs.ArgumentConfig
  name: ArgumentConfig
  file_path: src/google/adk/agents/common_configs.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'An argument passed to a function or a class''s constructor.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, name: typing.Optional[str] = None, value: typing.Any):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'name: typing.Optional[str]'
    docstring: 'Optional. The argument name.


      When the argument is for a positional argument, this can be omitted.'
  - signature: 'value: typing.Any'
    docstring: The argument value.
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 135
  id: google.adk.agents.common_configs.CodeConfig
  name: CodeConfig
  file_path: src/google/adk/agents/common_configs.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Code reference config for a variable, a function, or a class.


    This config is used for configuring callbacks and tools.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, name: str, args: typing.Optional[typing.List[google.adk.agents.common_configs.ArgumentConfig]] = None):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'name: str'
    docstring: "Required. The name of the variable, function, class, etc. in code.\n\nExamples:\n\n  When used for tools,\n    - It can be ADK built-in tools, such as `google_search` and `AgentTool`.\n    - It can also be users' custom tools, e.g. my_library.my_tools.my_tool.\n\n  When used for callbacks, it refers to a function, e.g. `my_library.my_callbacks.my_callback`"
  - signature: 'args: typing.Optional[typing.List[google.adk.agents.common_configs.ArgumentConfig]]'
    docstring: "Optional. The arguments for the code when `name` refers to a function or a\nclass's constructor.\n\nExamples:\n  ```\n  tools\n    - name: AgentTool\n      args:\n        - name: agent\n          value: search_agent.yaml\n        - name: skip_summarization\n          value: True\n  ```"
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 136
  id: google.adk.agents.config_agent_utils
  name: config_agent_utils
  file_path: src/google/adk/agents/config_agent_utils.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def from_config(config_path: str) -> google.adk.agents.base_agent.BaseAgent:'
    docstring: "Build agent from a configfile path.\n\nArgs:\n  config: the path to a YAML config file.\n\nReturns:\n  The created agent instance.\n\nRaises:\n  FileNotFoundError: If config file doesn't exist.\n  ValidationError: If config file's content is invalid YAML.\n  ValueError: If agent type is unsupported."
  - signature: 'def resolve_fully_qualified_name(name: str) -> typing.Any:'
  - signature: 'def resolve_agent_reference(ref_config: google.adk.agents.common_configs.AgentRefConfig, referencing_agent_config_abs_path: str) -> google.adk.agents.base_agent.BaseAgent:'
    docstring: "Build an agent from a reference.\n\nArgs:\n  ref_config: The agent reference configuration (AgentRefConfig).\n  referencing_agent_config_abs_path: The absolute path to the agent config\n  that contains the reference.\n\nReturns:\n  The created agent instance."
  - signature: 'def resolve_code_reference(code_config: google.adk.agents.common_configs.CodeConfig) -> typing.Any:'
    docstring: "Resolve a code reference to actual Python object.\n\nArgs:\n  code_config: The code configuration (CodeConfig).\n\nReturns:\n  The resolved Python object.\n\nRaises:\n  ValueError: If the code reference cannot be resolved."
  - signature: 'def resolve_callbacks(callbacks_config: typing.List[google.adk.agents.common_configs.CodeConfig]) -> typing.Any:'
    docstring: "Resolve callbacks from configuration.\n\nArgs:\n  callbacks_config: List of callback configurations (CodeConfig objects).\n\nReturns:\n  List of resolved callback objects."
- rank: 137
  id: google.adk.agents.config_agent_utils.from_config
  name: from_config
  file_path: src/google/adk/agents/config_agent_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Build agent from a configfile path.\n\nArgs:\n  config: the path to a YAML config file.\n\nReturns:\n  The created agent instance.\n\nRaises:\n  FileNotFoundError: If config file doesn't exist.\n  ValidationError: If config file's content is invalid YAML.\n  ValueError: If agent type is unsupported."
  signature: 'def from_config(config_path: str) -> google.adk.agents.base_agent.BaseAgent:'
- rank: 138
  id: google.adk.agents.config_agent_utils.resolve_agent_reference
  name: resolve_agent_reference
  file_path: src/google/adk/agents/config_agent_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Build an agent from a reference.\n\nArgs:\n  ref_config: The agent reference configuration (AgentRefConfig).\n  referencing_agent_config_abs_path: The absolute path to the agent config\n  that contains the reference.\n\nReturns:\n  The created agent instance."
  signature: 'def resolve_agent_reference(ref_config: google.adk.agents.common_configs.AgentRefConfig, referencing_agent_config_abs_path: str) -> google.adk.agents.base_agent.BaseAgent:'
- rank: 139
  id: google.adk.agents.config_agent_utils.resolve_callbacks
  name: resolve_callbacks
  file_path: src/google/adk/agents/config_agent_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Resolve callbacks from configuration.\n\nArgs:\n  callbacks_config: List of callback configurations (CodeConfig objects).\n\nReturns:\n  List of resolved callback objects."
  signature: 'def resolve_callbacks(callbacks_config: typing.List[google.adk.agents.common_configs.CodeConfig]) -> typing.Any:'
- rank: 140
  id: google.adk.agents.config_agent_utils.resolve_code_reference
  name: resolve_code_reference
  file_path: src/google/adk/agents/config_agent_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Resolve a code reference to actual Python object.\n\nArgs:\n  code_config: The code configuration (CodeConfig).\n\nReturns:\n  The resolved Python object.\n\nRaises:\n  ValueError: If the code reference cannot be resolved."
  signature: 'def resolve_code_reference(code_config: google.adk.agents.common_configs.CodeConfig) -> typing.Any:'
- rank: 141
  id: google.adk.agents.config_agent_utils.resolve_fully_qualified_name
  name: resolve_fully_qualified_name
  file_path: src/google/adk/agents/config_agent_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def resolve_fully_qualified_name(name: str) -> typing.Any:'
- rank: 142
  id: google.adk.agents.context_cache_config
  name: context_cache_config
  file_path: src/google/adk/agents/context_cache_config.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 143
  id: google.adk.agents.invocation_context
  name: invocation_context
  file_path: src/google/adk/agents/invocation_context.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def new_invocation_context_id() -> str:'
- rank: 144
  id: google.adk.agents.invocation_context.InvocationContext
  name: InvocationContext
  file_path: src/google/adk/agents/invocation_context.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "An invocation context represents the data of a single invocation of an agent.\n\nAn invocation:\n  1. Starts with a user message and ends with a final response.\n  2. Can contain one or multiple agent calls.\n  3. Is handled by runner.run_async().\n\nAn invocation runs an agent until it does not request to transfer to another\nagent.\n\nAn agent call:\n  1. Is handled by agent.run().\n  2. Ends when agent.run() ends.\n\nAn LLM agent call is an agent with a BaseLLMFlow.\nAn LLM agent call can contain one or multiple steps.\n\nAn LLM agent runs steps in a loop until:\n  1. A final response is generated.\n  2. The agent transfers to another agent.\n  3. The end_invocation is set to true by any callbacks or tools.\n\nA step:\n  1. Calls the LLM only once and yields its response.\n  2. Calls the tools and yields their responses if requested.\n\nThe summarization of the function response is considered another step, since\nit is another llm call.\nA step ends when it's done calling\
    \ llm and tools, or if the end_invocation\nis set to true at any time.\n\n```\n   \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 invocation \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 llm_agent_call_1 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250C\u2500 agent_call_2 \u2500\u2510\n   \u250C\u2500\u2500\u2500\u2500 step_1 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250C\u2500\u2500\u2500\u2500\u2500 step_2 \u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   [call_llm] [call_tool] [call_llm] [transfer]\n```\n\n[Note: Inherited members from pydantic.BaseModel are omitted.]"
  constructor_signature: 'def __init__(self, *, artifact_service: typing.Optional[google.adk.artifacts.base_artifact_service.BaseArtifactService] = None, session_service: google.adk.sessions.base_session_service.BaseSessionService, memory_service: typing.Optional[google.adk.memory.base_memory_service.BaseMemoryService] = None, credential_service: typing.Optional[google.adk.auth.credential_service.base_credential_service.BaseCredentialService] = None, context_cache_config: typing.Optional[google.adk.agents.context_cache_config.ContextCacheConfig] = None, branch: typing.Optional[str] = None, agent: google.adk.agents.base_agent.BaseAgent, user_content: typing.Optional[google.genai.types.Content] = None, session: google.adk.sessions.session.Session, agent_states: dict[str, dict[str, typing.Any]] = dict(), end_of_agents: dict[str, bool] = dict(), end_invocation: bool = False, live_request_queue: typing.Optional[google.adk.agents.live_request_queue.LiveRequestQueue] = None, active_streaming_tools:
    typing.Optional[dict[str, google.adk.agents.active_streaming_tool.ActiveStreamingTool]] = None, transcription_cache: typing.Optional[list[google.adk.agents.transcription_entry.TranscriptionEntry]] = None, live_session_resumption_handle: typing.Optional[str] = None, input_realtime_cache: typing.Optional[list[google.adk.agents.invocation_context.RealtimeCacheEntry]] = None, output_realtime_cache: typing.Optional[list[google.adk.agents.invocation_context.RealtimeCacheEntry]] = None, run_config: typing.Optional[google.adk.agents.run_config.RunConfig] = None, resumability_config: typing.Optional[google.adk.apps.app.ResumabilityConfig] = None, plugin_manager: google.adk.plugins.plugin_manager.PluginManager = Factory(PluginManager), canonical_tools_cache: typing.Optional[list[google.adk.tools.base_tool.BaseTool]] = None):'
  methods:
  - signature: 'def is_resumable(self) -> bool:'
    docstring: Returns whether the current invocation is resumable.
  - signature: 'def set_agent_state(self, agent_name: str, *, agent_state: typing.Optional[google.adk.agents.base_agent.BaseAgentState]=None, end_of_agent: bool=False) -> None:'
    docstring: "Sets the state of an agent in this invocation.\n\n* If end_of_agent is True, will set the end_of_agent flag to True and\n  clear the agent_state.\n* Otherwise, if agent_state is not None, will set the agent_state and\n  reset the end_of_agent flag to False.\n* Otherwise, will clear the agent_state and end_of_agent flag, to allow the\n  agent to re-run.\n\nArgs:\n  agent_name: The name of the agent.\n  agent_state: The state of the agent. Will be ignored if end_of_agent is\n    True.\n  end_of_agent: Whether the agent has finished running."
  - signature: 'def reset_sub_agent_states(self, agent_name: str) -> None:'
    docstring: "Resets the state of all sub-agents of the given agent in this invocation.\n\nArgs:\n  agent_name: The name of the agent whose sub-agent states need to be reset."
  - signature: 'def populate_invocation_agent_states(self) -> None:'
    docstring: 'Populates agent states for the current invocation if it is resumable.


      For history events that contain agent state information, set the

      agent_state and end_of_agent of the agent that generated the event.


      For non-workflow agents, also set an initial agent_state if it has

      already generated some contents.'
  - signature: 'def increment_llm_call_count(self):'
    docstring: "Tracks number of llm calls made.\n\nRaises:\n  LlmCallsLimitExceededError: If number of llm calls made exceed the set\n    threshold."
  - signature: 'def app_name(self) -> str:'
  - signature: 'def user_id(self) -> str:'
  - signature: 'def should_pause_invocation(self, event: google.adk.events.event.Event) -> bool:'
    docstring: "Returns whether to pause the invocation right after this event.\n\n\"Pausing\" an invocation is different from \"ending\" an invocation. A paused\ninvocation can be resumed later, while an ended invocation cannot.\n\nPausing the current agent's run will also pause all the agents that\ndepend on its execution, i.e. the subsequent agents in a workflow, and the\ncurrent agent's ancestors, etc.\n\nNote that parallel sibling agents won't be affected, but their common\nancestors will be paused after all the non-blocking sub-agents finished\nrunning.\n\nShould meet all following conditions to pause an invocation:\n  1. The app is resumable.\n  2. The current event has a long running function call.\n\nArgs:\n  event: The current event.\n\nReturns:\n  Whether to pause the invocation right after this event."
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
    docstring: The pydantic model config.
  - signature: 'artifact_service: typing.Optional[google.adk.artifacts.base_artifact_service.BaseArtifactService]'
  - signature: 'session_service: google.adk.sessions.base_session_service.BaseSessionService'
  - signature: 'memory_service: typing.Optional[google.adk.memory.base_memory_service.BaseMemoryService]'
  - signature: 'credential_service: typing.Optional[google.adk.auth.credential_service.base_credential_service.BaseCredentialService]'
  - signature: 'context_cache_config: typing.Optional[google.adk.agents.context_cache_config.ContextCacheConfig]'
  - signature: 'invocation_id: str'
    docstring: The id of this invocation context. Readonly.
  - signature: 'branch: typing.Optional[str]'
    docstring: 'The branch of the invocation context.


      The format is like agent_1.agent_2.agent_3, where agent_1 is the parent of

      agent_2, and agent_2 is the parent of agent_3.


      Branch is used when multiple sub-agents shouldn''t see their peer agents''

      conversation history.'
  - signature: 'agent: google.adk.agents.base_agent.BaseAgent'
    docstring: The current agent of this invocation context. Readonly.
  - signature: 'user_content: typing.Optional[google.genai.types.Content]'
    docstring: The user content that started this invocation. Readonly.
  - signature: 'session: google.adk.sessions.session.Session'
    docstring: The current session of this invocation context. Readonly.
  - signature: 'agent_states: dict[str, dict[str, typing.Any]]'
    docstring: The state of the agent for this invocation.
  - signature: 'end_of_agents: dict[str, bool]'
    docstring: The end of agent status for each agent in this invocation.
  - signature: 'end_invocation: bool'
    docstring: 'Whether to end this invocation.


      Set to True in callbacks or tools to terminate this invocation.'
  - signature: 'live_request_queue: typing.Optional[google.adk.agents.live_request_queue.LiveRequestQueue]'
    docstring: The queue to receive live requests.
  - signature: 'active_streaming_tools: typing.Optional[dict[str, google.adk.agents.active_streaming_tool.ActiveStreamingTool]]'
    docstring: The running streaming tools of this invocation.
  - signature: 'transcription_cache: typing.Optional[list[google.adk.agents.transcription_entry.TranscriptionEntry]]'
    docstring: Caches necessary data, audio or contents, that are needed by transcription.
  - signature: 'live_session_resumption_handle: typing.Optional[str]'
    docstring: The handle for live session resumption.
  - signature: 'input_realtime_cache: typing.Optional[list[google.adk.agents.invocation_context.RealtimeCacheEntry]]'
    docstring: Caches input audio chunks before flushing to session and artifact services.
  - signature: 'output_realtime_cache: typing.Optional[list[google.adk.agents.invocation_context.RealtimeCacheEntry]]'
    docstring: Caches output audio chunks before flushing to session and artifact services.
  - signature: 'run_config: typing.Optional[google.adk.agents.run_config.RunConfig]'
    docstring: Configurations for live agents under this invocation.
  - signature: 'resumability_config: typing.Optional[google.adk.apps.app.ResumabilityConfig]'
    docstring: The resumability config that applies to all agents under this invocation.
  - signature: 'plugin_manager: google.adk.plugins.plugin_manager.PluginManager'
    docstring: The manager for keeping track of plugins in this invocation.
  - signature: 'canonical_tools_cache: typing.Optional[list[google.adk.tools.base_tool.BaseTool]]'
    docstring: The cache of canonical tools for this invocation.
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 145
  id: google.adk.agents.invocation_context.InvocationContext.increment_llm_call_count
  name: increment_llm_call_count
  file_path: src/google/adk/agents/invocation_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Tracks number of llm calls made.\n\nRaises:\n  LlmCallsLimitExceededError: If number of llm calls made exceed the set\n    threshold."
  signature: 'def increment_llm_call_count(self):'
- rank: 146
  id: google.adk.agents.invocation_context.InvocationContext.is_resumable
  name: is_resumable
  file_path: src/google/adk/agents/invocation_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns whether the current invocation is resumable.
  signature: 'def is_resumable(self) -> bool:'
- rank: 147
  id: google.adk.agents.invocation_context.InvocationContext.populate_invocation_agent_states
  name: populate_invocation_agent_states
  file_path: src/google/adk/agents/invocation_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Populates agent states for the current invocation if it is resumable.


    For history events that contain agent state information, set the

    agent_state and end_of_agent of the agent that generated the event.


    For non-workflow agents, also set an initial agent_state if it has

    already generated some contents.'
  signature: 'def populate_invocation_agent_states(self) -> None:'
- rank: 148
  id: google.adk.agents.invocation_context.InvocationContext.reset_sub_agent_states
  name: reset_sub_agent_states
  file_path: src/google/adk/agents/invocation_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Resets the state of all sub-agents of the given agent in this invocation.\n\nArgs:\n  agent_name: The name of the agent whose sub-agent states need to be reset."
  signature: 'def reset_sub_agent_states(self, agent_name: str) -> None:'
- rank: 149
  id: google.adk.agents.invocation_context.InvocationContext.set_agent_state
  name: set_agent_state
  file_path: src/google/adk/agents/invocation_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Sets the state of an agent in this invocation.\n\n* If end_of_agent is True, will set the end_of_agent flag to True and\n  clear the agent_state.\n* Otherwise, if agent_state is not None, will set the agent_state and\n  reset the end_of_agent flag to False.\n* Otherwise, will clear the agent_state and end_of_agent flag, to allow the\n  agent to re-run.\n\nArgs:\n  agent_name: The name of the agent.\n  agent_state: The state of the agent. Will be ignored if end_of_agent is\n    True.\n  end_of_agent: Whether the agent has finished running."
  signature: 'def set_agent_state(self, agent_name: str, *, agent_state: typing.Optional[google.adk.agents.base_agent.BaseAgentState]=None, end_of_agent: bool=False) -> None:'
- rank: 150
  id: google.adk.agents.invocation_context.InvocationContext.should_pause_invocation
  name: should_pause_invocation
  file_path: src/google/adk/agents/invocation_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Returns whether to pause the invocation right after this event.\n\n\"Pausing\" an invocation is different from \"ending\" an invocation. A paused\ninvocation can be resumed later, while an ended invocation cannot.\n\nPausing the current agent's run will also pause all the agents that\ndepend on its execution, i.e. the subsequent agents in a workflow, and the\ncurrent agent's ancestors, etc.\n\nNote that parallel sibling agents won't be affected, but their common\nancestors will be paused after all the non-blocking sub-agents finished\nrunning.\n\nShould meet all following conditions to pause an invocation:\n  1. The app is resumable.\n  2. The current event has a long running function call.\n\nArgs:\n  event: The current event.\n\nReturns:\n  Whether to pause the invocation right after this event."
  signature: 'def should_pause_invocation(self, event: google.adk.events.event.Event) -> bool:'
- rank: 151
  id: google.adk.agents.invocation_context.LlmCallsLimitExceededError
  name: LlmCallsLimitExceededError
  file_path: src/google/adk/agents/invocation_context.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Error thrown when the number of LLM calls exceed the limit.


    [Note: Inherited members from Exception are omitted.]'
  omitted_inherited_members_from:
  - Exception
- rank: 152
  id: google.adk.agents.invocation_context.RealtimeCacheEntry
  name: RealtimeCacheEntry
  file_path: src/google/adk/agents/invocation_context.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Store audio data chunks for caching before flushing.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, role: str, data: google.genai.types.Blob, timestamp: float):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
    docstring: The pydantic model config.
  - signature: 'role: str'
    docstring: The role that created this audio data, typically "user" or "model".
  - signature: 'data: google.genai.types.Blob'
    docstring: The audio data chunk.
  - signature: 'timestamp: float'
    docstring: Timestamp when the audio chunk was received.
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 153
  id: google.adk.agents.langgraph_agent
  name: langgraph_agent
  file_path: src/google/adk/agents/langgraph_agent.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 154
  id: google.adk.agents.langgraph_agent.LangGraphAgent
  name: LangGraphAgent
  file_path: src/google/adk/agents/langgraph_agent.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Currently a concept implementation, supports single and multi-turn.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, name: str, description: str = '''', sub_agents: list[google.adk.agents.base_agent.BaseAgent] = list(), before_agent_callback: typing.Optional[google.adk.agents.base_agent.BeforeAgentCallback] = None, after_agent_callback: typing.Optional[google.adk.agents.base_agent.AfterAgentCallback] = None, graph: langgraph.graph.graph.CompiledGraph, instruction: str = ''''):'
  methods:
  - signature: 'def _run_async_impl(self, ctx: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
    docstring: The pydantic model config.
  - signature: 'graph: langgraph.graph.graph.CompiledGraph'
  - signature: 'instruction: str'
  inherited_methods:
    BaseAgent:
    - signature: 'def clone(self: google.adk.agents.base_agent.SelfAgent, update: Mapping[str, Any] | None) -> google.adk.agents.base_agent.SelfAgent:'
      docstring: "Creates a copy of this agent instance.\n\nArgs:\n  update: Optional mapping of new values for the fields of the cloned agent.\n    The keys of the mapping are the names of the fields to be updated, and\n    the values are the new values for those fields.\n    For example: {\"name\": \"cloned_agent\"}\n\nReturns:\n  A new agent instance with identical configuration as the original\n  agent except for the fields specified in the update."
    - signature: 'def run_async(self, parent_context: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
      docstring: "Entry method to run an agent via text-based conversation.\n\nArgs:\n  parent_context: InvocationContext, the invocation context of the parent\n    agent.\n\nYields:\n  Event: the events generated by the agent."
    - signature: 'def run_live(self, parent_context: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
      docstring: "Entry method to run an agent via video/audio-based conversation.\n\nArgs:\n  parent_context: InvocationContext, the invocation context of the parent\n    agent.\n\nYields:\n  Event: the events generated by the agent."
    - signature: 'def _run_async_impl(self, ctx: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
      docstring: "Core logic to run this agent via text-based conversation.\n\nArgs:\n  ctx: InvocationContext, the invocation context for this agent.\n\nYields:\n  Event: the events generated by the agent."
    - signature: 'def root_agent(self) -> google.adk.agents.base_agent.BaseAgent:'
      docstring: Gets the root agent of this agent.
    - signature: 'def find_agent(self, name: str) -> typing.Optional[google.adk.agents.base_agent.BaseAgent]:'
      docstring: "Finds the agent with the given name in this agent and its descendants.\n\nArgs:\n  name: The name of the agent to find.\n\nReturns:\n  The agent with the matching name, or None if no such agent is found."
    - signature: 'def find_sub_agent(self, name: str) -> typing.Optional[google.adk.agents.base_agent.BaseAgent]:'
      docstring: "Finds the agent with the given name in this agent's descendants.\n\nArgs:\n  name: The name of the agent to find.\n\nReturns:\n  The agent with the matching name, or None if no such agent is found."
    - signature: 'def model_post_init(self, __context: typing.Any) -> None:'
    - signature: 'def validate_name(cls, value: str):'
    - signature: 'def validate_sub_agents_unique_names(cls, value: list[google.adk.agents.base_agent.BaseAgent]) -> list[google.adk.agents.base_agent.BaseAgent]:'
      docstring: "Validates that all sub-agents have unique names.\n\nArgs:\n  value: The list of sub-agents to validate.\n\nReturns:\n  The validated list of sub-agents."
    - signature: 'def from_config(cls: typing.Type[google.adk.agents.base_agent.SelfAgent], config: google.adk.agents.base_agent_config.BaseAgentConfig, config_abs_path: str) -> google.adk.agents.base_agent.SelfAgent:'
      docstring: "Creates an agent from a config.\n\nIf sub-classes uses a custom agent config, override `_from_config_kwargs`\nmethod to return an updated kwargs for agent constructor.\n\nArgs:\n  config: The config to create the agent from.\n  config_abs_path: The absolute path to the config file that contains the\n    agent config.\n\nReturns:\n  The created agent."
  inherited_properties:
    BaseAgent:
    - signature: 'model_config: pydantic.ConfigDict'
      docstring: The pydantic model config.
    - signature: 'config_type: typing.ClassVar[type[google.adk.agents.base_agent_config.BaseAgentConfig]]'
      docstring: "The config type for this agent.\n\nSub-classes should override this to specify their own config type.\n\nExample:\n\n```\nclass MyAgentConfig(BaseAgentConfig):\n  my_field: str = ''\n\nclass MyAgent(BaseAgent):\n  config_type: ClassVar[type[BaseAgentConfig]] = MyAgentConfig\n```"
    - signature: 'name: str'
      docstring: 'The agent''s name.


        Agent name must be a Python identifier and unique within the agent tree.

        Agent name cannot be "user", since it''s reserved for end-user''s input.'
    - signature: 'description: str'
      docstring: 'Description about the agent''s capability.


        The model uses this to determine whether to delegate control to the agent.

        One-line description is enough and preferred.'
    - signature: 'parent_agent: typing.Optional[google.adk.agents.base_agent.BaseAgent]'
      docstring: 'The parent agent of this agent.


        Note that an agent can ONLY be added as sub-agent once.


        If you want to add one agent twice as sub-agent, consider to create two agent

        instances with identical config, but with different name and add them to the

        agent tree.'
    - signature: 'sub_agents: list[google.adk.agents.base_agent.BaseAgent]'
      docstring: The sub-agents of this agent.
    - signature: 'before_agent_callback: typing.Optional[google.adk.agents.base_agent.BeforeAgentCallback]'
      docstring: "Callback or list of callbacks to be invoked before the agent run.\n\nWhen a list of callbacks is provided, the callbacks will be called in the\norder they are listed until a callback does not return None.\n\nArgs:\n  callback_context: MUST be named 'callback_context' (enforced).\n\nReturns:\n  Optional[types.Content]: The content to return to the user.\n    When the content is present, the agent run will be skipped and the\n    provided content will be returned to user."
    - signature: 'after_agent_callback: typing.Optional[google.adk.agents.base_agent.AfterAgentCallback]'
      docstring: "Callback or list of callbacks to be invoked after the agent run.\n\nWhen a list of callbacks is provided, the callbacks will be called in the\norder they are listed until a callback does not return None.\n\nArgs:\n  callback_context: MUST be named 'callback_context' (enforced).\n\nReturns:\n  Optional[types.Content]: The content to return to the user.\n    When the content is present, an additional event with the provided content\n    will be appended to event history as an additional agent response."
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 155
  id: google.adk.agents.langgraph_agent.LangGraphAgent._run_async_impl
  name: _run_async_impl
  file_path: src/google/adk/agents/langgraph_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def _run_async_impl(self, ctx: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
- rank: 156
  id: google.adk.agents.live_request_queue
  name: live_request_queue
  file_path: src/google/adk/agents/live_request_queue.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 157
  id: google.adk.agents.live_request_queue.LiveRequest
  name: LiveRequest
  file_path: src/google/adk/agents/live_request_queue.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Request send to live agents.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, content: typing.Optional[google.genai.types.Content] = None, blob: typing.Optional[google.genai.types.Blob] = None, activity_start: typing.Optional[google.genai.types.ActivityStart] = None, activity_end: typing.Optional[google.genai.types.ActivityEnd] = None, close: bool = False):'
  aliases:
  - google.adk.agents.LiveRequest
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
    docstring: The pydantic model config.
  - signature: 'content: typing.Optional[google.genai.types.Content]'
    docstring: 'If set, send the content to the model in turn-by-turn mode.


      When multiple fields are set, they are processed by priority (highest first):

      activity_start > activity_end > blob > content.'
  - signature: 'blob: typing.Optional[google.genai.types.Blob]'
    docstring: 'If set, send the blob to the model in realtime mode.


      When multiple fields are set, they are processed by priority (highest first):

      activity_start > activity_end > blob > content.'
  - signature: 'activity_start: typing.Optional[google.genai.types.ActivityStart]'
    docstring: 'If set, signal the start of user activity to the model.


      When multiple fields are set, they are processed by priority (highest first):

      activity_start > activity_end > blob > content.'
  - signature: 'activity_end: typing.Optional[google.genai.types.ActivityEnd]'
    docstring: 'If set, signal the end of user activity to the model.


      When multiple fields are set, they are processed by priority (highest first):

      activity_start > activity_end > blob > content.'
  - signature: 'close: bool'
    docstring: If set, close the queue. queue.shutdown() is only supported in Python 3.13+.
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 158
  id: google.adk.agents.live_request_queue.LiveRequestQueue
  name: LiveRequestQueue
  file_path: src/google/adk/agents/live_request_queue.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Queue used to send LiveRequest in a live(bidirectional streaming) way.
  constructor_signature: 'def __init__(self):'
  aliases:
  - google.adk.agents.LiveRequestQueue
  methods:
  - signature: 'def close(self):'
  - signature: 'def send_content(self, content: google.genai.types.Content):'
  - signature: 'def send_realtime(self, blob: google.genai.types.Blob):'
  - signature: 'def send_activity_start(self):'
    docstring: Sends an activity start signal to mark the beginning of user input.
  - signature: 'def send_activity_end(self):'
    docstring: Sends an activity end signal to mark the end of user input.
  - signature: 'def send(self, req: google.adk.agents.live_request_queue.LiveRequest):'
  - signature: 'def get(self) -> google.adk.agents.live_request_queue.LiveRequest:'
- rank: 159
  id: google.adk.agents.llm_agent
  name: llm_agent
  file_path: src/google/adk/agents/llm_agent.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '_SingleBeforeModelCallback: typing_extensions.TypeAlias'
  - signature: 'BeforeModelCallback: typing_extensions.TypeAlias'
  - signature: '_SingleAfterModelCallback: typing_extensions.TypeAlias'
  - signature: 'AfterModelCallback: typing_extensions.TypeAlias'
  - signature: '_SingleOnModelErrorCallback: typing_extensions.TypeAlias'
  - signature: 'OnModelErrorCallback: typing_extensions.TypeAlias'
  - signature: '_SingleBeforeToolCallback: typing_extensions.TypeAlias'
  - signature: 'BeforeToolCallback: typing_extensions.TypeAlias'
  - signature: '_SingleAfterToolCallback: typing_extensions.TypeAlias'
  - signature: 'AfterToolCallback: typing_extensions.TypeAlias'
  - signature: '_SingleOnToolErrorCallback: typing_extensions.TypeAlias'
  - signature: 'OnToolErrorCallback: typing_extensions.TypeAlias'
  - signature: 'InstructionProvider: typing_extensions.TypeAlias'
  - signature: 'ToolUnion: typing_extensions.TypeAlias'
  - signature: 'Agent: typing_extensions.TypeAlias'
- rank: 160
  id: google.adk.agents.llm_agent.LlmAgent._run_async_impl
  name: _run_async_impl
  file_path: src/google/adk/agents/llm_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def _run_async_impl(self, ctx: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
- rank: 161
  id: google.adk.agents.llm_agent.LlmAgent.canonical_after_model_callbacks
  name: canonical_after_model_callbacks
  file_path: src/google/adk/agents/llm_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'The resolved self.after_model_callback field as a list of _SingleAfterModelCallback.


    This method is only for use by Agent Development Kit.'
  signature: 'def canonical_after_model_callbacks(self) -> list[google.adk.agents.llm_agent._SingleAfterModelCallback]:'
- rank: 162
  id: google.adk.agents.llm_agent.LlmAgent.canonical_after_tool_callbacks
  name: canonical_after_tool_callbacks
  file_path: src/google/adk/agents/llm_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'The resolved self.after_tool_callback field as a list of AfterToolCallback.


    This method is only for use by Agent Development Kit.'
  signature: 'def canonical_after_tool_callbacks(self) -> list[google.adk.agents.llm_agent.AfterToolCallback]:'
- rank: 163
  id: google.adk.agents.llm_agent.LlmAgent.canonical_before_model_callbacks
  name: canonical_before_model_callbacks
  file_path: src/google/adk/agents/llm_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'The resolved self.before_model_callback field as a list of _SingleBeforeModelCallback.


    This method is only for use by Agent Development Kit.'
  signature: 'def canonical_before_model_callbacks(self) -> list[google.adk.agents.llm_agent._SingleBeforeModelCallback]:'
- rank: 164
  id: google.adk.agents.llm_agent.LlmAgent.canonical_before_tool_callbacks
  name: canonical_before_tool_callbacks
  file_path: src/google/adk/agents/llm_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'The resolved self.before_tool_callback field as a list of BeforeToolCallback.


    This method is only for use by Agent Development Kit.'
  signature: 'def canonical_before_tool_callbacks(self) -> list[google.adk.agents.llm_agent.BeforeToolCallback]:'
- rank: 165
  id: google.adk.agents.llm_agent.LlmAgent.canonical_global_instruction
  name: canonical_global_instruction
  file_path: src/google/adk/agents/llm_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "The resolved self.instruction field to construct global instruction.\n\nThis method is only for use by Agent Development Kit.\n\nArgs:\n  ctx: The context to retrieve the session state.\n\nReturns:\n  A tuple of (instruction, bypass_state_injection).\n  instruction: The resolved self.global_instruction field.\n  bypass_state_injection: Whether the instruction is based on\n  InstructionProvider."
  signature: 'def canonical_global_instruction(self, ctx: google.adk.agents.readonly_context.ReadonlyContext) -> tuple[str, bool]:'
- rank: 166
  id: google.adk.agents.llm_agent.LlmAgent.canonical_instruction
  name: canonical_instruction
  file_path: src/google/adk/agents/llm_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "The resolved self.instruction field to construct instruction for this agent.\n\nThis method is only for use by Agent Development Kit.\n\nArgs:\n  ctx: The context to retrieve the session state.\n\nReturns:\n  A tuple of (instruction, bypass_state_injection).\n  instruction: The resolved self.instruction field.\n  bypass_state_injection: Whether the instruction is based on\n  InstructionProvider."
  signature: 'def canonical_instruction(self, ctx: google.adk.agents.readonly_context.ReadonlyContext) -> tuple[str, bool]:'
- rank: 167
  id: google.adk.agents.llm_agent.LlmAgent.canonical_model
  name: canonical_model
  file_path: src/google/adk/agents/llm_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'The resolved self.model field as BaseLlm.


    This method is only for use by Agent Development Kit.'
  signature: 'def canonical_model(self) -> google.adk.models.base_llm.BaseLlm:'
- rank: 168
  id: google.adk.agents.llm_agent.LlmAgent.canonical_on_model_error_callbacks
  name: canonical_on_model_error_callbacks
  file_path: src/google/adk/agents/llm_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'The resolved self.on_model_error_callback field as a list of _SingleOnModelErrorCallback.


    This method is only for use by Agent Development Kit.'
  signature: 'def canonical_on_model_error_callbacks(self) -> list[google.adk.agents.llm_agent._SingleOnModelErrorCallback]:'
- rank: 169
  id: google.adk.agents.llm_agent.LlmAgent.canonical_on_tool_error_callbacks
  name: canonical_on_tool_error_callbacks
  file_path: src/google/adk/agents/llm_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'The resolved self.on_tool_error_callback field as a list of OnToolErrorCallback.


    This method is only for use by Agent Development Kit.'
  signature: 'def canonical_on_tool_error_callbacks(self) -> list[google.adk.agents.llm_agent.OnToolErrorCallback]:'
- rank: 170
  id: google.adk.agents.llm_agent.LlmAgent.canonical_tools
  name: canonical_tools
  file_path: src/google/adk/agents/llm_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'The resolved self.tools field as a list of BaseTool based on the context.


    This method is only for use by Agent Development Kit.'
  signature: 'def canonical_tools(self, ctx: google.adk.agents.readonly_context.ReadonlyContext) -> list[google.adk.tools.base_tool.BaseTool]:'
- rank: 171
  id: google.adk.agents.llm_agent.LlmAgent.model_post_init
  name: model_post_init
  file_path: src/google/adk/agents/llm_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Provides a warning if multiple thinking configurations are found.
  signature: 'def model_post_init(self, __context: typing.Any) -> None:'
- rank: 172
  id: google.adk.agents.llm_agent.LlmAgent.set_default_model
  name: set_default_model
  file_path: src/google/adk/agents/llm_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Overrides the default model used when an agent has no model set.
  signature: 'def set_default_model(cls, model: typing.Union[str, google.adk.models.base_llm.BaseLlm]) -> None:'
- rank: 173
  id: google.adk.agents.llm_agent.LlmAgent.validate_generate_content_config
  name: validate_generate_content_config
  file_path: src/google/adk/agents/llm_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def validate_generate_content_config(cls, generate_content_config: typing.Optional[google.genai.types.GenerateContentConfig]) -> google.genai.types.GenerateContentConfig:'
- rank: 174
  id: google.adk.agents.llm_agent_config
  name: llm_agent_config
  file_path: src/google/adk/agents/llm_agent_config.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 175
  id: google.adk.agents.llm_agent_config.LlmAgentConfig
  name: LlmAgentConfig
  file_path: src/google/adk/agents/llm_agent_config.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'The config for the YAML schema of a LlmAgent.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, agent_class: typing.Union[typing.Literal[BaseAgent], str] = ''BaseAgent'', name: str, description: str = '''', sub_agents: typing.Optional[typing.List[google.adk.agents.common_configs.AgentRefConfig]] = None, before_agent_callbacks: typing.Optional[typing.List[google.adk.agents.common_configs.CodeConfig]] = None, after_agent_callbacks: typing.Optional[typing.List[google.adk.agents.common_configs.CodeConfig]] = None, model: typing.Optional[str] = None, model_code: typing.Optional[google.adk.agents.common_configs.CodeConfig] = None, instruction: str, static_instruction: typing.Optional[google.genai.types.ContentUnion] = None, disallow_transfer_to_parent: typing.Optional[bool] = None, disallow_transfer_to_peers: typing.Optional[bool] = None, input_schema: typing.Optional[google.adk.agents.common_configs.CodeConfig] = None, output_schema: typing.Optional[google.adk.agents.common_configs.CodeConfig] = None, output_key: typing.Optional[str] = None,
    include_contents: typing.Literal[default, none] = ''default'', tools: typing.Optional[list[google.adk.tools.tool_configs.ToolConfig]] = None, before_model_callbacks: typing.Optional[typing.List[google.adk.agents.common_configs.CodeConfig]] = None, after_model_callbacks: typing.Optional[typing.List[google.adk.agents.common_configs.CodeConfig]] = None, before_tool_callbacks: typing.Optional[typing.List[google.adk.agents.common_configs.CodeConfig]] = None, after_tool_callbacks: typing.Optional[typing.List[google.adk.agents.common_configs.CodeConfig]] = None, generate_content_config: typing.Optional[google.genai.types.GenerateContentConfig] = None):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'agent_class: str'
  - signature: 'model: typing.Optional[str]'
  - signature: 'model_code: typing.Optional[google.adk.agents.common_configs.CodeConfig]'
  - signature: 'instruction: str'
  - signature: 'static_instruction: typing.Optional[google.genai.types.ContentUnion]'
  - signature: 'disallow_transfer_to_parent: typing.Optional[bool]'
  - signature: 'disallow_transfer_to_peers: typing.Optional[bool]'
  - signature: 'input_schema: typing.Optional[google.adk.agents.common_configs.CodeConfig]'
  - signature: 'output_schema: typing.Optional[google.adk.agents.common_configs.CodeConfig]'
  - signature: 'output_key: typing.Optional[str]'
  - signature: 'include_contents: typing.Literal[default, none]'
  - signature: 'tools: typing.Optional[list[google.adk.tools.tool_configs.ToolConfig]]'
  - signature: 'before_model_callbacks: typing.Optional[typing.List[google.adk.agents.common_configs.CodeConfig]]'
  - signature: 'after_model_callbacks: typing.Optional[typing.List[google.adk.agents.common_configs.CodeConfig]]'
  - signature: 'before_tool_callbacks: typing.Optional[typing.List[google.adk.agents.common_configs.CodeConfig]]'
  - signature: 'after_tool_callbacks: typing.Optional[typing.List[google.adk.agents.common_configs.CodeConfig]]'
  - signature: 'generate_content_config: typing.Optional[google.genai.types.GenerateContentConfig]'
  inherited_properties:
    BaseAgentConfig:
    - signature: 'model_config: pydantic.ConfigDict'
    - signature: 'agent_class: typing.Union[typing.Literal[BaseAgent], str]'
    - signature: 'name: str'
    - signature: 'description: str'
    - signature: 'sub_agents: typing.Optional[typing.List[google.adk.agents.common_configs.AgentRefConfig]]'
    - signature: 'before_agent_callbacks: typing.Optional[typing.List[google.adk.agents.common_configs.CodeConfig]]'
    - signature: 'after_agent_callbacks: typing.Optional[typing.List[google.adk.agents.common_configs.CodeConfig]]'
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 176
  id: google.adk.agents.loop_agent
  name: loop_agent
  file_path: src/google/adk/agents/loop_agent.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Loop agent implementation.
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 177
  id: google.adk.agents.loop_agent.LoopAgent._run_async_impl
  name: _run_async_impl
  file_path: src/google/adk/agents/loop_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def _run_async_impl(self, ctx: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
- rank: 178
  id: google.adk.agents.loop_agent.LoopAgentState
  name: LoopAgentState
  file_path: src/google/adk/agents/loop_agent.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'State for LoopAgent.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, current_sub_agent: str = '''', times_looped: int = 0):'
  properties:
  - signature: 'current_sub_agent: str'
    docstring: The name of the current sub-agent to run in the loop.
  - signature: 'times_looped: int'
    docstring: The number of times the loop agent has looped.
  inherited_properties:
    BaseAgentState:
    - signature: 'model_config: pydantic.ConfigDict'
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 179
  id: google.adk.agents.loop_agent_config
  name: loop_agent_config
  file_path: src/google/adk/agents/loop_agent_config.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Loop agent implementation.
- rank: 180
  id: google.adk.agents.loop_agent_config.LoopAgentConfig
  name: LoopAgentConfig
  file_path: src/google/adk/agents/loop_agent_config.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'The config for the YAML schema of a LoopAgent.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, agent_class: typing.Union[typing.Literal[BaseAgent], str] = ''BaseAgent'', name: str, description: str = '''', sub_agents: typing.Optional[typing.List[google.adk.agents.common_configs.AgentRefConfig]] = None, before_agent_callbacks: typing.Optional[typing.List[google.adk.agents.common_configs.CodeConfig]] = None, after_agent_callbacks: typing.Optional[typing.List[google.adk.agents.common_configs.CodeConfig]] = None, max_iterations: typing.Optional[int] = None):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'agent_class: str'
  - signature: 'max_iterations: typing.Optional[int]'
  inherited_properties:
    BaseAgentConfig:
    - signature: 'model_config: pydantic.ConfigDict'
    - signature: 'agent_class: typing.Union[typing.Literal[BaseAgent], str]'
    - signature: 'name: str'
    - signature: 'description: str'
    - signature: 'sub_agents: typing.Optional[typing.List[google.adk.agents.common_configs.AgentRefConfig]]'
    - signature: 'before_agent_callbacks: typing.Optional[typing.List[google.adk.agents.common_configs.CodeConfig]]'
    - signature: 'after_agent_callbacks: typing.Optional[typing.List[google.adk.agents.common_configs.CodeConfig]]'
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 181
  id: google.adk.agents.mcp_instruction_provider
  name: mcp_instruction_provider
  file_path: src/google/adk/agents/mcp_instruction_provider.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Provides instructions to an agent by fetching prompts from an MCP server.
- rank: 182
  id: google.adk.agents.mcp_instruction_provider.McpInstructionProvider
  name: McpInstructionProvider
  file_path: src/google/adk/agents/mcp_instruction_provider.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Fetches agent instructions from an MCP server.


    [Note: Inherited members from InstructionProvider are omitted.]'
  constructor_signature: 'def __init__(self, connection_params: typing.Any, prompt_name: str, errlog: typing.TextIO):'
  aliases:
  - google.adk.agents.McpInstructionProvider
  omitted_inherited_members_from:
  - InstructionProvider
- rank: 183
  id: google.adk.agents.mcp_instruction_provider.McpInstructionProvider.__init__
  name: __init__
  file_path: src/google/adk/agents/mcp_instruction_provider.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the McpInstructionProvider.\n\nArgs:\n    connection_params: Parameters for connecting to the MCP server.\n    prompt_name: The name of the MCP Prompt to fetch.\n    errlog: TextIO stream for error logging."
  signature: 'def __init__(self, connection_params: typing.Any, prompt_name: str, errlog: typing.TextIO):'
- rank: 184
  id: google.adk.agents.parallel_agent
  name: parallel_agent
  file_path: src/google/adk/agents/parallel_agent.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Parallel agent implementation.
- rank: 185
  id: google.adk.agents.parallel_agent.ParallelAgent._run_async_impl
  name: _run_async_impl
  file_path: src/google/adk/agents/parallel_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def _run_async_impl(self, ctx: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
- rank: 186
  id: google.adk.agents.parallel_agent_config
  name: parallel_agent_config
  file_path: src/google/adk/agents/parallel_agent_config.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Parallel agent implementation.
- rank: 187
  id: google.adk.agents.parallel_agent_config.ParallelAgentConfig
  name: ParallelAgentConfig
  file_path: src/google/adk/agents/parallel_agent_config.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'The config for the YAML schema of a ParallelAgent.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, agent_class: typing.Union[typing.Literal[BaseAgent], str] = ''BaseAgent'', name: str, description: str = '''', sub_agents: typing.Optional[typing.List[google.adk.agents.common_configs.AgentRefConfig]] = None, before_agent_callbacks: typing.Optional[typing.List[google.adk.agents.common_configs.CodeConfig]] = None, after_agent_callbacks: typing.Optional[typing.List[google.adk.agents.common_configs.CodeConfig]] = None):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'agent_class: str'
  inherited_properties:
    BaseAgentConfig:
    - signature: 'model_config: pydantic.ConfigDict'
    - signature: 'agent_class: typing.Union[typing.Literal[BaseAgent], str]'
    - signature: 'name: str'
    - signature: 'description: str'
    - signature: 'sub_agents: typing.Optional[typing.List[google.adk.agents.common_configs.AgentRefConfig]]'
    - signature: 'before_agent_callbacks: typing.Optional[typing.List[google.adk.agents.common_configs.CodeConfig]]'
    - signature: 'after_agent_callbacks: typing.Optional[typing.List[google.adk.agents.common_configs.CodeConfig]]'
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 188
  id: google.adk.agents.readonly_context
  name: readonly_context
  file_path: src/google/adk/agents/readonly_context.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 189
  id: google.adk.agents.readonly_context.ReadonlyContext
  name: ReadonlyContext
  file_path: src/google/adk/agents/readonly_context.py
  type: CLASS
  group: Orphan
  usage_score: 0
  constructor_signature: 'def __init__(self, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> None:'
  methods:
  - signature: 'def user_content(self) -> typing.Optional[google.genai.types.Content]:'
    docstring: The user content that started this invocation. READONLY field.
  - signature: 'def invocation_id(self) -> str:'
    docstring: The current invocation id.
  - signature: 'def agent_name(self) -> str:'
    docstring: The name of the agent that is currently running.
  - signature: 'def state(self) -> types.MappingProxyType[str, typing.Any]:'
    docstring: The state of the current session. READONLY field.
  - signature: 'def session(self) -> google.adk.sessions.session.Session:'
    docstring: The current session for this invocation.
  - signature: 'def user_id(self) -> str:'
    docstring: The id of the user. READONLY field.
  - signature: 'def run_config(self) -> typing.Optional[google.adk.agents.run_config.RunConfig]:'
    docstring: The run config of the current invocation. READONLY field.
- rank: 190
  id: google.adk.agents.readonly_context.ReadonlyContext.__init__
  name: __init__
  file_path: src/google/adk/agents/readonly_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> None:'
- rank: 191
  id: google.adk.agents.remote_a2a_agent
  name: remote_a2a_agent
  file_path: src/google/adk/agents/remote_a2a_agent.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'AGENT_CARD_WELL_KNOWN_PATH: str'
  - signature: '__all__: Any'
  - signature: 'A2A_METADATA_PREFIX: str'
  - signature: 'DEFAULT_TIMEOUT: float'
  - signature: 'logger: logging.getLogger'
- rank: 192
  id: google.adk.agents.remote_a2a_agent.A2AClientError
  name: A2AClientError
  file_path: src/google/adk/agents/remote_a2a_agent.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Raised when A2A client operations fail.


    [Note: Inherited members from Exception are omitted.]'
  omitted_inherited_members_from:
  - Exception
- rank: 193
  id: google.adk.agents.remote_a2a_agent.AgentCardResolutionError
  name: AgentCardResolutionError
  file_path: src/google/adk/agents/remote_a2a_agent.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Raised when agent card resolution fails.


    [Note: Inherited members from Exception are omitted.]'
  omitted_inherited_members_from:
  - Exception
- rank: 194
  id: google.adk.agents.remote_a2a_agent.RemoteA2aAgent.__init__
  name: __init__
  file_path: src/google/adk/agents/remote_a2a_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initialize RemoteA2aAgent.\n\nArgs:\n  name: Agent name (must be unique identifier)\n  agent_card: AgentCard object, URL string, or file path string\n  description: Agent description (autopopulated from card if empty)\n  httpx_client: Optional shared HTTP client (will create own if not\n    provided) [deprecated] Use a2a_client_factory instead.\n  timeout: HTTP timeout in seconds\n  a2a_client_factory: Optional A2AClientFactory object (will create own if\n    not provided)\n  a2a_request_meta_provider: Optional callable that takes InvocationContext\n    and A2AMessage and returns a metadata object to attach to the A2A\n    request.\n  full_history_when_stateless: If True, stateless agents (those that do not\n    return Tasks or context IDs) will receive all session events on every\n    request. If False, the default behavior of sending only events since the\n    last reply from the agent will be used.\n  **kwargs: Additional arguments passed to BaseAgent\n\nRaises:\n  ValueError:\
    \ If name is invalid or agent_card is None\n  TypeError: If agent_card is not a supported type"
  signature: 'def __init__(self, name: str, agent_card: typing.Union[a2a.types.AgentCard, str], *, description: str='''', httpx_client: typing.Optional[httpx.AsyncClient]=None, timeout: float=DEFAULT_TIMEOUT, genai_part_converter: google.adk.a2a.converters.part_converter.GenAIPartToA2APartConverter=convert_genai_part_to_a2a_part, a2a_part_converter: google.adk.a2a.converters.part_converter.A2APartToGenAIPartConverter=convert_a2a_part_to_genai_part, a2a_client_factory: typing.Optional[a2a.client.client_factory.ClientFactory]=None, a2a_request_meta_provider: typing.Optional[typing.Callable[[InvocationContext, A2AMessage], dict[str, typing.Any]]]=None, full_history_when_stateless: bool=False) -> None:'
- rank: 195
  id: google.adk.agents.remote_a2a_agent.RemoteA2aAgent._run_async_impl
  name: _run_async_impl
  file_path: src/google/adk/agents/remote_a2a_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Core implementation for async agent execution.
  signature: 'def _run_async_impl(self, ctx: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
- rank: 196
  id: google.adk.agents.remote_a2a_agent.RemoteA2aAgent.cleanup
  name: cleanup
  file_path: src/google/adk/agents/remote_a2a_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Clean up resources, especially the HTTP client if owned by this agent.
  signature: 'def cleanup(self) -> None:'
- rank: 197
  id: google.adk.agents.run_config
  name: run_config
  file_path: src/google/adk/agents/run_config.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 198
  id: google.adk.agents.run_config.RunConfig.check_for_deprecated_save_live_audio
  name: check_for_deprecated_save_live_audio
  file_path: src/google/adk/agents/run_config.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: If save_live_audio is passed, use it to set save_live_blob.
  signature: 'def check_for_deprecated_save_live_audio(cls, data: typing.Any) -> typing.Any:'
- rank: 199
  id: google.adk.agents.run_config.RunConfig.validate_max_llm_calls
  name: validate_max_llm_calls
  file_path: src/google/adk/agents/run_config.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def validate_max_llm_calls(cls, value: int) -> int:'
- rank: 200
  id: google.adk.agents.run_config.StreamingMode
  name: StreamingMode
  file_path: src/google/adk/agents/run_config.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Streaming modes for agent execution.


    This enum defines different streaming behaviors for how the agent returns

    events as model response.


    [Note: Inherited members from Enum are omitted.]'
  properties:
  - signature: 'NONE: NoneType'
    docstring: "Non-streaming mode (default).\n\nIn this mode:\n- The runner returns one single content in a turn (one user / model\n  interaction).\n- No partial/intermediate events are produced\n- Suitable for: CLI tools, batch processing, synchronous workflows\n\nExample:\n  ```python\n  config = RunConfig(streaming_mode=StreamingMode.NONE)\n  async for event in runner.run_async(..., run_config=config):\n    # event.partial is always False\n    # Only final responses are yielded\n    if event.content:\n      print(event.content.parts[0].text)\n  ```"
  - signature: 'SSE: str'
    docstring: "Server-Sent Events (SSE) streaming mode.\n\nIn this mode:\n- The runner yields events progressively as the LLM generates responses\n- Both partial events (streaming chunks) and aggregated events are yielded\n- Suitable for: real-time display with typewriter effects in Web UIs, chat\n  applications, interactive displays\n\nEvent Types in SSE Mode:\n- **Partial text events** (event.partial=True, contains text):\n  Streaming text chunks for typewriter effect. These should typically be\n  displayed to users in real-time.\n\n- **Partial function call events** (event.partial=True, contains function_call):\n  Internal streaming chunks used to progressively build function call\n  arguments. These are typically NOT displayed to end users.\n\n- **Aggregated events** (event.partial=False):\n  The complete, aggregated response after all streaming chunks. Contains\n  the full text or complete function call with all arguments.\n\nImportant Considerations:\n1. **Duplicate text issue**:\
      \ With Progressive SSE Streaming enabled\n   (default), you will receive both partial text chunks AND a final\n   aggregated text event. To avoid displaying text twice:\n   - Option A: Only display partial text events, skip final text events\n   - Option B: Only display final events, skip all partial events\n   - Option C: Track what's been displayed and skip duplicates\n\n2. **Event filtering**: Applications should filter events based on their\n   needs. Common patterns:\n\n   # Pattern 1: Display only partial text + final function calls\n   async for event in runner.run_async(...):\n     if event.partial and event.content and event.content.parts:\n       # Check if it's text (not function call)\n       if any(part.text for part in event.content.parts):\n         if not any(part.function_call for part in event.content.parts):\n           # Display partial text for typewriter effect\n           text = ''.join(p.text or '' for p in event.content.parts)\n           print(text, end='',\
      \ flush=True)\n     elif not event.partial and event.get_function_calls():\n       # Display final function calls\n       for fc in event.get_function_calls():\n         print(f\"Calling {fc.name}({fc.args})\")\n\n   # Pattern 2: Display only final events (no streaming effect)\n   async for event in runner.run_async(...):\n     if not event.partial:\n       # Only process final responses\n       if event.content:\n         text = ''.join(p.text or '' for p in event.content.parts)\n         print(text)\n\n3. **Progressive SSE Streaming feature**: Controlled by the\n   ADK_ENABLE_PROGRESSIVE_SSE_STREAMING environment variable (default: ON).\n   - When ON: Preserves original part ordering, supports function call\n     argument streaming, produces partial events + final aggregated event\n   - When OFF: Simple text accumulation, may lose some information\n\nExample:\n  ```python\n  config = RunConfig(streaming_mode=StreamingMode.SSE)\n  displayed_text = \"\"\n\n  async for event in runner.run_async(...,\
      \ run_config=config):\n    if event.partial:\n      # Partial streaming event\n      if event.content and event.content.parts:\n        # Check if this is text (not a function call)\n        has_text = any(part.text for part in event.content.parts)\n        has_fc = any(part.function_call for part in event.content.parts)\n\n        if has_text and not has_fc:\n          # Display partial text chunks for typewriter effect\n          text = ''.join(p.text or '' for p in event.content.parts)\n          print(text, end='', flush=True)\n          displayed_text += text\n    else:\n      # Final event - check if we already displayed this content\n      if event.content:\n        final_text = ''.join(p.text or '' for p in event.content.parts)\n        if final_text != displayed_text:\n          # New content not yet displayed\n          print(final_text)\n  ```\n\nSee Also:\n- Event.is_final_response() for identifying final responses"
  - signature: 'BIDI: str'
    docstring: 'Bidirectional streaming mode.


      So far this mode is not used in the standard execution path. The actual

      bidirectional streaming behavior via runner.run_live() uses a completely

      different code path that doesn''t rely on streaming_mode.


      For bidirectional streaming, use runner.run_live() instead of run_async().'
  omitted_inherited_members_from:
  - Enum
- rank: 201
  id: google.adk.agents.run_config.ToolThreadPoolConfig
  name: ToolThreadPoolConfig
  file_path: src/google/adk/agents/run_config.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "Configuration for the tool thread pool executor.\n\nAttributes:\n  max_workers: Maximum number of worker threads in the pool. Defaults to 4.\n\n[Note: Inherited members from pydantic.BaseModel are omitted.]"
  constructor_signature: 'def __init__(self, *, max_workers: int = 4):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'max_workers: int'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 202
  id: google.adk.agents.sequential_agent
  name: sequential_agent
  file_path: src/google/adk/agents/sequential_agent.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Sequential agent implementation.
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 203
  id: google.adk.agents.sequential_agent.SequentialAgent._run_async_impl
  name: _run_async_impl
  file_path: src/google/adk/agents/sequential_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def _run_async_impl(self, ctx: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
- rank: 204
  id: google.adk.agents.sequential_agent.SequentialAgentState
  name: SequentialAgentState
  file_path: src/google/adk/agents/sequential_agent.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'State for SequentialAgent.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, current_sub_agent: str = ''''):'
  properties:
  - signature: 'current_sub_agent: str'
    docstring: The name of the current sub-agent to run.
  inherited_properties:
    BaseAgentState:
    - signature: 'model_config: pydantic.ConfigDict'
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 205
  id: google.adk.agents.sequential_agent_config
  name: sequential_agent_config
  file_path: src/google/adk/agents/sequential_agent_config.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Config definition for SequentialAgent.
- rank: 206
  id: google.adk.agents.sequential_agent_config.SequentialAgentConfig
  name: SequentialAgentConfig
  file_path: src/google/adk/agents/sequential_agent_config.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'The config for the YAML schema of a SequentialAgent.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, agent_class: typing.Union[typing.Literal[BaseAgent], str] = ''BaseAgent'', name: str, description: str = '''', sub_agents: typing.Optional[typing.List[google.adk.agents.common_configs.AgentRefConfig]] = None, before_agent_callbacks: typing.Optional[typing.List[google.adk.agents.common_configs.CodeConfig]] = None, after_agent_callbacks: typing.Optional[typing.List[google.adk.agents.common_configs.CodeConfig]] = None):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'agent_class: str'
  inherited_properties:
    BaseAgentConfig:
    - signature: 'model_config: pydantic.ConfigDict'
    - signature: 'agent_class: typing.Union[typing.Literal[BaseAgent], str]'
    - signature: 'name: str'
    - signature: 'description: str'
    - signature: 'sub_agents: typing.Optional[typing.List[google.adk.agents.common_configs.AgentRefConfig]]'
    - signature: 'before_agent_callbacks: typing.Optional[typing.List[google.adk.agents.common_configs.CodeConfig]]'
    - signature: 'after_agent_callbacks: typing.Optional[typing.List[google.adk.agents.common_configs.CodeConfig]]'
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 207
  id: google.adk.agents.transcription_entry
  name: transcription_entry
  file_path: src/google/adk/agents/transcription_entry.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 208
  id: google.adk.agents.transcription_entry.TranscriptionEntry
  name: TranscriptionEntry
  file_path: src/google/adk/agents/transcription_entry.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Store the data that can be used for transcription.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, role: typing.Optional[str] = None, data: typing.Union[google.genai.types.Blob, google.genai.types.Content]):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
    docstring: The pydantic model config.
  - signature: 'role: typing.Optional[str]'
    docstring: "The role that created this data, typically \"user\" or \"model\". For function \ncall, this is None."
  - signature: 'data: typing.Union[google.genai.types.Blob, google.genai.types.Content]'
    docstring: The data that can be used for transcription
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 209
  id: google.adk.apps
  name: apps
  file_path: src/google/adk/apps/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: '__all__: Any'
- rank: 210
  id: google.adk.apps.app
  name: app
  file_path: src/google/adk/apps/app.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def validate_app_name(name: str) -> None:'
    docstring: Ensures the provided application name is safe and intuitive.
- rank: 211
  id: google.adk.apps.app.EventsCompactionConfig
  name: EventsCompactionConfig
  file_path: src/google/adk/apps/app.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'The config of event compaction for an application.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, summarizer: typing.Optional[google.adk.apps.base_events_summarizer.BaseEventsSummarizer] = None, compaction_interval: int, overlap_size: int):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'summarizer: typing.Optional[google.adk.apps.base_events_summarizer.BaseEventsSummarizer]'
    docstring: The event summarizer to use for compaction.
  - signature: 'compaction_interval: int'
    docstring: 'The number of *new* user-initiated invocations that, once

      fully represented in the session''s events, will trigger a compaction.'
  - signature: 'overlap_size: int'
    docstring: 'The number of preceding invocations to include from the

      end of the last compacted range. This creates an overlap between consecutive

      compacted summaries, maintaining context.'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 212
  id: google.adk.apps.app.ResumabilityConfig
  name: ResumabilityConfig
  file_path: src/google/adk/apps/app.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'The config of the resumability for an application.


    The "resumability" in ADK refers to the ability to:

    1. pause an invocation upon a long-running function call.

    2. resume an invocation from the last event, if it''s paused or failed midway

    through.


    Note: ADK resumes the invocation in a best-effort manner:

    1. Tool call to resume needs to be idempotent because we only guarantee

    an at-least-once behavior once resumed.

    2. Any temporary / in-memory state will be lost upon resumption.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, is_resumable: bool = False):'
  properties:
  - signature: 'is_resumable: bool'
    docstring: 'Whether the app supports agent resumption.

      If enabled, the feature will be enabled for all agents in the app.'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 213
  id: google.adk.apps.app.validate_app_name
  name: validate_app_name
  file_path: src/google/adk/apps/app.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Ensures the provided application name is safe and intuitive.
  signature: 'def validate_app_name(name: str) -> None:'
- rank: 214
  id: google.adk.apps.base_events_summarizer
  name: base_events_summarizer
  file_path: src/google/adk/apps/base_events_summarizer.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 215
  id: google.adk.apps.base_events_summarizer.BaseEventsSummarizer
  name: BaseEventsSummarizer
  file_path: src/google/adk/apps/base_events_summarizer.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Base interface for compacting events.


    [Note: Inherited members from abc.ABC are omitted.]'
  methods:
  - signature: 'def maybe_summarize_events(self, *, events: list[google.adk.events.event.Event]) -> typing.Optional[google.adk.events.event.Event]:'
    docstring: "Compact a list of events into a single event.\n\nIf compaction failed, return None. Otherwise, compact into a content and\nreturn it.\n\nThis method will summarize the events and return a new summary event\nindicating the range of events it summarized.\n\nArgs:\n  events: Events to compact.\n\nReturns:\n  The new compacted event, or None if no compaction happened."
  omitted_inherited_members_from:
  - abc.ABC
- rank: 216
  id: google.adk.apps.base_events_summarizer.BaseEventsSummarizer.maybe_summarize_events
  name: maybe_summarize_events
  file_path: src/google/adk/apps/base_events_summarizer.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Compact a list of events into a single event.\n\nIf compaction failed, return None. Otherwise, compact into a content and\nreturn it.\n\nThis method will summarize the events and return a new summary event\nindicating the range of events it summarized.\n\nArgs:\n  events: Events to compact.\n\nReturns:\n  The new compacted event, or None if no compaction happened."
  signature: 'def maybe_summarize_events(self, *, events: list[google.adk.events.event.Event]) -> typing.Optional[google.adk.events.event.Event]:'
- rank: 217
  id: google.adk.apps.compaction
  name: compaction
  file_path: src/google/adk/apps/compaction.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 218
  id: google.adk.apps.llm_event_summarizer
  name: llm_event_summarizer
  file_path: src/google/adk/apps/llm_event_summarizer.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 219
  id: google.adk.apps.llm_event_summarizer.LlmEventSummarizer
  name: LlmEventSummarizer
  file_path: src/google/adk/apps/llm_event_summarizer.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'An LLM-based event summarizer for sliding window compaction.


    This class is responsible for summarizing a provided list of events into a

    single compacted event. It is designed to be used as part of a sliding window

    compaction process.


    The actual logic for determining *when* to trigger compaction and *which*

    events form the sliding window (based on parameters like

    `compaction_invocation_threshold` and `overlap_size` from

    `EventsCompactionConfig`) is handled by an external component, such as an ADK

    "Runner". This compactor focuses solely on generating a summary of the events

    it receives.


    When `maybe_compact_events` is called with a list of events, this class

    formats the events, generates a summary using an LLM, and returns a new

    `Event` containing the summary within an `EventCompaction`.


    [Note: Inherited members from abc.ABC are omitted.]'
  constructor_signature: 'def __init__(self, llm: google.adk.models.base_llm.BaseLlm, prompt_template: typing.Optional[str]):'
  methods:
  - signature: 'def maybe_summarize_events(self, *, events: list[google.adk.events.event.Event]) -> typing.Optional[google.adk.events.event.Event]:'
    docstring: "Compacts given events and returns the compacted content.\n\nArgs:\n  events: A list of events to compact.\n\nReturns:\n  The new compacted event, or None if no compaction is needed."
  inherited_methods:
    BaseEventsSummarizer:
    - signature: 'def maybe_summarize_events(self, *, events: list[google.adk.events.event.Event]) -> typing.Optional[google.adk.events.event.Event]:'
      docstring: "Compact a list of events into a single event.\n\nIf compaction failed, return None. Otherwise, compact into a content and\nreturn it.\n\nThis method will summarize the events and return a new summary event\nindicating the range of events it summarized.\n\nArgs:\n  events: Events to compact.\n\nReturns:\n  The new compacted event, or None if no compaction happened."
  omitted_inherited_members_from:
  - abc.ABC
- rank: 220
  id: google.adk.apps.llm_event_summarizer.LlmEventSummarizer.__init__
  name: __init__
  file_path: src/google/adk/apps/llm_event_summarizer.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the LlmEventSummarizer.\n\nArgs:\n    llm: The LLM used for summarization.\n    prompt_template: An optional template string for the summarization\n      prompt. If not provided, a default template will be used. The template\n      should contain a '{conversation_history}' placeholder."
  signature: 'def __init__(self, llm: google.adk.models.base_llm.BaseLlm, prompt_template: typing.Optional[str]):'
- rank: 221
  id: google.adk.apps.llm_event_summarizer.LlmEventSummarizer.maybe_summarize_events
  name: maybe_summarize_events
  file_path: src/google/adk/apps/llm_event_summarizer.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Compacts given events and returns the compacted content.\n\nArgs:\n  events: A list of events to compact.\n\nReturns:\n  The new compacted event, or None if no compaction is needed."
  signature: 'def maybe_summarize_events(self, *, events: list[google.adk.events.event.Event]) -> typing.Optional[google.adk.events.event.Event]:'
- rank: 222
  id: google.adk.artifacts
  name: artifacts
  file_path: src/google/adk/artifacts/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: '__all__: Any'
- rank: 223
  id: google.adk.artifacts.artifact_util
  name: artifact_util
  file_path: src/google/adk/artifacts/artifact_util.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Utility functions for handling artifact URIs.
  methods:
  - signature: 'def parse_artifact_uri(uri: str) -> typing.Optional[google.adk.artifacts.artifact_util.ParsedArtifactUri]:'
    docstring: "Parses an artifact URI.\n\nArgs:\n    uri: The artifact URI to parse.\n\nReturns:\n    A ParsedArtifactUri if parsing is successful, None otherwise."
  - signature: 'def get_artifact_uri(app_name: str, user_id: str, filename: str, version: int, session_id: typing.Optional[str]) -> str:'
    docstring: "Constructs an artifact URI.\n\nArgs:\n    app_name: The name of the application.\n    user_id: The ID of the user.\n    filename: The name of the artifact file.\n    version: The version of the artifact.\n    session_id: The ID of the session.\n\nReturns:\n    The constructed artifact URI."
  - signature: 'def is_artifact_ref(artifact: google.genai.types.Part) -> bool:'
    docstring: "Checks if an artifact part is an artifact reference.\n\nArgs:\n    artifact: The artifact part to check.\n\nReturns:\n    True if the artifact part is an artifact reference, False otherwise."
  properties:
  - signature: '_SESSION_SCOPED_ARTIFACT_URI_RE: re.compile'
  - signature: '_USER_SCOPED_ARTIFACT_URI_RE: re.compile'
- rank: 224
  id: google.adk.artifacts.artifact_util.ParsedArtifactUri
  name: ParsedArtifactUri
  file_path: src/google/adk/artifacts/artifact_util.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'The result of parsing an artifact URI.


    [Note: Inherited members from NamedTuple are omitted.]'
  properties:
  - signature: 'app_name: str'
  - signature: 'user_id: str'
  - signature: 'session_id: typing.Optional[str]'
  - signature: 'filename: str'
  - signature: 'version: int'
  omitted_inherited_members_from:
  - NamedTuple
- rank: 225
  id: google.adk.artifacts.artifact_util.get_artifact_uri
  name: get_artifact_uri
  file_path: src/google/adk/artifacts/artifact_util.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Constructs an artifact URI.\n\nArgs:\n    app_name: The name of the application.\n    user_id: The ID of the user.\n    filename: The name of the artifact file.\n    version: The version of the artifact.\n    session_id: The ID of the session.\n\nReturns:\n    The constructed artifact URI."
  signature: 'def get_artifact_uri(app_name: str, user_id: str, filename: str, version: int, session_id: typing.Optional[str]) -> str:'
- rank: 226
  id: google.adk.artifacts.artifact_util.is_artifact_ref
  name: is_artifact_ref
  file_path: src/google/adk/artifacts/artifact_util.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Checks if an artifact part is an artifact reference.\n\nArgs:\n    artifact: The artifact part to check.\n\nReturns:\n    True if the artifact part is an artifact reference, False otherwise."
  signature: 'def is_artifact_ref(artifact: google.genai.types.Part) -> bool:'
- rank: 227
  id: google.adk.artifacts.artifact_util.parse_artifact_uri
  name: parse_artifact_uri
  file_path: src/google/adk/artifacts/artifact_util.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Parses an artifact URI.\n\nArgs:\n    uri: The artifact URI to parse.\n\nReturns:\n    A ParsedArtifactUri if parsing is successful, None otherwise."
  signature: 'def parse_artifact_uri(uri: str) -> typing.Optional[google.adk.artifacts.artifact_util.ParsedArtifactUri]:'
- rank: 228
  id: google.adk.artifacts.base_artifact_service
  name: base_artifact_service
  file_path: src/google/adk/artifacts/base_artifact_service.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 229
  id: google.adk.artifacts.base_artifact_service.ArtifactVersion
  name: ArtifactVersion
  file_path: src/google/adk/artifacts/base_artifact_service.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Metadata describing a specific version of an artifact.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, version: int, canonical_uri: str, custom_metadata: dict[str, typing.Any] = dict(), create_time: float = Factory(lambda: datetime.now().timestamp()), mime_type: typing.Optional[str] = None):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'version: int'
  - signature: 'canonical_uri: str'
  - signature: 'custom_metadata: dict[str, typing.Any]'
  - signature: 'create_time: float'
  - signature: 'mime_type: typing.Optional[str]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 230
  id: google.adk.artifacts.base_artifact_service.BaseArtifactService
  name: BaseArtifactService
  file_path: src/google/adk/artifacts/base_artifact_service.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Abstract base class for artifact services.


    [Note: Inherited members from ABC are omitted.]'
  aliases:
  - google.adk.artifacts.BaseArtifactService
  methods:
  - signature: 'def save_artifact(self, *, app_name: str, user_id: str, filename: str, artifact: google.genai.types.Part, session_id: typing.Optional[str]=None, custom_metadata: typing.Optional[dict[str, typing.Any]]=None) -> int:'
    docstring: "Saves an artifact to the artifact service storage.\n\nThe artifact is a file identified by the app name, user ID, session ID, and\nfilename. After saving the artifact, a revision ID is returned to identify\nthe artifact version.\n\nArgs:\n  app_name: The app name.\n  user_id: The user ID.\n  filename: The filename of the artifact.\n  artifact: The artifact to save. If the artifact consists of `file_data`,\n    the artifact service assumes its content has been uploaded separately,\n    and this method will associate the `file_data` with the artifact if\n    necessary.\n  session_id: The session ID. If `None`, the artifact is user-scoped.\n  custom_metadata: custom metadata to associate with the artifact.\n\nReturns:\n  The revision ID. The first version of the artifact has a revision ID of 0.\n  This is incremented by 1 after each successful save."
  - signature: 'def load_artifact(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None, version: typing.Optional[int]=None) -> typing.Optional[google.genai.types.Part]:'
    docstring: "Gets an artifact from the artifact service storage.\n\nThe artifact is a file identified by the app name, user ID, session ID, and\nfilename.\n\nArgs:\n  app_name: The app name.\n  user_id: The user ID.\n  filename: The filename of the artifact.\n  session_id: The session ID. If `None`, load the user-scoped artifact.\n  version: The version of the artifact. If None, the latest version will be\n    returned.\n\nReturns:\n  The artifact or None if not found."
  - signature: 'def list_artifact_keys(self, *, app_name: str, user_id: str, session_id: typing.Optional[str]=None) -> list[str]:'
    docstring: "Lists all the artifact filenames within a session.\n\nArgs:\n    app_name: The name of the application.\n    user_id: The ID of the user.\n    session_id: The ID of the session.\n\nReturns:\n    A list of artifact filenames. If `session_id` is provided, returns\n    both session-scoped and user-scoped artifact filenames. If `session_id`\n    is `None`, returns\n    user-scoped artifact filenames."
  - signature: 'def delete_artifact(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> None:'
    docstring: "Deletes an artifact.\n\nArgs:\n    app_name: The name of the application.\n    user_id: The ID of the user.\n    filename: The name of the artifact file.\n    session_id: The ID of the session. If `None`, delete the user-scoped\n      artifact."
  - signature: 'def list_versions(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> list[int]:'
    docstring: "Lists all versions of an artifact.\n\nArgs:\n    app_name: The name of the application.\n    user_id: The ID of the user.\n    filename: The name of the artifact file.\n    session_id: The ID of the session. If `None`, only list the user-scoped\n      artifacts versions.\n\nReturns:\n    A list of all available versions of the artifact."
  - signature: 'def list_artifact_versions(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> list[google.adk.artifacts.base_artifact_service.ArtifactVersion]:'
    docstring: "Lists all versions and their metadata for a specific artifact.\n\nArgs:\n  app_name: The name of the application.\n  user_id: The ID of the user.\n  filename: The name of the artifact file.\n  session_id: The ID of the session. If `None`, lists versions of the\n    user-scoped artifact. Otherwise, lists versions of the artifact within\n    the specified session.\n\nReturns:\n  A list of ArtifactVersion objects, each representing a version of the\n  artifact and its associated metadata."
  - signature: 'def get_artifact_version(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None, version: typing.Optional[int]=None) -> typing.Optional[google.adk.artifacts.base_artifact_service.ArtifactVersion]:'
    docstring: "Gets the metadata for a specific version of an artifact.\n\nArgs:\n  app_name: The name of the application.\n  user_id: The ID of the user.\n  filename: The name of the artifact file.\n  session_id: The ID of the session. If `None`, the artifact will be fetched\n    from the user-scoped artifacts. Otherwise, it will be fetched from the\n    specified session.\n  version: The version number of the artifact to retrieve. If `None`, the\n    latest version will be returned.\n\nReturns:\n  An ArtifactVersion object containing the metadata of the specified\n  artifact version, or `None` if the artifact version is not found."
  omitted_inherited_members_from:
  - ABC
- rank: 231
  id: google.adk.artifacts.base_artifact_service.BaseArtifactService.delete_artifact
  name: delete_artifact
  file_path: src/google/adk/artifacts/base_artifact_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Deletes an artifact.\n\nArgs:\n    app_name: The name of the application.\n    user_id: The ID of the user.\n    filename: The name of the artifact file.\n    session_id: The ID of the session. If `None`, delete the user-scoped\n      artifact."
  signature: 'def delete_artifact(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> None:'
- rank: 232
  id: google.adk.artifacts.base_artifact_service.BaseArtifactService.get_artifact_version
  name: get_artifact_version
  file_path: src/google/adk/artifacts/base_artifact_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Gets the metadata for a specific version of an artifact.\n\nArgs:\n  app_name: The name of the application.\n  user_id: The ID of the user.\n  filename: The name of the artifact file.\n  session_id: The ID of the session. If `None`, the artifact will be fetched\n    from the user-scoped artifacts. Otherwise, it will be fetched from the\n    specified session.\n  version: The version number of the artifact to retrieve. If `None`, the\n    latest version will be returned.\n\nReturns:\n  An ArtifactVersion object containing the metadata of the specified\n  artifact version, or `None` if the artifact version is not found."
  signature: 'def get_artifact_version(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None, version: typing.Optional[int]=None) -> typing.Optional[google.adk.artifacts.base_artifact_service.ArtifactVersion]:'
- rank: 233
  id: google.adk.artifacts.base_artifact_service.BaseArtifactService.list_artifact_keys
  name: list_artifact_keys
  file_path: src/google/adk/artifacts/base_artifact_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Lists all the artifact filenames within a session.\n\nArgs:\n    app_name: The name of the application.\n    user_id: The ID of the user.\n    session_id: The ID of the session.\n\nReturns:\n    A list of artifact filenames. If `session_id` is provided, returns\n    both session-scoped and user-scoped artifact filenames. If `session_id`\n    is `None`, returns\n    user-scoped artifact filenames."
  signature: 'def list_artifact_keys(self, *, app_name: str, user_id: str, session_id: typing.Optional[str]=None) -> list[str]:'
- rank: 234
  id: google.adk.artifacts.base_artifact_service.BaseArtifactService.list_artifact_versions
  name: list_artifact_versions
  file_path: src/google/adk/artifacts/base_artifact_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Lists all versions and their metadata for a specific artifact.\n\nArgs:\n  app_name: The name of the application.\n  user_id: The ID of the user.\n  filename: The name of the artifact file.\n  session_id: The ID of the session. If `None`, lists versions of the\n    user-scoped artifact. Otherwise, lists versions of the artifact within\n    the specified session.\n\nReturns:\n  A list of ArtifactVersion objects, each representing a version of the\n  artifact and its associated metadata."
  signature: 'def list_artifact_versions(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> list[google.adk.artifacts.base_artifact_service.ArtifactVersion]:'
- rank: 235
  id: google.adk.artifacts.base_artifact_service.BaseArtifactService.list_versions
  name: list_versions
  file_path: src/google/adk/artifacts/base_artifact_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Lists all versions of an artifact.\n\nArgs:\n    app_name: The name of the application.\n    user_id: The ID of the user.\n    filename: The name of the artifact file.\n    session_id: The ID of the session. If `None`, only list the user-scoped\n      artifacts versions.\n\nReturns:\n    A list of all available versions of the artifact."
  signature: 'def list_versions(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> list[int]:'
- rank: 236
  id: google.adk.artifacts.base_artifact_service.BaseArtifactService.load_artifact
  name: load_artifact
  file_path: src/google/adk/artifacts/base_artifact_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Gets an artifact from the artifact service storage.\n\nThe artifact is a file identified by the app name, user ID, session ID, and\nfilename.\n\nArgs:\n  app_name: The app name.\n  user_id: The user ID.\n  filename: The filename of the artifact.\n  session_id: The session ID. If `None`, load the user-scoped artifact.\n  version: The version of the artifact. If None, the latest version will be\n    returned.\n\nReturns:\n  The artifact or None if not found."
  signature: 'def load_artifact(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None, version: typing.Optional[int]=None) -> typing.Optional[google.genai.types.Part]:'
- rank: 237
  id: google.adk.artifacts.base_artifact_service.BaseArtifactService.save_artifact
  name: save_artifact
  file_path: src/google/adk/artifacts/base_artifact_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Saves an artifact to the artifact service storage.\n\nThe artifact is a file identified by the app name, user ID, session ID, and\nfilename. After saving the artifact, a revision ID is returned to identify\nthe artifact version.\n\nArgs:\n  app_name: The app name.\n  user_id: The user ID.\n  filename: The filename of the artifact.\n  artifact: The artifact to save. If the artifact consists of `file_data`,\n    the artifact service assumes its content has been uploaded separately,\n    and this method will associate the `file_data` with the artifact if\n    necessary.\n  session_id: The session ID. If `None`, the artifact is user-scoped.\n  custom_metadata: custom metadata to associate with the artifact.\n\nReturns:\n  The revision ID. The first version of the artifact has a revision ID of 0.\n  This is incremented by 1 after each successful save."
  signature: 'def save_artifact(self, *, app_name: str, user_id: str, filename: str, artifact: google.genai.types.Part, session_id: typing.Optional[str]=None, custom_metadata: typing.Optional[dict[str, typing.Any]]=None) -> int:'
- rank: 238
  id: google.adk.artifacts.file_artifact_service
  name: file_artifact_service
  file_path: src/google/adk/artifacts/file_artifact_service.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '_USER_NAMESPACE_PREFIX: str'
- rank: 239
  id: google.adk.artifacts.file_artifact_service.FileArtifactService
  name: FileArtifactService
  file_path: src/google/adk/artifacts/file_artifact_service.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Stores filesystem-backed artifacts beneath a configurable root directory.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, root_dir: Path | str):'
  methods:
  - signature: 'def save_artifact(self, *, app_name: str, user_id: str, filename: str, artifact: google.genai.types.Part, session_id: typing.Optional[str]=None, custom_metadata: typing.Optional[dict[str, typing.Any]]=None) -> int:'
    docstring: 'Persists an artifact to disk.


      Filenames may be simple (``"report.txt"``), nested

      (``"images/photo.png"``), or explicitly user-scoped

      (``"user:shared/diagram.png"``). All values are interpreted relative to the

      computed scope root; absolute paths or inputs that traverse outside that

      root (for example ``"../../secret.txt"``) raise ``ValueError``.'
  - signature: 'def load_artifact(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None, version: typing.Optional[int]=None) -> typing.Optional[google.genai.types.Part]:'
  - signature: 'def list_artifact_keys(self, *, app_name: str, user_id: str, session_id: typing.Optional[str]=None) -> list[str]:'
  - signature: 'def delete_artifact(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> None:'
    docstring: "Deletes an artifact.\n\nArgs:\n    app_name: The name of the application.\n    user_id: The ID of the user.\n    filename: The name of the artifact file.\n    session_id: The ID of the session. Leave unset for user-scoped\n      artifacts."
  - signature: 'def list_versions(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> list[int]:'
    docstring: Lists all versions stored for an artifact.
  - signature: 'def list_artifact_versions(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> list[google.adk.artifacts.base_artifact_service.ArtifactVersion]:'
    docstring: Lists metadata for each artifact version on disk.
  - signature: 'def get_artifact_version(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None, version: typing.Optional[int]=None) -> typing.Optional[google.adk.artifacts.base_artifact_service.ArtifactVersion]:'
    docstring: Gets metadata for a specific artifact version.
  inherited_methods:
    BaseArtifactService:
    - signature: 'def save_artifact(self, *, app_name: str, user_id: str, filename: str, artifact: google.genai.types.Part, session_id: typing.Optional[str]=None, custom_metadata: typing.Optional[dict[str, typing.Any]]=None) -> int:'
      docstring: "Saves an artifact to the artifact service storage.\n\nThe artifact is a file identified by the app name, user ID, session ID, and\nfilename. After saving the artifact, a revision ID is returned to identify\nthe artifact version.\n\nArgs:\n  app_name: The app name.\n  user_id: The user ID.\n  filename: The filename of the artifact.\n  artifact: The artifact to save. If the artifact consists of `file_data`,\n    the artifact service assumes its content has been uploaded separately,\n    and this method will associate the `file_data` with the artifact if\n    necessary.\n  session_id: The session ID. If `None`, the artifact is user-scoped.\n  custom_metadata: custom metadata to associate with the artifact.\n\nReturns:\n  The revision ID. The first version of the artifact has a revision ID of 0.\n  This is incremented by 1 after each successful save."
    - signature: 'def load_artifact(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None, version: typing.Optional[int]=None) -> typing.Optional[google.genai.types.Part]:'
      docstring: "Gets an artifact from the artifact service storage.\n\nThe artifact is a file identified by the app name, user ID, session ID, and\nfilename.\n\nArgs:\n  app_name: The app name.\n  user_id: The user ID.\n  filename: The filename of the artifact.\n  session_id: The session ID. If `None`, load the user-scoped artifact.\n  version: The version of the artifact. If None, the latest version will be\n    returned.\n\nReturns:\n  The artifact or None if not found."
    - signature: 'def list_artifact_keys(self, *, app_name: str, user_id: str, session_id: typing.Optional[str]=None) -> list[str]:'
      docstring: "Lists all the artifact filenames within a session.\n\nArgs:\n    app_name: The name of the application.\n    user_id: The ID of the user.\n    session_id: The ID of the session.\n\nReturns:\n    A list of artifact filenames. If `session_id` is provided, returns\n    both session-scoped and user-scoped artifact filenames. If `session_id`\n    is `None`, returns\n    user-scoped artifact filenames."
    - signature: 'def delete_artifact(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> None:'
      docstring: "Deletes an artifact.\n\nArgs:\n    app_name: The name of the application.\n    user_id: The ID of the user.\n    filename: The name of the artifact file.\n    session_id: The ID of the session. If `None`, delete the user-scoped\n      artifact."
    - signature: 'def list_versions(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> list[int]:'
      docstring: "Lists all versions of an artifact.\n\nArgs:\n    app_name: The name of the application.\n    user_id: The ID of the user.\n    filename: The name of the artifact file.\n    session_id: The ID of the session. If `None`, only list the user-scoped\n      artifacts versions.\n\nReturns:\n    A list of all available versions of the artifact."
    - signature: 'def list_artifact_versions(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> list[google.adk.artifacts.base_artifact_service.ArtifactVersion]:'
      docstring: "Lists all versions and their metadata for a specific artifact.\n\nArgs:\n  app_name: The name of the application.\n  user_id: The ID of the user.\n  filename: The name of the artifact file.\n  session_id: The ID of the session. If `None`, lists versions of the\n    user-scoped artifact. Otherwise, lists versions of the artifact within\n    the specified session.\n\nReturns:\n  A list of ArtifactVersion objects, each representing a version of the\n  artifact and its associated metadata."
    - signature: 'def get_artifact_version(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None, version: typing.Optional[int]=None) -> typing.Optional[google.adk.artifacts.base_artifact_service.ArtifactVersion]:'
      docstring: "Gets the metadata for a specific version of an artifact.\n\nArgs:\n  app_name: The name of the application.\n  user_id: The ID of the user.\n  filename: The name of the artifact file.\n  session_id: The ID of the session. If `None`, the artifact will be fetched\n    from the user-scoped artifacts. Otherwise, it will be fetched from the\n    specified session.\n  version: The version number of the artifact to retrieve. If `None`, the\n    latest version will be returned.\n\nReturns:\n  An ArtifactVersion object containing the metadata of the specified\n  artifact version, or `None` if the artifact version is not found."
  omitted_inherited_members_from:
  - ABC
- rank: 240
  id: google.adk.artifacts.file_artifact_service.FileArtifactService.__init__
  name: __init__
  file_path: src/google/adk/artifacts/file_artifact_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the file-based artifact service.\n\nArgs:\n  root_dir: The directory that will contain artifact data."
  signature: 'def __init__(self, root_dir: Path | str):'
- rank: 241
  id: google.adk.artifacts.file_artifact_service.FileArtifactService.delete_artifact
  name: delete_artifact
  file_path: src/google/adk/artifacts/file_artifact_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Deletes an artifact.\n\nArgs:\n    app_name: The name of the application.\n    user_id: The ID of the user.\n    filename: The name of the artifact file.\n    session_id: The ID of the session. Leave unset for user-scoped\n      artifacts."
  signature: 'def delete_artifact(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> None:'
- rank: 242
  id: google.adk.artifacts.file_artifact_service.FileArtifactService.get_artifact_version
  name: get_artifact_version
  file_path: src/google/adk/artifacts/file_artifact_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Gets metadata for a specific artifact version.
  signature: 'def get_artifact_version(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None, version: typing.Optional[int]=None) -> typing.Optional[google.adk.artifacts.base_artifact_service.ArtifactVersion]:'
- rank: 243
  id: google.adk.artifacts.file_artifact_service.FileArtifactService.list_artifact_keys
  name: list_artifact_keys
  file_path: src/google/adk/artifacts/file_artifact_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def list_artifact_keys(self, *, app_name: str, user_id: str, session_id: typing.Optional[str]=None) -> list[str]:'
- rank: 244
  id: google.adk.artifacts.file_artifact_service.FileArtifactService.list_artifact_versions
  name: list_artifact_versions
  file_path: src/google/adk/artifacts/file_artifact_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Lists metadata for each artifact version on disk.
  signature: 'def list_artifact_versions(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> list[google.adk.artifacts.base_artifact_service.ArtifactVersion]:'
- rank: 245
  id: google.adk.artifacts.file_artifact_service.FileArtifactService.list_versions
  name: list_versions
  file_path: src/google/adk/artifacts/file_artifact_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Lists all versions stored for an artifact.
  signature: 'def list_versions(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> list[int]:'
- rank: 246
  id: google.adk.artifacts.file_artifact_service.FileArtifactService.load_artifact
  name: load_artifact
  file_path: src/google/adk/artifacts/file_artifact_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def load_artifact(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None, version: typing.Optional[int]=None) -> typing.Optional[google.genai.types.Part]:'
- rank: 247
  id: google.adk.artifacts.file_artifact_service.FileArtifactService.save_artifact
  name: save_artifact
  file_path: src/google/adk/artifacts/file_artifact_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Persists an artifact to disk.


    Filenames may be simple (``"report.txt"``), nested

    (``"images/photo.png"``), or explicitly user-scoped

    (``"user:shared/diagram.png"``). All values are interpreted relative to the

    computed scope root; absolute paths or inputs that traverse outside that

    root (for example ``"../../secret.txt"``) raise ``ValueError``.'
  signature: 'def save_artifact(self, *, app_name: str, user_id: str, filename: str, artifact: google.genai.types.Part, session_id: typing.Optional[str]=None, custom_metadata: typing.Optional[dict[str, typing.Any]]=None) -> int:'
- rank: 248
  id: google.adk.artifacts.file_artifact_service.FileArtifactVersion
  name: FileArtifactVersion
  file_path: src/google/adk/artifacts/file_artifact_service.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Represents persisted metadata for a file-backed artifact.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, version: int, canonical_uri: str, custom_metadata: dict[str, typing.Any] = dict(), create_time: float = Factory(lambda: datetime.now().timestamp()), mime_type: typing.Optional[str] = None, file_name: str):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'file_name: str'
  inherited_properties:
    ArtifactVersion:
    - signature: 'model_config: pydantic.ConfigDict'
    - signature: 'version: int'
    - signature: 'canonical_uri: str'
    - signature: 'custom_metadata: dict[str, typing.Any]'
    - signature: 'create_time: float'
    - signature: 'mime_type: typing.Optional[str]'
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 249
  id: google.adk.artifacts.gcs_artifact_service
  name: gcs_artifact_service
  file_path: src/google/adk/artifacts/gcs_artifact_service.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: "An artifact service implementation using Google Cloud Storage (GCS).\n\nThe blob name format used depends on whether the filename has a user namespace:\n  - For files with user namespace (starting with \"user:\"):\n    {app_name}/{user_id}/user/{filename}/{version}\n  - For regular session-scoped files:\n    {app_name}/{user_id}/{session_id}/{filename}/{version}"
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 250
  id: google.adk.artifacts.gcs_artifact_service.GcsArtifactService
  name: GcsArtifactService
  file_path: src/google/adk/artifacts/gcs_artifact_service.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'An artifact service implementation using Google Cloud Storage (GCS).


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, bucket_name: str):'
  methods:
  - signature: 'def save_artifact(self, *, app_name: str, user_id: str, filename: str, artifact: google.genai.types.Part, session_id: typing.Optional[str]=None, custom_metadata: typing.Optional[dict[str, typing.Any]]=None) -> int:'
  - signature: 'def load_artifact(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None, version: typing.Optional[int]=None) -> typing.Optional[google.genai.types.Part]:'
  - signature: 'def list_artifact_keys(self, *, app_name: str, user_id: str, session_id: typing.Optional[str]=None) -> list[str]:'
  - signature: 'def delete_artifact(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> None:'
  - signature: 'def list_versions(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> list[int]:'
  - signature: 'def list_artifact_versions(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> list[google.adk.artifacts.base_artifact_service.ArtifactVersion]:'
  - signature: 'def get_artifact_version(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None, version: typing.Optional[int]=None) -> typing.Optional[google.adk.artifacts.base_artifact_service.ArtifactVersion]:'
  inherited_methods:
    BaseArtifactService:
    - signature: 'def save_artifact(self, *, app_name: str, user_id: str, filename: str, artifact: google.genai.types.Part, session_id: typing.Optional[str]=None, custom_metadata: typing.Optional[dict[str, typing.Any]]=None) -> int:'
      docstring: "Saves an artifact to the artifact service storage.\n\nThe artifact is a file identified by the app name, user ID, session ID, and\nfilename. After saving the artifact, a revision ID is returned to identify\nthe artifact version.\n\nArgs:\n  app_name: The app name.\n  user_id: The user ID.\n  filename: The filename of the artifact.\n  artifact: The artifact to save. If the artifact consists of `file_data`,\n    the artifact service assumes its content has been uploaded separately,\n    and this method will associate the `file_data` with the artifact if\n    necessary.\n  session_id: The session ID. If `None`, the artifact is user-scoped.\n  custom_metadata: custom metadata to associate with the artifact.\n\nReturns:\n  The revision ID. The first version of the artifact has a revision ID of 0.\n  This is incremented by 1 after each successful save."
    - signature: 'def load_artifact(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None, version: typing.Optional[int]=None) -> typing.Optional[google.genai.types.Part]:'
      docstring: "Gets an artifact from the artifact service storage.\n\nThe artifact is a file identified by the app name, user ID, session ID, and\nfilename.\n\nArgs:\n  app_name: The app name.\n  user_id: The user ID.\n  filename: The filename of the artifact.\n  session_id: The session ID. If `None`, load the user-scoped artifact.\n  version: The version of the artifact. If None, the latest version will be\n    returned.\n\nReturns:\n  The artifact or None if not found."
    - signature: 'def list_artifact_keys(self, *, app_name: str, user_id: str, session_id: typing.Optional[str]=None) -> list[str]:'
      docstring: "Lists all the artifact filenames within a session.\n\nArgs:\n    app_name: The name of the application.\n    user_id: The ID of the user.\n    session_id: The ID of the session.\n\nReturns:\n    A list of artifact filenames. If `session_id` is provided, returns\n    both session-scoped and user-scoped artifact filenames. If `session_id`\n    is `None`, returns\n    user-scoped artifact filenames."
    - signature: 'def delete_artifact(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> None:'
      docstring: "Deletes an artifact.\n\nArgs:\n    app_name: The name of the application.\n    user_id: The ID of the user.\n    filename: The name of the artifact file.\n    session_id: The ID of the session. If `None`, delete the user-scoped\n      artifact."
    - signature: 'def list_versions(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> list[int]:'
      docstring: "Lists all versions of an artifact.\n\nArgs:\n    app_name: The name of the application.\n    user_id: The ID of the user.\n    filename: The name of the artifact file.\n    session_id: The ID of the session. If `None`, only list the user-scoped\n      artifacts versions.\n\nReturns:\n    A list of all available versions of the artifact."
    - signature: 'def list_artifact_versions(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> list[google.adk.artifacts.base_artifact_service.ArtifactVersion]:'
      docstring: "Lists all versions and their metadata for a specific artifact.\n\nArgs:\n  app_name: The name of the application.\n  user_id: The ID of the user.\n  filename: The name of the artifact file.\n  session_id: The ID of the session. If `None`, lists versions of the\n    user-scoped artifact. Otherwise, lists versions of the artifact within\n    the specified session.\n\nReturns:\n  A list of ArtifactVersion objects, each representing a version of the\n  artifact and its associated metadata."
    - signature: 'def get_artifact_version(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None, version: typing.Optional[int]=None) -> typing.Optional[google.adk.artifacts.base_artifact_service.ArtifactVersion]:'
      docstring: "Gets the metadata for a specific version of an artifact.\n\nArgs:\n  app_name: The name of the application.\n  user_id: The ID of the user.\n  filename: The name of the artifact file.\n  session_id: The ID of the session. If `None`, the artifact will be fetched\n    from the user-scoped artifacts. Otherwise, it will be fetched from the\n    specified session.\n  version: The version number of the artifact to retrieve. If `None`, the\n    latest version will be returned.\n\nReturns:\n  An ArtifactVersion object containing the metadata of the specified\n  artifact version, or `None` if the artifact version is not found."
  omitted_inherited_members_from:
  - ABC
- rank: 251
  id: google.adk.artifacts.gcs_artifact_service.GcsArtifactService.__init__
  name: __init__
  file_path: src/google/adk/artifacts/gcs_artifact_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the GcsArtifactService.\n\nArgs:\n    bucket_name: The name of the bucket to use.\n    **kwargs: Keyword arguments to pass to the Google Cloud Storage client."
  signature: 'def __init__(self, bucket_name: str):'
- rank: 252
  id: google.adk.artifacts.gcs_artifact_service.GcsArtifactService.delete_artifact
  name: delete_artifact
  file_path: src/google/adk/artifacts/gcs_artifact_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def delete_artifact(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> None:'
- rank: 253
  id: google.adk.artifacts.gcs_artifact_service.GcsArtifactService.get_artifact_version
  name: get_artifact_version
  file_path: src/google/adk/artifacts/gcs_artifact_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_artifact_version(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None, version: typing.Optional[int]=None) -> typing.Optional[google.adk.artifacts.base_artifact_service.ArtifactVersion]:'
- rank: 254
  id: google.adk.artifacts.gcs_artifact_service.GcsArtifactService.list_artifact_keys
  name: list_artifact_keys
  file_path: src/google/adk/artifacts/gcs_artifact_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def list_artifact_keys(self, *, app_name: str, user_id: str, session_id: typing.Optional[str]=None) -> list[str]:'
- rank: 255
  id: google.adk.artifacts.gcs_artifact_service.GcsArtifactService.list_artifact_versions
  name: list_artifact_versions
  file_path: src/google/adk/artifacts/gcs_artifact_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def list_artifact_versions(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> list[google.adk.artifacts.base_artifact_service.ArtifactVersion]:'
- rank: 256
  id: google.adk.artifacts.gcs_artifact_service.GcsArtifactService.list_versions
  name: list_versions
  file_path: src/google/adk/artifacts/gcs_artifact_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def list_versions(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> list[int]:'
- rank: 257
  id: google.adk.artifacts.gcs_artifact_service.GcsArtifactService.load_artifact
  name: load_artifact
  file_path: src/google/adk/artifacts/gcs_artifact_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def load_artifact(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None, version: typing.Optional[int]=None) -> typing.Optional[google.genai.types.Part]:'
- rank: 258
  id: google.adk.artifacts.gcs_artifact_service.GcsArtifactService.save_artifact
  name: save_artifact
  file_path: src/google/adk/artifacts/gcs_artifact_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def save_artifact(self, *, app_name: str, user_id: str, filename: str, artifact: google.genai.types.Part, session_id: typing.Optional[str]=None, custom_metadata: typing.Optional[dict[str, typing.Any]]=None) -> int:'
- rank: 259
  id: google.adk.artifacts.in_memory_artifact_service
  name: in_memory_artifact_service
  file_path: src/google/adk/artifacts/in_memory_artifact_service.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 260
  id: google.adk.artifacts.in_memory_artifact_service.InMemoryArtifactService.delete_artifact
  name: delete_artifact
  file_path: src/google/adk/artifacts/in_memory_artifact_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def delete_artifact(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> None:'
- rank: 261
  id: google.adk.artifacts.in_memory_artifact_service.InMemoryArtifactService.get_artifact_version
  name: get_artifact_version
  file_path: src/google/adk/artifacts/in_memory_artifact_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_artifact_version(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None, version: typing.Optional[int]=None) -> typing.Optional[google.adk.artifacts.base_artifact_service.ArtifactVersion]:'
- rank: 262
  id: google.adk.artifacts.in_memory_artifact_service.InMemoryArtifactService.list_artifact_keys
  name: list_artifact_keys
  file_path: src/google/adk/artifacts/in_memory_artifact_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def list_artifact_keys(self, *, app_name: str, user_id: str, session_id: typing.Optional[str]=None) -> list[str]:'
- rank: 263
  id: google.adk.artifacts.in_memory_artifact_service.InMemoryArtifactService.list_artifact_versions
  name: list_artifact_versions
  file_path: src/google/adk/artifacts/in_memory_artifact_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def list_artifact_versions(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> list[google.adk.artifacts.base_artifact_service.ArtifactVersion]:'
- rank: 264
  id: google.adk.artifacts.in_memory_artifact_service.InMemoryArtifactService.list_versions
  name: list_versions
  file_path: src/google/adk/artifacts/in_memory_artifact_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def list_versions(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None) -> list[int]:'
- rank: 265
  id: google.adk.artifacts.in_memory_artifact_service.InMemoryArtifactService.load_artifact
  name: load_artifact
  file_path: src/google/adk/artifacts/in_memory_artifact_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def load_artifact(self, *, app_name: str, user_id: str, filename: str, session_id: typing.Optional[str]=None, version: typing.Optional[int]=None) -> typing.Optional[google.genai.types.Part]:'
- rank: 266
  id: google.adk.artifacts.in_memory_artifact_service.InMemoryArtifactService.save_artifact
  name: save_artifact
  file_path: src/google/adk/artifacts/in_memory_artifact_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def save_artifact(self, *, app_name: str, user_id: str, filename: str, artifact: google.genai.types.Part, session_id: typing.Optional[str]=None, custom_metadata: typing.Optional[dict[str, typing.Any]]=None) -> int:'
- rank: 267
  id: google.adk.auth
  name: auth
  file_path: src/google/adk/auth/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 268
  id: google.adk.auth.auth_credential
  name: auth_credential
  file_path: src/google/adk/auth/auth_credential.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 269
  id: google.adk.auth.auth_credential.AuthCredentialTypes
  name: AuthCredentialTypes
  file_path: src/google/adk/auth/auth_credential.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Represents the type of authentication credential.


    [Note: Inherited members from Enum, str are omitted.]'
  properties:
  - signature: 'API_KEY: str'
  - signature: 'HTTP: str'
  - signature: 'OAUTH2: str'
  - signature: 'OPEN_ID_CONNECT: str'
  - signature: 'SERVICE_ACCOUNT: str'
  omitted_inherited_members_from:
  - str
  - Enum
- rank: 270
  id: google.adk.auth.auth_credential.BaseModelWithConfig
  name: BaseModelWithConfig
  file_path: src/google/adk/auth/auth_credential.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
    docstring: The pydantic model config.
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 271
  id: google.adk.auth.auth_credential.HttpAuth
  name: HttpAuth
  file_path: src/google/adk/auth/auth_credential.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'The credentials and metadata for HTTP authentication.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, scheme: str, credentials: google.adk.auth.auth_credential.HttpCredentials, additional_headers: typing.Optional[typing.Dict[str, str]] = None):'
  properties:
  - signature: 'scheme: str'
  - signature: 'credentials: google.adk.auth.auth_credential.HttpCredentials'
  - signature: 'additional_headers: typing.Optional[typing.Dict[str, str]]'
  inherited_properties:
    BaseModelWithConfig:
    - signature: 'model_config: pydantic.ConfigDict'
      docstring: The pydantic model config.
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 272
  id: google.adk.auth.auth_credential.HttpCredentials
  name: HttpCredentials
  file_path: src/google/adk/auth/auth_credential.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Represents the secret token value for HTTP authentication, like user name, password, oauth token, etc.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, username: typing.Optional[str] = None, password: typing.Optional[str] = None, token: typing.Optional[str] = None):'
  methods:
  - signature: 'def model_validate(cls, data: typing.Dict[str, typing.Any]) -> google.adk.auth.auth_credential.HttpCredentials:'
  properties:
  - signature: 'username: typing.Optional[str]'
  - signature: 'password: typing.Optional[str]'
  - signature: 'token: typing.Optional[str]'
  inherited_properties:
    BaseModelWithConfig:
    - signature: 'model_config: pydantic.ConfigDict'
      docstring: The pydantic model config.
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 273
  id: google.adk.auth.auth_credential.HttpCredentials.model_validate
  name: model_validate
  file_path: src/google/adk/auth/auth_credential.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def model_validate(cls, data: typing.Dict[str, typing.Any]) -> google.adk.auth.auth_credential.HttpCredentials:'
- rank: 274
  id: google.adk.auth.auth_credential.ServiceAccount
  name: ServiceAccount
  file_path: src/google/adk/auth/auth_credential.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Represents Google Service Account configuration.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, service_account_credential: typing.Optional[google.adk.auth.auth_credential.ServiceAccountCredential] = None, scopes: typing.List[str], use_default_credential: typing.Optional[bool] = False):'
  properties:
  - signature: 'service_account_credential: typing.Optional[google.adk.auth.auth_credential.ServiceAccountCredential]'
  - signature: 'scopes: typing.List[str]'
  - signature: 'use_default_credential: typing.Optional[bool]'
  inherited_properties:
    BaseModelWithConfig:
    - signature: 'model_config: pydantic.ConfigDict'
      docstring: The pydantic model config.
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 275
  id: google.adk.auth.auth_credential.ServiceAccountCredential
  name: ServiceAccountCredential
  file_path: src/google/adk/auth/auth_credential.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "Represents Google Service Account configuration.\n\nAttributes:\n  type: The type should be \"service_account\".\n  project_id: The project ID.\n  private_key_id: The ID of the private key.\n  private_key: The private key.\n  client_email: The client email.\n  client_id: The client ID.\n  auth_uri: The authorization URI.\n  token_uri: The token URI.\n  auth_provider_x509_cert_url: URL for auth provider's X.509 cert.\n  client_x509_cert_url: URL for the client's X.509 cert.\n  universe_domain: The universe domain.\n\nExample:\n\n    config = ServiceAccountCredential(\n        type_=\"service_account\",\n        project_id=\"your_project_id\",\n        private_key_id=\"your_private_key_id\",\n        private_key=\"-----BEGIN PRIVATE KEY-----...\",\n        client_email=\"...@....iam.gserviceaccount.com\",\n        client_id=\"your_client_id\",\n        auth_uri=\"https://accounts.google.com/o/oauth2/auth\",\n        token_uri=\"https://oauth2.googleapis.com/token\",\n       \
    \ auth_provider_x509_cert_url=\"https://www.googleapis.com/oauth2/v1/certs\",\n        client_x509_cert_url=\"https://www.googleapis.com/robot/v1/metadata/x509/...\",\n        universe_domain=\"googleapis.com\"\n    )\n\n    config = ServiceAccountConfig.model_construct(**{\n        ...service account config dict\n    })\n\n[Note: Inherited members from pydantic.BaseModel are omitted.]"
  constructor_signature: 'def __init__(self, *, type_: str, project_id: str, private_key_id: str, private_key: str, client_email: str, client_id: str, auth_uri: str, token_uri: str, auth_provider_x509_cert_url: str, client_x509_cert_url: str, universe_domain: str):'
  properties:
  - signature: 'type_: str'
  - signature: 'project_id: str'
  - signature: 'private_key_id: str'
  - signature: 'private_key: str'
  - signature: 'client_email: str'
  - signature: 'client_id: str'
  - signature: 'auth_uri: str'
  - signature: 'token_uri: str'
  - signature: 'auth_provider_x509_cert_url: str'
  - signature: 'client_x509_cert_url: str'
  - signature: 'universe_domain: str'
  inherited_properties:
    BaseModelWithConfig:
    - signature: 'model_config: pydantic.ConfigDict'
      docstring: The pydantic model config.
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 276
  id: google.adk.auth.auth_handler
  name: auth_handler
  file_path: src/google/adk/auth/auth_handler.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'AUTHLIB_AVAILABLE: bool'
- rank: 277
  id: google.adk.auth.auth_handler.AuthHandler
  name: AuthHandler
  file_path: src/google/adk/auth/auth_handler.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A handler that handles the auth flow in Agent Development Kit to help

    orchestrate the credential request and response flow (e.g. OAuth flow)

    This class should only be used by Agent Development Kit.'
  constructor_signature: 'def __init__(self, auth_config: google.adk.auth.auth_tool.AuthConfig):'
  aliases:
  - google.adk.auth.AuthHandler
  methods:
  - signature: 'def exchange_auth_token(self) -> google.adk.auth.auth_credential.AuthCredential:'
  - signature: 'def parse_and_store_auth_response(self, state: google.adk.sessions.state.State) -> None:'
  - signature: 'def get_auth_response(self, state: google.adk.sessions.state.State) -> google.adk.auth.auth_credential.AuthCredential:'
  - signature: 'def generate_auth_request(self) -> google.adk.auth.auth_tool.AuthConfig:'
  - signature: 'def generate_auth_uri(self) -> google.adk.auth.auth_credential.AuthCredential:'
    docstring: "Generates a response containing the auth uri for user to sign in.\n\nReturns:\n    An AuthCredential object containing the auth URI and state.\n\nRaises:\n    ValueError: If the authorization endpoint is not configured in the auth\n        scheme."
- rank: 278
  id: google.adk.auth.auth_handler.AuthHandler.exchange_auth_token
  name: exchange_auth_token
  file_path: src/google/adk/auth/auth_handler.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def exchange_auth_token(self) -> google.adk.auth.auth_credential.AuthCredential:'
- rank: 279
  id: google.adk.auth.auth_handler.AuthHandler.generate_auth_request
  name: generate_auth_request
  file_path: src/google/adk/auth/auth_handler.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def generate_auth_request(self) -> google.adk.auth.auth_tool.AuthConfig:'
- rank: 280
  id: google.adk.auth.auth_handler.AuthHandler.generate_auth_uri
  name: generate_auth_uri
  file_path: src/google/adk/auth/auth_handler.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Generates a response containing the auth uri for user to sign in.\n\nReturns:\n    An AuthCredential object containing the auth URI and state.\n\nRaises:\n    ValueError: If the authorization endpoint is not configured in the auth\n        scheme."
  signature: 'def generate_auth_uri(self) -> google.adk.auth.auth_credential.AuthCredential:'
- rank: 281
  id: google.adk.auth.auth_handler.AuthHandler.parse_and_store_auth_response
  name: parse_and_store_auth_response
  file_path: src/google/adk/auth/auth_handler.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def parse_and_store_auth_response(self, state: google.adk.sessions.state.State) -> None:'
- rank: 282
  id: google.adk.auth.auth_preprocessor
  name: auth_preprocessor
  file_path: src/google/adk/auth/auth_preprocessor.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'TOOLSET_AUTH_CREDENTIAL_ID_PREFIX: str'
  - signature: 'request_processor: _AuthLlmRequestProcessor'
- rank: 283
  id: google.adk.auth.auth_schemes
  name: auth_schemes
  file_path: src/google/adk/auth/auth_schemes.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'AuthScheme: Any'
  - signature: 'AuthSchemeType: Any'
- rank: 284
  id: google.adk.auth.auth_schemes.ExtendedOAuth2
  name: ExtendedOAuth2
  file_path: src/google/adk/auth/auth_schemes.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'OAuth2 scheme that incorporates auto-discovery for endpoints.


    [Note: Inherited members from OAuth2 are omitted.]'
  properties:
  - signature: 'issuer_url: typing.Optional[str]'
  omitted_inherited_members_from:
  - OAuth2
- rank: 285
  id: google.adk.auth.auth_schemes.OAuthGrantType
  name: OAuthGrantType
  file_path: src/google/adk/auth/auth_schemes.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Represents the OAuth2 flow (or grant type).


    [Note: Inherited members from Enum, str are omitted.]'
  methods:
  - signature: 'def from_flow(flow: fastapi.openapi.models.OAuthFlows) -> google.adk.auth.auth_schemes.OAuthGrantType:'
    docstring: Converts an OAuthFlows object to a OAuthGrantType.
  properties:
  - signature: 'CLIENT_CREDENTIALS: str'
  - signature: 'AUTHORIZATION_CODE: str'
  - signature: 'IMPLICIT: str'
  - signature: 'PASSWORD: str'
  omitted_inherited_members_from:
  - str
  - Enum
- rank: 286
  id: google.adk.auth.auth_schemes.OAuthGrantType.from_flow
  name: from_flow
  file_path: src/google/adk/auth/auth_schemes.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Converts an OAuthFlows object to a OAuthGrantType.
  signature: 'def from_flow(flow: fastapi.openapi.models.OAuthFlows) -> google.adk.auth.auth_schemes.OAuthGrantType:'
- rank: 287
  id: google.adk.auth.auth_schemes.OpenIdConnectWithConfig
  name: OpenIdConnectWithConfig
  file_path: src/google/adk/auth/auth_schemes.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from SecurityBase are omitted.]'
  properties:
  - signature: 'type_: fastapi.openapi.models.SecuritySchemeType'
  - signature: 'authorization_endpoint: str'
  - signature: 'token_endpoint: str'
  - signature: 'userinfo_endpoint: typing.Optional[str]'
  - signature: 'revocation_endpoint: typing.Optional[str]'
  - signature: 'token_endpoint_auth_methods_supported: typing.Optional[typing.List[str]]'
  - signature: 'grant_types_supported: typing.Optional[typing.List[str]]'
  - signature: 'scopes: typing.Optional[typing.List[str]]'
  omitted_inherited_members_from:
  - SecurityBase
- rank: 288
  id: google.adk.auth.auth_tool
  name: auth_tool
  file_path: src/google/adk/auth/auth_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 289
  id: google.adk.auth.auth_tool.AuthConfig.__init__
  name: __init__
  file_path: src/google/adk/auth/auth_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self):'
- rank: 290
  id: google.adk.auth.auth_tool.AuthConfig.get_credential_key
  name: get_credential_key
  file_path: src/google/adk/auth/auth_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Builds a stable key based on auth_scheme and raw_auth_credential.


    This is used to save/load credentials to/from a credential service when

    `credential_key` is not explicitly provided.'
  signature: 'def get_credential_key(self):'
- rank: 291
  id: google.adk.auth.auth_tool.AuthToolArguments
  name: AuthToolArguments
  file_path: src/google/adk/auth/auth_tool.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'the arguments for the special long running function tool that is used to


    request end user credentials.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, function_call_id: str, auth_config: google.adk.auth.auth_tool.AuthConfig):'
  properties:
  - signature: 'function_call_id: str'
  - signature: 'auth_config: google.adk.auth.auth_tool.AuthConfig'
  inherited_properties:
    BaseModelWithConfig:
    - signature: 'model_config: pydantic.ConfigDict'
      docstring: The pydantic model config.
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 292
  id: google.adk.auth.credential_manager
  name: credential_manager
  file_path: src/google/adk/auth/credential_manager.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 293
  id: google.adk.auth.credential_manager.CredentialManager
  name: CredentialManager
  file_path: src/google/adk/auth/credential_manager.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "Manages authentication credentials through a structured workflow.\n\nThe CredentialManager orchestrates the complete lifecycle of authentication\ncredentials, from initial loading to final preparation for use. It provides\na centralized interface for handling various credential types and authentication\nschemes while maintaining proper credential hygiene (refresh, exchange, caching).\n\nThis class is only for use by Agent Development Kit.\n\nArgs:\n    auth_config: Configuration containing authentication scheme and credentials\n\nExample:\n    ```python\n    auth_config = AuthConfig(\n        auth_scheme=oauth2_scheme,\n        raw_auth_credential=service_account_credential\n    )\n    manager = CredentialManager(auth_config)\n\n    # Register custom exchanger if needed\n    manager.register_credential_exchanger(\n        AuthCredentialTypes.CUSTOM_TYPE,\n        CustomCredentialExchanger()\n    )\n\n    # Register custom refresher if needed\n    manager.register_credential_refresher(\n\
    \        AuthCredentialTypes.CUSTOM_TYPE,\n        CustomCredentialRefresher()\n    )\n\n    # Load and prepare credential\n    credential = await manager.load_auth_credential(tool_context)\n    ```"
  constructor_signature: 'def __init__(self, auth_config: google.adk.auth.auth_tool.AuthConfig):'
  methods:
  - signature: 'def register_credential_exchanger(self, credential_type: google.adk.auth.auth_credential.AuthCredentialTypes, exchanger_instance: google.adk.auth.exchanger.base_credential_exchanger.BaseCredentialExchanger) -> None:'
    docstring: "Register a credential exchanger for a credential type.\n\nArgs:\n    credential_type: The credential type to register for.\n    exchanger_instance: The exchanger instance to register."
  - signature: 'def request_credential(self, context: google.adk.agents.callback_context.CallbackContext) -> None:'
  - signature: 'def get_auth_credential(self, context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.adk.auth.auth_credential.AuthCredential]:'
    docstring: Load and prepare authentication credential through a structured workflow.
- rank: 294
  id: google.adk.auth.credential_manager.CredentialManager.__init__
  name: __init__
  file_path: src/google/adk/auth/credential_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, auth_config: google.adk.auth.auth_tool.AuthConfig):'
- rank: 295
  id: google.adk.auth.credential_manager.CredentialManager.get_auth_credential
  name: get_auth_credential
  file_path: src/google/adk/auth/credential_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Load and prepare authentication credential through a structured workflow.
  signature: 'def get_auth_credential(self, context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.adk.auth.auth_credential.AuthCredential]:'
- rank: 296
  id: google.adk.auth.credential_manager.CredentialManager.register_credential_exchanger
  name: register_credential_exchanger
  file_path: src/google/adk/auth/credential_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Register a credential exchanger for a credential type.\n\nArgs:\n    credential_type: The credential type to register for.\n    exchanger_instance: The exchanger instance to register."
  signature: 'def register_credential_exchanger(self, credential_type: google.adk.auth.auth_credential.AuthCredentialTypes, exchanger_instance: google.adk.auth.exchanger.base_credential_exchanger.BaseCredentialExchanger) -> None:'
- rank: 297
  id: google.adk.auth.credential_manager.CredentialManager.request_credential
  name: request_credential
  file_path: src/google/adk/auth/credential_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def request_credential(self, context: google.adk.agents.callback_context.CallbackContext) -> None:'
- rank: 298
  id: google.adk.auth.credential_service
  name: credential_service
  file_path: src/google/adk/auth/credential_service/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 299
  id: google.adk.auth.credential_service.base_credential_service
  name: base_credential_service
  file_path: src/google/adk/auth/credential_service/base_credential_service.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 300
  id: google.adk.auth.credential_service.base_credential_service.BaseCredentialService
  name: BaseCredentialService
  file_path: src/google/adk/auth/credential_service/base_credential_service.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Abstract class for Service that loads / saves tool credentials from / to

    the backend credential store.


    [Note: Inherited members from ABC are omitted.]'
  methods:
  - signature: 'def load_credential(self, auth_config: google.adk.auth.auth_tool.AuthConfig, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.adk.auth.auth_credential.AuthCredential]:'
    docstring: "Loads the credential by auth config and current callback context from the\nbackend credential store.\n\nArgs:\n    auth_config: The auth config which contains the auth scheme and auth\n    credential information. auth_config.get_credential_key will be used to\n    build the key to load the credential.\n\n    callback_context: The context of the current invocation when the tool is\n    trying to load the credential.\n\nReturns:\n    Optional[AuthCredential]: the credential saved in the store."
  - signature: 'def save_credential(self, auth_config: google.adk.auth.auth_tool.AuthConfig, callback_context: google.adk.agents.callback_context.CallbackContext) -> None:'
    docstring: "Saves the exchanged_auth_credential in auth config to the backend credential\nstore.\n\nArgs:\n    auth_config: The auth config which contains the auth scheme and auth\n    credential information. auth_config.get_credential_key will be used to\n    build the key to save the credential.\n\n    callback_context: The context of the current invocation when the tool is\n    trying to save the credential.\n\nReturns:\n    None"
  omitted_inherited_members_from:
  - ABC
- rank: 301
  id: google.adk.auth.credential_service.base_credential_service.BaseCredentialService.load_credential
  name: load_credential
  file_path: src/google/adk/auth/credential_service/base_credential_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Loads the credential by auth config and current callback context from the\nbackend credential store.\n\nArgs:\n    auth_config: The auth config which contains the auth scheme and auth\n    credential information. auth_config.get_credential_key will be used to\n    build the key to load the credential.\n\n    callback_context: The context of the current invocation when the tool is\n    trying to load the credential.\n\nReturns:\n    Optional[AuthCredential]: the credential saved in the store."
  signature: 'def load_credential(self, auth_config: google.adk.auth.auth_tool.AuthConfig, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.adk.auth.auth_credential.AuthCredential]:'
- rank: 302
  id: google.adk.auth.credential_service.base_credential_service.BaseCredentialService.save_credential
  name: save_credential
  file_path: src/google/adk/auth/credential_service/base_credential_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Saves the exchanged_auth_credential in auth config to the backend credential\nstore.\n\nArgs:\n    auth_config: The auth config which contains the auth scheme and auth\n    credential information. auth_config.get_credential_key will be used to\n    build the key to save the credential.\n\n    callback_context: The context of the current invocation when the tool is\n    trying to save the credential.\n\nReturns:\n    None"
  signature: 'def save_credential(self, auth_config: google.adk.auth.auth_tool.AuthConfig, callback_context: google.adk.agents.callback_context.CallbackContext) -> None:'
- rank: 303
  id: google.adk.auth.credential_service.in_memory_credential_service
  name: in_memory_credential_service
  file_path: src/google/adk/auth/credential_service/in_memory_credential_service.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 304
  id: google.adk.auth.credential_service.in_memory_credential_service.InMemoryCredentialService
  name: InMemoryCredentialService
  file_path: src/google/adk/auth/credential_service/in_memory_credential_service.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Class for in memory implementation of credential service(Experimental)


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self):'
  methods:
  - signature: 'def load_credential(self, auth_config: google.adk.auth.auth_tool.AuthConfig, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.adk.auth.auth_credential.AuthCredential]:'
  - signature: 'def save_credential(self, auth_config: google.adk.auth.auth_tool.AuthConfig, callback_context: google.adk.agents.callback_context.CallbackContext) -> None:'
  inherited_methods:
    BaseCredentialService:
    - signature: 'def load_credential(self, auth_config: google.adk.auth.auth_tool.AuthConfig, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.adk.auth.auth_credential.AuthCredential]:'
      docstring: "Loads the credential by auth config and current callback context from the\nbackend credential store.\n\nArgs:\n    auth_config: The auth config which contains the auth scheme and auth\n    credential information. auth_config.get_credential_key will be used to\n    build the key to load the credential.\n\n    callback_context: The context of the current invocation when the tool is\n    trying to load the credential.\n\nReturns:\n    Optional[AuthCredential]: the credential saved in the store."
    - signature: 'def save_credential(self, auth_config: google.adk.auth.auth_tool.AuthConfig, callback_context: google.adk.agents.callback_context.CallbackContext) -> None:'
      docstring: "Saves the exchanged_auth_credential in auth config to the backend credential\nstore.\n\nArgs:\n    auth_config: The auth config which contains the auth scheme and auth\n    credential information. auth_config.get_credential_key will be used to\n    build the key to save the credential.\n\n    callback_context: The context of the current invocation when the tool is\n    trying to save the credential.\n\nReturns:\n    None"
  omitted_inherited_members_from:
  - ABC
- rank: 305
  id: google.adk.auth.credential_service.in_memory_credential_service.InMemoryCredentialService.load_credential
  name: load_credential
  file_path: src/google/adk/auth/credential_service/in_memory_credential_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def load_credential(self, auth_config: google.adk.auth.auth_tool.AuthConfig, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.adk.auth.auth_credential.AuthCredential]:'
- rank: 306
  id: google.adk.auth.credential_service.in_memory_credential_service.InMemoryCredentialService.save_credential
  name: save_credential
  file_path: src/google/adk/auth/credential_service/in_memory_credential_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def save_credential(self, auth_config: google.adk.auth.auth_tool.AuthConfig, callback_context: google.adk.agents.callback_context.CallbackContext) -> None:'
- rank: 307
  id: google.adk.auth.credential_service.session_state_credential_service
  name: session_state_credential_service
  file_path: src/google/adk/auth/credential_service/session_state_credential_service.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 308
  id: google.adk.auth.credential_service.session_state_credential_service.SessionStateCredentialService
  name: SessionStateCredentialService
  file_path: src/google/adk/auth/credential_service/session_state_credential_service.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Class for implementation of credential service using session state as the

    store.

    Note: store credential in session may not be secure, use at your own risk.


    [Note: Inherited members from ABC are omitted.]'
  methods:
  - signature: 'def load_credential(self, auth_config: google.adk.auth.auth_tool.AuthConfig, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.adk.auth.auth_credential.AuthCredential]:'
    docstring: "Loads the credential by auth config and current callback context from the\nbackend credential store.\n\nArgs:\n    auth_config: The auth config which contains the auth scheme and auth\n    credential information. auth_config.get_credential_key will be used to\n    build the key to load the credential.\n\n    callback_context: The context of the current invocation when the tool is\n    trying to load the credential.\n\nReturns:\n    Optional[AuthCredential]: the credential saved in the store."
  - signature: 'def save_credential(self, auth_config: google.adk.auth.auth_tool.AuthConfig, callback_context: google.adk.agents.callback_context.CallbackContext) -> None:'
    docstring: "Saves the exchanged_auth_credential in auth config to the backend credential\nstore.\n\nArgs:\n    auth_config: The auth config which contains the auth scheme and auth\n    credential information. auth_config.get_credential_key will be used to\n    build the key to save the credential.\n\n    callback_context: The context of the current invocation when the tool is\n    trying to save the credential.\n\nReturns:\n    None"
  inherited_methods:
    BaseCredentialService:
    - signature: 'def load_credential(self, auth_config: google.adk.auth.auth_tool.AuthConfig, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.adk.auth.auth_credential.AuthCredential]:'
      docstring: "Loads the credential by auth config and current callback context from the\nbackend credential store.\n\nArgs:\n    auth_config: The auth config which contains the auth scheme and auth\n    credential information. auth_config.get_credential_key will be used to\n    build the key to load the credential.\n\n    callback_context: The context of the current invocation when the tool is\n    trying to load the credential.\n\nReturns:\n    Optional[AuthCredential]: the credential saved in the store."
    - signature: 'def save_credential(self, auth_config: google.adk.auth.auth_tool.AuthConfig, callback_context: google.adk.agents.callback_context.CallbackContext) -> None:'
      docstring: "Saves the exchanged_auth_credential in auth config to the backend credential\nstore.\n\nArgs:\n    auth_config: The auth config which contains the auth scheme and auth\n    credential information. auth_config.get_credential_key will be used to\n    build the key to save the credential.\n\n    callback_context: The context of the current invocation when the tool is\n    trying to save the credential.\n\nReturns:\n    None"
  omitted_inherited_members_from:
  - ABC
- rank: 309
  id: google.adk.auth.credential_service.session_state_credential_service.SessionStateCredentialService.load_credential
  name: load_credential
  file_path: src/google/adk/auth/credential_service/session_state_credential_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Loads the credential by auth config and current callback context from the\nbackend credential store.\n\nArgs:\n    auth_config: The auth config which contains the auth scheme and auth\n    credential information. auth_config.get_credential_key will be used to\n    build the key to load the credential.\n\n    callback_context: The context of the current invocation when the tool is\n    trying to load the credential.\n\nReturns:\n    Optional[AuthCredential]: the credential saved in the store."
  signature: 'def load_credential(self, auth_config: google.adk.auth.auth_tool.AuthConfig, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.adk.auth.auth_credential.AuthCredential]:'
- rank: 310
  id: google.adk.auth.credential_service.session_state_credential_service.SessionStateCredentialService.save_credential
  name: save_credential
  file_path: src/google/adk/auth/credential_service/session_state_credential_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Saves the exchanged_auth_credential in auth config to the backend credential\nstore.\n\nArgs:\n    auth_config: The auth config which contains the auth scheme and auth\n    credential information. auth_config.get_credential_key will be used to\n    build the key to save the credential.\n\n    callback_context: The context of the current invocation when the tool is\n    trying to save the credential.\n\nReturns:\n    None"
  signature: 'def save_credential(self, auth_config: google.adk.auth.auth_tool.AuthConfig, callback_context: google.adk.agents.callback_context.CallbackContext) -> None:'
- rank: 311
  id: google.adk.auth.exchanger
  name: exchanger
  file_path: src/google/adk/auth/exchanger/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Credential exchanger module.
  properties:
  - signature: '__all__: Any'
- rank: 312
  id: google.adk.auth.exchanger.base_credential_exchanger
  name: base_credential_exchanger
  file_path: src/google/adk/auth/exchanger/base_credential_exchanger.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Base credential exchanger interface.
- rank: 313
  id: google.adk.auth.exchanger.base_credential_exchanger.BaseCredentialExchanger
  name: BaseCredentialExchanger
  file_path: src/google/adk/auth/exchanger/base_credential_exchanger.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Base interface for credential exchangers.


    Credential exchangers are responsible for exchanging credentials from

    one format or scheme to another.


    [Note: Inherited members from abc.ABC are omitted.]'
  aliases:
  - google.adk.auth.exchanger.BaseCredentialExchanger
  methods:
  - signature: 'def exchange(self, auth_credential: google.adk.auth.auth_credential.AuthCredential, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme]) -> google.adk.auth.exchanger.base_credential_exchanger.ExchangeResult:'
    docstring: "Exchange credential if needed.\n\nArgs:\n    auth_credential: The credential to exchange.\n    auth_scheme: The authentication scheme (optional, some exchangers don't\n      need it).\n\nReturns:\n    An ExchangeResult object containing the exchanged credential and a\n    boolean indicating whether the credential was exchanged.\n\nRaises:\n    CredentialExchangeError: If credential exchange fails."
  omitted_inherited_members_from:
  - abc.ABC
- rank: 314
  id: google.adk.auth.exchanger.base_credential_exchanger.BaseCredentialExchanger.exchange
  name: exchange
  file_path: src/google/adk/auth/exchanger/base_credential_exchanger.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Exchange credential if needed.\n\nArgs:\n    auth_credential: The credential to exchange.\n    auth_scheme: The authentication scheme (optional, some exchangers don't\n      need it).\n\nReturns:\n    An ExchangeResult object containing the exchanged credential and a\n    boolean indicating whether the credential was exchanged.\n\nRaises:\n    CredentialExchangeError: If credential exchange fails."
  signature: 'def exchange(self, auth_credential: google.adk.auth.auth_credential.AuthCredential, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme]) -> google.adk.auth.exchanger.base_credential_exchanger.ExchangeResult:'
- rank: 315
  id: google.adk.auth.exchanger.base_credential_exchanger.CredentialExchangeError
  name: CredentialExchangeError
  file_path: src/google/adk/auth/exchanger/base_credential_exchanger.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Base exception for credential exchange errors.


    [Note: Inherited members from Exception are omitted.]'
  omitted_inherited_members_from:
  - Exception
- rank: 316
  id: google.adk.auth.exchanger.base_credential_exchanger.ExchangeResult
  name: ExchangeResult
  file_path: src/google/adk/auth/exchanger/base_credential_exchanger.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from NamedTuple are omitted.]'
  properties:
  - signature: 'credential: google.adk.auth.auth_credential.AuthCredential'
  - signature: 'was_exchanged: bool'
  omitted_inherited_members_from:
  - NamedTuple
- rank: 317
  id: google.adk.auth.exchanger.credential_exchanger_registry
  name: credential_exchanger_registry
  file_path: src/google/adk/auth/exchanger/credential_exchanger_registry.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Credential exchanger registry.
- rank: 318
  id: google.adk.auth.exchanger.credential_exchanger_registry.CredentialExchangerRegistry
  name: CredentialExchangerRegistry
  file_path: src/google/adk/auth/exchanger/credential_exchanger_registry.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Registry for credential exchanger instances.
  constructor_signature: 'def __init__(self):'
  methods:
  - signature: 'def register(self, credential_type: google.adk.auth.auth_credential.AuthCredentialTypes, exchanger_instance: google.adk.auth.exchanger.base_credential_exchanger.BaseCredentialExchanger) -> None:'
    docstring: "Register an exchanger instance for a credential type.\n\nArgs:\n    credential_type: The credential type to register for.\n    exchanger_instance: The exchanger instance to register."
  - signature: 'def get_exchanger(self, credential_type: google.adk.auth.auth_credential.AuthCredentialTypes) -> typing.Optional[google.adk.auth.exchanger.base_credential_exchanger.BaseCredentialExchanger]:'
    docstring: "Get the exchanger instance for a credential type.\n\nArgs:\n    credential_type: The credential type to get exchanger for.\n\nReturns:\n    The exchanger instance if registered, None otherwise."
- rank: 319
  id: google.adk.auth.exchanger.credential_exchanger_registry.CredentialExchangerRegistry.get_exchanger
  name: get_exchanger
  file_path: src/google/adk/auth/exchanger/credential_exchanger_registry.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Get the exchanger instance for a credential type.\n\nArgs:\n    credential_type: The credential type to get exchanger for.\n\nReturns:\n    The exchanger instance if registered, None otherwise."
  signature: 'def get_exchanger(self, credential_type: google.adk.auth.auth_credential.AuthCredentialTypes) -> typing.Optional[google.adk.auth.exchanger.base_credential_exchanger.BaseCredentialExchanger]:'
- rank: 320
  id: google.adk.auth.exchanger.credential_exchanger_registry.CredentialExchangerRegistry.register
  name: register
  file_path: src/google/adk/auth/exchanger/credential_exchanger_registry.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Register an exchanger instance for a credential type.\n\nArgs:\n    credential_type: The credential type to register for.\n    exchanger_instance: The exchanger instance to register."
  signature: 'def register(self, credential_type: google.adk.auth.auth_credential.AuthCredentialTypes, exchanger_instance: google.adk.auth.exchanger.base_credential_exchanger.BaseCredentialExchanger) -> None:'
- rank: 321
  id: google.adk.auth.exchanger.oauth2_credential_exchanger
  name: oauth2_credential_exchanger
  file_path: src/google/adk/auth/exchanger/oauth2_credential_exchanger.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: OAuth2 credential exchanger implementation.
  properties:
  - signature: 'AUTHLIB_AVAILABLE: bool'
  - signature: 'logger: logging.getLogger'
- rank: 322
  id: google.adk.auth.exchanger.oauth2_credential_exchanger.OAuth2CredentialExchanger
  name: OAuth2CredentialExchanger
  file_path: src/google/adk/auth/exchanger/oauth2_credential_exchanger.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Exchanges OAuth2 credentials from authorization responses.


    [Note: Inherited members from abc.ABC are omitted.]'
  methods:
  - signature: 'def exchange(self, auth_credential: google.adk.auth.auth_credential.AuthCredential, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme]) -> google.adk.auth.exchanger.base_credential_exchanger.ExchangeResult:'
    docstring: "Exchange OAuth2 credential from authorization response.\n\nif credential exchange failed, the original credential will be returned.\n\nArgs:\n    auth_credential: The OAuth2 credential to exchange.\n    auth_scheme: The OAuth2 authentication scheme.\n\nReturns:\n    An ExchangeResult object containing the exchanged credential and a\n    boolean indicating whether the credential was exchanged.\n\nRaises:\n    CredentialExchangeError: If auth_scheme is missing."
  inherited_methods:
    BaseCredentialExchanger:
    - signature: 'def exchange(self, auth_credential: google.adk.auth.auth_credential.AuthCredential, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme]) -> google.adk.auth.exchanger.base_credential_exchanger.ExchangeResult:'
      docstring: "Exchange credential if needed.\n\nArgs:\n    auth_credential: The credential to exchange.\n    auth_scheme: The authentication scheme (optional, some exchangers don't\n      need it).\n\nReturns:\n    An ExchangeResult object containing the exchanged credential and a\n    boolean indicating whether the credential was exchanged.\n\nRaises:\n    CredentialExchangeError: If credential exchange fails."
  omitted_inherited_members_from:
  - abc.ABC
- rank: 323
  id: google.adk.auth.exchanger.oauth2_credential_exchanger.OAuth2CredentialExchanger.exchange
  name: exchange
  file_path: src/google/adk/auth/exchanger/oauth2_credential_exchanger.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Exchange OAuth2 credential from authorization response.\n\nif credential exchange failed, the original credential will be returned.\n\nArgs:\n    auth_credential: The OAuth2 credential to exchange.\n    auth_scheme: The OAuth2 authentication scheme.\n\nReturns:\n    An ExchangeResult object containing the exchanged credential and a\n    boolean indicating whether the credential was exchanged.\n\nRaises:\n    CredentialExchangeError: If auth_scheme is missing."
  signature: 'def exchange(self, auth_credential: google.adk.auth.auth_credential.AuthCredential, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme]) -> google.adk.auth.exchanger.base_credential_exchanger.ExchangeResult:'
- rank: 324
  id: google.adk.auth.oauth2_credential_util
  name: oauth2_credential_util
  file_path: src/google/adk/auth/oauth2_credential_util.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def create_oauth2_session(auth_scheme: google.adk.auth.auth_schemes.AuthScheme, auth_credential: google.adk.auth.auth_credential.AuthCredential) -> typing.Tuple[typing.Optional[authlib.integrations.requests_client.OAuth2Session], typing.Optional[str]]:'
    docstring: "Create an OAuth2 session for token operations.\n\nArgs:\n    auth_scheme: The authentication scheme configuration.\n    auth_credential: The authentication credential.\n\nReturns:\n    Tuple of (OAuth2Session, token_endpoint) or (None, None) if cannot create session."
  - signature: 'def update_credential_with_tokens(auth_credential: google.adk.auth.auth_credential.AuthCredential, tokens: authlib.oauth2.rfc6749.OAuth2Token) -> None:'
    docstring: "Update the credential with new tokens.\n\nArgs:\n    auth_credential: The authentication credential to update.\n    tokens: The OAuth2Token object containing new token information."
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 325
  id: google.adk.auth.oauth2_credential_util.create_oauth2_session
  name: create_oauth2_session
  file_path: src/google/adk/auth/oauth2_credential_util.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Create an OAuth2 session for token operations.\n\nArgs:\n    auth_scheme: The authentication scheme configuration.\n    auth_credential: The authentication credential.\n\nReturns:\n    Tuple of (OAuth2Session, token_endpoint) or (None, None) if cannot create session."
  signature: 'def create_oauth2_session(auth_scheme: google.adk.auth.auth_schemes.AuthScheme, auth_credential: google.adk.auth.auth_credential.AuthCredential) -> typing.Tuple[typing.Optional[authlib.integrations.requests_client.OAuth2Session], typing.Optional[str]]:'
- rank: 326
  id: google.adk.auth.oauth2_credential_util.update_credential_with_tokens
  name: update_credential_with_tokens
  file_path: src/google/adk/auth/oauth2_credential_util.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Update the credential with new tokens.\n\nArgs:\n    auth_credential: The authentication credential to update.\n    tokens: The OAuth2Token object containing new token information."
  signature: 'def update_credential_with_tokens(auth_credential: google.adk.auth.auth_credential.AuthCredential, tokens: authlib.oauth2.rfc6749.OAuth2Token) -> None:'
- rank: 327
  id: google.adk.auth.oauth2_discovery
  name: oauth2_discovery
  file_path: src/google/adk/auth/oauth2_discovery.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 328
  id: google.adk.auth.oauth2_discovery.AuthorizationServerMetadata
  name: AuthorizationServerMetadata
  file_path: src/google/adk/auth/oauth2_discovery.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Represents the OAuth2 authorization server metadata per RFC8414.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, issuer: str, authorization_endpoint: str, token_endpoint: str, scopes_supported: typing.Optional[typing.List[str]] = None, registration_endpoint: typing.Optional[str] = None):'
  properties:
  - signature: 'issuer: str'
  - signature: 'authorization_endpoint: str'
  - signature: 'token_endpoint: str'
  - signature: 'scopes_supported: typing.Optional[typing.List[str]]'
  - signature: 'registration_endpoint: typing.Optional[str]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 329
  id: google.adk.auth.oauth2_discovery.OAuth2DiscoveryManager
  name: OAuth2DiscoveryManager
  file_path: src/google/adk/auth/oauth2_discovery.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Implements Metadata discovery for OAuth2 following RFC8414 and RFC9728.
  methods:
  - signature: 'def discover_auth_server_metadata(self, issuer_url: str) -> typing.Optional[google.adk.auth.oauth2_discovery.AuthorizationServerMetadata]:'
    docstring: Discovers the OAuth2 authorization server metadata.
  - signature: 'def discover_resource_metadata(self, resource_url: str) -> typing.Optional[google.adk.auth.oauth2_discovery.ProtectedResourceMetadata]:'
    docstring: Discovers the OAuth2 protected resource metadata.
- rank: 330
  id: google.adk.auth.oauth2_discovery.OAuth2DiscoveryManager.discover_auth_server_metadata
  name: discover_auth_server_metadata
  file_path: src/google/adk/auth/oauth2_discovery.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Discovers the OAuth2 authorization server metadata.
  signature: 'def discover_auth_server_metadata(self, issuer_url: str) -> typing.Optional[google.adk.auth.oauth2_discovery.AuthorizationServerMetadata]:'
- rank: 331
  id: google.adk.auth.oauth2_discovery.OAuth2DiscoveryManager.discover_resource_metadata
  name: discover_resource_metadata
  file_path: src/google/adk/auth/oauth2_discovery.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Discovers the OAuth2 protected resource metadata.
  signature: 'def discover_resource_metadata(self, resource_url: str) -> typing.Optional[google.adk.auth.oauth2_discovery.ProtectedResourceMetadata]:'
- rank: 332
  id: google.adk.auth.oauth2_discovery.ProtectedResourceMetadata
  name: ProtectedResourceMetadata
  file_path: src/google/adk/auth/oauth2_discovery.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Represents the OAuth2 protected resource metadata per RFC9728.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, resource: str, authorization_servers: typing.List[str] = []):'
  properties:
  - signature: 'resource: str'
  - signature: 'authorization_servers: typing.List[str]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 333
  id: google.adk.auth.refresher
  name: refresher
  file_path: src/google/adk/auth/refresher/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Credential refresher module.
  properties:
  - signature: '__all__: Any'
- rank: 334
  id: google.adk.auth.refresher.base_credential_refresher
  name: base_credential_refresher
  file_path: src/google/adk/auth/refresher/base_credential_refresher.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Base credential refresher interface.
- rank: 335
  id: google.adk.auth.refresher.base_credential_refresher.BaseCredentialRefresher
  name: BaseCredentialRefresher
  file_path: src/google/adk/auth/refresher/base_credential_refresher.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Base interface for credential refreshers.


    Credential refreshers are responsible for checking if a credential is expired

    or needs to be refreshed, and for refreshing it if necessary.


    [Note: Inherited members from abc.ABC are omitted.]'
  methods:
  - signature: 'def is_refresh_needed(self, auth_credential: google.adk.auth.auth_credential.AuthCredential, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme]) -> bool:'
    docstring: "Checks if a credential needs to be refreshed.\n\nArgs:\n    auth_credential: The credential to check.\n    auth_scheme: The authentication scheme (optional, some refreshers don't need it).\n\nReturns:\n    True if the credential needs to be refreshed, False otherwise."
  - signature: 'def refresh(self, auth_credential: google.adk.auth.auth_credential.AuthCredential, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme]) -> google.adk.auth.auth_credential.AuthCredential:'
    docstring: "Refreshes a credential if needed.\n\nArgs:\n    auth_credential: The credential to refresh.\n    auth_scheme: The authentication scheme (optional, some refreshers don't need it).\n\nReturns:\n    The refreshed credential.\n\nRaises:\n    CredentialRefresherError: If credential refresh fails."
  omitted_inherited_members_from:
  - abc.ABC
- rank: 336
  id: google.adk.auth.refresher.base_credential_refresher.BaseCredentialRefresher.is_refresh_needed
  name: is_refresh_needed
  file_path: src/google/adk/auth/refresher/base_credential_refresher.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Checks if a credential needs to be refreshed.\n\nArgs:\n    auth_credential: The credential to check.\n    auth_scheme: The authentication scheme (optional, some refreshers don't need it).\n\nReturns:\n    True if the credential needs to be refreshed, False otherwise."
  signature: 'def is_refresh_needed(self, auth_credential: google.adk.auth.auth_credential.AuthCredential, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme]) -> bool:'
- rank: 337
  id: google.adk.auth.refresher.base_credential_refresher.BaseCredentialRefresher.refresh
  name: refresh
  file_path: src/google/adk/auth/refresher/base_credential_refresher.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Refreshes a credential if needed.\n\nArgs:\n    auth_credential: The credential to refresh.\n    auth_scheme: The authentication scheme (optional, some refreshers don't need it).\n\nReturns:\n    The refreshed credential.\n\nRaises:\n    CredentialRefresherError: If credential refresh fails."
  signature: 'def refresh(self, auth_credential: google.adk.auth.auth_credential.AuthCredential, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme]) -> google.adk.auth.auth_credential.AuthCredential:'
- rank: 338
  id: google.adk.auth.refresher.base_credential_refresher.CredentialRefresherError
  name: CredentialRefresherError
  file_path: src/google/adk/auth/refresher/base_credential_refresher.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Base exception for credential refresh errors.


    [Note: Inherited members from Exception are omitted.]'
  omitted_inherited_members_from:
  - Exception
- rank: 339
  id: google.adk.auth.refresher.credential_refresher_registry
  name: credential_refresher_registry
  file_path: src/google/adk/auth/refresher/credential_refresher_registry.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Credential refresher registry.
- rank: 340
  id: google.adk.auth.refresher.credential_refresher_registry.CredentialRefresherRegistry
  name: CredentialRefresherRegistry
  file_path: src/google/adk/auth/refresher/credential_refresher_registry.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Registry for credential refresher instances.
  constructor_signature: 'def __init__(self):'
  methods:
  - signature: 'def register(self, credential_type: google.adk.auth.auth_credential.AuthCredentialTypes, refresher_instance: google.adk.auth.refresher.base_credential_refresher.BaseCredentialRefresher) -> None:'
    docstring: "Register a refresher instance for a credential type.\n\nArgs:\n    credential_type: The credential type to register for.\n    refresher_instance: The refresher instance to register."
  - signature: 'def get_refresher(self, credential_type: google.adk.auth.auth_credential.AuthCredentialTypes) -> typing.Optional[google.adk.auth.refresher.base_credential_refresher.BaseCredentialRefresher]:'
    docstring: "Get the refresher instance for a credential type.\n\nArgs:\n    credential_type: The credential type to get refresher for.\n\nReturns:\n    The refresher instance if registered, None otherwise."
- rank: 341
  id: google.adk.auth.refresher.credential_refresher_registry.CredentialRefresherRegistry.get_refresher
  name: get_refresher
  file_path: src/google/adk/auth/refresher/credential_refresher_registry.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Get the refresher instance for a credential type.\n\nArgs:\n    credential_type: The credential type to get refresher for.\n\nReturns:\n    The refresher instance if registered, None otherwise."
  signature: 'def get_refresher(self, credential_type: google.adk.auth.auth_credential.AuthCredentialTypes) -> typing.Optional[google.adk.auth.refresher.base_credential_refresher.BaseCredentialRefresher]:'
- rank: 342
  id: google.adk.auth.refresher.credential_refresher_registry.CredentialRefresherRegistry.register
  name: register
  file_path: src/google/adk/auth/refresher/credential_refresher_registry.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Register a refresher instance for a credential type.\n\nArgs:\n    credential_type: The credential type to register for.\n    refresher_instance: The refresher instance to register."
  signature: 'def register(self, credential_type: google.adk.auth.auth_credential.AuthCredentialTypes, refresher_instance: google.adk.auth.refresher.base_credential_refresher.BaseCredentialRefresher) -> None:'
- rank: 343
  id: google.adk.auth.refresher.oauth2_credential_refresher
  name: oauth2_credential_refresher
  file_path: src/google/adk/auth/refresher/oauth2_credential_refresher.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: OAuth2 credential refresher implementation.
  properties:
  - signature: 'AUTHLIB_AVAILABLE: bool'
  - signature: 'logger: logging.getLogger'
- rank: 344
  id: google.adk.auth.refresher.oauth2_credential_refresher.OAuth2CredentialRefresher
  name: OAuth2CredentialRefresher
  file_path: src/google/adk/auth/refresher/oauth2_credential_refresher.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Refreshes OAuth2 credentials including Google OAuth2 JSON credentials.


    [Note: Inherited members from abc.ABC are omitted.]'
  methods:
  - signature: 'def is_refresh_needed(self, auth_credential: google.adk.auth.auth_credential.AuthCredential, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme]) -> bool:'
    docstring: "Check if the OAuth2 credential needs to be refreshed.\n\nArgs:\n    auth_credential: The OAuth2 credential to check.\n    auth_scheme: The OAuth2 authentication scheme (optional for Google OAuth2 JSON).\n\nReturns:\n    True if the credential needs to be refreshed, False otherwise."
  - signature: 'def refresh(self, auth_credential: google.adk.auth.auth_credential.AuthCredential, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme]) -> google.adk.auth.auth_credential.AuthCredential:'
    docstring: "Refresh the OAuth2 credential.\nIf refresh failed, return the original credential.\n\nArgs:\n    auth_credential: The OAuth2 credential to refresh.\n    auth_scheme: The OAuth2 authentication scheme (optional for Google OAuth2 JSON).\n\nReturns:\n    The refreshed credential."
  inherited_methods:
    BaseCredentialRefresher:
    - signature: 'def is_refresh_needed(self, auth_credential: google.adk.auth.auth_credential.AuthCredential, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme]) -> bool:'
      docstring: "Checks if a credential needs to be refreshed.\n\nArgs:\n    auth_credential: The credential to check.\n    auth_scheme: The authentication scheme (optional, some refreshers don't need it).\n\nReturns:\n    True if the credential needs to be refreshed, False otherwise."
    - signature: 'def refresh(self, auth_credential: google.adk.auth.auth_credential.AuthCredential, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme]) -> google.adk.auth.auth_credential.AuthCredential:'
      docstring: "Refreshes a credential if needed.\n\nArgs:\n    auth_credential: The credential to refresh.\n    auth_scheme: The authentication scheme (optional, some refreshers don't need it).\n\nReturns:\n    The refreshed credential.\n\nRaises:\n    CredentialRefresherError: If credential refresh fails."
  omitted_inherited_members_from:
  - abc.ABC
- rank: 345
  id: google.adk.auth.refresher.oauth2_credential_refresher.OAuth2CredentialRefresher.is_refresh_needed
  name: is_refresh_needed
  file_path: src/google/adk/auth/refresher/oauth2_credential_refresher.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Check if the OAuth2 credential needs to be refreshed.\n\nArgs:\n    auth_credential: The OAuth2 credential to check.\n    auth_scheme: The OAuth2 authentication scheme (optional for Google OAuth2 JSON).\n\nReturns:\n    True if the credential needs to be refreshed, False otherwise."
  signature: 'def is_refresh_needed(self, auth_credential: google.adk.auth.auth_credential.AuthCredential, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme]) -> bool:'
- rank: 346
  id: google.adk.auth.refresher.oauth2_credential_refresher.OAuth2CredentialRefresher.refresh
  name: refresh
  file_path: src/google/adk/auth/refresher/oauth2_credential_refresher.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Refresh the OAuth2 credential.\nIf refresh failed, return the original credential.\n\nArgs:\n    auth_credential: The OAuth2 credential to refresh.\n    auth_scheme: The OAuth2 authentication scheme (optional for Google OAuth2 JSON).\n\nReturns:\n    The refreshed credential."
  signature: 'def refresh(self, auth_credential: google.adk.auth.auth_credential.AuthCredential, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme]) -> google.adk.auth.auth_credential.AuthCredential:'
- rank: 347
  id: google.adk.cli
  name: cli
  file_path: src/google/adk/cli/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 348
  id: google.adk.cli.adk_web_server
  name: adk_web_server
  file_path: src/google/adk/cli/adk_web_server.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '_EVAL_SET_FILE_EXTENSION: str'
  - signature: 'TAG_DEBUG: str'
  - signature: 'TAG_EVALUATION: str'
  - signature: '_REGEX_PREFIX: str'
- rank: 349
  id: google.adk.cli.adk_web_server.AddSessionToEvalSetRequest
  name: AddSessionToEvalSetRequest
  file_path: src/google/adk/cli/adk_web_server.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, eval_id: str, session_id: str, user_id: str):'
  properties:
  - signature: 'eval_id: str'
  - signature: 'session_id: str'
  - signature: 'user_id: str'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 350
  id: google.adk.cli.adk_web_server.AdkWebServer
  name: AdkWebServer
  file_path: src/google/adk/cli/adk_web_server.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "Helper class for setting up and running the ADK web server on FastAPI.\n\nYou construct this class with all the Services required to run ADK agents and\ncan then call the get_fast_api_app method to get a FastAPI app instance that\ncan will use your provided service instances, static assets, and agent loader.\nIf you pass in a web_assets_dir, the static assets will be served under\n/dev-ui in addition to the API endpoints created by default.\n\nYou can add additional API endpoints by modifying the FastAPI app\ninstance returned by get_fast_api_app as this class exposes the agent runners\nand most other bits of state retained during the lifetime of the server.\n\nAttributes:\n    agent_loader: An instance of BaseAgentLoader for loading agents.\n    session_service: An instance of BaseSessionService for managing sessions.\n    memory_service: An instance of BaseMemoryService for managing memory.\n    artifact_service: An instance of BaseArtifactService for managing\n      artifacts.\n\
    \    credential_service: An instance of BaseCredentialService for managing\n      credentials.\n    eval_sets_manager: An instance of EvalSetsManager for managing evaluation\n      sets.\n    eval_set_results_manager: An instance of EvalSetResultsManager for\n      managing evaluation set results.\n    agents_dir: Root directory containing subdirs for agents with those\n      containing resources (e.g. .env files, eval sets, etc.) for the agents.\n    extra_plugins: A list of fully qualified names of extra plugins to load.\n    logo_text: Text to display in the logo of the UI.\n    logo_image_url: URL of an image to display as logo of the UI.\n    runners_to_clean: Set of runner names marked for cleanup.\n    current_app_name_ref: A shared reference to the latest ran app name.\n    runner_dict: A dict of instantiated runners for each app."
  constructor_signature: 'def __init__(self, *, agent_loader: google.adk.cli.utils.base_agent_loader.BaseAgentLoader, session_service: google.adk.sessions.base_session_service.BaseSessionService, memory_service: google.adk.memory.base_memory_service.BaseMemoryService, artifact_service: google.adk.artifacts.base_artifact_service.BaseArtifactService, credential_service: google.adk.auth.credential_service.base_credential_service.BaseCredentialService, eval_sets_manager: google.adk.evaluation.eval_sets_manager.EvalSetsManager, eval_set_results_manager: google.adk.evaluation.eval_set_results_manager.EvalSetResultsManager, agents_dir: str, extra_plugins: typing.Optional[list[str]]=None, logo_text: typing.Optional[str]=None, logo_image_url: typing.Optional[str]=None, url_prefix: typing.Optional[str]=None):'
  methods:
  - signature: 'def get_runner_async(self, app_name: str) -> google.adk.runners.Runner:'
    docstring: Returns the cached runner for the given app.
  - signature: 'def get_fast_api_app(self, lifespan: typing.Optional[starlette.types.Lifespan[fastapi.FastAPI]], allow_origins: typing.Optional[list[str]], web_assets_dir: typing.Optional[str], setup_observer: typing.Callable[[Observer, ''AdkWebServer''], None], tear_down_observer: typing.Callable[[Observer, ''AdkWebServer''], None], register_processors: typing.Callable[[TracerProvider], None], otel_to_cloud: bool):'
    docstring: "Creates a FastAPI app for the ADK web server.\n\nBy default it'll just return a FastAPI instance with the API server\nendpoints,\nbut if you specify a web_assets_dir, it'll also serve the static web assets\nfrom that directory.\n\nArgs:\n  lifespan: The lifespan of the FastAPI app.\n  allow_origins: The origins that are allowed to make cross-origin requests.\n    Entries can be literal origins (e.g., 'https://example.com') or regex\n    patterns prefixed with 'regex:' (e.g., 'regex:https://.*\\.example\\.com').\n  web_assets_dir: The directory containing the web assets to serve.\n  setup_observer: Callback for setting up the file system observer.\n  tear_down_observer: Callback for cleaning up the file system observer.\n  register_processors: Callback for additional Span processors to be added\n    to the TracerProvider.\n  otel_to_cloud: Whether to enable Cloud Trace and Cloud Logging\n    integrations.\n\nReturns:\n  A FastAPI app instance."
- rank: 351
  id: google.adk.cli.adk_web_server.AdkWebServer.__init__
  name: __init__
  file_path: src/google/adk/cli/adk_web_server.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, *, agent_loader: google.adk.cli.utils.base_agent_loader.BaseAgentLoader, session_service: google.adk.sessions.base_session_service.BaseSessionService, memory_service: google.adk.memory.base_memory_service.BaseMemoryService, artifact_service: google.adk.artifacts.base_artifact_service.BaseArtifactService, credential_service: google.adk.auth.credential_service.base_credential_service.BaseCredentialService, eval_sets_manager: google.adk.evaluation.eval_sets_manager.EvalSetsManager, eval_set_results_manager: google.adk.evaluation.eval_set_results_manager.EvalSetResultsManager, agents_dir: str, extra_plugins: typing.Optional[list[str]]=None, logo_text: typing.Optional[str]=None, logo_image_url: typing.Optional[str]=None, url_prefix: typing.Optional[str]=None):'
- rank: 352
  id: google.adk.cli.adk_web_server.AdkWebServer.get_fast_api_app
  name: get_fast_api_app
  file_path: src/google/adk/cli/adk_web_server.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Creates a FastAPI app for the ADK web server.\n\nBy default it'll just return a FastAPI instance with the API server\nendpoints,\nbut if you specify a web_assets_dir, it'll also serve the static web assets\nfrom that directory.\n\nArgs:\n  lifespan: The lifespan of the FastAPI app.\n  allow_origins: The origins that are allowed to make cross-origin requests.\n    Entries can be literal origins (e.g., 'https://example.com') or regex\n    patterns prefixed with 'regex:' (e.g., 'regex:https://.*\\.example\\.com').\n  web_assets_dir: The directory containing the web assets to serve.\n  setup_observer: Callback for setting up the file system observer.\n  tear_down_observer: Callback for cleaning up the file system observer.\n  register_processors: Callback for additional Span processors to be added\n    to the TracerProvider.\n  otel_to_cloud: Whether to enable Cloud Trace and Cloud Logging\n    integrations.\n\nReturns:\n  A FastAPI app instance."
  signature: 'def get_fast_api_app(self, lifespan: typing.Optional[starlette.types.Lifespan[fastapi.FastAPI]], allow_origins: typing.Optional[list[str]], web_assets_dir: typing.Optional[str], setup_observer: typing.Callable[[Observer, ''AdkWebServer''], None], tear_down_observer: typing.Callable[[Observer, ''AdkWebServer''], None], register_processors: typing.Callable[[TracerProvider], None], otel_to_cloud: bool):'
- rank: 353
  id: google.adk.cli.adk_web_server.AdkWebServer.get_runner_async
  name: get_runner_async
  file_path: src/google/adk/cli/adk_web_server.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns the cached runner for the given app.
  signature: 'def get_runner_async(self, app_name: str) -> google.adk.runners.Runner:'
- rank: 354
  id: google.adk.cli.adk_web_server.ApiServerSpanExporter
  name: ApiServerSpanExporter
  file_path: src/google/adk/cli/adk_web_server.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from export_lib.SpanExporter are omitted.]'
  constructor_signature: 'def __init__(self, trace_dict):'
  methods:
  - signature: 'def export(self, spans: typing.Sequence[opentelemetry.sdk.trace.ReadableSpan]) -> opentelemetry.sdk.trace.export.SpanExportResult:'
  - signature: 'def force_flush(self, timeout_millis: int) -> bool:'
  omitted_inherited_members_from:
  - export_lib.SpanExporter
- rank: 355
  id: google.adk.cli.adk_web_server.ApiServerSpanExporter.export
  name: export
  file_path: src/google/adk/cli/adk_web_server.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def export(self, spans: typing.Sequence[opentelemetry.sdk.trace.ReadableSpan]) -> opentelemetry.sdk.trace.export.SpanExportResult:'
- rank: 356
  id: google.adk.cli.adk_web_server.AppInfo
  name: AppInfo
  file_path: src/google/adk/cli/adk_web_server.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, name: str, root_agent_name: str, description: str, language: typing.Literal[yaml, python], is_computer_use: bool = False):'
  properties:
  - signature: 'name: str'
  - signature: 'root_agent_name: str'
  - signature: 'description: str'
  - signature: 'language: typing.Literal[yaml, python]'
  - signature: 'is_computer_use: bool'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 357
  id: google.adk.cli.adk_web_server.CreateEvalSetRequest
  name: CreateEvalSetRequest
  file_path: src/google/adk/cli/adk_web_server.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, eval_set: google.adk.evaluation.eval_set.EvalSet):'
  properties:
  - signature: 'eval_set: google.adk.evaluation.eval_set.EvalSet'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 358
  id: google.adk.cli.adk_web_server.CreateSessionRequest
  name: CreateSessionRequest
  file_path: src/google/adk/cli/adk_web_server.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, session_id: typing.Optional[str] = None, state: typing.Optional[dict[str, typing.Any]] = None, events: typing.Optional[list[google.adk.events.event.Event]] = None):'
  properties:
  - signature: 'session_id: typing.Optional[str]'
  - signature: 'state: typing.Optional[dict[str, typing.Any]]'
  - signature: 'events: typing.Optional[list[google.adk.events.event.Event]]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 359
  id: google.adk.cli.adk_web_server.EvalResult
  name: EvalResult
  file_path: src/google/adk/cli/adk_web_server.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'This class has no field intentionally.


    The goal here is to just give a new name to the class to align with the API

    endpoint.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, eval_set_result_id: str, eval_set_result_name: typing.Optional[str] = None, eval_set_id: str, eval_case_results: list[google.adk.evaluation.eval_result.EvalCaseResult] = list(), creation_timestamp: float = 0.0):'
  inherited_properties:
    EvalSetResult:
    - signature: 'model_config: pydantic.ConfigDict'
    - signature: 'eval_set_result_id: str'
    - signature: 'eval_set_result_name: typing.Optional[str]'
    - signature: 'eval_set_id: str'
    - signature: 'eval_case_results: list[google.adk.evaluation.eval_result.EvalCaseResult]'
    - signature: 'creation_timestamp: float'
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 360
  id: google.adk.cli.adk_web_server.GetEventGraphResult
  name: GetEventGraphResult
  file_path: src/google/adk/cli/adk_web_server.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, dot_src: str):'
  properties:
  - signature: 'dot_src: str'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 361
  id: google.adk.cli.adk_web_server.InMemoryExporter
  name: InMemoryExporter
  file_path: src/google/adk/cli/adk_web_server.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from export_lib.SpanExporter are omitted.]'
  constructor_signature: 'def __init__(self, trace_dict):'
  methods:
  - signature: 'def export(self, spans: typing.Sequence[opentelemetry.sdk.trace.ReadableSpan]) -> opentelemetry.sdk.trace.export.SpanExportResult:'
  - signature: 'def force_flush(self, timeout_millis: int) -> bool:'
  - signature: 'def get_finished_spans(self, session_id: str):'
  - signature: 'def clear(self):'
  omitted_inherited_members_from:
  - export_lib.SpanExporter
- rank: 362
  id: google.adk.cli.adk_web_server.InMemoryExporter.__init__
  name: __init__
  file_path: src/google/adk/cli/adk_web_server.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, trace_dict):'
- rank: 363
  id: google.adk.cli.adk_web_server.InMemoryExporter.export
  name: export
  file_path: src/google/adk/cli/adk_web_server.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def export(self, spans: typing.Sequence[opentelemetry.sdk.trace.ReadableSpan]) -> opentelemetry.sdk.trace.export.SpanExportResult:'
- rank: 364
  id: google.adk.cli.adk_web_server.InMemoryExporter.get_finished_spans
  name: get_finished_spans
  file_path: src/google/adk/cli/adk_web_server.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_finished_spans(self, session_id: str):'
- rank: 365
  id: google.adk.cli.adk_web_server.ListAppsResponse
  name: ListAppsResponse
  file_path: src/google/adk/cli/adk_web_server.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, apps: list[google.adk.cli.adk_web_server.AppInfo]):'
  properties:
  - signature: 'apps: list[google.adk.cli.adk_web_server.AppInfo]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 366
  id: google.adk.cli.adk_web_server.ListEvalResultsResponse
  name: ListEvalResultsResponse
  file_path: src/google/adk/cli/adk_web_server.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, eval_result_ids: list[str]):'
  properties:
  - signature: 'eval_result_ids: list[str]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 367
  id: google.adk.cli.adk_web_server.ListEvalSetsResponse
  name: ListEvalSetsResponse
  file_path: src/google/adk/cli/adk_web_server.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, eval_set_ids: list[str]):'
  properties:
  - signature: 'eval_set_ids: list[str]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 368
  id: google.adk.cli.adk_web_server.ListMetricsInfoResponse
  name: ListMetricsInfoResponse
  file_path: src/google/adk/cli/adk_web_server.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, metrics_info: list[google.adk.evaluation.eval_metrics.MetricInfo]):'
  properties:
  - signature: 'metrics_info: list[google.adk.evaluation.eval_metrics.MetricInfo]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 369
  id: google.adk.cli.adk_web_server.RunAgentRequest
  name: RunAgentRequest
  file_path: src/google/adk/cli/adk_web_server.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, app_name: str, user_id: str, session_id: str, new_message: google.genai.types.Content, streaming: bool = False, state_delta: typing.Optional[dict[str, typing.Any]] = None):'
  properties:
  - signature: 'app_name: str'
  - signature: 'user_id: str'
  - signature: 'session_id: str'
  - signature: 'new_message: google.genai.types.Content'
  - signature: 'streaming: bool'
  - signature: 'state_delta: typing.Optional[dict[str, typing.Any]]'
  - signature: 'invocation_id: typing.Optional[str]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 370
  id: google.adk.cli.adk_web_server.RunEvalRequest
  name: RunEvalRequest
  file_path: src/google/adk/cli/adk_web_server.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, eval_ids: list[str] = list(), eval_case_ids: list[str] = list(), eval_metrics: list[google.adk.evaluation.eval_metrics.EvalMetric]):'
  properties:
  - signature: 'eval_ids: list[str]'
  - signature: 'eval_case_ids: list[str]'
  - signature: 'eval_metrics: list[google.adk.evaluation.eval_metrics.EvalMetric]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 371
  id: google.adk.cli.adk_web_server.RunEvalResponse
  name: RunEvalResponse
  file_path: src/google/adk/cli/adk_web_server.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, run_eval_results: list[google.adk.cli.adk_web_server.RunEvalResult]):'
  properties:
  - signature: 'run_eval_results: list[google.adk.cli.adk_web_server.RunEvalResult]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 372
  id: google.adk.cli.adk_web_server.RunEvalResult
  name: RunEvalResult
  file_path: src/google/adk/cli/adk_web_server.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, eval_set_file: str, eval_set_id: str, eval_id: str, final_eval_status: google.adk.evaluation.eval_metrics.EvalStatus, eval_metric_results: list[tuple[google.adk.evaluation.eval_metrics.EvalMetric, google.adk.evaluation.eval_metrics.EvalMetricResult]] = [], overall_eval_metric_results: list[google.adk.evaluation.eval_metrics.EvalMetricResult], eval_metric_result_per_invocation: list[google.adk.evaluation.eval_metrics.EvalMetricResultPerInvocation], user_id: str, session_id: str):'
  properties:
  - signature: 'eval_set_file: str'
  - signature: 'eval_set_id: str'
  - signature: 'eval_id: str'
  - signature: 'final_eval_status: google.adk.evaluation.eval_metrics.EvalStatus'
  - signature: 'eval_metric_results: list[tuple[google.adk.evaluation.eval_metrics.EvalMetric, google.adk.evaluation.eval_metrics.EvalMetricResult]]'
  - signature: 'overall_eval_metric_results: list[google.adk.evaluation.eval_metrics.EvalMetricResult]'
  - signature: 'eval_metric_result_per_invocation: list[google.adk.evaluation.eval_metrics.EvalMetricResultPerInvocation]'
  - signature: 'user_id: str'
  - signature: 'session_id: str'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 373
  id: google.adk.cli.adk_web_server.SaveArtifactRequest
  name: SaveArtifactRequest
  file_path: src/google/adk/cli/adk_web_server.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Request payload for saving a new artifact.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, filename: str, artifact: google.genai.types.Part, custom_metadata: typing.Optional[dict[str, typing.Any]] = None):'
  properties:
  - signature: 'filename: str'
  - signature: 'artifact: google.genai.types.Part'
  - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 374
  id: google.adk.cli.adk_web_server.UpdateMemoryRequest
  name: UpdateMemoryRequest
  file_path: src/google/adk/cli/adk_web_server.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Request to add a session to the memory service.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, session_id: str):'
  properties:
  - signature: 'session_id: str'
    docstring: The ID of the session to add to memory.
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 375
  id: google.adk.cli.adk_web_server.UpdateSessionRequest
  name: UpdateSessionRequest
  file_path: src/google/adk/cli/adk_web_server.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Request to update session state without running the agent.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, state_delta: dict[str, typing.Any]):'
  properties:
  - signature: 'state_delta: dict[str, typing.Any]'
    docstring: The state changes to apply to the session.
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 376
  id: google.adk.cli.agent_graph
  name: agent_graph
  file_path: src/google/adk/cli/agent_graph.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def build_graph(graph: graphviz.Digraph, agent: google.adk.agents.base_agent.BaseAgent, highlight_pairs, parent_agent):'
    docstring: "Build a graph of the agent and its sub-agents.\nArgs:\n  graph: The graph to build on.\n  agent: The agent to build the graph for.\n  highlight_pairs: A list of pairs of nodes to highlight.\n  parent_agent: The parent agent of the current agent. This is specifically used when building Workflow Agents to directly connect a node to nodes inside a Workflow Agent.\n\nReturns:\n  None"
  - signature: 'def get_agent_graph(root_agent, highlights_pairs, image):'
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: 'retrieval_tool_module_loaded: bool'
- rank: 377
  id: google.adk.cli.agent_graph.build_graph
  name: build_graph
  file_path: src/google/adk/cli/agent_graph.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Build a graph of the agent and its sub-agents.\nArgs:\n  graph: The graph to build on.\n  agent: The agent to build the graph for.\n  highlight_pairs: A list of pairs of nodes to highlight.\n  parent_agent: The parent agent of the current agent. This is specifically used when building Workflow Agents to directly connect a node to nodes inside a Workflow Agent.\n\nReturns:\n  None"
  signature: 'def build_graph(graph: graphviz.Digraph, agent: google.adk.agents.base_agent.BaseAgent, highlight_pairs, parent_agent):'
- rank: 378
  id: google.adk.cli.agent_graph.get_agent_graph
  name: get_agent_graph
  file_path: src/google/adk/cli/agent_graph.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_agent_graph(root_agent, highlights_pairs, image):'
- rank: 379
  id: google.adk.cli.built_in_agents
  name: built_in_agents
  file_path: src/google/adk/cli/built_in_agents/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: 'Agent Builder Assistant for ADK.


    This package provides an intelligent assistant for building multi-agent systems

    using YAML configurations. It can be used directly as an agent or integrated

    with ADK tools and web interfaces.'
  properties:
  - signature: '__all__: Any'
- rank: 380
  id: google.adk.cli.built_in_agents.adk_agent_builder_assistant
  name: adk_agent_builder_assistant
  file_path: src/google/adk/cli/built_in_agents/adk_agent_builder_assistant.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Agent factory for creating Agent Builder Assistant with embedded schema.
  properties:
  - signature: 'root_agent: google.adk.cli.built_in_agents.adk_agent_builder_assistant.AgentBuilderAssistant.create_agent'
- rank: 381
  id: google.adk.cli.built_in_agents.adk_agent_builder_assistant.AgentBuilderAssistant
  name: AgentBuilderAssistant
  file_path: src/google/adk/cli/built_in_agents/adk_agent_builder_assistant.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Agent Builder Assistant factory for creating configured instances.
  methods:
  - signature: 'def create_agent(model: typing.Union[str, google.adk.models.BaseLlm], working_directory: typing.Optional[str]) -> google.adk.agents.LlmAgent:'
    docstring: "Create Agent Builder Assistant with embedded ADK AgentConfig schema.\n\nArgs:\n  model: Model to use for the assistant (default: gemini-2.5-flash)\n  working_directory: Working directory for path resolution (default: current\n    working directory)\n\nReturns:\n  Configured LlmAgent with embedded ADK AgentConfig schema"
- rank: 382
  id: google.adk.cli.built_in_agents.adk_agent_builder_assistant.AgentBuilderAssistant.create_agent
  name: create_agent
  file_path: src/google/adk/cli/built_in_agents/adk_agent_builder_assistant.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Create Agent Builder Assistant with embedded ADK AgentConfig schema.\n\nArgs:\n  model: Model to use for the assistant (default: gemini-2.5-flash)\n  working_directory: Working directory for path resolution (default: current\n    working directory)\n\nReturns:\n  Configured LlmAgent with embedded ADK AgentConfig schema"
  signature: 'def create_agent(model: typing.Union[str, google.adk.models.BaseLlm], working_directory: typing.Optional[str]) -> google.adk.agents.LlmAgent:'
- rank: 383
  id: google.adk.cli.built_in_agents.agent
  name: agent
  file_path: src/google/adk/cli/built_in_agents/agent.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Agent Builder Assistant instance for ADK web testing.
  properties:
  - signature: 'root_agent: google.adk.cli.built_in_agents.adk_agent_builder_assistant.AgentBuilderAssistant.create_agent'
- rank: 384
  id: google.adk.cli.built_in_agents.sub_agents
  name: sub_agents
  file_path: src/google/adk/cli/built_in_agents/sub_agents/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Sub-agents for Agent Builder Assistant.
  properties:
  - signature: '__all__: Any'
- rank: 385
  id: google.adk.cli.built_in_agents.sub_agents.google_search_agent
  name: google_search_agent
  file_path: src/google/adk/cli/built_in_agents/sub_agents/google_search_agent.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Sub-agent for Google Search functionality.
  methods:
  - signature: 'def create_google_search_agent() -> google.adk.agents.LlmAgent:'
    docstring: Create a sub-agent that only uses google_search tool.
- rank: 386
  id: google.adk.cli.built_in_agents.sub_agents.google_search_agent.create_google_search_agent
  name: create_google_search_agent
  file_path: src/google/adk/cli/built_in_agents/sub_agents/google_search_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Create a sub-agent that only uses google_search tool.
  signature: 'def create_google_search_agent() -> google.adk.agents.LlmAgent:'
- rank: 387
  id: google.adk.cli.built_in_agents.sub_agents.url_context_agent
  name: url_context_agent
  file_path: src/google/adk/cli/built_in_agents/sub_agents/url_context_agent.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Sub-agent for URL context fetching functionality.
  methods:
  - signature: 'def create_url_context_agent() -> google.adk.agents.LlmAgent:'
    docstring: Create a sub-agent that only uses url_context tool.
- rank: 388
  id: google.adk.cli.built_in_agents.sub_agents.url_context_agent.create_url_context_agent
  name: create_url_context_agent
  file_path: src/google/adk/cli/built_in_agents/sub_agents/url_context_agent.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Create a sub-agent that only uses url_context tool.
  signature: 'def create_url_context_agent() -> google.adk.agents.LlmAgent:'
- rank: 389
  id: google.adk.cli.built_in_agents.tools
  name: tools
  file_path: src/google/adk/cli/built_in_agents/tools/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Tools for Agent Builder Assistant.
  properties:
  - signature: '__all__: Any'
- rank: 390
  id: google.adk.cli.built_in_agents.tools.cleanup_unused_files
  name: cleanup_unused_files
  file_path: src/google/adk/cli/built_in_agents/tools/cleanup_unused_files.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Cleanup unused files tool for Agent Builder Assistant.
  methods:
  - signature: 'def cleanup_unused_files(used_files: list[str], tool_context: google.adk.tools.tool_context.ToolContext, file_patterns: list[str] | None, exclude_patterns: list[str] | None) -> dict[str, typing.Any]:'
    docstring: "Identify and optionally delete unused files in project directories.\n\nThis tool helps clean up unused tool files when agent configurations change.\nIt identifies files that match patterns but aren't referenced in used_files\nlist. Paths are resolved automatically using the tool context.\n\nArgs:\n  used_files: List of file paths currently in use (should not be deleted)\n  tool_context: Tool execution context (provides session state)\n  file_patterns: List of glob patterns to match files (default: [\"*.py\"])\n  exclude_patterns: List of patterns to exclude (default: [\"__init__.py\"])\n\nReturns:\n  Dict containing cleanup results:\n    - success: bool indicating if scan succeeded\n    - unused_files: list of unused files found\n    - deleted_files: list of files actually deleted\n    - backup_files: list of backup files created\n    - errors: list of error messages\n    - total_freed_space: total bytes freed by deletions"
- rank: 391
  id: google.adk.cli.built_in_agents.tools.cleanup_unused_files.cleanup_unused_files
  name: cleanup_unused_files
  file_path: src/google/adk/cli/built_in_agents/tools/cleanup_unused_files.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Identify and optionally delete unused files in project directories.\n\nThis tool helps clean up unused tool files when agent configurations change.\nIt identifies files that match patterns but aren't referenced in used_files\nlist. Paths are resolved automatically using the tool context.\n\nArgs:\n  used_files: List of file paths currently in use (should not be deleted)\n  tool_context: Tool execution context (provides session state)\n  file_patterns: List of glob patterns to match files (default: [\"*.py\"])\n  exclude_patterns: List of patterns to exclude (default: [\"__init__.py\"])\n\nReturns:\n  Dict containing cleanup results:\n    - success: bool indicating if scan succeeded\n    - unused_files: list of unused files found\n    - deleted_files: list of files actually deleted\n    - backup_files: list of backup files created\n    - errors: list of error messages\n    - total_freed_space: total bytes freed by deletions"
  signature: 'def cleanup_unused_files(used_files: list[str], tool_context: google.adk.tools.tool_context.ToolContext, file_patterns: list[str] | None, exclude_patterns: list[str] | None) -> dict[str, typing.Any]:'
- rank: 392
  id: google.adk.cli.built_in_agents.tools.delete_files
  name: delete_files
  file_path: src/google/adk/cli/built_in_agents/tools/delete_files.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: File deletion tool for Agent Builder Assistant.
  methods:
  - signature: 'def delete_files(file_paths: typing.List[str], tool_context: google.adk.tools.tool_context.ToolContext, create_backup: bool, confirm_deletion: bool) -> typing.Dict[str, typing.Any]:'
    docstring: "Delete multiple files with optional backup creation.\n\nThis tool safely deletes multiple files with validation and optional backup\ncreation.\nIt's designed for cleaning up unused tool files when agent configurations\nchange.\n\nArgs:\n  file_paths: List of absolute or relative paths to files to delete\n  create_backup: Whether to create a backup before deletion (default: False)\n  confirm_deletion: Whether deletion was confirmed by user (default: True for\n    safety)\n\nReturns:\n  Dict containing deletion operation results:\n    - success: bool indicating if all deletions succeeded\n    - files: dict mapping file_path to file deletion info:\n      - existed: bool indicating if file existed before deletion\n      - backup_created: bool indicating if backup was created\n      - backup_path: path to backup file if created\n      - error: error message if deletion failed for this file\n      - file_size: size of deleted file in bytes (if existed)\n    - successful_deletions:\
      \ number of files deleted successfully\n    - total_files: total number of files requested\n    - errors: list of general error messages"
- rank: 393
  id: google.adk.cli.built_in_agents.tools.delete_files.delete_files
  name: delete_files
  file_path: src/google/adk/cli/built_in_agents/tools/delete_files.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Delete multiple files with optional backup creation.\n\nThis tool safely deletes multiple files with validation and optional backup\ncreation.\nIt's designed for cleaning up unused tool files when agent configurations\nchange.\n\nArgs:\n  file_paths: List of absolute or relative paths to files to delete\n  create_backup: Whether to create a backup before deletion (default: False)\n  confirm_deletion: Whether deletion was confirmed by user (default: True for\n    safety)\n\nReturns:\n  Dict containing deletion operation results:\n    - success: bool indicating if all deletions succeeded\n    - files: dict mapping file_path to file deletion info:\n      - existed: bool indicating if file existed before deletion\n      - backup_created: bool indicating if backup was created\n      - backup_path: path to backup file if created\n      - error: error message if deletion failed for this file\n      - file_size: size of deleted file in bytes (if existed)\n    - successful_deletions:\
    \ number of files deleted successfully\n    - total_files: total number of files requested\n    - errors: list of general error messages"
  signature: 'def delete_files(file_paths: typing.List[str], tool_context: google.adk.tools.tool_context.ToolContext, create_backup: bool, confirm_deletion: bool) -> typing.Dict[str, typing.Any]:'
- rank: 394
  id: google.adk.cli.built_in_agents.tools.explore_project
  name: explore_project
  file_path: src/google/adk/cli/built_in_agents/tools/explore_project.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Project explorer tool for analyzing structure and suggesting file paths.
  methods:
  - signature: 'def explore_project(tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Dict[str, typing.Any]:'
    docstring: "Analyze project structure and suggest optimal file paths for ADK agents.\n\nThis tool performs comprehensive project analysis to understand the existing\nstructure and recommend appropriate locations for new agent configurations,\ntools, and related files following ADK best practices.\n\nThe tool automatically determines the project directory from session state.\n\nReturns:\n  Dict containing analysis results with ALL PATHS RELATIVE TO PROJECT FOLDER:\n    Always included:\n      - success: bool indicating if exploration succeeded\n\n    Success cases only (success=True):\n      - project_info: dict with basic project metadata. Contains:\n                     \u2022 \"name\": project directory name\n                     \u2022 \"absolute_path\": full path to project root\n                     \u2022 \"is_empty\": bool indicating if directory is empty\n                     \u2022 \"total_files\": count of all files in project\n                     \u2022 \"total_directories\"\
      : count of all subdirectories\n                     \u2022 \"has_python_files\": bool indicating presence of .py\n                     files\n                     \u2022 \"has_yaml_files\": bool indicating presence of\n                     .yaml/.yml files\n                     \u2022 \"has_tools_directory\": bool indicating if tools/ exists\n                     \u2022 \"has_callbacks_directory\": bool indicating if\n                     callbacks/ exists\n      - existing_configs: list of dicts for found YAML configuration files.\n                         Each dict contains:\n                         \u2022 \"filename\": name of the config file\n                         \u2022 \"relative_path\": path relative to project folder\n                         \u2022 \"size\": file size in bytes\n                         \u2022 \"is_valid_yaml\": bool indicating if YAML parses\n                         correctly\n                         \u2022 \"agent_name\": extracted agent name (or None)\n\
      \                         \u2022 \"agent_class\": agent class type (default:\n                         \"LlmAgent\")\n                         \u2022 \"has_sub_agents\": bool indicating if config has\n                         sub_agents\n                         \u2022 \"has_tools\": bool indicating if config has tools\n      - directory_structure: dict with hierarchical project tree view\n      - suggestions: dict with recommended paths for new components. Contains:\n                    \u2022 \"root_agent_configs\": list of suggested main agent\n                    filenames\n                    \u2022 \"sub_agent_patterns\": list of naming pattern templates\n                    \u2022 \"directories\": dict with tool/callback directory info\n                    \u2022 \"naming_examples\": dict with example agent sets by\n                    domain\n      - conventions: dict with ADK naming and organization best practices\n\n    Error cases only (success=False):\n      - error: descriptive\
      \ error message explaining the failure\n\nExamples:\n  Basic project exploration:\n    result = await explore_project(tool_context)\n\n  Check project structure:\n    if result[\"project_info\"][\"has_tools_directory\"]:\n        print(\"Tools directory already exists\")\n\n  Analyze existing configs:\n    for config in result[\"existing_configs\"]:\n        if config[\"is_valid_yaml\"]:\n            print(f\"Found agent: {config['agent_name']}\")\n\n  Get path suggestions:\n    suggestions = result[\"suggestions\"][\"root_agent_configs\"]\n    directories = result[\"suggestions\"][\"directories\"][\"tools\"]"
- rank: 395
  id: google.adk.cli.built_in_agents.tools.explore_project.explore_project
  name: explore_project
  file_path: src/google/adk/cli/built_in_agents/tools/explore_project.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Analyze project structure and suggest optimal file paths for ADK agents.\n\nThis tool performs comprehensive project analysis to understand the existing\nstructure and recommend appropriate locations for new agent configurations,\ntools, and related files following ADK best practices.\n\nThe tool automatically determines the project directory from session state.\n\nReturns:\n  Dict containing analysis results with ALL PATHS RELATIVE TO PROJECT FOLDER:\n    Always included:\n      - success: bool indicating if exploration succeeded\n\n    Success cases only (success=True):\n      - project_info: dict with basic project metadata. Contains:\n                     \u2022 \"name\": project directory name\n                     \u2022 \"absolute_path\": full path to project root\n                     \u2022 \"is_empty\": bool indicating if directory is empty\n                     \u2022 \"total_files\": count of all files in project\n                     \u2022 \"total_directories\"\
    : count of all subdirectories\n                     \u2022 \"has_python_files\": bool indicating presence of .py\n                     files\n                     \u2022 \"has_yaml_files\": bool indicating presence of\n                     .yaml/.yml files\n                     \u2022 \"has_tools_directory\": bool indicating if tools/ exists\n                     \u2022 \"has_callbacks_directory\": bool indicating if\n                     callbacks/ exists\n      - existing_configs: list of dicts for found YAML configuration files.\n                         Each dict contains:\n                         \u2022 \"filename\": name of the config file\n                         \u2022 \"relative_path\": path relative to project folder\n                         \u2022 \"size\": file size in bytes\n                         \u2022 \"is_valid_yaml\": bool indicating if YAML parses\n                         correctly\n                         \u2022 \"agent_name\": extracted agent name (or None)\n\
    \                         \u2022 \"agent_class\": agent class type (default:\n                         \"LlmAgent\")\n                         \u2022 \"has_sub_agents\": bool indicating if config has\n                         sub_agents\n                         \u2022 \"has_tools\": bool indicating if config has tools\n      - directory_structure: dict with hierarchical project tree view\n      - suggestions: dict with recommended paths for new components. Contains:\n                    \u2022 \"root_agent_configs\": list of suggested main agent\n                    filenames\n                    \u2022 \"sub_agent_patterns\": list of naming pattern templates\n                    \u2022 \"directories\": dict with tool/callback directory info\n                    \u2022 \"naming_examples\": dict with example agent sets by\n                    domain\n      - conventions: dict with ADK naming and organization best practices\n\n    Error cases only (success=False):\n      - error: descriptive\
    \ error message explaining the failure\n\nExamples:\n  Basic project exploration:\n    result = await explore_project(tool_context)\n\n  Check project structure:\n    if result[\"project_info\"][\"has_tools_directory\"]:\n        print(\"Tools directory already exists\")\n\n  Analyze existing configs:\n    for config in result[\"existing_configs\"]:\n        if config[\"is_valid_yaml\"]:\n            print(f\"Found agent: {config['agent_name']}\")\n\n  Get path suggestions:\n    suggestions = result[\"suggestions\"][\"root_agent_configs\"]\n    directories = result[\"suggestions\"][\"directories\"][\"tools\"]"
  signature: 'def explore_project(tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Dict[str, typing.Any]:'
- rank: 396
  id: google.adk.cli.built_in_agents.tools.query_schema
  name: query_schema
  file_path: src/google/adk/cli/built_in_agents/tools/query_schema.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: ADK AgentConfig schema query tool for dynamic schema information access.
  methods:
  - signature: 'def query_schema(query_type: str, component: typing.Optional[str], field_path: typing.Optional[str]) -> typing.Dict[str, typing.Any]:'
    docstring: "Dynamically query ADK AgentConfig schema for specific information.\n\nThis tool provides on-demand access to ADK AgentConfig schema details without\nembedding\nthe full schema in context. It's designed for \"query\" mode where\nagents need specific schema information without the memory overhead\nof the complete schema.\n\nArgs:\n  query_type: Type of schema query to perform. Supported values: - \"overview\":\n    Get high-level schema structure and main properties - \"component\": Get\n    detailed info about a specific top-level component - \"field\": Get details\n    about a specific field using dot notation - \"properties\": Get flat list of\n    all available properties\n  component: Component name to explore (required for \"component\" query_type).\n            Examples: \"name\", \"instruction\", \"tools\", \"model\", \"memory\"\n  field_path: Dot-separated path to specific field (required for \"field\"\n    query_type).\n             Examples: \"tools.function_tool.function_path\"\
      , \"model.name\"\n\nReturns:\n  Dict containing schema exploration results:\n    Always included:\n      - query_type: type of query performed\n      - success: bool indicating if exploration succeeded\n\n    Success cases vary by query_type:\n      overview: schema title, description, main properties list\n      component: component details, nested properties, type info\n      field: field traversal path, type, description, constraints\n      properties: complete flat property list with types\n\n    Error cases only (success=False):\n      - error: descriptive error message\n      - supported_queries: list of valid query types and usage\n\nExamples:\n  Get schema overview:\n    result = await query_schema(\"overview\")\n\n  Explore tools component:\n    result = await query_schema(\"component\", component=\"tools\")\n\n  Get specific field details:\n    result = await query_schema(\"field\", field_path=\"model.name\")"
- rank: 397
  id: google.adk.cli.built_in_agents.tools.query_schema.query_schema
  name: query_schema
  file_path: src/google/adk/cli/built_in_agents/tools/query_schema.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Dynamically query ADK AgentConfig schema for specific information.\n\nThis tool provides on-demand access to ADK AgentConfig schema details without\nembedding\nthe full schema in context. It's designed for \"query\" mode where\nagents need specific schema information without the memory overhead\nof the complete schema.\n\nArgs:\n  query_type: Type of schema query to perform. Supported values: - \"overview\":\n    Get high-level schema structure and main properties - \"component\": Get\n    detailed info about a specific top-level component - \"field\": Get details\n    about a specific field using dot notation - \"properties\": Get flat list of\n    all available properties\n  component: Component name to explore (required for \"component\" query_type).\n            Examples: \"name\", \"instruction\", \"tools\", \"model\", \"memory\"\n  field_path: Dot-separated path to specific field (required for \"field\"\n    query_type).\n             Examples: \"tools.function_tool.function_path\"\
    , \"model.name\"\n\nReturns:\n  Dict containing schema exploration results:\n    Always included:\n      - query_type: type of query performed\n      - success: bool indicating if exploration succeeded\n\n    Success cases vary by query_type:\n      overview: schema title, description, main properties list\n      component: component details, nested properties, type info\n      field: field traversal path, type, description, constraints\n      properties: complete flat property list with types\n\n    Error cases only (success=False):\n      - error: descriptive error message\n      - supported_queries: list of valid query types and usage\n\nExamples:\n  Get schema overview:\n    result = await query_schema(\"overview\")\n\n  Explore tools component:\n    result = await query_schema(\"component\", component=\"tools\")\n\n  Get specific field details:\n    result = await query_schema(\"field\", field_path=\"model.name\")"
  signature: 'def query_schema(query_type: str, component: typing.Optional[str], field_path: typing.Optional[str]) -> typing.Dict[str, typing.Any]:'
- rank: 398
  id: google.adk.cli.built_in_agents.tools.read_config_files
  name: read_config_files
  file_path: src/google/adk/cli/built_in_agents/tools/read_config_files.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Configuration file reader tool for existing YAML configs.
  methods:
  - signature: 'def read_config_files(file_paths: typing.List[str], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Dict[str, typing.Any]:'
    docstring: "Read multiple YAML configuration files and extract metadata.\n\nArgs:\n  file_paths: List of absolute or relative paths to YAML configuration files\n\nReturns:\n  Dict containing:\n    - success: bool indicating if all files were processed\n    - total_files: number of files requested\n    - successful_reads: number of files read successfully\n    - files: dict mapping file_path to file analysis:\n      - success: bool for this specific file\n      - file_path: absolute path to the file\n      - file_size: size of file in characters\n      - line_count: number of lines in file\n      - content: parsed YAML content as dict (success only)\n      - agent_info: extracted agent metadata (success only)\n      - sub_agents: list of referenced sub-agent files (success only)\n      - tools: list of tools used by the agent (success only)\n      - error: error message (failure only)\n      - raw_yaml: original YAML string (parsing errors only)\n    - errors: list of general error messages"
- rank: 399
  id: google.adk.cli.built_in_agents.tools.read_config_files.read_config_files
  name: read_config_files
  file_path: src/google/adk/cli/built_in_agents/tools/read_config_files.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Read multiple YAML configuration files and extract metadata.\n\nArgs:\n  file_paths: List of absolute or relative paths to YAML configuration files\n\nReturns:\n  Dict containing:\n    - success: bool indicating if all files were processed\n    - total_files: number of files requested\n    - successful_reads: number of files read successfully\n    - files: dict mapping file_path to file analysis:\n      - success: bool for this specific file\n      - file_path: absolute path to the file\n      - file_size: size of file in characters\n      - line_count: number of lines in file\n      - content: parsed YAML content as dict (success only)\n      - agent_info: extracted agent metadata (success only)\n      - sub_agents: list of referenced sub-agent files (success only)\n      - tools: list of tools used by the agent (success only)\n      - error: error message (failure only)\n      - raw_yaml: original YAML string (parsing errors only)\n    - errors: list of general error messages"
  signature: 'def read_config_files(file_paths: typing.List[str], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Dict[str, typing.Any]:'
- rank: 400
  id: google.adk.cli.built_in_agents.tools.read_files
  name: read_files
  file_path: src/google/adk/cli/built_in_agents/tools/read_files.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: File reading tool for Agent Builder Assistant.
  methods:
  - signature: 'def read_files(file_paths: typing.List[str], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Dict[str, typing.Any]:'
    docstring: "Read content from multiple files.\n\nThis tool reads content from multiple files and returns their contents.\nIt's designed for reading Python tools, configuration files, and other text\nfiles.\n\nArgs:\n  file_paths: List of absolute or relative paths to files to read\n\nReturns:\n  Dict containing read operation results:\n    - success: bool indicating if all reads succeeded\n    - files: dict mapping file_path to file info:\n      - content: file content as string\n      - file_size: size of file in bytes\n      - exists: bool indicating if file exists\n      - error: error message if read failed for this file\n    - successful_reads: number of files read successfully\n    - total_files: total number of files requested\n    - errors: list of general error messages"
- rank: 401
  id: google.adk.cli.built_in_agents.tools.read_files.read_files
  name: read_files
  file_path: src/google/adk/cli/built_in_agents/tools/read_files.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Read content from multiple files.\n\nThis tool reads content from multiple files and returns their contents.\nIt's designed for reading Python tools, configuration files, and other text\nfiles.\n\nArgs:\n  file_paths: List of absolute or relative paths to files to read\n\nReturns:\n  Dict containing read operation results:\n    - success: bool indicating if all reads succeeded\n    - files: dict mapping file_path to file info:\n      - content: file content as string\n      - file_size: size of file in bytes\n      - exists: bool indicating if file exists\n      - error: error message if read failed for this file\n    - successful_reads: number of files read successfully\n    - total_files: total number of files requested\n    - errors: list of general error messages"
  signature: 'def read_files(file_paths: typing.List[str], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Dict[str, typing.Any]:'
- rank: 402
  id: google.adk.cli.built_in_agents.tools.search_adk_knowledge
  name: search_adk_knowledge
  file_path: src/google/adk/cli/built_in_agents/tools/search_adk_knowledge.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: ADK knowledge search tool.
  methods:
  - signature: 'def search_adk_knowledge(query: str) -> dict[str, typing.Any]:'
    docstring: "Searches ADK knowledge base for relevant information.\n\nArgs:\n  query: The query to search in ADK knowledge base.\n\nReturns:\n  A dict with status and the response from the knowledge service."
  - signature: 'def error_response(error_message: str) -> dict[str, typing.Any]:'
    docstring: Returns an error response.
  - signature: 'def post_request(url: str, payload: dict[str, typing.Any]) -> dict[str, typing.Any]:'
    docstring: Executes a POST request.
  properties:
  - signature: 'KNOWLEDGE_SERVICE_APP_URL: str'
  - signature: 'KNOWLEDGE_SERVICE_APP_NAME: str'
  - signature: 'KNOWLEDGE_SERVICE_APP_USER_NAME: str'
  - signature: 'HEADERS: Any'
- rank: 403
  id: google.adk.cli.built_in_agents.tools.search_adk_knowledge.post_request
  name: post_request
  file_path: src/google/adk/cli/built_in_agents/tools/search_adk_knowledge.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Executes a POST request.
  signature: 'def post_request(url: str, payload: dict[str, typing.Any]) -> dict[str, typing.Any]:'
- rank: 404
  id: google.adk.cli.built_in_agents.tools.search_adk_knowledge.search_adk_knowledge
  name: search_adk_knowledge
  file_path: src/google/adk/cli/built_in_agents/tools/search_adk_knowledge.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Searches ADK knowledge base for relevant information.\n\nArgs:\n  query: The query to search in ADK knowledge base.\n\nReturns:\n  A dict with status and the response from the knowledge service."
  signature: 'def search_adk_knowledge(query: str) -> dict[str, typing.Any]:'
- rank: 405
  id: google.adk.cli.built_in_agents.tools.search_adk_source
  name: search_adk_source
  file_path: src/google/adk/cli/built_in_agents/tools/search_adk_source.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: ADK source code search tool for Agent Builder Assistant.
  methods:
  - signature: 'def search_adk_source(search_pattern: str, file_patterns: typing.Optional[typing.List[str]], max_results: int, context_lines: int, case_sensitive: bool) -> typing.Dict[str, typing.Any]:'
    docstring: "Search ADK source code using regex patterns.\n\nThis tool provides a regex-based alternative to vector-based retrieval for\nfinding\nspecific code patterns, class definitions, function signatures, and\nimplementations\nin the ADK source code.\n\nArgs:\n  search_pattern: Regex pattern to search for (e.g., \"class FunctionTool\",\n    \"def __init__\")\n  file_patterns: List of glob patterns for files to search (default: [\"*.py\"])\n  max_results: Maximum number of results to return (default: 20)\n  context_lines: Number of context lines to include around matches (default:\n    3)\n  case_sensitive: Whether search should be case-sensitive (default: False)\n\nReturns:\n  Dict containing search results:\n    - success: bool indicating if search succeeded\n    - pattern: the regex pattern used\n    - total_matches: total number of matches found\n    - files_searched: number of files searched\n    - results: list of match results:\n      - file_path: path to file containing match\n\
      \      - line_number: line number of match\n      - match_text: the matched text\n      - context_before: lines before the match\n      - context_after: lines after the match\n      - full_match: complete context including before/match/after\n    - errors: list of error messages"
- rank: 406
  id: google.adk.cli.built_in_agents.tools.search_adk_source.search_adk_source
  name: search_adk_source
  file_path: src/google/adk/cli/built_in_agents/tools/search_adk_source.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Search ADK source code using regex patterns.\n\nThis tool provides a regex-based alternative to vector-based retrieval for\nfinding\nspecific code patterns, class definitions, function signatures, and\nimplementations\nin the ADK source code.\n\nArgs:\n  search_pattern: Regex pattern to search for (e.g., \"class FunctionTool\",\n    \"def __init__\")\n  file_patterns: List of glob patterns for files to search (default: [\"*.py\"])\n  max_results: Maximum number of results to return (default: 20)\n  context_lines: Number of context lines to include around matches (default:\n    3)\n  case_sensitive: Whether search should be case-sensitive (default: False)\n\nReturns:\n  Dict containing search results:\n    - success: bool indicating if search succeeded\n    - pattern: the regex pattern used\n    - total_matches: total number of matches found\n    - files_searched: number of files searched\n    - results: list of match results:\n      - file_path: path to file containing match\n\
    \      - line_number: line number of match\n      - match_text: the matched text\n      - context_before: lines before the match\n      - context_after: lines after the match\n      - full_match: complete context including before/match/after\n    - errors: list of error messages"
  signature: 'def search_adk_source(search_pattern: str, file_patterns: typing.Optional[typing.List[str]], max_results: int, context_lines: int, case_sensitive: bool) -> typing.Dict[str, typing.Any]:'
- rank: 407
  id: google.adk.cli.built_in_agents.tools.write_config_files
  name: write_config_files
  file_path: src/google/adk/cli/built_in_agents/tools/write_config_files.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Configuration file writer tool with validation-before-write.
  methods:
  - signature: 'def write_config_files(configs: typing.Dict[str, str], tool_context: google.adk.tools.tool_context.ToolContext, backup_existing: bool, create_directories: bool) -> typing.Dict[str, typing.Any]:'
    docstring: "Write multiple YAML configurations with comprehensive validation-before-write.\n\nThis tool validates YAML syntax and AgentConfig schema compliance before\nwriting files to prevent invalid configurations from being saved. It\nprovides detailed error reporting and optional backup functionality.\n\nArgs:\n  configs: Dict mapping file_path to config_content (YAML as string)\n  backup_existing: Whether to create timestamped backup of existing files\n    before overwriting (default: False, User should decide)\n  create_directories: Whether to create parent directories if they don't exist\n    (default: True)\n\nReturns:\n  Dict containing write operation results:\n    Always included:\n      - success: bool indicating if all write operations succeeded\n      - total_files: number of files requested\n      - successful_writes: number of files written successfully\n      - files: dict mapping file_path to file results\n\n    Success cases only (success=True):\n      - file_size:\
      \ size of written file in bytes\n      - agent_name: extracted agent name from configuration\n      - agent_class: agent class type (e.g., \"LlmAgent\")\n      - warnings: list of warning messages for best practice violations.\n                 Empty list if no warnings. Common warning types:\n                 \u2022 Agent name formatting issues (special characters)\n                 \u2022 Empty instruction for LlmAgent\n                 \u2022 Missing sub-agent files\n                 \u2022 Incorrect file extensions (.yaml/.yml)\n                 \u2022 Mixed tool format consistency\n      - target_file_path: normalized path used for writing the config\n      - rename_applied: whether the file name was changed to match agent name\n      - written_file_path: absolute path that was ultimately written\n\n    Conditionally included:\n      - backup: dict with backup information (if backup was created).\n               Contains:\n               \u2022 \"backup_created\": True (always\
      \ True when present)\n               \u2022 \"backup_path\": absolute path to the timestamped backup file\n                               (format: \"original.yaml.backup.{timestamp}\")\n\n    Error cases only (success=False):\n      - error: descriptive error message explaining the failure\n      - error_type: categorized error type for programmatic handling\n      - validation_step: stage where validation process stopped.\n                        Possible values:\n                        \u2022 \"yaml_parsing\": YAML syntax is invalid\n                        \u2022 \"yaml_structure\": YAML is valid but not a\n                        dict/object\n                        \u2022 \"schema_validation\": YAML violates AgentConfig\n                        schema\n                        \u2022 Not present: Error during file operations\n      - validation_errors: detailed validation error list (for schema errors\n      only)\n      - retry_suggestion: helpful suggestions for fixing the error\n\
      \nExamples:\n  Write new configuration:\n    result = await write_config_files({\"my_agent.yaml\": yaml_content})\n\n  Write without backup:\n    result = await write_config_files(\n        {\"temp_agent.yaml\": yaml_content},\n        backup_existing=False\n    )\n\n  Check backup information:\n    result = await write_config_files({\"existing_agent.yaml\": new_content})\n    if result[\"success\"] and\n    result[\"files\"][\"existing_agent.yaml\"][\"backup_created\"]:\n        backup_path = result[\"files\"][\"existing_agent.yaml\"][\"backup_path\"]\n        print(f\"Original file backed up to: {backup_path}\")\n\n  Check validation warnings:\n    result = await write_config_files({\"agent.yaml\": yaml_content})\n    if result[\"success\"] and result[\"files\"][\"agent.yaml\"][\"warnings\"]:\n        for warning in result[\"files\"][\"agent.yaml\"][\"warnings\"]:\n            print(f\"Warning: {warning}\")\n\n  Handle validation errors:\n    result = await write_config_files({\"\
      agent.yaml\": invalid_yaml})\n    if not result[\"success\"]:\n        step = result.get(\"validation_step\", \"file_operation\")\n        if step == \"yaml_parsing\":\n            print(\"YAML syntax error:\", result[\"error\"])\n        elif step == \"schema_validation\":\n            print(\"Schema validation failed:\", result[\"retry_suggestion\"])\n        else:\n            print(\"Error:\", result[\"error\"])"
  properties:
  - signature: 'INVALID_FILENAME_CHARACTERS: frozenset'
  - signature: 'PARSED_CONFIG_KEY: str'
  - signature: 'WORKFLOW_AGENT_CLASSES: frozenset'
  - signature: 'IDENTIFIER_PATTERN: re.compile'
  - signature: 'CALLBACK_FIELD_NAMES: Any'
- rank: 408
  id: google.adk.cli.built_in_agents.tools.write_config_files.write_config_files
  name: write_config_files
  file_path: src/google/adk/cli/built_in_agents/tools/write_config_files.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Write multiple YAML configurations with comprehensive validation-before-write.\n\nThis tool validates YAML syntax and AgentConfig schema compliance before\nwriting files to prevent invalid configurations from being saved. It\nprovides detailed error reporting and optional backup functionality.\n\nArgs:\n  configs: Dict mapping file_path to config_content (YAML as string)\n  backup_existing: Whether to create timestamped backup of existing files\n    before overwriting (default: False, User should decide)\n  create_directories: Whether to create parent directories if they don't exist\n    (default: True)\n\nReturns:\n  Dict containing write operation results:\n    Always included:\n      - success: bool indicating if all write operations succeeded\n      - total_files: number of files requested\n      - successful_writes: number of files written successfully\n      - files: dict mapping file_path to file results\n\n    Success cases only (success=True):\n      - file_size: size\
    \ of written file in bytes\n      - agent_name: extracted agent name from configuration\n      - agent_class: agent class type (e.g., \"LlmAgent\")\n      - warnings: list of warning messages for best practice violations.\n                 Empty list if no warnings. Common warning types:\n                 \u2022 Agent name formatting issues (special characters)\n                 \u2022 Empty instruction for LlmAgent\n                 \u2022 Missing sub-agent files\n                 \u2022 Incorrect file extensions (.yaml/.yml)\n                 \u2022 Mixed tool format consistency\n      - target_file_path: normalized path used for writing the config\n      - rename_applied: whether the file name was changed to match agent name\n      - written_file_path: absolute path that was ultimately written\n\n    Conditionally included:\n      - backup: dict with backup information (if backup was created).\n               Contains:\n               \u2022 \"backup_created\": True (always True when\
    \ present)\n               \u2022 \"backup_path\": absolute path to the timestamped backup file\n                               (format: \"original.yaml.backup.{timestamp}\")\n\n    Error cases only (success=False):\n      - error: descriptive error message explaining the failure\n      - error_type: categorized error type for programmatic handling\n      - validation_step: stage where validation process stopped.\n                        Possible values:\n                        \u2022 \"yaml_parsing\": YAML syntax is invalid\n                        \u2022 \"yaml_structure\": YAML is valid but not a\n                        dict/object\n                        \u2022 \"schema_validation\": YAML violates AgentConfig\n                        schema\n                        \u2022 Not present: Error during file operations\n      - validation_errors: detailed validation error list (for schema errors\n      only)\n      - retry_suggestion: helpful suggestions for fixing the error\n\nExamples:\n\
    \  Write new configuration:\n    result = await write_config_files({\"my_agent.yaml\": yaml_content})\n\n  Write without backup:\n    result = await write_config_files(\n        {\"temp_agent.yaml\": yaml_content},\n        backup_existing=False\n    )\n\n  Check backup information:\n    result = await write_config_files({\"existing_agent.yaml\": new_content})\n    if result[\"success\"] and\n    result[\"files\"][\"existing_agent.yaml\"][\"backup_created\"]:\n        backup_path = result[\"files\"][\"existing_agent.yaml\"][\"backup_path\"]\n        print(f\"Original file backed up to: {backup_path}\")\n\n  Check validation warnings:\n    result = await write_config_files({\"agent.yaml\": yaml_content})\n    if result[\"success\"] and result[\"files\"][\"agent.yaml\"][\"warnings\"]:\n        for warning in result[\"files\"][\"agent.yaml\"][\"warnings\"]:\n            print(f\"Warning: {warning}\")\n\n  Handle validation errors:\n    result = await write_config_files({\"agent.yaml\":\
    \ invalid_yaml})\n    if not result[\"success\"]:\n        step = result.get(\"validation_step\", \"file_operation\")\n        if step == \"yaml_parsing\":\n            print(\"YAML syntax error:\", result[\"error\"])\n        elif step == \"schema_validation\":\n            print(\"Schema validation failed:\", result[\"retry_suggestion\"])\n        else:\n            print(\"Error:\", result[\"error\"])"
  signature: 'def write_config_files(configs: typing.Dict[str, str], tool_context: google.adk.tools.tool_context.ToolContext, backup_existing: bool, create_directories: bool) -> typing.Dict[str, typing.Any]:'
- rank: 409
  id: google.adk.cli.built_in_agents.tools.write_files
  name: write_files
  file_path: src/google/adk/cli/built_in_agents/tools/write_files.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: File writing tool for Agent Builder Assistant.
  methods:
  - signature: 'def write_files(files: typing.Dict[str, str], tool_context: google.adk.tools.tool_context.ToolContext, create_backup: bool, create_directories: bool) -> typing.Dict[str, typing.Any]:'
    docstring: "Write content to multiple files with optional backup creation.\n\nThis tool writes content to multiple files. It's designed for creating\nPython tools, callbacks, configuration files, and other code files.\n\nArgs:\n  files: Dict mapping file_path to content to write\n  create_backup: Whether to create backups of existing files (default: False)\n  create_directories: Whether to create parent directories (default: True)\n\nReturns:\n  Dict containing write operation results:\n    - success: bool indicating if all writes succeeded\n    - files: dict mapping file_path to file info:\n      - file_size: size of written file in bytes\n      - existed_before: bool indicating if file existed before write\n      - backup_created: bool indicating if backup was created\n      - backup_path: path to backup file if created\n      - error: error message if write failed for this file\n    - successful_writes: number of files written successfully\n    - total_files: total number of files\
      \ requested\n    - errors: list of general error messages"
- rank: 410
  id: google.adk.cli.built_in_agents.tools.write_files.write_files
  name: write_files
  file_path: src/google/adk/cli/built_in_agents/tools/write_files.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Write content to multiple files with optional backup creation.\n\nThis tool writes content to multiple files. It's designed for creating\nPython tools, callbacks, configuration files, and other code files.\n\nArgs:\n  files: Dict mapping file_path to content to write\n  create_backup: Whether to create backups of existing files (default: False)\n  create_directories: Whether to create parent directories (default: True)\n\nReturns:\n  Dict containing write operation results:\n    - success: bool indicating if all writes succeeded\n    - files: dict mapping file_path to file info:\n      - file_size: size of written file in bytes\n      - existed_before: bool indicating if file existed before write\n      - backup_created: bool indicating if backup was created\n      - backup_path: path to backup file if created\n      - error: error message if write failed for this file\n    - successful_writes: number of files written successfully\n    - total_files: total number of files requested\n\
    \    - errors: list of general error messages"
  signature: 'def write_files(files: typing.Dict[str, str], tool_context: google.adk.tools.tool_context.ToolContext, create_backup: bool, create_directories: bool) -> typing.Dict[str, typing.Any]:'
- rank: 411
  id: google.adk.cli.built_in_agents.utils
  name: utils
  file_path: src/google/adk/cli/built_in_agents/utils/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Utility modules for Agent Builder Assistant.
  properties:
  - signature: '__all__: Any'
- rank: 412
  id: google.adk.cli.built_in_agents.utils.adk_source_utils
  name: adk_source_utils
  file_path: src/google/adk/cli/built_in_agents/utils/adk_source_utils.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Utilities for finding ADK source folder dynamically and loading schema.
  methods:
  - signature: 'def find_adk_source_folder(start_path: typing.Optional[str]) -> typing.Optional[str]:'
    docstring: "Find the ADK source folder by searching up the directory tree.\n\nSearches for either 'src/google/adk' or 'google/adk' directories starting\nfrom the given path and moving up the directory tree until the root.\n\nArgs:\n  start_path: Directory to start search from. If None, uses current directory.\n\nReturns:\n  Absolute path to the ADK source folder if found, None otherwise.\n\nExamples:\n  Find ADK source from current directory:\n    adk_path = find_adk_source_folder()\n\n  Find ADK source from specific directory:\n    adk_path = find_adk_source_folder(\"/path/to/project\")"
  - signature: 'def get_adk_schema_path(start_path: typing.Optional[str]) -> typing.Optional[str]:'
    docstring: "Find the path to the ADK AgentConfig schema file.\n\nArgs:\n  start_path: Directory to start search from. If None, uses current directory.\n\nReturns:\n  Absolute path to AgentConfig.json schema file if found, None otherwise."
  - signature: 'def load_agent_config_schema(raw_format: bool, escape_braces: bool) -> str | Dict[str, Any]:'
    docstring: "Load the ADK AgentConfig.json schema with various formatting options.\n\nThis function provides a centralized way to load the ADK AgentConfig schema\nand format it for different use cases across the Agent Builder Assistant.\n\nArgs:\n  raw_format: If True, return as JSON string. If False, return as parsed dict.\n  escape_braces: If True, replace { and } with {{ and }} for template\n    embedding. Only applies when raw_format=True.\n\nReturns:\n  Either the ADK AgentConfig schema as a Dict (raw_format=False) or as a\n  formatted string (raw_format=True), optionally with escaped braces for\n  template use.\n\nRaises:\n  FileNotFoundError: If ADK AgentConfig.json schema file is not found.\n\nExamples:\n  # Get parsed ADK AgentConfig schema dict for validation\n  schema_dict = load_agent_config_schema()\n\n  # Get raw ADK AgentConfig schema JSON string for display\n  schema_str = load_agent_config_schema(raw_format=True)\n\n  # Get template-safe ADK AgentConfig schema JSON string\
      \ for instruction\n  # embedding\n  schema_template = load_agent_config_schema(\n      raw_format=True, escape_braces=True\n  )"
  - signature: 'def clear_schema_cache() -> None:'
    docstring: 'Clear the cached schema data.


      This can be useful for testing or if the schema file has been updated

      and you need to reload it.'
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '_schema_cache: typing.Optional[typing.Dict[str, typing.Any]]'
- rank: 413
  id: google.adk.cli.built_in_agents.utils.adk_source_utils.clear_schema_cache
  name: clear_schema_cache
  file_path: src/google/adk/cli/built_in_agents/utils/adk_source_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Clear the cached schema data.


    This can be useful for testing or if the schema file has been updated

    and you need to reload it.'
  signature: 'def clear_schema_cache() -> None:'
- rank: 414
  id: google.adk.cli.built_in_agents.utils.adk_source_utils.find_adk_source_folder
  name: find_adk_source_folder
  file_path: src/google/adk/cli/built_in_agents/utils/adk_source_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Find the ADK source folder by searching up the directory tree.\n\nSearches for either 'src/google/adk' or 'google/adk' directories starting\nfrom the given path and moving up the directory tree until the root.\n\nArgs:\n  start_path: Directory to start search from. If None, uses current directory.\n\nReturns:\n  Absolute path to the ADK source folder if found, None otherwise.\n\nExamples:\n  Find ADK source from current directory:\n    adk_path = find_adk_source_folder()\n\n  Find ADK source from specific directory:\n    adk_path = find_adk_source_folder(\"/path/to/project\")"
  signature: 'def find_adk_source_folder(start_path: typing.Optional[str]) -> typing.Optional[str]:'
  aliases:
  - google.adk.cli.built_in_agents.utils.find_adk_source_folder
- rank: 415
  id: google.adk.cli.built_in_agents.utils.adk_source_utils.get_adk_schema_path
  name: get_adk_schema_path
  file_path: src/google/adk/cli/built_in_agents/utils/adk_source_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Find the path to the ADK AgentConfig schema file.\n\nArgs:\n  start_path: Directory to start search from. If None, uses current directory.\n\nReturns:\n  Absolute path to AgentConfig.json schema file if found, None otherwise."
  signature: 'def get_adk_schema_path(start_path: typing.Optional[str]) -> typing.Optional[str]:'
  aliases:
  - google.adk.cli.built_in_agents.utils.get_adk_schema_path
- rank: 416
  id: google.adk.cli.built_in_agents.utils.adk_source_utils.load_agent_config_schema
  name: load_agent_config_schema
  file_path: src/google/adk/cli/built_in_agents/utils/adk_source_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Load the ADK AgentConfig.json schema with various formatting options.\n\nThis function provides a centralized way to load the ADK AgentConfig schema\nand format it for different use cases across the Agent Builder Assistant.\n\nArgs:\n  raw_format: If True, return as JSON string. If False, return as parsed dict.\n  escape_braces: If True, replace { and } with {{ and }} for template\n    embedding. Only applies when raw_format=True.\n\nReturns:\n  Either the ADK AgentConfig schema as a Dict (raw_format=False) or as a\n  formatted string (raw_format=True), optionally with escaped braces for\n  template use.\n\nRaises:\n  FileNotFoundError: If ADK AgentConfig.json schema file is not found.\n\nExamples:\n  # Get parsed ADK AgentConfig schema dict for validation\n  schema_dict = load_agent_config_schema()\n\n  # Get raw ADK AgentConfig schema JSON string for display\n  schema_str = load_agent_config_schema(raw_format=True)\n\n  # Get template-safe ADK AgentConfig schema JSON string\
    \ for instruction\n  # embedding\n  schema_template = load_agent_config_schema(\n      raw_format=True, escape_braces=True\n  )"
  signature: 'def load_agent_config_schema(raw_format: bool, escape_braces: bool) -> str | Dict[str, Any]:'
  aliases:
  - google.adk.cli.built_in_agents.utils.load_agent_config_schema
- rank: 417
  id: google.adk.cli.built_in_agents.utils.path_normalizer
  name: path_normalizer
  file_path: src/google/adk/cli/built_in_agents/utils/path_normalizer.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Helpers for normalizing file path strings produced by the model.
  methods:
  - signature: 'def sanitize_generated_file_path(file_path: str) -> str:'
    docstring: "Strip stray quotes/whitespace around each path segment.\n\nThe agent occasionally emits quoted paths such as `'tools/web.yaml'` which\nwould otherwise create directories literally named `'<name>`. This helper\nremoves leading/trailing whitespace and quote-like characters from the path\nand from each path component while preserving intentional interior\ncharacters.\n\nArgs:\n  file_path: Path string provided by the model or user.\n\nReturns:\n  Sanitized path string safe to feed into pathlib.Path."
  properties:
  - signature: '_SEGMENT_SPLIT_PATTERN: re.compile'
  - signature: '_BOUNDARY_CHARS: str'
- rank: 418
  id: google.adk.cli.built_in_agents.utils.path_normalizer.sanitize_generated_file_path
  name: sanitize_generated_file_path
  file_path: src/google/adk/cli/built_in_agents/utils/path_normalizer.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Strip stray quotes/whitespace around each path segment.\n\nThe agent occasionally emits quoted paths such as `'tools/web.yaml'` which\nwould otherwise create directories literally named `'<name>`. This helper\nremoves leading/trailing whitespace and quote-like characters from the path\nand from each path component while preserving intentional interior\ncharacters.\n\nArgs:\n  file_path: Path string provided by the model or user.\n\nReturns:\n  Sanitized path string safe to feed into pathlib.Path."
  signature: 'def sanitize_generated_file_path(file_path: str) -> str:'
- rank: 419
  id: google.adk.cli.built_in_agents.utils.resolve_root_directory
  name: resolve_root_directory
  file_path: src/google/adk/cli/built_in_agents/utils/resolve_root_directory.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Working directory helper tool to resolve path context issues.
  methods:
  - signature: 'def resolve_file_path(file_path: str, session_state: typing.Optional[typing.Dict[str, typing.Any]], working_directory: typing.Optional[str]) -> pathlib.Path:'
    docstring: "Resolve a file path using root directory from session state.\n\nThis is a helper function that other tools can use to resolve file paths\nwithout needing to be async or return detailed resolution information.\n\nArgs:\n  file_path: File path (relative or absolute)\n  session_state: Session state dict that may contain root_directory\n  working_directory: Working directory to use as base (defaults to cwd)\n\nReturns:\n  Resolved absolute Path object"
  - signature: 'def resolve_file_paths(file_paths: typing.List[str], session_state: typing.Optional[typing.Dict[str, typing.Any]], working_directory: typing.Optional[str]) -> typing.List[pathlib.Path]:'
    docstring: "Resolve multiple file paths using root directory from session state.\n\nArgs:\n  file_paths: List of file paths (relative or absolute)\n  session_state: Session state dict that may contain root_directory\n  working_directory: Working directory to use as base (defaults to cwd)\n\nReturns:\n  List of resolved absolute Path objects"
- rank: 420
  id: google.adk.cli.built_in_agents.utils.resolve_root_directory.resolve_file_path
  name: resolve_file_path
  file_path: src/google/adk/cli/built_in_agents/utils/resolve_root_directory.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Resolve a file path using root directory from session state.\n\nThis is a helper function that other tools can use to resolve file paths\nwithout needing to be async or return detailed resolution information.\n\nArgs:\n  file_path: File path (relative or absolute)\n  session_state: Session state dict that may contain root_directory\n  working_directory: Working directory to use as base (defaults to cwd)\n\nReturns:\n  Resolved absolute Path object"
  signature: 'def resolve_file_path(file_path: str, session_state: typing.Optional[typing.Dict[str, typing.Any]], working_directory: typing.Optional[str]) -> pathlib.Path:'
- rank: 421
  id: google.adk.cli.built_in_agents.utils.resolve_root_directory.resolve_file_paths
  name: resolve_file_paths
  file_path: src/google/adk/cli/built_in_agents/utils/resolve_root_directory.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Resolve multiple file paths using root directory from session state.\n\nArgs:\n  file_paths: List of file paths (relative or absolute)\n  session_state: Session state dict that may contain root_directory\n  working_directory: Working directory to use as base (defaults to cwd)\n\nReturns:\n  List of resolved absolute Path objects"
  signature: 'def resolve_file_paths(file_paths: typing.List[str], session_state: typing.Optional[typing.Dict[str, typing.Any]], working_directory: typing.Optional[str]) -> typing.List[pathlib.Path]:'
- rank: 422
  id: google.adk.cli.cli
  name: cli
  file_path: src/google/adk/cli/cli.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def run_input_file(app_name: str, user_id: str, agent_or_app: typing.Union[google.adk.agents.llm_agent.LlmAgent, google.adk.apps.app.App], artifact_service: google.adk.artifacts.base_artifact_service.BaseArtifactService, session_service: google.adk.sessions.base_session_service.BaseSessionService, credential_service: google.adk.auth.credential_service.base_credential_service.BaseCredentialService, input_path: str) -> google.adk.sessions.session.Session:'
  - signature: 'def run_interactively(root_agent_or_app: typing.Union[google.adk.agents.llm_agent.LlmAgent, google.adk.apps.app.App], artifact_service: google.adk.artifacts.base_artifact_service.BaseArtifactService, session: google.adk.sessions.session.Session, session_service: google.adk.sessions.base_session_service.BaseSessionService, credential_service: google.adk.auth.credential_service.base_credential_service.BaseCredentialService) -> None:'
  - signature: 'def run_cli(*, agent_parent_dir: str, agent_folder_name: str, input_file: typing.Optional[str]=None, saved_session_file: typing.Optional[str]=None, save_session: bool, session_id: typing.Optional[str]=None, session_service_uri: typing.Optional[str]=None, artifact_service_uri: typing.Optional[str]=None, use_local_storage: bool=True) -> None:'
    docstring: "Runs an interactive CLI for a certain agent.\n\nArgs:\n  agent_parent_dir: str, the absolute path of the parent folder of the agent\n    folder.\n  agent_folder_name: str, the name of the agent folder.\n  input_file: Optional[str], the absolute path to the json file that contains\n    the initial session state and user queries, exclusive with\n    saved_session_file.\n  saved_session_file: Optional[str], the absolute path to the json file that\n    contains a previously saved session, exclusive with input_file.\n  save_session: bool, whether to save the session on exit.\n  session_id: Optional[str], the session ID to save the session to on exit.\n  session_service_uri: Optional[str], custom session service URI.\n  artifact_service_uri: Optional[str], custom artifact service URI.\n  use_local_storage: bool, whether to use local .adk storage by default."
- rank: 423
  id: google.adk.cli.cli.InputFile
  name: InputFile
  file_path: src/google/adk/cli/cli.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, state: dict[str, object], queries: list[str]):'
  properties:
  - signature: 'state: dict[str, object]'
  - signature: 'queries: list[str]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 424
  id: google.adk.cli.cli.run_cli
  name: run_cli
  file_path: src/google/adk/cli/cli.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Runs an interactive CLI for a certain agent.\n\nArgs:\n  agent_parent_dir: str, the absolute path of the parent folder of the agent\n    folder.\n  agent_folder_name: str, the name of the agent folder.\n  input_file: Optional[str], the absolute path to the json file that contains\n    the initial session state and user queries, exclusive with\n    saved_session_file.\n  saved_session_file: Optional[str], the absolute path to the json file that\n    contains a previously saved session, exclusive with input_file.\n  save_session: bool, whether to save the session on exit.\n  session_id: Optional[str], the session ID to save the session to on exit.\n  session_service_uri: Optional[str], custom session service URI.\n  artifact_service_uri: Optional[str], custom artifact service URI.\n  use_local_storage: bool, whether to use local .adk storage by default."
  signature: 'def run_cli(*, agent_parent_dir: str, agent_folder_name: str, input_file: typing.Optional[str]=None, saved_session_file: typing.Optional[str]=None, save_session: bool, session_id: typing.Optional[str]=None, session_service_uri: typing.Optional[str]=None, artifact_service_uri: typing.Optional[str]=None, use_local_storage: bool=True) -> None:'
- rank: 425
  id: google.adk.cli.cli.run_input_file
  name: run_input_file
  file_path: src/google/adk/cli/cli.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def run_input_file(app_name: str, user_id: str, agent_or_app: typing.Union[google.adk.agents.llm_agent.LlmAgent, google.adk.apps.app.App], artifact_service: google.adk.artifacts.base_artifact_service.BaseArtifactService, session_service: google.adk.sessions.base_session_service.BaseSessionService, credential_service: google.adk.auth.credential_service.base_credential_service.BaseCredentialService, input_path: str) -> google.adk.sessions.session.Session:'
- rank: 426
  id: google.adk.cli.cli.run_interactively
  name: run_interactively
  file_path: src/google/adk/cli/cli.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def run_interactively(root_agent_or_app: typing.Union[google.adk.agents.llm_agent.LlmAgent, google.adk.apps.app.App], artifact_service: google.adk.artifacts.base_artifact_service.BaseArtifactService, session: google.adk.sessions.session.Session, session_service: google.adk.sessions.base_session_service.BaseSessionService, credential_service: google.adk.auth.credential_service.base_credential_service.BaseCredentialService) -> None:'
- rank: 427
  id: google.adk.cli.cli_create
  name: cli_create
  file_path: src/google/adk/cli/cli_create.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def run_cmd(agent_name: str, *, model: typing.Optional[str], google_api_key: typing.Optional[str], google_cloud_project: typing.Optional[str], google_cloud_region: typing.Optional[str], type: typing.Optional[str]):'
    docstring: "Runs `adk create` command to create agent template.\n\nArgs:\n  agent_name: str, The name of the agent.\n  google_api_key: Optional[str], The Google API key for using Google AI as\n    backend.\n  google_cloud_project: Optional[str], The Google Cloud project for using\n    VertexAI as backend.\n  google_cloud_region: Optional[str], The Google Cloud region for using\n    VertexAI as backend.\n  type: Optional[str], Whether to define agent with config file or code."
  properties:
  - signature: '_INIT_PY_TEMPLATE: str'
  - signature: '_AGENT_PY_TEMPLATE: str'
  - signature: '_AGENT_CONFIG_TEMPLATE: str'
  - signature: '_GOOGLE_API_MSG: str'
  - signature: '_GOOGLE_CLOUD_SETUP_MSG: str'
  - signature: '_OTHER_MODEL_MSG: str'
  - signature: '_SUCCESS_MSG_CODE: str'
  - signature: '_SUCCESS_MSG_CONFIG: str'
- rank: 428
  id: google.adk.cli.cli_create.run_cmd
  name: run_cmd
  file_path: src/google/adk/cli/cli_create.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Runs `adk create` command to create agent template.\n\nArgs:\n  agent_name: str, The name of the agent.\n  google_api_key: Optional[str], The Google API key for using Google AI as\n    backend.\n  google_cloud_project: Optional[str], The Google Cloud project for using\n    VertexAI as backend.\n  google_cloud_region: Optional[str], The Google Cloud region for using\n    VertexAI as backend.\n  type: Optional[str], Whether to define agent with config file or code."
  signature: 'def run_cmd(agent_name: str, *, model: typing.Optional[str], google_api_key: typing.Optional[str], google_cloud_project: typing.Optional[str], google_cloud_region: typing.Optional[str], type: typing.Optional[str]):'
- rank: 429
  id: google.adk.cli.cli_deploy
  name: cli_deploy
  file_path: src/google/adk/cli/cli_deploy.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def to_cloud_run(*, agent_folder: str, project: typing.Optional[str], region: typing.Optional[str], service_name: str, app_name: str, temp_folder: str, port: int, trace_to_cloud: bool, otel_to_cloud: bool, with_ui: bool, log_level: str, verbosity: str, adk_version: str, allow_origins: typing.Optional[list[str]]=None, session_service_uri: typing.Optional[str]=None, artifact_service_uri: typing.Optional[str]=None, memory_service_uri: typing.Optional[str]=None, use_local_storage: bool=False, a2a: bool=False, extra_gcloud_args: typing.Optional[tuple[str, Ellipsis]]=None):'
    docstring: "Deploys an agent to Google Cloud Run.\n\n`agent_folder` should contain the following files:\n\n- __init__.py\n- agent.py\n- requirements.txt (optional, for additional dependencies)\n- ... (other required source files)\n\nThe folder structure of temp_folder will be\n\n* dist/[google_adk wheel file]\n* agents/[app_name]/\n  * agent source code from `agent_folder`\n\nArgs:\n  agent_folder: The folder (absolute path) containing the agent source code.\n  project: Google Cloud project id.\n  region: Google Cloud region.\n  service_name: The service name in Cloud Run.\n  app_name: The name of the app, by default, it's basename of `agent_folder`.\n  temp_folder: The temp folder for the generated Cloud Run source files.\n  port: The port of the ADK api server.\n  trace_to_cloud: Whether to enable Cloud Trace.\n  otel_to_cloud: Whether to enable exporting OpenTelemetry signals\n    to Google Cloud.\n  with_ui: Whether to deploy with UI.\n  verbosity: The verbosity level of the CLI.\n\
      \  adk_version: The ADK version to use in Cloud Run.\n  allow_origins: Origins to allow for CORS. Can be literal origins or regex\n    patterns prefixed with 'regex:'.\n  session_service_uri: The URI of the session service.\n  artifact_service_uri: The URI of the artifact service.\n  memory_service_uri: The URI of the memory service.\n  use_local_storage: Whether to use local .adk storage in the container."
  - signature: 'def to_agent_engine(*, agent_folder: str, temp_folder: typing.Optional[str]=None, adk_app: str, staging_bucket: typing.Optional[str]=None, trace_to_cloud: typing.Optional[bool]=None, otel_to_cloud: typing.Optional[bool]=None, api_key: typing.Optional[str]=None, adk_app_object: typing.Optional[str]=None, agent_engine_id: typing.Optional[str]=None, absolutize_imports: bool=True, project: typing.Optional[str]=None, region: typing.Optional[str]=None, display_name: typing.Optional[str]=None, description: typing.Optional[str]=None, requirements_file: typing.Optional[str]=None, env_file: typing.Optional[str]=None, agent_engine_config_file: typing.Optional[str]=None, skip_agent_import_validation: bool=True):'
    docstring: "Deploys an agent to Vertex AI Agent Engine.\n\n`agent_folder` should contain the following files:\n\n- __init__.py\n- agent.py\n- <adk_app>.py (optional, for customization; will be autogenerated otherwise)\n- requirements.txt (optional, for additional dependencies)\n- .env (optional, for environment variables)\n- ... (other required source files)\n\nThe contents of `adk_app` should look something like:\n\n```\nfrom agent import <adk_app_object>\nfrom vertexai.agent_engines import AdkApp\n\nadk_app = AdkApp(\n  agent=<adk_app_object>,  # or `app=<adk_app_object>`\n)\n```\n\nArgs:\n  agent_folder (str): The folder (absolute path) containing the agent source\n    code.\n  temp_folder (str): The temp folder for the generated Agent Engine source\n    files. It will be replaced with the generated files if it already exists.\n  adk_app (str): The name of the file (without .py) containing the AdkApp\n    instance.\n  staging_bucket (str): Deprecated. This argument is no longer required\
      \ or\n    used.\n  trace_to_cloud (bool): Whether to enable Cloud Trace.\n  otel_to_cloud (bool): Whether to enable exporting OpenTelemetry signals\n    to Google Cloud.\n  api_key (str): Optional. The API key to use for Express Mode.\n    If not provided, the API key from the GOOGLE_API_KEY environment variable\n    will be used. It will only be used if GOOGLE_GENAI_USE_VERTEXAI is true.\n  adk_app_object (str): Optional. The Python object corresponding to the root\n    ADK agent or app. Defaults to `root_agent` if not specified.\n  agent_engine_id (str): Optional. The ID of the Agent Engine instance to\n    update. If not specified, a new Agent Engine instance will be created.\n  absolutize_imports (bool): Optional. Default is True. Whether to absolutize\n    imports. If True, all relative imports will be converted to absolute\n    import statements.\n  project (str): Optional. Google Cloud project id for the deployed agent. If\n    not specified, the project from the `GOOGLE_CLOUD_PROJECT`\
      \ environment\n    variable will be used. It will be ignored if `api_key` is specified.\n  region (str): Optional. Google Cloud region for the deployed agent. If not\n    specified, the region from the `GOOGLE_CLOUD_LOCATION` environment\n    variable will be used. It will be ignored if `api_key` is specified.\n  display_name (str): Optional. The display name of the Agent Engine.\n  description (str): Optional. The description of the Agent Engine.\n  requirements_file (str): Optional. The filepath to the `requirements.txt`\n    file to use. If not specified, the `requirements.txt` file in the\n    `agent_folder` will be used.\n  env_file (str): Optional. The filepath to the `.env` file for environment\n    variables. If not specified, the `.env` file in the `agent_folder` will be\n    used. The values of `GOOGLE_CLOUD_PROJECT` and `GOOGLE_CLOUD_LOCATION`\n    will be overridden by `project` and `region` if they are specified.\n  agent_engine_config_file (str): The filepath to the agent\
      \ engine config file\n    to use. If not specified, the `.agent_engine_config.json` file in the\n    `agent_folder` will be used.\n  skip_agent_import_validation (bool): Optional. Default is True. If True,\n    skip the pre-deployment import validation of `agent.py`. This can be\n    useful when the local environment does not have the same dependencies as\n    the deployment environment."
  - signature: 'def to_gke(*, agent_folder: str, project: typing.Optional[str], region: typing.Optional[str], cluster_name: str, service_name: str, app_name: str, temp_folder: str, port: int, trace_to_cloud: bool, otel_to_cloud: bool, with_ui: bool, log_level: str, adk_version: str, allow_origins: typing.Optional[list[str]]=None, session_service_uri: typing.Optional[str]=None, artifact_service_uri: typing.Optional[str]=None, memory_service_uri: typing.Optional[str]=None, use_local_storage: bool=False, a2a: bool=False):'
    docstring: "Deploys an agent to Google Kubernetes Engine(GKE).\n\nArgs:\n  agent_folder: The folder (absolute path) containing the agent source code.\n  project: Google Cloud project id.\n  region: Google Cloud region.\n  cluster_name: The name of the GKE cluster.\n  service_name: The service name in GKE.\n  app_name: The name of the app, by default, it's basename of `agent_folder`.\n  temp_folder: The local directory to use as a temporary workspace for\n    preparing deployment artifacts. The tool populates this folder with a copy\n    of the agent's source code and auto-generates necessary files like a\n    Dockerfile and deployment.yaml.\n  port: The port of the ADK api server.\n  trace_to_cloud: Whether to enable Cloud Trace.\n  otel_to_cloud: Whether to enable exporting OpenTelemetry signals\n    to Google Cloud.\n  with_ui: Whether to deploy with UI.\n  log_level: The logging level.\n  adk_version: The ADK version to use in GKE.\n  allow_origins: Origins to allow for CORS. Can\
      \ be literal origins or regex\n    patterns prefixed with 'regex:'.\n  session_service_uri: The URI of the session service.\n  artifact_service_uri: The URI of the artifact service.\n  memory_service_uri: The URI of the memory service.\n  use_local_storage: Whether to use local .adk storage in the container."
  properties:
  - signature: '_IS_WINDOWS: Any'
  - signature: '_GCLOUD_CMD: Any'
  - signature: '_LOCAL_STORAGE_FLAG_MIN_VERSION: typing.Final[str]'
  - signature: '_AGENT_ENGINE_REQUIREMENT: typing.Final[str]'
  - signature: '_DOCKERFILE_TEMPLATE: typing.Final[str]'
  - signature: '_AGENT_ENGINE_APP_TEMPLATE: typing.Final[str]'
  - signature: '_AGENT_ENGINE_CLASS_METHODS: Any'
- rank: 430
  id: google.adk.cli.cli_deploy.to_agent_engine
  name: to_agent_engine
  file_path: src/google/adk/cli/cli_deploy.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Deploys an agent to Vertex AI Agent Engine.\n\n`agent_folder` should contain the following files:\n\n- __init__.py\n- agent.py\n- <adk_app>.py (optional, for customization; will be autogenerated otherwise)\n- requirements.txt (optional, for additional dependencies)\n- .env (optional, for environment variables)\n- ... (other required source files)\n\nThe contents of `adk_app` should look something like:\n\n```\nfrom agent import <adk_app_object>\nfrom vertexai.agent_engines import AdkApp\n\nadk_app = AdkApp(\n  agent=<adk_app_object>,  # or `app=<adk_app_object>`\n)\n```\n\nArgs:\n  agent_folder (str): The folder (absolute path) containing the agent source\n    code.\n  temp_folder (str): The temp folder for the generated Agent Engine source\n    files. It will be replaced with the generated files if it already exists.\n  adk_app (str): The name of the file (without .py) containing the AdkApp\n    instance.\n  staging_bucket (str): Deprecated. This argument is no longer required\
    \ or\n    used.\n  trace_to_cloud (bool): Whether to enable Cloud Trace.\n  otel_to_cloud (bool): Whether to enable exporting OpenTelemetry signals\n    to Google Cloud.\n  api_key (str): Optional. The API key to use for Express Mode.\n    If not provided, the API key from the GOOGLE_API_KEY environment variable\n    will be used. It will only be used if GOOGLE_GENAI_USE_VERTEXAI is true.\n  adk_app_object (str): Optional. The Python object corresponding to the root\n    ADK agent or app. Defaults to `root_agent` if not specified.\n  agent_engine_id (str): Optional. The ID of the Agent Engine instance to\n    update. If not specified, a new Agent Engine instance will be created.\n  absolutize_imports (bool): Optional. Default is True. Whether to absolutize\n    imports. If True, all relative imports will be converted to absolute\n    import statements.\n  project (str): Optional. Google Cloud project id for the deployed agent. If\n    not specified, the project from the `GOOGLE_CLOUD_PROJECT`\
    \ environment\n    variable will be used. It will be ignored if `api_key` is specified.\n  region (str): Optional. Google Cloud region for the deployed agent. If not\n    specified, the region from the `GOOGLE_CLOUD_LOCATION` environment\n    variable will be used. It will be ignored if `api_key` is specified.\n  display_name (str): Optional. The display name of the Agent Engine.\n  description (str): Optional. The description of the Agent Engine.\n  requirements_file (str): Optional. The filepath to the `requirements.txt`\n    file to use. If not specified, the `requirements.txt` file in the\n    `agent_folder` will be used.\n  env_file (str): Optional. The filepath to the `.env` file for environment\n    variables. If not specified, the `.env` file in the `agent_folder` will be\n    used. The values of `GOOGLE_CLOUD_PROJECT` and `GOOGLE_CLOUD_LOCATION`\n    will be overridden by `project` and `region` if they are specified.\n  agent_engine_config_file (str): The filepath to the agent\
    \ engine config file\n    to use. If not specified, the `.agent_engine_config.json` file in the\n    `agent_folder` will be used.\n  skip_agent_import_validation (bool): Optional. Default is True. If True,\n    skip the pre-deployment import validation of `agent.py`. This can be\n    useful when the local environment does not have the same dependencies as\n    the deployment environment."
  signature: 'def to_agent_engine(*, agent_folder: str, temp_folder: typing.Optional[str]=None, adk_app: str, staging_bucket: typing.Optional[str]=None, trace_to_cloud: typing.Optional[bool]=None, otel_to_cloud: typing.Optional[bool]=None, api_key: typing.Optional[str]=None, adk_app_object: typing.Optional[str]=None, agent_engine_id: typing.Optional[str]=None, absolutize_imports: bool=True, project: typing.Optional[str]=None, region: typing.Optional[str]=None, display_name: typing.Optional[str]=None, description: typing.Optional[str]=None, requirements_file: typing.Optional[str]=None, env_file: typing.Optional[str]=None, agent_engine_config_file: typing.Optional[str]=None, skip_agent_import_validation: bool=True):'
- rank: 431
  id: google.adk.cli.cli_deploy.to_cloud_run
  name: to_cloud_run
  file_path: src/google/adk/cli/cli_deploy.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Deploys an agent to Google Cloud Run.\n\n`agent_folder` should contain the following files:\n\n- __init__.py\n- agent.py\n- requirements.txt (optional, for additional dependencies)\n- ... (other required source files)\n\nThe folder structure of temp_folder will be\n\n* dist/[google_adk wheel file]\n* agents/[app_name]/\n  * agent source code from `agent_folder`\n\nArgs:\n  agent_folder: The folder (absolute path) containing the agent source code.\n  project: Google Cloud project id.\n  region: Google Cloud region.\n  service_name: The service name in Cloud Run.\n  app_name: The name of the app, by default, it's basename of `agent_folder`.\n  temp_folder: The temp folder for the generated Cloud Run source files.\n  port: The port of the ADK api server.\n  trace_to_cloud: Whether to enable Cloud Trace.\n  otel_to_cloud: Whether to enable exporting OpenTelemetry signals\n    to Google Cloud.\n  with_ui: Whether to deploy with UI.\n  verbosity: The verbosity level of the CLI.\n\
    \  adk_version: The ADK version to use in Cloud Run.\n  allow_origins: Origins to allow for CORS. Can be literal origins or regex\n    patterns prefixed with 'regex:'.\n  session_service_uri: The URI of the session service.\n  artifact_service_uri: The URI of the artifact service.\n  memory_service_uri: The URI of the memory service.\n  use_local_storage: Whether to use local .adk storage in the container."
  signature: 'def to_cloud_run(*, agent_folder: str, project: typing.Optional[str], region: typing.Optional[str], service_name: str, app_name: str, temp_folder: str, port: int, trace_to_cloud: bool, otel_to_cloud: bool, with_ui: bool, log_level: str, verbosity: str, adk_version: str, allow_origins: typing.Optional[list[str]]=None, session_service_uri: typing.Optional[str]=None, artifact_service_uri: typing.Optional[str]=None, memory_service_uri: typing.Optional[str]=None, use_local_storage: bool=False, a2a: bool=False, extra_gcloud_args: typing.Optional[tuple[str, Ellipsis]]=None):'
- rank: 432
  id: google.adk.cli.cli_deploy.to_gke
  name: to_gke
  file_path: src/google/adk/cli/cli_deploy.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Deploys an agent to Google Kubernetes Engine(GKE).\n\nArgs:\n  agent_folder: The folder (absolute path) containing the agent source code.\n  project: Google Cloud project id.\n  region: Google Cloud region.\n  cluster_name: The name of the GKE cluster.\n  service_name: The service name in GKE.\n  app_name: The name of the app, by default, it's basename of `agent_folder`.\n  temp_folder: The local directory to use as a temporary workspace for\n    preparing deployment artifacts. The tool populates this folder with a copy\n    of the agent's source code and auto-generates necessary files like a\n    Dockerfile and deployment.yaml.\n  port: The port of the ADK api server.\n  trace_to_cloud: Whether to enable Cloud Trace.\n  otel_to_cloud: Whether to enable exporting OpenTelemetry signals\n    to Google Cloud.\n  with_ui: Whether to deploy with UI.\n  log_level: The logging level.\n  adk_version: The ADK version to use in GKE.\n  allow_origins: Origins to allow for CORS. Can be\
    \ literal origins or regex\n    patterns prefixed with 'regex:'.\n  session_service_uri: The URI of the session service.\n  artifact_service_uri: The URI of the artifact service.\n  memory_service_uri: The URI of the memory service.\n  use_local_storage: Whether to use local .adk storage in the container."
  signature: 'def to_gke(*, agent_folder: str, project: typing.Optional[str], region: typing.Optional[str], cluster_name: str, service_name: str, app_name: str, temp_folder: str, port: int, trace_to_cloud: bool, otel_to_cloud: bool, with_ui: bool, log_level: str, adk_version: str, allow_origins: typing.Optional[list[str]]=None, session_service_uri: typing.Optional[str]=None, artifact_service_uri: typing.Optional[str]=None, memory_service_uri: typing.Optional[str]=None, use_local_storage: bool=False, a2a: bool=False):'
- rank: 433
  id: google.adk.cli.cli_eval
  name: cli_eval
  file_path: src/google/adk/cli/cli_eval.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def get_default_metric_info(metric_name: str, description: str) -> google.adk.evaluation.eval_metrics.MetricInfo:'
    docstring: Returns a default MetricInfo for a metric.
  - signature: 'def get_root_agent(agent_module_file_path: str) -> google.adk.agents.llm_agent.Agent:'
    docstring: Returns root agent given the agent module.
  - signature: 'def try_get_reset_func(agent_module_file_path: str) -> typing.Any:'
    docstring: Returns reset function for the agent, if present, given the agent module.
  - signature: 'def parse_and_get_evals_to_run(evals_to_run_info: list[str]) -> dict[str, list[str]]:'
    docstring: "Returns a dictionary of eval set info to evals that should be run.\n\nArgs:\n  evals_to_run_info: While the structure is quite simple, a list of string,\n    each string actually is formatted with the following convention:\n    <eval_set_file_path | eval_set_id>:[comma separated eval case ids]"
  - signature: 'def pretty_print_eval_result(eval_result: google.adk.evaluation.eval_result.EvalCaseResult):'
    docstring: Pretty prints eval result.
  - signature: 'def get_eval_sets_manager(eval_storage_uri: typing.Optional[str], agents_dir: str) -> google.adk.evaluation.eval_sets_manager.EvalSetsManager:'
    docstring: Returns an instance of EvalSetsManager.
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: 'TOOL_TRAJECTORY_SCORE_KEY: str'
  - signature: 'RESPONSE_MATCH_SCORE_KEY: str'
  - signature: 'SAFETY_V1_KEY: str'
  - signature: 'FINAL_RESPONSE_MATCH_V2: str'
  - signature: 'RESPONSE_EVALUATION_SCORE_KEY: str'
  - signature: 'EVAL_SESSION_ID_PREFIX: str'
  - signature: 'DEFAULT_CRITERIA: Any'
- rank: 434
  id: google.adk.cli.cli_eval.get_default_metric_info
  name: get_default_metric_info
  file_path: src/google/adk/cli/cli_eval.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns a default MetricInfo for a metric.
  signature: 'def get_default_metric_info(metric_name: str, description: str) -> google.adk.evaluation.eval_metrics.MetricInfo:'
- rank: 435
  id: google.adk.cli.cli_eval.get_eval_sets_manager
  name: get_eval_sets_manager
  file_path: src/google/adk/cli/cli_eval.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns an instance of EvalSetsManager.
  signature: 'def get_eval_sets_manager(eval_storage_uri: typing.Optional[str], agents_dir: str) -> google.adk.evaluation.eval_sets_manager.EvalSetsManager:'
- rank: 436
  id: google.adk.cli.cli_eval.get_root_agent
  name: get_root_agent
  file_path: src/google/adk/cli/cli_eval.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns root agent given the agent module.
  signature: 'def get_root_agent(agent_module_file_path: str) -> google.adk.agents.llm_agent.Agent:'
- rank: 437
  id: google.adk.cli.cli_eval.parse_and_get_evals_to_run
  name: parse_and_get_evals_to_run
  file_path: src/google/adk/cli/cli_eval.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Returns a dictionary of eval set info to evals that should be run.\n\nArgs:\n  evals_to_run_info: While the structure is quite simple, a list of string,\n    each string actually is formatted with the following convention:\n    <eval_set_file_path | eval_set_id>:[comma separated eval case ids]"
  signature: 'def parse_and_get_evals_to_run(evals_to_run_info: list[str]) -> dict[str, list[str]]:'
- rank: 438
  id: google.adk.cli.cli_eval.pretty_print_eval_result
  name: pretty_print_eval_result
  file_path: src/google/adk/cli/cli_eval.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Pretty prints eval result.
  signature: 'def pretty_print_eval_result(eval_result: google.adk.evaluation.eval_result.EvalCaseResult):'
- rank: 439
  id: google.adk.cli.cli_eval.try_get_reset_func
  name: try_get_reset_func
  file_path: src/google/adk/cli/cli_eval.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns reset function for the agent, if present, given the agent module.
  signature: 'def try_get_reset_func(agent_module_file_path: str) -> typing.Any:'
- rank: 440
  id: google.adk.cli.cli_tools_click
  name: cli_tools_click
  file_path: src/google/adk/cli/cli_tools_click.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def feature_options():'
    docstring: Decorator to add feature override options to click commands.
  - signature: 'def main():'
    docstring: Agent Development Kit CLI tools.
  - signature: 'def deploy():'
    docstring: Deploys agent to hosted environments.
  - signature: 'def conformance():'
    docstring: Conformance testing tools for ADK.
  - signature: 'def cli_conformance_record(ctx, paths: tuple[str, Ellipsis]):'
    docstring: 'Generate ADK conformance test YAML files from TestCaseInput specifications.


      NOTE: this is work in progress.


      This command reads TestCaseInput specifications from input.yaml files,

      executes the specified test cases against agents, and generates conformance

      test files with recorded agent interactions as test.yaml files.


      Expected directory structure:

      category/name/input.yaml (TestCaseInput) -> category/name/test.yaml (TestCase)


      PATHS: One or more directories containing test case specifications.

      If no paths are provided, defaults to ''tests/'' directory.


      Examples:


      Use default directory: adk conformance record


      Custom directories: adk conformance record tests/core tests/tools'
  - signature: 'def cli_conformance_test(ctx, paths: tuple[str, Ellipsis], mode: str):'
    docstring: "Run conformance tests to verify agent behavior consistency.\n\nValidates that agents produce consistent outputs by comparing against recorded\ninteractions or evaluating live execution results.\n\nPATHS can be any number of folder paths. Each folder can either:\n- Contain a spec.yaml file directly (single test case)\n- Contain subdirectories with spec.yaml files (multiple test cases)\n\nIf no paths are provided, defaults to searching the 'tests' folder.\n\nTEST MODES:\n\n\b\nreplay  : Verifies agent interactions match previously recorded behaviors\n          exactly. Compares LLM requests/responses and tool calls/results.\nlive    : Runs evaluation-based verification (not yet implemented)\n\nDIRECTORY STRUCTURE:\n\nTest cases must follow this structure:\n\n\b\ncategory/\n  test_name/\n    spec.yaml                    # Test specification\n    generated-recordings.yaml    # Recorded interactions (replay mode)\n    generated-session.yaml       # Session data (replay mode)\n\
      \nEXAMPLES:\n\n\b\n# Run all tests in current directory's 'tests' folder\nadk conformance test\n\n\b\n# Run tests from specific folders\nadk conformance test tests/core tests/tools\n\n\b\n# Run a single test case\nadk conformance test tests/core/description_001\n\n\b\n# Run in live mode (when available)\nadk conformance test --mode=live tests/core"
  - signature: 'def cli_create_cmd(app_name: str, model: typing.Optional[str], api_key: typing.Optional[str], project: typing.Optional[str], region: typing.Optional[str], type: typing.Optional[str]):'
    docstring: "Creates a new app in the current folder with prepopulated agent template.\n\nAPP_NAME: required, the folder of the agent source code.\n\nExample:\n\n  adk create path/to/my_app"
  - signature: 'def validate_exclusive(ctx, param, value):'
  - signature: 'def adk_services_options(*, default_use_local_storage: bool=True):'
    docstring: Decorator to add ADK services options to click commands.
  - signature: 'def cli_run(agent: str, save_session: bool, session_id: typing.Optional[str], replay: typing.Optional[str], resume: typing.Optional[str], session_service_uri: typing.Optional[str], artifact_service_uri: typing.Optional[str], memory_service_uri: typing.Optional[str], use_local_storage: bool):'
    docstring: "Runs an interactive CLI for a certain agent.\n\nAGENT: The path to the agent source code folder.\n\nExample:\n\n  adk run path/to/my_agent"
  - signature: 'def eval_options():'
    docstring: Decorator to add common eval options to click commands.
  - signature: 'def cli_eval(agent_module_file_path: str, eval_set_file_path_or_id: list[str], config_file_path: str, print_detailed_results: bool, eval_storage_uri: typing.Optional[str], log_level: str):'
    docstring: "Evaluates an agent given the eval sets.\n\nAGENT_MODULE_FILE_PATH: The path to the __init__.py file that contains a\nmodule by the name \"agent\". \"agent\" module contains a root_agent.\n\nEVAL_SET_FILE_PATH_OR_ID: You can specify one or more eval set file paths or\neval set id.\n\nMixing of eval set file paths with eval set ids is not allowed.\n\n*Eval Set File Path*\nFor each file, all evals will be run by default.\n\nIf you want to run only specific evals from an eval set, first create a comma\nseparated list of eval names and then add that as a suffix to the eval set\nfile name, demarcated by a `:`.\n\nFor example, we have `sample_eval_set_file.json` file that has following the\neval cases:\nsample_eval_set_file.json:\n  |....... eval_1\n  |....... eval_2\n  |....... eval_3\n  |....... eval_4\n  |....... eval_5\n\nsample_eval_set_file.json:eval_1,eval_2,eval_3\n\nThis will only run eval_1, eval_2 and eval_3 from sample_eval_set_file.json.\n\n*Eval Set ID*\nFor each eval\
      \ set, all evals will be run by default.\n\nIf you want to run only specific evals from an eval set, first create a comma\nseparated list of eval names and then add that as a suffix to the eval set\nfile name, demarcated by a `:`.\n\nFor example, we have `sample_eval_set_id` that has following the eval cases:\nsample_eval_set_id:\n  |....... eval_1\n  |....... eval_2\n  |....... eval_3\n  |....... eval_4\n  |....... eval_5\n\nIf we did:\n    sample_eval_set_id:eval_1,eval_2,eval_3\n\nThis will only run eval_1, eval_2 and eval_3 from sample_eval_set_id.\n\nCONFIG_FILE_PATH: The path to config file.\n\nPRINT_DETAILED_RESULTS: Prints detailed results on the console."
  - signature: 'def eval_set():'
    docstring: Manage Eval Sets.
  - signature: 'def cli_create_eval_set(agent_module_file_path: str, eval_set_id: str, eval_storage_uri: typing.Optional[str], log_level: str):'
    docstring: Creates an empty EvalSet given the agent_module_file_path and eval_set_id.
  - signature: 'def cli_add_eval_case(agent_module_file_path: str, eval_set_id: str, scenarios_file: str, eval_storage_uri: typing.Optional[str], session_input_file: typing.Optional[str], log_level: str):'
    docstring: 'Adds eval cases to the given eval set.


      There are several ways that an eval case can be created, for now this method

      only supports adding one using a conversation scenarios file.


      If an eval case for the generated id already exists, then we skip adding it.'
  - signature: 'def web_options():'
    docstring: Decorator to add web UI options to click commands.
  - signature: 'def deprecated_adk_services_options():'
    docstring: Deprecated ADK services options.
  - signature: 'def fast_api_common_options():'
    docstring: Decorator to add common fast api options to click commands.
  - signature: 'def cli_web(agents_dir: str, eval_storage_uri: typing.Optional[str], log_level: str, allow_origins: typing.Optional[list[str]], host: str, port: int, url_prefix: typing.Optional[str], trace_to_cloud: bool, otel_to_cloud: bool, reload: bool, session_service_uri: typing.Optional[str], artifact_service_uri: typing.Optional[str], memory_service_uri: typing.Optional[str], use_local_storage: bool, session_db_url: typing.Optional[str], artifact_storage_uri: typing.Optional[str], a2a: bool, reload_agents: bool, extra_plugins: typing.Optional[list[str]], logo_text: typing.Optional[str], logo_image_url: typing.Optional[str]):'
    docstring: "Starts a FastAPI server with Web UI for agents.\n\nAGENTS_DIR: The directory of agents, where each subdirectory is a single\nagent, containing at least `__init__.py` and `agent.py` files.\n\nExample:\n\n  adk web --session_service_uri=[uri] --port=[port] path/to/agents_dir"
  - signature: 'def cli_api_server(agents_dir: str, eval_storage_uri: typing.Optional[str], log_level: str, allow_origins: typing.Optional[list[str]], host: str, port: int, url_prefix: typing.Optional[str], trace_to_cloud: bool, otel_to_cloud: bool, reload: bool, session_service_uri: typing.Optional[str], artifact_service_uri: typing.Optional[str], memory_service_uri: typing.Optional[str], use_local_storage: bool, session_db_url: typing.Optional[str], artifact_storage_uri: typing.Optional[str], a2a: bool, reload_agents: bool, extra_plugins: typing.Optional[list[str]]):'
    docstring: "Starts a FastAPI server for agents.\n\nAGENTS_DIR: The directory of agents, where each subdirectory is a single\nagent, containing at least `__init__.py` and `agent.py` files.\n\nExample:\n\n  adk api_server --session_service_uri=[uri] --port=[port] path/to/agents_dir"
  - signature: 'def cli_deploy_cloud_run(ctx, agent: str, project: typing.Optional[str], region: typing.Optional[str], service_name: str, app_name: str, temp_folder: str, port: int, trace_to_cloud: bool, otel_to_cloud: bool, with_ui: bool, adk_version: str, log_level: str, verbosity: typing.Optional[str], allow_origins: typing.Optional[list[str]], session_service_uri: typing.Optional[str], artifact_service_uri: typing.Optional[str], memory_service_uri: typing.Optional[str], use_local_storage: bool, session_db_url: typing.Optional[str], artifact_storage_uri: typing.Optional[str], a2a: bool):'
    docstring: "Deploys an agent to Cloud Run.\n\nAGENT: The path to the agent source code folder.\n\nUse '--' to separate gcloud arguments from adk arguments.\n\nExamples:\n\n  adk deploy cloud_run --project=[project] --region=[region] path/to/my_agent\n\n  adk deploy cloud_run --project=[project] --region=[region] path/to/my_agent\n    -- --no-allow-unauthenticated --min-instances=2"
  - signature: 'def migrate():'
    docstring: ADK migration commands.
  - signature: 'def cli_migrate_session(*, source_db_url: str, dest_db_url: str, log_level: str):'
    docstring: Migrates a session database to the latest schema version.
  - signature: 'def cli_deploy_agent_engine(agent: str, project: typing.Optional[str], region: typing.Optional[str], staging_bucket: typing.Optional[str], agent_engine_id: typing.Optional[str], trace_to_cloud: typing.Optional[bool], otel_to_cloud: typing.Optional[bool], api_key: typing.Optional[str], display_name: str, description: str, adk_app: str, adk_app_object: typing.Optional[str], temp_folder: typing.Optional[str], env_file: str, requirements_file: str, absolutize_imports: bool, agent_engine_config_file: str, validate_agent_import: bool, skip_agent_import_validation_alias: bool):'
    docstring: "Deploys an agent to Agent Engine.\n\nExample:\n\n  # With Express Mode API Key\n  adk deploy agent_engine --api_key=[api_key] my_agent\n\n  # With Google Cloud Project and Region\n  adk deploy agent_engine --project=[project] --region=[region]\n    --display_name=[app_name] my_agent"
  - signature: 'def cli_deploy_gke(agent: str, project: typing.Optional[str], region: typing.Optional[str], cluster_name: str, service_name: str, app_name: str, temp_folder: str, port: int, trace_to_cloud: bool, otel_to_cloud: bool, with_ui: bool, adk_version: str, log_level: typing.Optional[str], session_service_uri: typing.Optional[str], artifact_service_uri: typing.Optional[str], memory_service_uri: typing.Optional[str], use_local_storage: bool):'
    docstring: "Deploys an agent to GKE.\n\nAGENT: The path to the agent source code folder.\n\nExample:\n\n  adk deploy gke --project=[project] --region=[region]\n    --cluster_name=[cluster_name] path/to/my_agent"
  properties:
  - signature: 'LOG_LEVELS: click.Choice'
  - signature: 'logger: logging.getLogger'
  - signature: '_ADK_WEB_WARNING: str'
- rank: 441
  id: google.adk.cli.cli_tools_click.HelpfulCommand
  name: HelpfulCommand
  file_path: src/google/adk/cli/cli_tools_click.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "Command that shows full help on error instead of just the error message.\n\nA custom Click Command class that overrides the default error handling\nbehavior to display the full help text when a required argument is missing,\nfollowed by the error message. This provides users with better context\nabout command usage without needing to run a separate --help command.\n\nArgs:\n  *args: Variable length argument list to pass to the parent class.\n  **kwargs: Arbitrary keyword arguments to pass to the parent class.\n\nReturns:\n  None. Inherits behavior from the parent Click Command class.\n\nReturns:\n\n[Note: Inherited members from click.Command are omitted.]"
  constructor_signature: 'def __init__(self):'
  methods:
  - signature: 'def parse_args(self, ctx, args):'
    docstring: "Override the parse_args method to show help text on error.\n\nArgs:\n  ctx: Click context object for the current command.\n  args: List of command-line arguments to parse.\n\nReturns:\n  The parsed arguments as returned by the parent class's parse_args method.\n\nRaises:\n  click.MissingParameter: When a required parameter is missing, but this\n    is caught and handled by displaying the help text before exiting."
  omitted_inherited_members_from:
  - click.Command
- rank: 442
  id: google.adk.cli.cli_tools_click.HelpfulCommand.parse_args
  name: parse_args
  file_path: src/google/adk/cli/cli_tools_click.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Override the parse_args method to show help text on error.\n\nArgs:\n  ctx: Click context object for the current command.\n  args: List of command-line arguments to parse.\n\nReturns:\n  The parsed arguments as returned by the parent class's parse_args method.\n\nRaises:\n  click.MissingParameter: When a required parameter is missing, but this\n    is caught and handled by displaying the help text before exiting."
  signature: 'def parse_args(self, ctx, args):'
- rank: 443
  id: google.adk.cli.cli_tools_click.adk_services_options
  name: adk_services_options
  file_path: src/google/adk/cli/cli_tools_click.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Decorator to add ADK services options to click commands.
  signature: 'def adk_services_options(*, default_use_local_storage: bool=True):'
- rank: 444
  id: google.adk.cli.cli_tools_click.cli_add_eval_case
  name: cli_add_eval_case
  file_path: src/google/adk/cli/cli_tools_click.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Adds eval cases to the given eval set.


    There are several ways that an eval case can be created, for now this method

    only supports adding one using a conversation scenarios file.


    If an eval case for the generated id already exists, then we skip adding it.'
  signature: 'def cli_add_eval_case(agent_module_file_path: str, eval_set_id: str, scenarios_file: str, eval_storage_uri: typing.Optional[str], session_input_file: typing.Optional[str], log_level: str):'
- rank: 445
  id: google.adk.cli.cli_tools_click.cli_api_server
  name: cli_api_server
  file_path: src/google/adk/cli/cli_tools_click.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Starts a FastAPI server for agents.\n\nAGENTS_DIR: The directory of agents, where each subdirectory is a single\nagent, containing at least `__init__.py` and `agent.py` files.\n\nExample:\n\n  adk api_server --session_service_uri=[uri] --port=[port] path/to/agents_dir"
  signature: 'def cli_api_server(agents_dir: str, eval_storage_uri: typing.Optional[str], log_level: str, allow_origins: typing.Optional[list[str]], host: str, port: int, url_prefix: typing.Optional[str], trace_to_cloud: bool, otel_to_cloud: bool, reload: bool, session_service_uri: typing.Optional[str], artifact_service_uri: typing.Optional[str], memory_service_uri: typing.Optional[str], use_local_storage: bool, session_db_url: typing.Optional[str], artifact_storage_uri: typing.Optional[str], a2a: bool, reload_agents: bool, extra_plugins: typing.Optional[list[str]]):'
- rank: 446
  id: google.adk.cli.cli_tools_click.cli_conformance_record
  name: cli_conformance_record
  file_path: src/google/adk/cli/cli_tools_click.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Generate ADK conformance test YAML files from TestCaseInput specifications.


    NOTE: this is work in progress.


    This command reads TestCaseInput specifications from input.yaml files,

    executes the specified test cases against agents, and generates conformance

    test files with recorded agent interactions as test.yaml files.


    Expected directory structure:

    category/name/input.yaml (TestCaseInput) -> category/name/test.yaml (TestCase)


    PATHS: One or more directories containing test case specifications.

    If no paths are provided, defaults to ''tests/'' directory.


    Examples:


    Use default directory: adk conformance record


    Custom directories: adk conformance record tests/core tests/tools'
  signature: 'def cli_conformance_record(ctx, paths: tuple[str, Ellipsis]):'
- rank: 447
  id: google.adk.cli.cli_tools_click.cli_conformance_test
  name: cli_conformance_test
  file_path: src/google/adk/cli/cli_tools_click.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Run conformance tests to verify agent behavior consistency.\n\nValidates that agents produce consistent outputs by comparing against recorded\ninteractions or evaluating live execution results.\n\nPATHS can be any number of folder paths. Each folder can either:\n- Contain a spec.yaml file directly (single test case)\n- Contain subdirectories with spec.yaml files (multiple test cases)\n\nIf no paths are provided, defaults to searching the 'tests' folder.\n\nTEST MODES:\n\n\b\nreplay  : Verifies agent interactions match previously recorded behaviors\n          exactly. Compares LLM requests/responses and tool calls/results.\nlive    : Runs evaluation-based verification (not yet implemented)\n\nDIRECTORY STRUCTURE:\n\nTest cases must follow this structure:\n\n\b\ncategory/\n  test_name/\n    spec.yaml                    # Test specification\n    generated-recordings.yaml    # Recorded interactions (replay mode)\n    generated-session.yaml       # Session data (replay mode)\n\n\
    EXAMPLES:\n\n\b\n# Run all tests in current directory's 'tests' folder\nadk conformance test\n\n\b\n# Run tests from specific folders\nadk conformance test tests/core tests/tools\n\n\b\n# Run a single test case\nadk conformance test tests/core/description_001\n\n\b\n# Run in live mode (when available)\nadk conformance test --mode=live tests/core"
  signature: 'def cli_conformance_test(ctx, paths: tuple[str, Ellipsis], mode: str):'
- rank: 448
  id: google.adk.cli.cli_tools_click.cli_create_cmd
  name: cli_create_cmd
  file_path: src/google/adk/cli/cli_tools_click.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Creates a new app in the current folder with prepopulated agent template.\n\nAPP_NAME: required, the folder of the agent source code.\n\nExample:\n\n  adk create path/to/my_app"
  signature: 'def cli_create_cmd(app_name: str, model: typing.Optional[str], api_key: typing.Optional[str], project: typing.Optional[str], region: typing.Optional[str], type: typing.Optional[str]):'
- rank: 449
  id: google.adk.cli.cli_tools_click.cli_create_eval_set
  name: cli_create_eval_set
  file_path: src/google/adk/cli/cli_tools_click.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Creates an empty EvalSet given the agent_module_file_path and eval_set_id.
  signature: 'def cli_create_eval_set(agent_module_file_path: str, eval_set_id: str, eval_storage_uri: typing.Optional[str], log_level: str):'
- rank: 450
  id: google.adk.cli.cli_tools_click.cli_deploy_agent_engine
  name: cli_deploy_agent_engine
  file_path: src/google/adk/cli/cli_tools_click.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Deploys an agent to Agent Engine.\n\nExample:\n\n  # With Express Mode API Key\n  adk deploy agent_engine --api_key=[api_key] my_agent\n\n  # With Google Cloud Project and Region\n  adk deploy agent_engine --project=[project] --region=[region]\n    --display_name=[app_name] my_agent"
  signature: 'def cli_deploy_agent_engine(agent: str, project: typing.Optional[str], region: typing.Optional[str], staging_bucket: typing.Optional[str], agent_engine_id: typing.Optional[str], trace_to_cloud: typing.Optional[bool], otel_to_cloud: typing.Optional[bool], api_key: typing.Optional[str], display_name: str, description: str, adk_app: str, adk_app_object: typing.Optional[str], temp_folder: typing.Optional[str], env_file: str, requirements_file: str, absolutize_imports: bool, agent_engine_config_file: str, validate_agent_import: bool, skip_agent_import_validation_alias: bool):'
- rank: 451
  id: google.adk.cli.cli_tools_click.cli_deploy_cloud_run
  name: cli_deploy_cloud_run
  file_path: src/google/adk/cli/cli_tools_click.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Deploys an agent to Cloud Run.\n\nAGENT: The path to the agent source code folder.\n\nUse '--' to separate gcloud arguments from adk arguments.\n\nExamples:\n\n  adk deploy cloud_run --project=[project] --region=[region] path/to/my_agent\n\n  adk deploy cloud_run --project=[project] --region=[region] path/to/my_agent\n    -- --no-allow-unauthenticated --min-instances=2"
  signature: 'def cli_deploy_cloud_run(ctx, agent: str, project: typing.Optional[str], region: typing.Optional[str], service_name: str, app_name: str, temp_folder: str, port: int, trace_to_cloud: bool, otel_to_cloud: bool, with_ui: bool, adk_version: str, log_level: str, verbosity: typing.Optional[str], allow_origins: typing.Optional[list[str]], session_service_uri: typing.Optional[str], artifact_service_uri: typing.Optional[str], memory_service_uri: typing.Optional[str], use_local_storage: bool, session_db_url: typing.Optional[str], artifact_storage_uri: typing.Optional[str], a2a: bool):'
- rank: 452
  id: google.adk.cli.cli_tools_click.cli_deploy_gke
  name: cli_deploy_gke
  file_path: src/google/adk/cli/cli_tools_click.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Deploys an agent to GKE.\n\nAGENT: The path to the agent source code folder.\n\nExample:\n\n  adk deploy gke --project=[project] --region=[region]\n    --cluster_name=[cluster_name] path/to/my_agent"
  signature: 'def cli_deploy_gke(agent: str, project: typing.Optional[str], region: typing.Optional[str], cluster_name: str, service_name: str, app_name: str, temp_folder: str, port: int, trace_to_cloud: bool, otel_to_cloud: bool, with_ui: bool, adk_version: str, log_level: typing.Optional[str], session_service_uri: typing.Optional[str], artifact_service_uri: typing.Optional[str], memory_service_uri: typing.Optional[str], use_local_storage: bool):'
- rank: 453
  id: google.adk.cli.cli_tools_click.cli_eval
  name: cli_eval
  file_path: src/google/adk/cli/cli_tools_click.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Evaluates an agent given the eval sets.\n\nAGENT_MODULE_FILE_PATH: The path to the __init__.py file that contains a\nmodule by the name \"agent\". \"agent\" module contains a root_agent.\n\nEVAL_SET_FILE_PATH_OR_ID: You can specify one or more eval set file paths or\neval set id.\n\nMixing of eval set file paths with eval set ids is not allowed.\n\n*Eval Set File Path*\nFor each file, all evals will be run by default.\n\nIf you want to run only specific evals from an eval set, first create a comma\nseparated list of eval names and then add that as a suffix to the eval set\nfile name, demarcated by a `:`.\n\nFor example, we have `sample_eval_set_file.json` file that has following the\neval cases:\nsample_eval_set_file.json:\n  |....... eval_1\n  |....... eval_2\n  |....... eval_3\n  |....... eval_4\n  |....... eval_5\n\nsample_eval_set_file.json:eval_1,eval_2,eval_3\n\nThis will only run eval_1, eval_2 and eval_3 from sample_eval_set_file.json.\n\n*Eval Set ID*\nFor each eval\
    \ set, all evals will be run by default.\n\nIf you want to run only specific evals from an eval set, first create a comma\nseparated list of eval names and then add that as a suffix to the eval set\nfile name, demarcated by a `:`.\n\nFor example, we have `sample_eval_set_id` that has following the eval cases:\nsample_eval_set_id:\n  |....... eval_1\n  |....... eval_2\n  |....... eval_3\n  |....... eval_4\n  |....... eval_5\n\nIf we did:\n    sample_eval_set_id:eval_1,eval_2,eval_3\n\nThis will only run eval_1, eval_2 and eval_3 from sample_eval_set_id.\n\nCONFIG_FILE_PATH: The path to config file.\n\nPRINT_DETAILED_RESULTS: Prints detailed results on the console."
  signature: 'def cli_eval(agent_module_file_path: str, eval_set_file_path_or_id: list[str], config_file_path: str, print_detailed_results: bool, eval_storage_uri: typing.Optional[str], log_level: str):'
- rank: 454
  id: google.adk.cli.cli_tools_click.cli_migrate_session
  name: cli_migrate_session
  file_path: src/google/adk/cli/cli_tools_click.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Migrates a session database to the latest schema version.
  signature: 'def cli_migrate_session(*, source_db_url: str, dest_db_url: str, log_level: str):'
- rank: 455
  id: google.adk.cli.cli_tools_click.cli_run
  name: cli_run
  file_path: src/google/adk/cli/cli_tools_click.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Runs an interactive CLI for a certain agent.\n\nAGENT: The path to the agent source code folder.\n\nExample:\n\n  adk run path/to/my_agent"
  signature: 'def cli_run(agent: str, save_session: bool, session_id: typing.Optional[str], replay: typing.Optional[str], resume: typing.Optional[str], session_service_uri: typing.Optional[str], artifact_service_uri: typing.Optional[str], memory_service_uri: typing.Optional[str], use_local_storage: bool):'
- rank: 456
  id: google.adk.cli.cli_tools_click.cli_web
  name: cli_web
  file_path: src/google/adk/cli/cli_tools_click.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Starts a FastAPI server with Web UI for agents.\n\nAGENTS_DIR: The directory of agents, where each subdirectory is a single\nagent, containing at least `__init__.py` and `agent.py` files.\n\nExample:\n\n  adk web --session_service_uri=[uri] --port=[port] path/to/agents_dir"
  signature: 'def cli_web(agents_dir: str, eval_storage_uri: typing.Optional[str], log_level: str, allow_origins: typing.Optional[list[str]], host: str, port: int, url_prefix: typing.Optional[str], trace_to_cloud: bool, otel_to_cloud: bool, reload: bool, session_service_uri: typing.Optional[str], artifact_service_uri: typing.Optional[str], memory_service_uri: typing.Optional[str], use_local_storage: bool, session_db_url: typing.Optional[str], artifact_storage_uri: typing.Optional[str], a2a: bool, reload_agents: bool, extra_plugins: typing.Optional[list[str]], logo_text: typing.Optional[str], logo_image_url: typing.Optional[str]):'
- rank: 457
  id: google.adk.cli.cli_tools_click.deprecated_adk_services_options
  name: deprecated_adk_services_options
  file_path: src/google/adk/cli/cli_tools_click.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Deprecated ADK services options.
  signature: 'def deprecated_adk_services_options():'
- rank: 458
  id: google.adk.cli.cli_tools_click.eval_options
  name: eval_options
  file_path: src/google/adk/cli/cli_tools_click.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Decorator to add common eval options to click commands.
  signature: 'def eval_options():'
- rank: 459
  id: google.adk.cli.cli_tools_click.fast_api_common_options
  name: fast_api_common_options
  file_path: src/google/adk/cli/cli_tools_click.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Decorator to add common fast api options to click commands.
  signature: 'def fast_api_common_options():'
- rank: 460
  id: google.adk.cli.cli_tools_click.feature_options
  name: feature_options
  file_path: src/google/adk/cli/cli_tools_click.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Decorator to add feature override options to click commands.
  signature: 'def feature_options():'
- rank: 461
  id: google.adk.cli.cli_tools_click.validate_exclusive
  name: validate_exclusive
  file_path: src/google/adk/cli/cli_tools_click.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def validate_exclusive(ctx, param, value):'
- rank: 462
  id: google.adk.cli.cli_tools_click.web_options
  name: web_options
  file_path: src/google/adk/cli/cli_tools_click.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Decorator to add web UI options to click commands.
  signature: 'def web_options():'
- rank: 463
  id: google.adk.cli.conformance
  name: conformance
  file_path: src/google/adk/cli/conformance/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 464
  id: google.adk.cli.conformance.adk_web_server_client
  name: adk_web_server_client
  file_path: src/google/adk/cli/conformance/adk_web_server_client.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: HTTP client for interacting with the ADK web server.
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 465
  id: google.adk.cli.conformance.adk_web_server_client.AdkWebServerClient
  name: AdkWebServerClient
  file_path: src/google/adk/cli/conformance/adk_web_server_client.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "HTTP client for interacting with the ADK web server for conformance tests.\n\nUsage patterns:\n\n  # Pattern 1: Manual lifecycle management\n  client = AdkWebServerClient()\n  session = await client.create_session(app_name=\"app\", user_id=\"user\")\n  async for event in client.run_agent(request):\n      # Process events...\n  await client.close()  # Optional explicit cleanup\n\n  # Pattern 2: Automatic cleanup with context manager (recommended)\n  async with AdkWebServerClient() as client:\n      session = await client.create_session(app_name=\"app\", user_id=\"user\")\n      async for event in client.run_agent(request):\n          # Process events...\n      # Client automatically closed here"
  constructor_signature: 'def __init__(self, base_url: str, timeout: float):'
  methods:
  - signature: 'def close(self) -> None:'
    docstring: Close the HTTP client and clean up resources.
  - signature: 'def get_session(self, *, app_name: str, user_id: str, session_id: str) -> google.adk.sessions.session.Session:'
    docstring: "Retrieve a specific session from the ADK web server.\n\nArgs:\n  app_name: Name of the application\n  user_id: User identifier\n  session_id: Session identifier\n\nReturns:\n  The requested Session object\n\nRaises:\n  httpx.HTTPStatusError: If the request fails or session not found"
  - signature: 'def create_session(self, *, app_name: str, user_id: str, state: typing.Optional[typing.Dict[str, typing.Any]]=None) -> google.adk.sessions.session.Session:'
    docstring: "Create a new session in the ADK web server.\n\nArgs:\n  app_name: Name of the application\n  user_id: User identifier\n  state: Optional initial state for the session\n\nReturns:\n  The newly created Session object\n\nRaises:\n  httpx.HTTPStatusError: If the request fails"
  - signature: 'def delete_session(self, *, app_name: str, user_id: str, session_id: str) -> None:'
    docstring: "Delete a session from the ADK web server.\n\nArgs:\n  app_name: Name of the application\n  user_id: User identifier\n  session_id: Session identifier to delete\n\nRaises:\n  httpx.HTTPStatusError: If the request fails or session not found"
  - signature: 'def update_session(self, *, app_name: str, user_id: str, session_id: str, state_delta: typing.Dict[str, typing.Any]) -> google.adk.sessions.session.Session:'
    docstring: "Update session state without running the agent.\n\nArgs:\n  app_name: Name of the application\n  user_id: User identifier\n  session_id: Session identifier to update\n  state_delta: The state changes to apply to the session\n\nReturns:\n  The updated Session object\n\nRaises:\n  httpx.HTTPStatusError: If the request fails or session not found"
  - signature: 'def run_agent(self, request: google.adk.cli.adk_web_server.RunAgentRequest, mode: typing.Optional[typing.Literal[record, replay]], test_case_dir: typing.Optional[str], user_message_index: typing.Optional[int]) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
    docstring: "Run an agent with streaming Server-Sent Events response.\n\nArgs:\n  request: The RunAgentRequest containing agent execution parameters\n  mode: Optional conformance mode (\"record\" or \"replay\") to trigger recording\n  test_case_dir: Optional test case directory path for conformance recording\n  user_message_index: Optional user message index for conformance recording\n\nYields:\n  Event objects streamed from the agent execution\n\nRaises:\n  ValueError: If mode is provided but test_case_dir or user_message_index is None\n  httpx.HTTPStatusError: If the request fails\n  json.JSONDecodeError: If event data cannot be parsed\n  RuntimeError: If the server streams an error payload"
- rank: 466
  id: google.adk.cli.conformance.adk_web_server_client.AdkWebServerClient.__init__
  name: __init__
  file_path: src/google/adk/cli/conformance/adk_web_server_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initialize the ADK web server client for conformance testing.\n\nArgs:\n  base_url: Base URL of the ADK web server (default: http://127.0.0.1:8000)\n  timeout: Request timeout in seconds (default: 30.0)"
  signature: 'def __init__(self, base_url: str, timeout: float):'
- rank: 467
  id: google.adk.cli.conformance.adk_web_server_client.AdkWebServerClient.close
  name: close
  file_path: src/google/adk/cli/conformance/adk_web_server_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Close the HTTP client and clean up resources.
  signature: 'def close(self) -> None:'
- rank: 468
  id: google.adk.cli.conformance.adk_web_server_client.AdkWebServerClient.create_session
  name: create_session
  file_path: src/google/adk/cli/conformance/adk_web_server_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Create a new session in the ADK web server.\n\nArgs:\n  app_name: Name of the application\n  user_id: User identifier\n  state: Optional initial state for the session\n\nReturns:\n  The newly created Session object\n\nRaises:\n  httpx.HTTPStatusError: If the request fails"
  signature: 'def create_session(self, *, app_name: str, user_id: str, state: typing.Optional[typing.Dict[str, typing.Any]]=None) -> google.adk.sessions.session.Session:'
- rank: 469
  id: google.adk.cli.conformance.adk_web_server_client.AdkWebServerClient.delete_session
  name: delete_session
  file_path: src/google/adk/cli/conformance/adk_web_server_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Delete a session from the ADK web server.\n\nArgs:\n  app_name: Name of the application\n  user_id: User identifier\n  session_id: Session identifier to delete\n\nRaises:\n  httpx.HTTPStatusError: If the request fails or session not found"
  signature: 'def delete_session(self, *, app_name: str, user_id: str, session_id: str) -> None:'
- rank: 470
  id: google.adk.cli.conformance.adk_web_server_client.AdkWebServerClient.get_session
  name: get_session
  file_path: src/google/adk/cli/conformance/adk_web_server_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Retrieve a specific session from the ADK web server.\n\nArgs:\n  app_name: Name of the application\n  user_id: User identifier\n  session_id: Session identifier\n\nReturns:\n  The requested Session object\n\nRaises:\n  httpx.HTTPStatusError: If the request fails or session not found"
  signature: 'def get_session(self, *, app_name: str, user_id: str, session_id: str) -> google.adk.sessions.session.Session:'
- rank: 471
  id: google.adk.cli.conformance.adk_web_server_client.AdkWebServerClient.run_agent
  name: run_agent
  file_path: src/google/adk/cli/conformance/adk_web_server_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Run an agent with streaming Server-Sent Events response.\n\nArgs:\n  request: The RunAgentRequest containing agent execution parameters\n  mode: Optional conformance mode (\"record\" or \"replay\") to trigger recording\n  test_case_dir: Optional test case directory path for conformance recording\n  user_message_index: Optional user message index for conformance recording\n\nYields:\n  Event objects streamed from the agent execution\n\nRaises:\n  ValueError: If mode is provided but test_case_dir or user_message_index is None\n  httpx.HTTPStatusError: If the request fails\n  json.JSONDecodeError: If event data cannot be parsed\n  RuntimeError: If the server streams an error payload"
  signature: 'def run_agent(self, request: google.adk.cli.adk_web_server.RunAgentRequest, mode: typing.Optional[typing.Literal[record, replay]], test_case_dir: typing.Optional[str], user_message_index: typing.Optional[int]) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
- rank: 472
  id: google.adk.cli.conformance.adk_web_server_client.AdkWebServerClient.update_session
  name: update_session
  file_path: src/google/adk/cli/conformance/adk_web_server_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Update session state without running the agent.\n\nArgs:\n  app_name: Name of the application\n  user_id: User identifier\n  session_id: Session identifier to update\n  state_delta: The state changes to apply to the session\n\nReturns:\n  The updated Session object\n\nRaises:\n  httpx.HTTPStatusError: If the request fails or session not found"
  signature: 'def update_session(self, *, app_name: str, user_id: str, session_id: str, state_delta: typing.Dict[str, typing.Any]) -> google.adk.sessions.session.Session:'
- rank: 473
  id: google.adk.cli.conformance.cli_record
  name: cli_record
  file_path: src/google/adk/cli/conformance/cli_record.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: CLI commands for ADK conformance testing.
  methods:
  - signature: 'def run_conformance_record(paths: list[pathlib.Path]) -> None:'
    docstring: "Generate conformance tests from TestCaseInput files.\n\nArgs:\n  paths: list of directories containing test cases input files (spec.yaml)."
- rank: 474
  id: google.adk.cli.conformance.cli_record.run_conformance_record
  name: run_conformance_record
  file_path: src/google/adk/cli/conformance/cli_record.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Generate conformance tests from TestCaseInput files.\n\nArgs:\n  paths: list of directories containing test cases input files (spec.yaml)."
  signature: 'def run_conformance_record(paths: list[pathlib.Path]) -> None:'
- rank: 475
  id: google.adk.cli.conformance.cli_test
  name: cli_test
  file_path: src/google/adk/cli/conformance/cli_test.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: CLI implementation for ADK conformance testing.
  methods:
  - signature: 'def run_conformance_test(test_paths: list[pathlib.Path], mode: str) -> None:'
    docstring: Run conformance tests.
- rank: 476
  id: google.adk.cli.conformance.cli_test.ConformanceTestRunner
  name: ConformanceTestRunner
  file_path: src/google/adk/cli/conformance/cli_test.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Runs conformance tests in replay mode.
  constructor_signature: 'def __init__(self, test_paths: list[pathlib.Path], client: google.adk.cli.conformance.adk_web_server_client.AdkWebServerClient, mode: str, user_id: str):'
  methods:
  - signature: 'def run_all_tests(self) -> google.adk.cli.conformance.cli_test._ConformanceTestSummary:'
    docstring: Run all discovered test cases.
- rank: 477
  id: google.adk.cli.conformance.cli_test.ConformanceTestRunner.__init__
  name: __init__
  file_path: src/google/adk/cli/conformance/cli_test.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, test_paths: list[pathlib.Path], client: google.adk.cli.conformance.adk_web_server_client.AdkWebServerClient, mode: str, user_id: str):'
- rank: 478
  id: google.adk.cli.conformance.cli_test.ConformanceTestRunner.run_all_tests
  name: run_all_tests
  file_path: src/google/adk/cli/conformance/cli_test.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Run all discovered test cases.
  signature: 'def run_all_tests(self) -> google.adk.cli.conformance.cli_test._ConformanceTestSummary:'
- rank: 479
  id: google.adk.cli.conformance.cli_test.run_conformance_test
  name: run_conformance_test
  file_path: src/google/adk/cli/conformance/cli_test.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Run conformance tests.
  signature: 'def run_conformance_test(test_paths: list[pathlib.Path], mode: str) -> None:'
- rank: 480
  id: google.adk.cli.fast_api
  name: fast_api
  file_path: src/google/adk/cli/fast_api.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def get_fast_api_app(*, agents_dir: str, session_service_uri: typing.Optional[str]=None, session_db_kwargs: typing.Optional[typing.Mapping[str, typing.Any]]=None, artifact_service_uri: typing.Optional[str]=None, memory_service_uri: typing.Optional[str]=None, use_local_storage: bool=True, eval_storage_uri: typing.Optional[str]=None, allow_origins: typing.Optional[list[str]]=None, web: bool, a2a: bool=False, host: str=''127.0.0.1'', port: int=8000, url_prefix: typing.Optional[str]=None, trace_to_cloud: bool=False, otel_to_cloud: bool=False, reload_agents: bool=False, lifespan: typing.Optional[starlette.types.Lifespan[fastapi.FastAPI]]=None, extra_plugins: typing.Optional[list[str]]=None, logo_text: typing.Optional[str]=None, logo_image_url: typing.Optional[str]=None) -> fastapi.FastAPI:'
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '_LAZY_SERVICE_IMPORTS: dict[str, str]'
- rank: 481
  id: google.adk.cli.fast_api.get_fast_api_app
  name: get_fast_api_app
  file_path: src/google/adk/cli/fast_api.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_fast_api_app(*, agents_dir: str, session_service_uri: typing.Optional[str]=None, session_db_kwargs: typing.Optional[typing.Mapping[str, typing.Any]]=None, artifact_service_uri: typing.Optional[str]=None, memory_service_uri: typing.Optional[str]=None, use_local_storage: bool=True, eval_storage_uri: typing.Optional[str]=None, allow_origins: typing.Optional[list[str]]=None, web: bool, a2a: bool=False, host: str=''127.0.0.1'', port: int=8000, url_prefix: typing.Optional[str]=None, trace_to_cloud: bool=False, otel_to_cloud: bool=False, reload_agents: bool=False, lifespan: typing.Optional[starlette.types.Lifespan[fastapi.FastAPI]]=None, extra_plugins: typing.Optional[list[str]]=None, logo_text: typing.Optional[str]=None, logo_image_url: typing.Optional[str]=None) -> fastapi.FastAPI:'
- rank: 482
  id: google.adk.cli.plugins
  name: plugins
  file_path: src/google/adk/cli/plugins/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 483
  id: google.adk.cli.plugins.recordings_plugin
  name: recordings_plugin
  file_path: src/google/adk/cli/plugins/recordings_plugin.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Recording plugin for ADK conformance testing.
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 484
  id: google.adk.cli.plugins.recordings_plugin.RecordingsPlugin
  name: RecordingsPlugin
  file_path: src/google/adk/cli/plugins/recordings_plugin.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Plugin for recording ADK agent interactions.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, *, name: str=''adk_recordings'') -> None:'
  methods:
  - signature: 'def before_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.Optional[google.genai.types.Content]:'
    docstring: Always create fresh per-invocation recording state when enabled.
  - signature: 'def before_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
    docstring: 'Create pending LLM recording awaiting response.


      Uses per-invocation recording state. Assumes state was created in

      before_run; raises if missing to surface misuse.'
  - signature: 'def after_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_response: google.adk.models.llm_response.LlmResponse) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
    docstring: Complete pending LLM recording for the invocation specified in session state.
  - signature: 'def before_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Optional[dict]:'
    docstring: Create pending tool recording for the invocation specified in session state.
  - signature: 'def after_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, result: dict) -> typing.Optional[dict]:'
    docstring: Complete pending tool recording for the invocation specified in session state.
  - signature: 'def on_tool_error_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, error: Exception) -> typing.Optional[dict]:'
    docstring: 'Handle tool error callback with state guard.


      Recording schema does not yet capture errors; we only validate state.'
  - signature: 'def after_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> None:'
    docstring: Finalize and persist recordings, then clean per-invocation state.
  inherited_methods:
    BasePlugin:
    - signature: 'def on_user_message_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, user_message: google.genai.types.Content) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed when a user message is received before an invocation starts.\n\nThis callback helps logging and modifying the user message before the\nrunner starts the invocation.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n  user_message: The message content input by user.\n\nReturns:\n  An optional `types.Content` to be returned to the ADK. Returning a\n  value to replace the user message. Returning `None` to proceed\n  normally."
    - signature: 'def before_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed before the ADK runner runs.\n\nThis is the first callback to be called in the lifecycle, ideal for global\nsetup or initialization tasks.\n\nArgs:\n  invocation_context: The context for the entire invocation, containing\n    session information, the root agent, etc.\n\nReturns:\n  An optional `Event` to be returned to the ADK. Returning a value to\n  halt execution of the runner and ends the runner with that event. Return\n  `None` to proceed normally."
    - signature: 'def on_event_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, event: google.adk.events.event.Event) -> typing.Optional[google.adk.events.event.Event]:'
      docstring: "Callback executed after an event is yielded from runner.\n\nThis is the ideal place to make modification to the event before the event\nis handled by the underlying agent app.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n  event: The event raised by the runner.\n\nReturns:\n  An optional value. A non-`None` return may be used by the framework to\n  modify or replace the response. Returning `None` allows the original\n  response to be used."
    - signature: 'def after_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> None:'
      docstring: "Callback executed after an ADK runner run has completed.\n\nThis is the final callback in the ADK lifecycle, suitable for cleanup, final\nlogging, or reporting tasks.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n\nReturns:\n  None"
    - signature: 'def close(self) -> None:'
      docstring: 'Method executed when the runner is closed.


        This method is used for cleanup tasks such as closing network connections

        or releasing resources.'
    - signature: 'def before_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed before an agent's primary logic is invoked.\n\nThis callback can be used for logging, setup, or to short-circuit the\nagent's execution by returning a value.\n\nArgs:\n  agent: The agent that is about to run.\n  callback_context: The context for the agent invocation.\n\nReturns:\n  An optional `types.Content` object. If a value is returned, it will bypass\n  the agent's callbacks and its execution, and return this value directly.\n  Returning `None` allows the agent to proceed normally."
    - signature: 'def after_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed after an agent's primary logic has completed.\n\nArgs:\n  agent: The agent that has just run.\n  callback_context: The context for the agent invocation.\n\nReturns:\n  An optional `types.Content` object. The content to return to the user.\n  When the content is present, the provided content will be used as agent\n  response and appended to event history as agent response."
    - signature: 'def before_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed before a request is sent to the model.\n\nThis provides an opportunity to inspect, log, or modify the `LlmRequest`\nobject. It can also be used to implement caching by returning a cached\n`LlmResponse`, which would skip the actual model call.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_request: The prepared request object to be sent to the model.\n\nReturns:\n  An optional value. The interpretation of a non-`None` trigger an early\n  exit and returns the response immediately. Returning `None` allows the LLM\n  request to proceed normally."
    - signature: 'def after_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_response: google.adk.models.llm_response.LlmResponse) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed after a response is received from the model.\n\nThis is the ideal place to log model responses, collect metrics on token\nusage, or perform post-processing on the raw `LlmResponse`.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_response: The response object received from the model.\n\nReturns:\n  An optional value. A non-`None` return may be used by the framework to\n  modify or replace the response. Returning `None` allows the original\n  response to be used."
    - signature: 'def on_model_error_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest, error: Exception) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed when a model call encounters an error.\n\nThis callback provides an opportunity to handle model errors gracefully,\npotentially providing alternative responses or recovery mechanisms.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_request: The request that was sent to the model when the error\n    occurred.\n  error: The exception that was raised during model execution.\n\nReturns:\n  An optional LlmResponse. If an LlmResponse is returned, it will be used\n  instead of propagating the error. Returning `None` allows the original\n  error to be raised."
    - signature: 'def before_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Optional[dict]:'
      docstring: "Callback executed before a tool is called.\n\nThis callback is useful for logging tool usage, input validation, or\nmodifying the arguments before they are passed to the tool.\n\nArgs:\n  tool: The tool instance that is about to be executed.\n  tool_args: The dictionary of arguments to be used for invoking the tool.\n  tool_context: The context specific to the tool execution.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will stop the tool\n  execution and return this response immediately. Returning `None` uses the\n  original, unmodified arguments."
    - signature: 'def after_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, result: dict) -> typing.Optional[dict]:'
      docstring: "Callback executed after a tool has been called.\n\nThis callback allows for inspecting, logging, or modifying the result\nreturned by a tool.\n\nArgs:\n  tool: The tool instance that has just been executed.\n  tool_args: The original arguments that were passed to the tool.\n  tool_context: The context specific to the tool execution.\n  result: The dictionary returned by the tool invocation.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will **replace**\n  the original result from the tool. This allows for post-processing or\n  altering tool outputs. Returning `None` uses the original, unmodified\n  result."
    - signature: 'def on_tool_error_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, error: Exception) -> typing.Optional[dict]:'
      docstring: "Callback executed when a tool call encounters an error.\n\nThis callback provides an opportunity to handle tool errors gracefully,\npotentially providing alternative responses or recovery mechanisms.\n\nArgs:\n  tool: The tool instance that encountered an error.\n  tool_args: The arguments that were passed to the tool.\n  tool_context: The context specific to the tool execution.\n  error: The exception that was raised during tool execution.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will be used as\n  the tool response instead of propagating the error. Returning `None`\n  allows the original error to be raised."
  omitted_inherited_members_from:
  - ABC
- rank: 485
  id: google.adk.cli.plugins.recordings_plugin.RecordingsPlugin.__init__
  name: __init__
  file_path: src/google/adk/cli/plugins/recordings_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, *, name: str=''adk_recordings'') -> None:'
- rank: 486
  id: google.adk.cli.plugins.recordings_plugin.RecordingsPlugin.after_model_callback
  name: after_model_callback
  file_path: src/google/adk/cli/plugins/recordings_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Complete pending LLM recording for the invocation specified in session state.
  signature: 'def after_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_response: google.adk.models.llm_response.LlmResponse) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
- rank: 487
  id: google.adk.cli.plugins.recordings_plugin.RecordingsPlugin.after_run_callback
  name: after_run_callback
  file_path: src/google/adk/cli/plugins/recordings_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Finalize and persist recordings, then clean per-invocation state.
  signature: 'def after_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> None:'
- rank: 488
  id: google.adk.cli.plugins.recordings_plugin.RecordingsPlugin.after_tool_callback
  name: after_tool_callback
  file_path: src/google/adk/cli/plugins/recordings_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Complete pending tool recording for the invocation specified in session state.
  signature: 'def after_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, result: dict) -> typing.Optional[dict]:'
- rank: 489
  id: google.adk.cli.plugins.recordings_plugin.RecordingsPlugin.before_model_callback
  name: before_model_callback
  file_path: src/google/adk/cli/plugins/recordings_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Create pending LLM recording awaiting response.


    Uses per-invocation recording state. Assumes state was created in

    before_run; raises if missing to surface misuse.'
  signature: 'def before_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
- rank: 490
  id: google.adk.cli.plugins.recordings_plugin.RecordingsPlugin.before_run_callback
  name: before_run_callback
  file_path: src/google/adk/cli/plugins/recordings_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Always create fresh per-invocation recording state when enabled.
  signature: 'def before_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.Optional[google.genai.types.Content]:'
- rank: 491
  id: google.adk.cli.plugins.recordings_plugin.RecordingsPlugin.before_tool_callback
  name: before_tool_callback
  file_path: src/google/adk/cli/plugins/recordings_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Create pending tool recording for the invocation specified in session state.
  signature: 'def before_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Optional[dict]:'
- rank: 492
  id: google.adk.cli.plugins.recordings_plugin.RecordingsPlugin.on_tool_error_callback
  name: on_tool_error_callback
  file_path: src/google/adk/cli/plugins/recordings_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Handle tool error callback with state guard.


    Recording schema does not yet capture errors; we only validate state.'
  signature: 'def on_tool_error_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, error: Exception) -> typing.Optional[dict]:'
- rank: 493
  id: google.adk.cli.plugins.recordings_schema
  name: recordings_schema
  file_path: src/google/adk/cli/plugins/recordings_schema.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Pydantic models for ADK recordings.
- rank: 494
  id: google.adk.cli.plugins.recordings_schema.LlmRecording
  name: LlmRecording
  file_path: src/google/adk/cli/plugins/recordings_schema.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Paired LLM request and response.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, llm_request: typing.Optional[google.adk.models.llm_request.LlmRequest] = None, llm_response: typing.Optional[google.adk.models.llm_response.LlmResponse] = None):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'llm_request: typing.Optional[google.adk.models.llm_request.LlmRequest]'
    docstring: Required. The LLM request.
  - signature: 'llm_response: typing.Optional[google.adk.models.llm_response.LlmResponse]'
    docstring: Required. The LLM response.
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 495
  id: google.adk.cli.plugins.recordings_schema.Recording
  name: Recording
  file_path: src/google/adk/cli/plugins/recordings_schema.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Single interaction recording, ordered by request timestamp.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, user_message_index: int, agent_name: str, llm_recording: typing.Optional[google.adk.cli.plugins.recordings_schema.LlmRecording] = None, tool_recording: typing.Optional[google.adk.cli.plugins.recordings_schema.ToolRecording] = None):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'user_message_index: int'
    docstring: Index of the user message this recording belongs to (0-based).
  - signature: 'agent_name: str'
    docstring: Name of the agent.
  - signature: 'llm_recording: typing.Optional[google.adk.cli.plugins.recordings_schema.LlmRecording]'
    docstring: LLM request-response pair.
  - signature: 'tool_recording: typing.Optional[google.adk.cli.plugins.recordings_schema.ToolRecording]'
    docstring: Tool call-response pair.
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 496
  id: google.adk.cli.plugins.recordings_schema.Recordings
  name: Recordings
  file_path: src/google/adk/cli/plugins/recordings_schema.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'All recordings in chronological order.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, recordings: list[google.adk.cli.plugins.recordings_schema.Recording] = list()):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'recordings: list[google.adk.cli.plugins.recordings_schema.Recording]'
    docstring: Chronological list of all recordings.
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 497
  id: google.adk.cli.plugins.recordings_schema.ToolRecording
  name: ToolRecording
  file_path: src/google/adk/cli/plugins/recordings_schema.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Paired tool call and response.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, tool_call: typing.Optional[google.genai.types.FunctionCall] = None, tool_response: typing.Optional[google.genai.types.FunctionResponse] = None):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'tool_call: typing.Optional[google.genai.types.FunctionCall]'
    docstring: Required. The tool call.
  - signature: 'tool_response: typing.Optional[google.genai.types.FunctionResponse]'
    docstring: Required. The tool response.
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 498
  id: google.adk.cli.plugins.replay_plugin
  name: replay_plugin
  file_path: src/google/adk/cli/plugins/replay_plugin.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Replay plugin for ADK conformance testing.
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 499
  id: google.adk.cli.plugins.replay_plugin.ReplayConfigError
  name: ReplayConfigError
  file_path: src/google/adk/cli/plugins/replay_plugin.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Exception raised when replay configuration is invalid or missing.


    [Note: Inherited members from Exception are omitted.]'
  omitted_inherited_members_from:
  - Exception
- rank: 500
  id: google.adk.cli.plugins.replay_plugin.ReplayPlugin
  name: ReplayPlugin
  file_path: src/google/adk/cli/plugins/replay_plugin.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Plugin for replaying ADK agent interactions from recordings.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, *, name: str=''adk_replay'') -> None:'
  methods:
  - signature: 'def before_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.Optional[google.genai.types.Content]:'
    docstring: Load replay recordings when enabled.
  - signature: 'def before_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
    docstring: Replay LLM response from recordings instead of making real call.
  - signature: 'def before_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Optional[dict]:'
    docstring: Replay tool response from recordings instead of executing tool.
  - signature: 'def after_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> None:'
    docstring: Clean up replay state after invocation completes.
  inherited_methods:
    BasePlugin:
    - signature: 'def on_user_message_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, user_message: google.genai.types.Content) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed when a user message is received before an invocation starts.\n\nThis callback helps logging and modifying the user message before the\nrunner starts the invocation.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n  user_message: The message content input by user.\n\nReturns:\n  An optional `types.Content` to be returned to the ADK. Returning a\n  value to replace the user message. Returning `None` to proceed\n  normally."
    - signature: 'def before_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed before the ADK runner runs.\n\nThis is the first callback to be called in the lifecycle, ideal for global\nsetup or initialization tasks.\n\nArgs:\n  invocation_context: The context for the entire invocation, containing\n    session information, the root agent, etc.\n\nReturns:\n  An optional `Event` to be returned to the ADK. Returning a value to\n  halt execution of the runner and ends the runner with that event. Return\n  `None` to proceed normally."
    - signature: 'def on_event_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, event: google.adk.events.event.Event) -> typing.Optional[google.adk.events.event.Event]:'
      docstring: "Callback executed after an event is yielded from runner.\n\nThis is the ideal place to make modification to the event before the event\nis handled by the underlying agent app.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n  event: The event raised by the runner.\n\nReturns:\n  An optional value. A non-`None` return may be used by the framework to\n  modify or replace the response. Returning `None` allows the original\n  response to be used."
    - signature: 'def after_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> None:'
      docstring: "Callback executed after an ADK runner run has completed.\n\nThis is the final callback in the ADK lifecycle, suitable for cleanup, final\nlogging, or reporting tasks.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n\nReturns:\n  None"
    - signature: 'def close(self) -> None:'
      docstring: 'Method executed when the runner is closed.


        This method is used for cleanup tasks such as closing network connections

        or releasing resources.'
    - signature: 'def before_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed before an agent's primary logic is invoked.\n\nThis callback can be used for logging, setup, or to short-circuit the\nagent's execution by returning a value.\n\nArgs:\n  agent: The agent that is about to run.\n  callback_context: The context for the agent invocation.\n\nReturns:\n  An optional `types.Content` object. If a value is returned, it will bypass\n  the agent's callbacks and its execution, and return this value directly.\n  Returning `None` allows the agent to proceed normally."
    - signature: 'def after_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed after an agent's primary logic has completed.\n\nArgs:\n  agent: The agent that has just run.\n  callback_context: The context for the agent invocation.\n\nReturns:\n  An optional `types.Content` object. The content to return to the user.\n  When the content is present, the provided content will be used as agent\n  response and appended to event history as agent response."
    - signature: 'def before_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed before a request is sent to the model.\n\nThis provides an opportunity to inspect, log, or modify the `LlmRequest`\nobject. It can also be used to implement caching by returning a cached\n`LlmResponse`, which would skip the actual model call.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_request: The prepared request object to be sent to the model.\n\nReturns:\n  An optional value. The interpretation of a non-`None` trigger an early\n  exit and returns the response immediately. Returning `None` allows the LLM\n  request to proceed normally."
    - signature: 'def after_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_response: google.adk.models.llm_response.LlmResponse) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed after a response is received from the model.\n\nThis is the ideal place to log model responses, collect metrics on token\nusage, or perform post-processing on the raw `LlmResponse`.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_response: The response object received from the model.\n\nReturns:\n  An optional value. A non-`None` return may be used by the framework to\n  modify or replace the response. Returning `None` allows the original\n  response to be used."
    - signature: 'def on_model_error_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest, error: Exception) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed when a model call encounters an error.\n\nThis callback provides an opportunity to handle model errors gracefully,\npotentially providing alternative responses or recovery mechanisms.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_request: The request that was sent to the model when the error\n    occurred.\n  error: The exception that was raised during model execution.\n\nReturns:\n  An optional LlmResponse. If an LlmResponse is returned, it will be used\n  instead of propagating the error. Returning `None` allows the original\n  error to be raised."
    - signature: 'def before_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Optional[dict]:'
      docstring: "Callback executed before a tool is called.\n\nThis callback is useful for logging tool usage, input validation, or\nmodifying the arguments before they are passed to the tool.\n\nArgs:\n  tool: The tool instance that is about to be executed.\n  tool_args: The dictionary of arguments to be used for invoking the tool.\n  tool_context: The context specific to the tool execution.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will stop the tool\n  execution and return this response immediately. Returning `None` uses the\n  original, unmodified arguments."
    - signature: 'def after_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, result: dict) -> typing.Optional[dict]:'
      docstring: "Callback executed after a tool has been called.\n\nThis callback allows for inspecting, logging, or modifying the result\nreturned by a tool.\n\nArgs:\n  tool: The tool instance that has just been executed.\n  tool_args: The original arguments that were passed to the tool.\n  tool_context: The context specific to the tool execution.\n  result: The dictionary returned by the tool invocation.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will **replace**\n  the original result from the tool. This allows for post-processing or\n  altering tool outputs. Returning `None` uses the original, unmodified\n  result."
    - signature: 'def on_tool_error_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, error: Exception) -> typing.Optional[dict]:'
      docstring: "Callback executed when a tool call encounters an error.\n\nThis callback provides an opportunity to handle tool errors gracefully,\npotentially providing alternative responses or recovery mechanisms.\n\nArgs:\n  tool: The tool instance that encountered an error.\n  tool_args: The arguments that were passed to the tool.\n  tool_context: The context specific to the tool execution.\n  error: The exception that was raised during tool execution.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will be used as\n  the tool response instead of propagating the error. Returning `None`\n  allows the original error to be raised."
  omitted_inherited_members_from:
  - ABC
- rank: 501
  id: google.adk.cli.plugins.replay_plugin.ReplayPlugin.__init__
  name: __init__
  file_path: src/google/adk/cli/plugins/replay_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, *, name: str=''adk_replay'') -> None:'
- rank: 502
  id: google.adk.cli.plugins.replay_plugin.ReplayPlugin.after_run_callback
  name: after_run_callback
  file_path: src/google/adk/cli/plugins/replay_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Clean up replay state after invocation completes.
  signature: 'def after_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> None:'
- rank: 503
  id: google.adk.cli.plugins.replay_plugin.ReplayPlugin.before_model_callback
  name: before_model_callback
  file_path: src/google/adk/cli/plugins/replay_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Replay LLM response from recordings instead of making real call.
  signature: 'def before_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
- rank: 504
  id: google.adk.cli.plugins.replay_plugin.ReplayPlugin.before_run_callback
  name: before_run_callback
  file_path: src/google/adk/cli/plugins/replay_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Load replay recordings when enabled.
  signature: 'def before_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.Optional[google.genai.types.Content]:'
- rank: 505
  id: google.adk.cli.plugins.replay_plugin.ReplayPlugin.before_tool_callback
  name: before_tool_callback
  file_path: src/google/adk/cli/plugins/replay_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Replay tool response from recordings instead of executing tool.
  signature: 'def before_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Optional[dict]:'
- rank: 506
  id: google.adk.cli.plugins.replay_plugin.ReplayVerificationError
  name: ReplayVerificationError
  file_path: src/google/adk/cli/plugins/replay_plugin.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Exception raised when replay verification fails.


    [Note: Inherited members from Exception are omitted.]'
  omitted_inherited_members_from:
  - Exception
- rank: 507
  id: google.adk.cli.service_registry
  name: service_registry
  file_path: src/google/adk/cli/service_registry.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: "ADK Service Registry.\n\nThis module manages pluggable backend services for sessions, artifacts, and memory.\nADK includes built-in support for common backends like SQLite, PostgreSQL,\nGCS, and Vertex AI Agent Engine. You can also extend ADK by registering\ncustom services.\n\nThere are two ways to register custom services:\n\n1. YAML Configuration (Recommended for simple cases)\n   If your custom service can be instantiated with `MyService(uri=\"...\", **kwargs)`,\n   you can register it without writing Python code by creating a `services.yaml`\n   or `services.yml` file in your agent directory (e.g., `my_agent/services.yaml`).\n\n   Example `services.yaml`:\n   ```yaml\n   services:\n     - scheme: mysession\n       type: session\n       class: my_package.my_module.MyCustomSessionService\n     - scheme: mymemory\n       type: memory\n       class: my_package.other_module.MyCustomMemoryService\n   ```\n\n2. Python Registration (`services.py`)\n   For more complex initialization\
    \ logic, create a `services.py` file in your\n   agent directory (e.g., `my_agent/services.py`). In this file, get the\n   registry instance and register your custom factory functions. This file can\n   be used for registration in addition to, or instead of, `services.yaml`.\n\n   Example `services.py`:\n   ```python\n   from google.adk.cli.service_registry import get_service_registry\n   from my_package.my_module import MyCustomSessionService\n\n   def my_session_factory(uri: str, **kwargs):\n       # custom logic\n       return MyCustomSessionService(...)\n\n   get_service_registry().register_session_service(\"mysession\", my_session_factory)\n   ```\n\nNote: If both `services.yaml` (or `.yml`) and `services.py` are present in the\nsame directory, services from **both** files will be loaded. YAML files are\nprocessed first, then `services.py`. If the same service scheme is defined in\nboth, the definition in `services.py` will overwrite the one from YAML."
  methods:
  - signature: 'def get_service_registry() -> google.adk.cli.service_registry.ServiceRegistry:'
    docstring: Gets the singleton ServiceRegistry instance, initializing it if needed.
  - signature: 'def load_services_module(agents_dir: str) -> None:'
    docstring: 'Load services.py or services.yaml from agents_dir for custom service registration.


      If services.yaml or services.yml is found, it will be loaded first,

      followed by services.py if it exists.


      Skip if neither services.yaml/yml nor services.py is not found.'
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '_service_registry_instance: ServiceRegistry | None'
- rank: 508
  id: google.adk.cli.service_registry.ServiceFactory
  name: ServiceFactory
  file_path: src/google/adk/cli/service_registry.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Protocol for service factory functions.


    [Note: Inherited members from Protocol are omitted.]'
  omitted_inherited_members_from:
  - Protocol
- rank: 509
  id: google.adk.cli.service_registry.ServiceRegistry
  name: ServiceRegistry
  file_path: src/google/adk/cli/service_registry.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Registry for custom service URI schemes.
  constructor_signature: 'def __init__(self):'
  methods:
  - signature: 'def register_session_service(self, scheme: str, factory: google.adk.cli.service_registry.ServiceFactory) -> None:'
    docstring: "Register a factory for a custom session service URI scheme.\n\nArgs:\n    scheme: URI scheme (e.g., 'custom')\n    factory: Callable that takes (uri, **kwargs) and returns\n      BaseSessionService"
  - signature: 'def register_artifact_service(self, scheme: str, factory: google.adk.cli.service_registry.ServiceFactory) -> None:'
    docstring: Register a factory for a custom artifact service URI scheme.
  - signature: 'def register_memory_service(self, scheme: str, factory: google.adk.cli.service_registry.ServiceFactory) -> None:'
    docstring: Register a factory for a custom memory service URI scheme.
  - signature: 'def create_session_service(self, uri: str) -> BaseSessionService | None:'
    docstring: Create session service from URI using registered factories.
  - signature: 'def create_artifact_service(self, uri: str) -> BaseArtifactService | None:'
    docstring: Create artifact service from URI using registered factories.
  - signature: 'def create_memory_service(self, uri: str) -> BaseMemoryService | None:'
    docstring: Create memory service from URI using registered factories.
- rank: 510
  id: google.adk.cli.service_registry.ServiceRegistry.__init__
  name: __init__
  file_path: src/google/adk/cli/service_registry.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self):'
- rank: 511
  id: google.adk.cli.service_registry.ServiceRegistry.create_artifact_service
  name: create_artifact_service
  file_path: src/google/adk/cli/service_registry.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Create artifact service from URI using registered factories.
  signature: 'def create_artifact_service(self, uri: str) -> BaseArtifactService | None:'
- rank: 512
  id: google.adk.cli.service_registry.ServiceRegistry.create_memory_service
  name: create_memory_service
  file_path: src/google/adk/cli/service_registry.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Create memory service from URI using registered factories.
  signature: 'def create_memory_service(self, uri: str) -> BaseMemoryService | None:'
- rank: 513
  id: google.adk.cli.service_registry.ServiceRegistry.create_session_service
  name: create_session_service
  file_path: src/google/adk/cli/service_registry.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Create session service from URI using registered factories.
  signature: 'def create_session_service(self, uri: str) -> BaseSessionService | None:'
- rank: 514
  id: google.adk.cli.service_registry.ServiceRegistry.register_artifact_service
  name: register_artifact_service
  file_path: src/google/adk/cli/service_registry.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Register a factory for a custom artifact service URI scheme.
  signature: 'def register_artifact_service(self, scheme: str, factory: google.adk.cli.service_registry.ServiceFactory) -> None:'
- rank: 515
  id: google.adk.cli.service_registry.ServiceRegistry.register_memory_service
  name: register_memory_service
  file_path: src/google/adk/cli/service_registry.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Register a factory for a custom memory service URI scheme.
  signature: 'def register_memory_service(self, scheme: str, factory: google.adk.cli.service_registry.ServiceFactory) -> None:'
- rank: 516
  id: google.adk.cli.service_registry.ServiceRegistry.register_session_service
  name: register_session_service
  file_path: src/google/adk/cli/service_registry.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Register a factory for a custom session service URI scheme.\n\nArgs:\n    scheme: URI scheme (e.g., 'custom')\n    factory: Callable that takes (uri, **kwargs) and returns\n      BaseSessionService"
  signature: 'def register_session_service(self, scheme: str, factory: google.adk.cli.service_registry.ServiceFactory) -> None:'
- rank: 517
  id: google.adk.cli.service_registry.get_service_registry
  name: get_service_registry
  file_path: src/google/adk/cli/service_registry.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Gets the singleton ServiceRegistry instance, initializing it if needed.
  signature: 'def get_service_registry() -> google.adk.cli.service_registry.ServiceRegistry:'
- rank: 518
  id: google.adk.cli.service_registry.load_services_module
  name: load_services_module
  file_path: src/google/adk/cli/service_registry.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Load services.py or services.yaml from agents_dir for custom service registration.


    If services.yaml or services.yml is found, it will be loaded first,

    followed by services.py if it exists.


    Skip if neither services.yaml/yml nor services.py is not found.'
  signature: 'def load_services_module(agents_dir: str) -> None:'
- rank: 519
  id: google.adk.cli.utils
  name: utils
  file_path: src/google/adk/cli/utils/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: '__all__: Any'
- rank: 520
  id: google.adk.cli.utils.agent_change_handler
  name: agent_change_handler
  file_path: src/google/adk/cli/utils/agent_change_handler.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: File system event handler for agent changes to trigger hot reload for agents.
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 521
  id: google.adk.cli.utils.agent_change_handler.AgentChangeEventHandler
  name: AgentChangeEventHandler
  file_path: src/google/adk/cli/utils/agent_change_handler.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from FileSystemEventHandler are omitted.]'
  constructor_signature: 'def __init__(self, agent_loader: google.adk.cli.utils.agent_loader.AgentLoader, runners_to_clean: set[str], current_app_name_ref: google.adk.cli.utils.shared_value.SharedValue[str]):'
  methods:
  - signature: 'def on_modified(self, event):'
  omitted_inherited_members_from:
  - FileSystemEventHandler
- rank: 522
  id: google.adk.cli.utils.agent_change_handler.AgentChangeEventHandler.__init__
  name: __init__
  file_path: src/google/adk/cli/utils/agent_change_handler.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, agent_loader: google.adk.cli.utils.agent_loader.AgentLoader, runners_to_clean: set[str], current_app_name_ref: google.adk.cli.utils.shared_value.SharedValue[str]):'
- rank: 523
  id: google.adk.cli.utils.agent_change_handler.AgentChangeEventHandler.on_modified
  name: on_modified
  file_path: src/google/adk/cli/utils/agent_change_handler.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def on_modified(self, event):'
- rank: 524
  id: google.adk.cli.utils.agent_loader
  name: agent_loader
  file_path: src/google/adk/cli/utils/agent_loader.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: 'SPECIAL_AGENTS_DIR: os.path.join'
- rank: 525
  id: google.adk.cli.utils.agent_loader.AgentLoader
  name: AgentLoader
  file_path: src/google/adk/cli/utils/agent_loader.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "Centralized agent loading with proper isolation, caching, and .env loading.\nSupport loading agents from below folder/file structures:\na)  {agent_name}.agent as a module name:\n    agents_dir/{agent_name}/agent.py (with root_agent defined in the module)\nb)  {agent_name} as a module name\n    agents_dir/{agent_name}.py (with root_agent defined in the module)\nc)  {agent_name} as a package name\n    agents_dir/{agent_name}/__init__.py (with root_agent in the package)\nd)  {agent_name} as a YAML config folder:\n    agents_dir/{agent_name}/root_agent.yaml defines the root agent\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, agents_dir: str):'
  methods:
  - signature: 'def load_agent(self, agent_name: str) -> typing.Union[google.adk.agents.base_agent.BaseAgent, google.adk.apps.app.App]:'
    docstring: Load an agent module (with caching & .env) and return its root_agent.
  - signature: 'def list_agents(self) -> list[str]:'
    docstring: Lists all agents available in the agent loader (sorted alphabetically).
  - signature: 'def list_agents_detailed(self) -> list[dict[str, typing.Any]]:'
    docstring: Lists all agents with detailed metadata (name, description, type).
  - signature: 'def remove_agent_from_cache(self, agent_name: str):'
  inherited_methods:
    BaseAgentLoader:
    - signature: 'def load_agent(self, agent_name: str) -> typing.Union[google.adk.agents.base_agent.BaseAgent, google.adk.apps.app.App]:'
      docstring: Loads an instance of an agent with the given name.
    - signature: 'def list_agents(self) -> list[str]:'
      docstring: Lists all agents available in the agent loader in alphabetical order.
    - signature: 'def list_agents_detailed(self) -> list[dict[str, typing.Any]]:'
  omitted_inherited_members_from:
  - ABC
- rank: 526
  id: google.adk.cli.utils.agent_loader.AgentLoader.__init__
  name: __init__
  file_path: src/google/adk/cli/utils/agent_loader.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, agents_dir: str):'
- rank: 527
  id: google.adk.cli.utils.agent_loader.AgentLoader.list_agents
  name: list_agents
  file_path: src/google/adk/cli/utils/agent_loader.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Lists all agents available in the agent loader (sorted alphabetically).
  signature: 'def list_agents(self) -> list[str]:'
- rank: 528
  id: google.adk.cli.utils.agent_loader.AgentLoader.list_agents_detailed
  name: list_agents_detailed
  file_path: src/google/adk/cli/utils/agent_loader.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Lists all agents with detailed metadata (name, description, type).
  signature: 'def list_agents_detailed(self) -> list[dict[str, typing.Any]]:'
- rank: 529
  id: google.adk.cli.utils.agent_loader.AgentLoader.load_agent
  name: load_agent
  file_path: src/google/adk/cli/utils/agent_loader.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Load an agent module (with caching & .env) and return its root_agent.
  signature: 'def load_agent(self, agent_name: str) -> typing.Union[google.adk.agents.base_agent.BaseAgent, google.adk.apps.app.App]:'
- rank: 530
  id: google.adk.cli.utils.agent_loader.AgentLoader.remove_agent_from_cache
  name: remove_agent_from_cache
  file_path: src/google/adk/cli/utils/agent_loader.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def remove_agent_from_cache(self, agent_name: str):'
- rank: 531
  id: google.adk.cli.utils.base_agent_loader
  name: base_agent_loader
  file_path: src/google/adk/cli/utils/base_agent_loader.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Base class for agent loaders.
- rank: 532
  id: google.adk.cli.utils.base_agent_loader.BaseAgentLoader
  name: BaseAgentLoader
  file_path: src/google/adk/cli/utils/base_agent_loader.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Abstract base class for agent loaders.


    [Note: Inherited members from ABC are omitted.]'
  methods:
  - signature: 'def load_agent(self, agent_name: str) -> typing.Union[google.adk.agents.base_agent.BaseAgent, google.adk.apps.app.App]:'
    docstring: Loads an instance of an agent with the given name.
  - signature: 'def list_agents(self) -> list[str]:'
    docstring: Lists all agents available in the agent loader in alphabetical order.
  - signature: 'def list_agents_detailed(self) -> list[dict[str, typing.Any]]:'
  omitted_inherited_members_from:
  - ABC
- rank: 533
  id: google.adk.cli.utils.base_agent_loader.BaseAgentLoader.list_agents_detailed
  name: list_agents_detailed
  file_path: src/google/adk/cli/utils/base_agent_loader.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def list_agents_detailed(self) -> list[dict[str, typing.Any]]:'
- rank: 534
  id: google.adk.cli.utils.cleanup
  name: cleanup
  file_path: src/google/adk/cli/utils/cleanup.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def close_runners(runners: typing.List[google.adk.runners.Runner]) -> None:'
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 535
  id: google.adk.cli.utils.cleanup.close_runners
  name: close_runners
  file_path: src/google/adk/cli/utils/cleanup.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def close_runners(runners: typing.List[google.adk.runners.Runner]) -> None:'
- rank: 536
  id: google.adk.cli.utils.common
  name: common
  file_path: src/google/adk/cli/utils/common.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 537
  id: google.adk.cli.utils.common.BaseModel
  name: BaseModel
  file_path: src/google/adk/cli/utils/common.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 538
  id: google.adk.cli.utils.dot_adk_folder
  name: dot_adk_folder
  file_path: src/google/adk/cli/utils/dot_adk_folder.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Helpers for managing an agent's `.adk` folder.
  methods:
  - signature: 'def dot_adk_folder_for_agent(*, agents_root: Path | str, app_name: str) -> google.adk.cli.utils.dot_adk_folder.DotAdkFolder:'
    docstring: "Creates a manager for an agent rooted under `agents_root`.\n\nArgs:\n  agents_root: Directory that contains all agents.\n  app_name: Name of the agent directory.\n\nReturns:\n  A `DotAdkFolder` scoped to the given agent.\n\nRaises:\n  ValueError: If `app_name` traverses outside of `agents_root`."
- rank: 539
  id: google.adk.cli.utils.dot_adk_folder.DotAdkFolder
  name: DotAdkFolder
  file_path: src/google/adk/cli/utils/dot_adk_folder.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Manages the lifecycle of the `.adk` folder for a single agent.
  constructor_signature: 'def __init__(self, agent_dir: Path | str):'
  methods:
  - signature: 'def agent_dir(self) -> pathlib.Path:'
  - signature: 'def dot_adk_dir(self) -> pathlib.Path:'
  - signature: 'def artifacts_dir(self) -> pathlib.Path:'
  - signature: 'def session_db_path(self) -> pathlib.Path:'
- rank: 540
  id: google.adk.cli.utils.dot_adk_folder.dot_adk_folder_for_agent
  name: dot_adk_folder_for_agent
  file_path: src/google/adk/cli/utils/dot_adk_folder.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Creates a manager for an agent rooted under `agents_root`.\n\nArgs:\n  agents_root: Directory that contains all agents.\n  app_name: Name of the agent directory.\n\nReturns:\n  A `DotAdkFolder` scoped to the given agent.\n\nRaises:\n  ValueError: If `app_name` traverses outside of `agents_root`."
  signature: 'def dot_adk_folder_for_agent(*, agents_root: Path | str, app_name: str) -> google.adk.cli.utils.dot_adk_folder.DotAdkFolder:'
- rank: 541
  id: google.adk.cli.utils.envs
  name: envs
  file_path: src/google/adk/cli/utils/envs.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def load_dotenv_for_agent(agent_name: str, agent_parent_folder: str, filename: str):'
    docstring: 'Loads the `.env` file for the agent module.


      Explicit environment variables (present before the first `.env` load) are

      preserved, while values loaded from `.env` may be overridden by later `.env`

      loads.'
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '_ADK_DISABLE_LOAD_DOTENV_ENV_VAR: str'
- rank: 542
  id: google.adk.cli.utils.envs.load_dotenv_for_agent
  name: load_dotenv_for_agent
  file_path: src/google/adk/cli/utils/envs.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Loads the `.env` file for the agent module.


    Explicit environment variables (present before the first `.env` load) are

    preserved, while values loaded from `.env` may be overridden by later `.env`

    loads.'
  signature: 'def load_dotenv_for_agent(agent_name: str, agent_parent_folder: str, filename: str):'
- rank: 543
  id: google.adk.cli.utils.evals
  name: evals
  file_path: src/google/adk/cli/utils/evals.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def convert_session_to_eval_invocations(session: google.adk.sessions.session.Session) -> list[google.adk.evaluation.eval_case.Invocation]:'
    docstring: "Converts a session data into a list of Invocation.\n\nArgs:\n    session: The session that should be converted.\n\nReturns:\n    list: A list of invocation."
  - signature: 'def create_gcs_eval_managers_from_uri(eval_storage_uri: str) -> google.adk.cli.utils.evals.GcsEvalManagers:'
    docstring: "Creates GcsEvalManagers from eval_storage_uri.\n\nArgs:\n    eval_storage_uri: The evals storage URI to use. Supported URIs:\n      gs://<bucket name>. If a path is provided, the bucket will be extracted.\n\nReturns:\n    GcsEvalManagers: The GcsEvalManagers object.\n\nRaises:\n    ValueError: If the eval_storage_uri is not supported."
- rank: 544
  id: google.adk.cli.utils.evals.GcsEvalManagers
  name: GcsEvalManagers
  file_path: src/google/adk/cli/utils/evals.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, eval_sets_manager: google.adk.evaluation.gcs_eval_sets_manager.GcsEvalSetsManager, eval_set_results_manager: google.adk.evaluation.gcs_eval_set_results_manager.GcsEvalSetResultsManager):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'eval_sets_manager: google.adk.evaluation.gcs_eval_sets_manager.GcsEvalSetsManager'
  - signature: 'eval_set_results_manager: google.adk.evaluation.gcs_eval_set_results_manager.GcsEvalSetResultsManager'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 545
  id: google.adk.cli.utils.evals.convert_session_to_eval_invocations
  name: convert_session_to_eval_invocations
  file_path: src/google/adk/cli/utils/evals.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Converts a session data into a list of Invocation.\n\nArgs:\n    session: The session that should be converted.\n\nReturns:\n    list: A list of invocation."
  signature: 'def convert_session_to_eval_invocations(session: google.adk.sessions.session.Session) -> list[google.adk.evaluation.eval_case.Invocation]:'
- rank: 546
  id: google.adk.cli.utils.evals.create_gcs_eval_managers_from_uri
  name: create_gcs_eval_managers_from_uri
  file_path: src/google/adk/cli/utils/evals.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Creates GcsEvalManagers from eval_storage_uri.\n\nArgs:\n    eval_storage_uri: The evals storage URI to use. Supported URIs:\n      gs://<bucket name>. If a path is provided, the bucket will be extracted.\n\nReturns:\n    GcsEvalManagers: The GcsEvalManagers object.\n\nRaises:\n    ValueError: If the eval_storage_uri is not supported."
  signature: 'def create_gcs_eval_managers_from_uri(eval_storage_uri: str) -> google.adk.cli.utils.evals.GcsEvalManagers:'
- rank: 547
  id: google.adk.cli.utils.local_storage
  name: local_storage
  file_path: src/google/adk/cli/utils/local_storage.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Utilities for local .adk folder persistence.
  methods:
  - signature: 'def create_local_database_session_service(*, base_dir: Path | str) -> google.adk.sessions.base_session_service.BaseSessionService:'
    docstring: "Creates a SQLite-backed session service at .adk/session.db.\n\nArgs:\n  base_dir: The base directory for the agent (parent of .adk folder).\n\nReturns:\n  A SqliteSessionService instance."
  - signature: 'def create_local_session_service(*, base_dir: Path | str, per_agent: bool=False, app_name_to_dir: typing.Optional[typing.Mapping[str, str]]=None) -> google.adk.sessions.base_session_service.BaseSessionService:'
    docstring: "Creates a local SQLite-backed session service.\n\nArgs:\n  base_dir: The base directory for the agent(s).\n  per_agent: If True, creates a PerAgentDatabaseSessionService that stores\n    sessions in each agent's .adk folder. If False, creates a single\n    SqliteSessionService at base_dir/.adk/session.db.\n  app_name_to_dir: Optional mapping from logical app name to on-disk agent\n    folder name. Only used when per_agent is True; defaults to identity.\n\nReturns:\n  A BaseSessionService instance backed by SQLite."
  - signature: 'def create_local_artifact_service(*, base_dir: Path | str) -> google.adk.artifacts.base_artifact_service.BaseArtifactService:'
    docstring: "Creates a file-backed artifact service rooted in `.adk/artifacts`.\n\nArgs:\n  base_dir: Directory whose `.adk` folder will store artifacts.\n\nReturns:\n  A `FileArtifactService` scoped to the derived root directory."
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '_BUILT_IN_SESSION_SERVICE_KEY: str'
- rank: 548
  id: google.adk.cli.utils.local_storage.PerAgentDatabaseSessionService
  name: PerAgentDatabaseSessionService
  file_path: src/google/adk/cli/utils/local_storage.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Routes session storage to per-agent `.adk/session.db` files.


    [Note: Inherited members from abc.ABC are omitted.]'
  constructor_signature: 'def __init__(self, *, agents_root: Path | str, app_name_to_dir: typing.Optional[typing.Mapping[str, str]]=None):'
  methods:
  - signature: 'def create_session(self, *, app_name: str, user_id: str, state: typing.Optional[dict[str, object]]=None, session_id: typing.Optional[str]=None) -> google.adk.sessions.session.Session:'
  - signature: 'def get_session(self, *, app_name: str, user_id: str, session_id: str, config: typing.Optional[google.adk.sessions.base_session_service.GetSessionConfig]=None) -> typing.Optional[google.adk.sessions.session.Session]:'
  - signature: 'def list_sessions(self, *, app_name: str, user_id: typing.Optional[str]=None) -> google.adk.sessions.base_session_service.ListSessionsResponse:'
  - signature: 'def delete_session(self, *, app_name: str, user_id: str, session_id: str) -> None:'
  - signature: 'def append_event(self, session: google.adk.sessions.session.Session, event: google.adk.events.event.Event) -> google.adk.events.event.Event:'
  inherited_methods:
    BaseSessionService:
    - signature: 'def create_session(self, *, app_name: str, user_id: str, state: typing.Optional[dict[str, typing.Any]]=None, session_id: typing.Optional[str]=None) -> google.adk.sessions.session.Session:'
      docstring: "Creates a new session.\n\nArgs:\n  app_name: the name of the app.\n  user_id: the id of the user.\n  state: the initial state of the session.\n  session_id: the client-provided id of the session. If not provided, a\n    generated ID will be used.\n\nReturns:\n  session: The newly created session instance."
    - signature: 'def get_session(self, *, app_name: str, user_id: str, session_id: str, config: typing.Optional[google.adk.sessions.base_session_service.GetSessionConfig]=None) -> typing.Optional[google.adk.sessions.session.Session]:'
      docstring: Gets a session.
    - signature: 'def list_sessions(self, *, app_name: str, user_id: typing.Optional[str]=None) -> google.adk.sessions.base_session_service.ListSessionsResponse:'
      docstring: "Lists all the sessions for a user.\n\nArgs:\n  app_name: The name of the app.\n  user_id: The ID of the user. If not provided, lists all sessions for all\n    users.\n\nReturns:\n  A ListSessionsResponse containing the sessions."
    - signature: 'def delete_session(self, *, app_name: str, user_id: str, session_id: str) -> None:'
      docstring: Deletes a session.
    - signature: 'def append_event(self, session: google.adk.sessions.session.Session, event: google.adk.events.event.Event) -> google.adk.events.event.Event:'
      docstring: Appends an event to a session object.
  omitted_inherited_members_from:
  - abc.ABC
- rank: 549
  id: google.adk.cli.utils.local_storage.PerAgentDatabaseSessionService.__init__
  name: __init__
  file_path: src/google/adk/cli/utils/local_storage.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, *, agents_root: Path | str, app_name_to_dir: typing.Optional[typing.Mapping[str, str]]=None):'
- rank: 550
  id: google.adk.cli.utils.local_storage.PerAgentDatabaseSessionService.create_session
  name: create_session
  file_path: src/google/adk/cli/utils/local_storage.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def create_session(self, *, app_name: str, user_id: str, state: typing.Optional[dict[str, object]]=None, session_id: typing.Optional[str]=None) -> google.adk.sessions.session.Session:'
- rank: 551
  id: google.adk.cli.utils.local_storage.PerAgentDatabaseSessionService.delete_session
  name: delete_session
  file_path: src/google/adk/cli/utils/local_storage.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def delete_session(self, *, app_name: str, user_id: str, session_id: str) -> None:'
- rank: 552
  id: google.adk.cli.utils.local_storage.PerAgentDatabaseSessionService.get_session
  name: get_session
  file_path: src/google/adk/cli/utils/local_storage.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_session(self, *, app_name: str, user_id: str, session_id: str, config: typing.Optional[google.adk.sessions.base_session_service.GetSessionConfig]=None) -> typing.Optional[google.adk.sessions.session.Session]:'
- rank: 553
  id: google.adk.cli.utils.local_storage.PerAgentDatabaseSessionService.list_sessions
  name: list_sessions
  file_path: src/google/adk/cli/utils/local_storage.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def list_sessions(self, *, app_name: str, user_id: typing.Optional[str]=None) -> google.adk.sessions.base_session_service.ListSessionsResponse:'
- rank: 554
  id: google.adk.cli.utils.local_storage.create_local_artifact_service
  name: create_local_artifact_service
  file_path: src/google/adk/cli/utils/local_storage.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Creates a file-backed artifact service rooted in `.adk/artifacts`.\n\nArgs:\n  base_dir: Directory whose `.adk` folder will store artifacts.\n\nReturns:\n  A `FileArtifactService` scoped to the derived root directory."
  signature: 'def create_local_artifact_service(*, base_dir: Path | str) -> google.adk.artifacts.base_artifact_service.BaseArtifactService:'
- rank: 555
  id: google.adk.cli.utils.local_storage.create_local_database_session_service
  name: create_local_database_session_service
  file_path: src/google/adk/cli/utils/local_storage.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Creates a SQLite-backed session service at .adk/session.db.\n\nArgs:\n  base_dir: The base directory for the agent (parent of .adk folder).\n\nReturns:\n  A SqliteSessionService instance."
  signature: 'def create_local_database_session_service(*, base_dir: Path | str) -> google.adk.sessions.base_session_service.BaseSessionService:'
- rank: 556
  id: google.adk.cli.utils.local_storage.create_local_session_service
  name: create_local_session_service
  file_path: src/google/adk/cli/utils/local_storage.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Creates a local SQLite-backed session service.\n\nArgs:\n  base_dir: The base directory for the agent(s).\n  per_agent: If True, creates a PerAgentDatabaseSessionService that stores\n    sessions in each agent's .adk folder. If False, creates a single\n    SqliteSessionService at base_dir/.adk/session.db.\n  app_name_to_dir: Optional mapping from logical app name to on-disk agent\n    folder name. Only used when per_agent is True; defaults to identity.\n\nReturns:\n  A BaseSessionService instance backed by SQLite."
  signature: 'def create_local_session_service(*, base_dir: Path | str, per_agent: bool=False, app_name_to_dir: typing.Optional[typing.Mapping[str, str]]=None) -> google.adk.sessions.base_session_service.BaseSessionService:'
- rank: 557
  id: google.adk.cli.utils.logs
  name: logs
  file_path: src/google/adk/cli/utils/logs.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def setup_adk_logger(level):'
  - signature: 'def log_to_tmp_folder(level, *, sub_folder: str=''agents_log'', log_file_prefix: str=''agent'', log_file_timestamp: str=time.strftime(''%Y%m%d_%H%M%S'')):'
    docstring: "Logs to system temp folder, instead of logging to stderr.\n\nArgs\n  sub_folder: str = 'agents_log',\n  log_file_prefix: str = 'agent',\n  log_file_timestamp: str = time.strftime('%Y%m%d_%H%M%S'),\n\nReturns\n  the log file path."
  properties:
  - signature: 'LOGGING_FORMAT: str'
- rank: 558
  id: google.adk.cli.utils.service_factory
  name: service_factory
  file_path: src/google/adk/cli/utils/service_factory.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def create_session_service_from_options(*, base_dir: Path | str, session_service_uri: typing.Optional[str]=None, session_db_kwargs: typing.Optional[dict[str, typing.Any]]=None, app_name_to_dir: typing.Optional[dict[str, str]]=None, use_local_storage: bool=True) -> google.adk.sessions.base_session_service.BaseSessionService:'
    docstring: Creates a session service based on CLI/web options.
  - signature: 'def create_memory_service_from_options(*, base_dir: Path | str, memory_service_uri: typing.Optional[str]=None) -> google.adk.memory.base_memory_service.BaseMemoryService:'
    docstring: Creates a memory service based on CLI/web options.
  - signature: 'def create_artifact_service_from_options(*, base_dir: Path | str, artifact_service_uri: typing.Optional[str]=None, strict_uri: bool=False, use_local_storage: bool=True) -> google.adk.artifacts.base_artifact_service.BaseArtifactService:'
    docstring: Creates an artifact service based on CLI/web options.
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '_DISABLE_LOCAL_STORAGE_ENV: str'
  - signature: '_FORCE_LOCAL_STORAGE_ENV: str'
  - signature: '_LOCAL_STORAGE_ERRNOS: frozenset'
  - signature: '_CLOUD_RUN_SERVICE_ENV: str'
  - signature: '_KUBERNETES_HOST_ENV: str'
- rank: 559
  id: google.adk.cli.utils.service_factory.create_artifact_service_from_options
  name: create_artifact_service_from_options
  file_path: src/google/adk/cli/utils/service_factory.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Creates an artifact service based on CLI/web options.
  signature: 'def create_artifact_service_from_options(*, base_dir: Path | str, artifact_service_uri: typing.Optional[str]=None, strict_uri: bool=False, use_local_storage: bool=True) -> google.adk.artifacts.base_artifact_service.BaseArtifactService:'
- rank: 560
  id: google.adk.cli.utils.service_factory.create_memory_service_from_options
  name: create_memory_service_from_options
  file_path: src/google/adk/cli/utils/service_factory.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Creates a memory service based on CLI/web options.
  signature: 'def create_memory_service_from_options(*, base_dir: Path | str, memory_service_uri: typing.Optional[str]=None) -> google.adk.memory.base_memory_service.BaseMemoryService:'
- rank: 561
  id: google.adk.cli.utils.service_factory.create_session_service_from_options
  name: create_session_service_from_options
  file_path: src/google/adk/cli/utils/service_factory.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Creates a session service based on CLI/web options.
  signature: 'def create_session_service_from_options(*, base_dir: Path | str, session_service_uri: typing.Optional[str]=None, session_db_kwargs: typing.Optional[dict[str, typing.Any]]=None, app_name_to_dir: typing.Optional[dict[str, str]]=None, use_local_storage: bool=True) -> google.adk.sessions.base_session_service.BaseSessionService:'
- rank: 562
  id: google.adk.cli.utils.shared_value
  name: shared_value
  file_path: src/google/adk/cli/utils/shared_value.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'T: typing.TypeVar'
- rank: 563
  id: google.adk.cli.utils.shared_value.SharedValue
  name: SharedValue
  file_path: src/google/adk/cli/utils/shared_value.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Simple wrapper around a value to allow modifying it from callbacks.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, value: google.adk.cli.utils.shared_value.T):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'value: google.adk.cli.utils.shared_value.T'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 564
  id: google.adk.cli.utils.state
  name: state
  file_path: src/google/adk/cli/utils/state.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def create_empty_state(agent: google.adk.agents.base_agent.BaseAgent, initialized_states: typing.Optional[dict[str, typing.Any]]) -> dict[str, typing.Any]:'
    docstring: Creates empty str for non-initialized states.
- rank: 565
  id: google.adk.cli.utils.state.create_empty_state
  name: create_empty_state
  file_path: src/google/adk/cli/utils/state.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Creates empty str for non-initialized states.
  signature: 'def create_empty_state(agent: google.adk.agents.base_agent.BaseAgent, initialized_states: typing.Optional[dict[str, typing.Any]]) -> dict[str, typing.Any]:'
- rank: 566
  id: google.adk.code_executors
  name: code_executors
  file_path: src/google/adk/code_executors/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '__all__: Any'
- rank: 567
  id: google.adk.code_executors.agent_engine_sandbox_code_executor
  name: agent_engine_sandbox_code_executor
  file_path: src/google/adk/code_executors/agent_engine_sandbox_code_executor.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 568
  id: google.adk.code_executors.agent_engine_sandbox_code_executor.AgentEngineSandboxCodeExecutor
  name: AgentEngineSandboxCodeExecutor
  file_path: src/google/adk/code_executors/agent_engine_sandbox_code_executor.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "A code executor that uses Agent Engine Code Execution Sandbox to execute code.\n\nAttributes:\n  sandbox_resource_name: If set, load the existing resource name of the code\n    interpreter extension instead of creating a new one. Format:\n    projects/123/locations/us-central1/reasoningEngines/456/sandboxEnvironments/789\n\n[Note: Inherited members from pydantic.BaseModel are omitted.]"
  constructor_signature: 'def __init__(self, sandbox_resource_name: typing.Optional[str], agent_engine_resource_name: typing.Optional[str]):'
  methods:
  - signature: 'def execute_code(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, code_execution_input: google.adk.code_executors.code_execution_utils.CodeExecutionInput) -> google.adk.code_executors.code_execution_utils.CodeExecutionResult:'
  properties:
  - signature: 'sandbox_resource_name: str'
  inherited_methods:
    BaseCodeExecutor:
    - signature: 'def execute_code(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, code_execution_input: google.adk.code_executors.code_execution_utils.CodeExecutionInput) -> google.adk.code_executors.code_execution_utils.CodeExecutionResult:'
      docstring: "Executes code and return the code execution result.\n\nArgs:\n  invocation_context: The invocation context of the code execution.\n  code_execution_input: The code execution input.\n\nReturns:\n  The code execution result."
  inherited_properties:
    BaseCodeExecutor:
    - signature: 'optimize_data_file: bool'
      docstring: 'If true, extract and process data files from the model request

        and attach them to the code executor.


        Supported data file MimeTypes are [text/csv].

        Default to False.'
    - signature: 'stateful: bool'
      docstring: Whether the code executor is stateful. Default to False.
    - signature: 'error_retry_attempts: int'
      docstring: The number of attempts to retry on consecutive code execution errors. Default to 2.
    - signature: 'code_block_delimiters: typing.List[tuple[str, str]]'
      docstring: "The list of the enclosing delimiters to identify the code blocks.\n\nFor example, the delimiter ('```python\\n', '\\n```') can be\nused to identify code blocks with the following format::\n\n    ```python\n    print(\"hello\")\n    ```"
    - signature: 'execution_result_delimiters: tuple[str, str]'
      docstring: The delimiters to format the code execution result.
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 569
  id: google.adk.code_executors.agent_engine_sandbox_code_executor.AgentEngineSandboxCodeExecutor.__init__
  name: __init__
  file_path: src/google/adk/code_executors/agent_engine_sandbox_code_executor.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the AgentEngineSandboxCodeExecutor.\n\nArgs:\n  sandbox_resource_name: If set, load the existing resource name of code\n    execution sandbox, if not set, create a new one. Format:\n    projects/123/locations/us-central1/reasoningEngines/456/\n    sandboxEnvironments/789\n  agent_engine_resource_name: The resource name of the agent engine to use\n    to create the code execution sandbox. Format:\n    projects/123/locations/us-central1/reasoningEngines/456, when both\n    sandbox_resource_name and agent_engine_resource_name are set,\n    agent_engine_resource_name will be ignored.\n  **data: Additional keyword arguments to be passed to the base class."
  signature: 'def __init__(self, sandbox_resource_name: typing.Optional[str], agent_engine_resource_name: typing.Optional[str]):'
- rank: 570
  id: google.adk.code_executors.agent_engine_sandbox_code_executor.AgentEngineSandboxCodeExecutor.execute_code
  name: execute_code
  file_path: src/google/adk/code_executors/agent_engine_sandbox_code_executor.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def execute_code(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, code_execution_input: google.adk.code_executors.code_execution_utils.CodeExecutionInput) -> google.adk.code_executors.code_execution_utils.CodeExecutionResult:'
- rank: 571
  id: google.adk.code_executors.base_code_executor
  name: base_code_executor
  file_path: src/google/adk/code_executors/base_code_executor.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 572
  id: google.adk.code_executors.base_code_executor.BaseCodeExecutor
  name: BaseCodeExecutor
  file_path: src/google/adk/code_executors/base_code_executor.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "Abstract base class for all code executors.\n\nThe code executor allows the agent to execute code blocks from model responses\nand incorporate the execution results into the final response.\n\nAttributes:\n  optimize_data_file: If true, extract and process data files from the model\n    request and attach them to the code executor. Supported data file\n    MimeTypes are [text/csv]. Default to False.\n  stateful: Whether the code executor is stateful. Default to False.\n  error_retry_attempts: The number of attempts to retry on consecutive code\n    execution errors. Default to 2.\n  code_block_delimiters: The list of the enclosing delimiters to identify the\n    code blocks.\n  execution_result_delimiters: The delimiters to format the code execution\n    result.\n\n[Note: Inherited members from pydantic.BaseModel are omitted.]"
  constructor_signature: 'def __init__(self, *, optimize_data_file: bool = False, stateful: bool = False, error_retry_attempts: int = 2, code_block_delimiters: typing.List[tuple[str, str]] = [(''```tool_code\n'', ''\n```''), (''```python\n'', ''\n```'')], execution_result_delimiters: tuple[str, str] = (''```tool_output\n'', ''\n```'')):'
  methods:
  - signature: 'def execute_code(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, code_execution_input: google.adk.code_executors.code_execution_utils.CodeExecutionInput) -> google.adk.code_executors.code_execution_utils.CodeExecutionResult:'
    docstring: "Executes code and return the code execution result.\n\nArgs:\n  invocation_context: The invocation context of the code execution.\n  code_execution_input: The code execution input.\n\nReturns:\n  The code execution result."
  properties:
  - signature: 'optimize_data_file: bool'
    docstring: 'If true, extract and process data files from the model request

      and attach them to the code executor.


      Supported data file MimeTypes are [text/csv].

      Default to False.'
  - signature: 'stateful: bool'
    docstring: Whether the code executor is stateful. Default to False.
  - signature: 'error_retry_attempts: int'
    docstring: The number of attempts to retry on consecutive code execution errors. Default to 2.
  - signature: 'code_block_delimiters: typing.List[tuple[str, str]]'
    docstring: "The list of the enclosing delimiters to identify the code blocks.\n\nFor example, the delimiter ('```python\\n', '\\n```') can be\nused to identify code blocks with the following format::\n\n    ```python\n    print(\"hello\")\n    ```"
  - signature: 'execution_result_delimiters: tuple[str, str]'
    docstring: The delimiters to format the code execution result.
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 573
  id: google.adk.code_executors.base_code_executor.BaseCodeExecutor.execute_code
  name: execute_code
  file_path: src/google/adk/code_executors/base_code_executor.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Executes code and return the code execution result.\n\nArgs:\n  invocation_context: The invocation context of the code execution.\n  code_execution_input: The code execution input.\n\nReturns:\n  The code execution result."
  signature: 'def execute_code(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, code_execution_input: google.adk.code_executors.code_execution_utils.CodeExecutionInput) -> google.adk.code_executors.code_execution_utils.CodeExecutionResult:'
- rank: 574
  id: google.adk.code_executors.built_in_code_executor
  name: built_in_code_executor
  file_path: src/google/adk/code_executors/built_in_code_executor.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 575
  id: google.adk.code_executors.built_in_code_executor.BuiltInCodeExecutor
  name: BuiltInCodeExecutor
  file_path: src/google/adk/code_executors/built_in_code_executor.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A code executor that uses the Model''s built-in code executor.


    Currently only supports Gemini 2.0+ models, but will be expanded to

    other models.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, optimize_data_file: bool = False, stateful: bool = False, error_retry_attempts: int = 2, code_block_delimiters: typing.List[tuple[str, str]] = [(''```tool_code\n'', ''\n```''), (''```python\n'', ''\n```'')], execution_result_delimiters: tuple[str, str] = (''```tool_output\n'', ''\n```'')):'
  methods:
  - signature: 'def execute_code(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, code_execution_input: google.adk.code_executors.code_execution_utils.CodeExecutionInput) -> google.adk.code_executors.code_execution_utils.CodeExecutionResult:'
  - signature: 'def process_llm_request(self, llm_request: google.adk.models.LlmRequest) -> None:'
    docstring: Pre-process the LLM request for Gemini 2.0+ models to use the code execution tool.
  inherited_methods:
    BaseCodeExecutor:
    - signature: 'def execute_code(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, code_execution_input: google.adk.code_executors.code_execution_utils.CodeExecutionInput) -> google.adk.code_executors.code_execution_utils.CodeExecutionResult:'
      docstring: "Executes code and return the code execution result.\n\nArgs:\n  invocation_context: The invocation context of the code execution.\n  code_execution_input: The code execution input.\n\nReturns:\n  The code execution result."
  inherited_properties:
    BaseCodeExecutor:
    - signature: 'optimize_data_file: bool'
      docstring: 'If true, extract and process data files from the model request

        and attach them to the code executor.


        Supported data file MimeTypes are [text/csv].

        Default to False.'
    - signature: 'stateful: bool'
      docstring: Whether the code executor is stateful. Default to False.
    - signature: 'error_retry_attempts: int'
      docstring: The number of attempts to retry on consecutive code execution errors. Default to 2.
    - signature: 'code_block_delimiters: typing.List[tuple[str, str]]'
      docstring: "The list of the enclosing delimiters to identify the code blocks.\n\nFor example, the delimiter ('```python\\n', '\\n```') can be\nused to identify code blocks with the following format::\n\n    ```python\n    print(\"hello\")\n    ```"
    - signature: 'execution_result_delimiters: tuple[str, str]'
      docstring: The delimiters to format the code execution result.
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 576
  id: google.adk.code_executors.built_in_code_executor.BuiltInCodeExecutor.execute_code
  name: execute_code
  file_path: src/google/adk/code_executors/built_in_code_executor.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def execute_code(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, code_execution_input: google.adk.code_executors.code_execution_utils.CodeExecutionInput) -> google.adk.code_executors.code_execution_utils.CodeExecutionResult:'
- rank: 577
  id: google.adk.code_executors.built_in_code_executor.BuiltInCodeExecutor.process_llm_request
  name: process_llm_request
  file_path: src/google/adk/code_executors/built_in_code_executor.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Pre-process the LLM request for Gemini 2.0+ models to use the code execution tool.
  signature: 'def process_llm_request(self, llm_request: google.adk.models.LlmRequest) -> None:'
- rank: 578
  id: google.adk.code_executors.code_execution_utils
  name: code_execution_utils
  file_path: src/google/adk/code_executors/code_execution_utils.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Utility functions for code execution.
- rank: 579
  id: google.adk.code_executors.code_execution_utils.CodeExecutionInput
  name: CodeExecutionInput
  file_path: src/google/adk/code_executors/code_execution_utils.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: A structure that contains the input of code execution.
  constructor_signature: 'def __init__(self, *, code: str, input_files: list[google.adk.code_executors.code_execution_utils.File] = list(), execution_id: typing.Optional[str] = None):'
  properties:
  - signature: 'code: str'
    docstring: The code to execute.
  - signature: 'input_files: list[google.adk.code_executors.code_execution_utils.File]'
    docstring: The input files available to the code.
  - signature: 'execution_id: typing.Optional[str]'
    docstring: The execution ID for the stateful code execution.
- rank: 580
  id: google.adk.code_executors.code_execution_utils.CodeExecutionResult
  name: CodeExecutionResult
  file_path: src/google/adk/code_executors/code_execution_utils.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: A structure that contains the result of code execution.
  constructor_signature: 'def __init__(self, *, stdout: str = '''', stderr: str = '''', output_files: list[google.adk.code_executors.code_execution_utils.File] = list()):'
  properties:
  - signature: 'stdout: str'
    docstring: The standard output of the code execution.
  - signature: 'stderr: str'
    docstring: The standard error of the code execution.
  - signature: 'output_files: list[google.adk.code_executors.code_execution_utils.File]'
    docstring: The output files from the code execution.
- rank: 581
  id: google.adk.code_executors.code_execution_utils.CodeExecutionUtils
  name: CodeExecutionUtils
  file_path: src/google/adk/code_executors/code_execution_utils.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Utility functions for code execution.
  methods:
  - signature: 'def get_encoded_file_content(data: bytes) -> bytes:'
    docstring: "Gets the file content as a base64-encoded bytes.\n\nArgs:\n  data: The file content bytes.\n\nReturns:\n  The file content as a base64-encoded bytes."
  - signature: 'def extract_code_and_truncate_content(content: google.genai.types.Content, code_block_delimiters: typing.List[tuple[str, str]]) -> typing.Optional[str]:'
    docstring: "Extracts the first code block from the content and truncate everything after it.\n\nArgs:\n  content: The mutable content to extract the code from.\n  code_block_delimiters: The list of the enclosing delimiters to identify\n    the code blocks.\n\nReturns:\n  The first code block if found; otherwise, None."
  - signature: 'def build_executable_code_part(code: str) -> google.genai.types.Part:'
    docstring: "Builds an executable code part with code string.\n\nArgs:\n  code: The code string.\n\nReturns:\n  The constructed executable code part."
  - signature: 'def build_code_execution_result_part(code_execution_result: google.adk.code_executors.code_execution_utils.CodeExecutionResult) -> google.genai.types.Part:'
    docstring: "Builds the code execution result part from the code execution result.\n\nArgs:\n  code_execution_result: The code execution result.\n\nReturns:\n  The constructed code execution result part."
  - signature: 'def convert_code_execution_parts(content: google.genai.types.Content, code_block_delimiter: tuple[str, str], execution_result_delimiters: tuple[str, str]):'
    docstring: "Converts the code execution parts to text parts in a Content.\n\nArgs:\n  content: The mutable content to convert the code execution parts to text\n    parts.\n  code_block_delimiter: The delimiter to format the code block.\n  execution_result_delimiters: The delimiter to format the code execution\n    result."
- rank: 582
  id: google.adk.code_executors.code_execution_utils.CodeExecutionUtils.build_code_execution_result_part
  name: build_code_execution_result_part
  file_path: src/google/adk/code_executors/code_execution_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Builds the code execution result part from the code execution result.\n\nArgs:\n  code_execution_result: The code execution result.\n\nReturns:\n  The constructed code execution result part."
  signature: 'def build_code_execution_result_part(code_execution_result: google.adk.code_executors.code_execution_utils.CodeExecutionResult) -> google.genai.types.Part:'
- rank: 583
  id: google.adk.code_executors.code_execution_utils.CodeExecutionUtils.build_executable_code_part
  name: build_executable_code_part
  file_path: src/google/adk/code_executors/code_execution_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Builds an executable code part with code string.\n\nArgs:\n  code: The code string.\n\nReturns:\n  The constructed executable code part."
  signature: 'def build_executable_code_part(code: str) -> google.genai.types.Part:'
- rank: 584
  id: google.adk.code_executors.code_execution_utils.CodeExecutionUtils.convert_code_execution_parts
  name: convert_code_execution_parts
  file_path: src/google/adk/code_executors/code_execution_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Converts the code execution parts to text parts in a Content.\n\nArgs:\n  content: The mutable content to convert the code execution parts to text\n    parts.\n  code_block_delimiter: The delimiter to format the code block.\n  execution_result_delimiters: The delimiter to format the code execution\n    result."
  signature: 'def convert_code_execution_parts(content: google.genai.types.Content, code_block_delimiter: tuple[str, str], execution_result_delimiters: tuple[str, str]):'
- rank: 585
  id: google.adk.code_executors.code_execution_utils.CodeExecutionUtils.extract_code_and_truncate_content
  name: extract_code_and_truncate_content
  file_path: src/google/adk/code_executors/code_execution_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Extracts the first code block from the content and truncate everything after it.\n\nArgs:\n  content: The mutable content to extract the code from.\n  code_block_delimiters: The list of the enclosing delimiters to identify\n    the code blocks.\n\nReturns:\n  The first code block if found; otherwise, None."
  signature: 'def extract_code_and_truncate_content(content: google.genai.types.Content, code_block_delimiters: typing.List[tuple[str, str]]) -> typing.Optional[str]:'
- rank: 586
  id: google.adk.code_executors.code_execution_utils.CodeExecutionUtils.get_encoded_file_content
  name: get_encoded_file_content
  file_path: src/google/adk/code_executors/code_execution_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Gets the file content as a base64-encoded bytes.\n\nArgs:\n  data: The file content bytes.\n\nReturns:\n  The file content as a base64-encoded bytes."
  signature: 'def get_encoded_file_content(data: bytes) -> bytes:'
- rank: 587
  id: google.adk.code_executors.code_execution_utils.File
  name: File
  file_path: src/google/adk/code_executors/code_execution_utils.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: A structure that contains a file name and its content.
  constructor_signature: 'def __init__(self, *, name: str, content: str | bytes, mime_type: str = ''text/plain''):'
  properties:
  - signature: 'name: str'
    docstring: The name of the file with file extension (e.g., "file.csv").
  - signature: 'content: str | bytes'
    docstring: The base64-encoded bytes of the file content or the original bytes of the file content.
  - signature: 'mime_type: str'
    docstring: The mime type of the file (e.g., "image/png").
- rank: 588
  id: google.adk.code_executors.code_executor_context
  name: code_executor_context
  file_path: src/google/adk/code_executors/code_executor_context.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: '_CONTEXT_KEY: str'
  - signature: '_SESSION_ID_KEY: str'
  - signature: '_PROCESSED_FILE_NAMES_KEY: str'
  - signature: '_INPUT_FILE_KEY: str'
  - signature: '_ERROR_COUNT_KEY: str'
  - signature: '_CODE_EXECUTION_RESULTS_KEY: str'
- rank: 589
  id: google.adk.code_executors.code_executor_context.CodeExecutorContext
  name: CodeExecutorContext
  file_path: src/google/adk/code_executors/code_executor_context.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: The persistent context used to configure the code executor.
  constructor_signature: 'def __init__(self, session_state: google.adk.sessions.state.State):'
  methods:
  - signature: 'def get_state_delta(self) -> dict[str, typing.Any]:'
    docstring: "Gets the state delta to update in the persistent session state.\n\nReturns:\n  The state delta to update in the persistent session state."
  - signature: 'def get_execution_id(self) -> typing.Optional[str]:'
    docstring: "Gets the session ID for the code executor.\n\nReturns:\n  The session ID for the code executor context."
  - signature: 'def set_execution_id(self, session_id: str):'
    docstring: "Sets the session ID for the code executor.\n\nArgs:\n  session_id: The session ID for the code executor."
  - signature: 'def get_processed_file_names(self) -> list[str]:'
    docstring: "Gets the processed file names from the session state.\n\nReturns:\n  A list of processed file names in the code executor context."
  - signature: 'def add_processed_file_names(self, file_names: [str]):'
    docstring: "Adds the processed file name to the session state.\n\nArgs:\n  file_names: The processed file names to add to the session state."
  - signature: 'def get_input_files(self) -> list[google.adk.code_executors.code_execution_utils.File]:'
    docstring: "Gets the code executor input file names from the session state.\n\nReturns:\n  A list of input files in the code executor context."
  - signature: 'def add_input_files(self, input_files: list[google.adk.code_executors.code_execution_utils.File]):'
    docstring: "Adds the input files to the code executor context.\n\nArgs:\n  input_files: The input files to add to the code executor context."
  - signature: 'def clear_input_files(self):'
    docstring: Removes the input files and processed file names to the code executor context.
  - signature: 'def get_error_count(self, invocation_id: str) -> int:'
    docstring: "Gets the error count from the session state.\n\nArgs:\n  invocation_id: The invocation ID to get the error count for.\n\nReturns:\n  The error count for the given invocation ID."
  - signature: 'def increment_error_count(self, invocation_id: str):'
    docstring: "Increments the error count from the session state.\n\nArgs:\n  invocation_id: The invocation ID to increment the error count for."
  - signature: 'def reset_error_count(self, invocation_id: str):'
    docstring: "Resets the error count from the session state.\n\nArgs:\n  invocation_id: The invocation ID to reset the error count for."
  - signature: 'def update_code_execution_result(self, invocation_id: str, code: str, result_stdout: str, result_stderr: str):'
    docstring: "Updates the code execution result.\n\nArgs:\n  invocation_id: The invocation ID to update the code execution result for.\n  code: The code to execute.\n  result_stdout: The standard output of the code execution.\n  result_stderr: The standard error of the code execution."
- rank: 590
  id: google.adk.code_executors.code_executor_context.CodeExecutorContext.__init__
  name: __init__
  file_path: src/google/adk/code_executors/code_executor_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the code executor context.\n\nArgs:\n  session_state: The session state to get the code executor context from."
  signature: 'def __init__(self, session_state: google.adk.sessions.state.State):'
- rank: 591
  id: google.adk.code_executors.code_executor_context.CodeExecutorContext.add_input_files
  name: add_input_files
  file_path: src/google/adk/code_executors/code_executor_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Adds the input files to the code executor context.\n\nArgs:\n  input_files: The input files to add to the code executor context."
  signature: 'def add_input_files(self, input_files: list[google.adk.code_executors.code_execution_utils.File]):'
- rank: 592
  id: google.adk.code_executors.code_executor_context.CodeExecutorContext.add_processed_file_names
  name: add_processed_file_names
  file_path: src/google/adk/code_executors/code_executor_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Adds the processed file name to the session state.\n\nArgs:\n  file_names: The processed file names to add to the session state."
  signature: 'def add_processed_file_names(self, file_names: [str]):'
- rank: 593
  id: google.adk.code_executors.code_executor_context.CodeExecutorContext.clear_input_files
  name: clear_input_files
  file_path: src/google/adk/code_executors/code_executor_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Removes the input files and processed file names to the code executor context.
  signature: 'def clear_input_files(self):'
- rank: 594
  id: google.adk.code_executors.code_executor_context.CodeExecutorContext.get_error_count
  name: get_error_count
  file_path: src/google/adk/code_executors/code_executor_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Gets the error count from the session state.\n\nArgs:\n  invocation_id: The invocation ID to get the error count for.\n\nReturns:\n  The error count for the given invocation ID."
  signature: 'def get_error_count(self, invocation_id: str) -> int:'
- rank: 595
  id: google.adk.code_executors.code_executor_context.CodeExecutorContext.get_execution_id
  name: get_execution_id
  file_path: src/google/adk/code_executors/code_executor_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Gets the session ID for the code executor.\n\nReturns:\n  The session ID for the code executor context."
  signature: 'def get_execution_id(self) -> typing.Optional[str]:'
- rank: 596
  id: google.adk.code_executors.code_executor_context.CodeExecutorContext.get_input_files
  name: get_input_files
  file_path: src/google/adk/code_executors/code_executor_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Gets the code executor input file names from the session state.\n\nReturns:\n  A list of input files in the code executor context."
  signature: 'def get_input_files(self) -> list[google.adk.code_executors.code_execution_utils.File]:'
- rank: 597
  id: google.adk.code_executors.code_executor_context.CodeExecutorContext.get_processed_file_names
  name: get_processed_file_names
  file_path: src/google/adk/code_executors/code_executor_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Gets the processed file names from the session state.\n\nReturns:\n  A list of processed file names in the code executor context."
  signature: 'def get_processed_file_names(self) -> list[str]:'
- rank: 598
  id: google.adk.code_executors.code_executor_context.CodeExecutorContext.get_state_delta
  name: get_state_delta
  file_path: src/google/adk/code_executors/code_executor_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Gets the state delta to update in the persistent session state.\n\nReturns:\n  The state delta to update in the persistent session state."
  signature: 'def get_state_delta(self) -> dict[str, typing.Any]:'
- rank: 599
  id: google.adk.code_executors.code_executor_context.CodeExecutorContext.increment_error_count
  name: increment_error_count
  file_path: src/google/adk/code_executors/code_executor_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Increments the error count from the session state.\n\nArgs:\n  invocation_id: The invocation ID to increment the error count for."
  signature: 'def increment_error_count(self, invocation_id: str):'
- rank: 600
  id: google.adk.code_executors.code_executor_context.CodeExecutorContext.reset_error_count
  name: reset_error_count
  file_path: src/google/adk/code_executors/code_executor_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Resets the error count from the session state.\n\nArgs:\n  invocation_id: The invocation ID to reset the error count for."
  signature: 'def reset_error_count(self, invocation_id: str):'
- rank: 601
  id: google.adk.code_executors.code_executor_context.CodeExecutorContext.set_execution_id
  name: set_execution_id
  file_path: src/google/adk/code_executors/code_executor_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Sets the session ID for the code executor.\n\nArgs:\n  session_id: The session ID for the code executor."
  signature: 'def set_execution_id(self, session_id: str):'
- rank: 602
  id: google.adk.code_executors.code_executor_context.CodeExecutorContext.update_code_execution_result
  name: update_code_execution_result
  file_path: src/google/adk/code_executors/code_executor_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Updates the code execution result.\n\nArgs:\n  invocation_id: The invocation ID to update the code execution result for.\n  code: The code to execute.\n  result_stdout: The standard output of the code execution.\n  result_stderr: The standard error of the code execution."
  signature: 'def update_code_execution_result(self, invocation_id: str, code: str, result_stdout: str, result_stderr: str):'
- rank: 603
  id: google.adk.code_executors.container_code_executor
  name: container_code_executor
  file_path: src/google/adk/code_executors/container_code_executor.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: 'DEFAULT_IMAGE_TAG: str'
- rank: 604
  id: google.adk.code_executors.container_code_executor.ContainerCodeExecutor
  name: ContainerCodeExecutor
  file_path: src/google/adk/code_executors/container_code_executor.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "A code executor that uses a custom container to execute code.\n\nAttributes:\n  base_url: Optional. The base url of the user hosted Docker client.\n  image: The tag of the predefined image or custom image to run on the\n    container. Either docker_path or image must be set.\n  docker_path: The path to the directory containing the Dockerfile. If set,\n    build the image from the dockerfile path instead of using the predefined\n    image. Either docker_path or image must be set.\n\n[Note: Inherited members from pydantic.BaseModel are omitted.]"
  constructor_signature: 'def __init__(self, base_url: typing.Optional[str], image: typing.Optional[str], docker_path: typing.Optional[str]):'
  methods:
  - signature: 'def execute_code(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, code_execution_input: google.adk.code_executors.code_execution_utils.CodeExecutionInput) -> google.adk.code_executors.code_execution_utils.CodeExecutionResult:'
  properties:
  - signature: 'base_url: typing.Optional[str]'
    docstring: Optional. The base url of the user hosted Docker client.
  - signature: 'image: str'
    docstring: 'The tag of the predefined image or custom image to run on the container.

      Either docker_path or image must be set.'
  - signature: 'docker_path: str'
    docstring: 'The path to the directory containing the Dockerfile.

      If set, build the image from the dockerfile path instead of using the

      predefined image. Either docker_path or image must be set.'
  - signature: 'stateful: bool'
  - signature: 'optimize_data_file: bool'
  inherited_methods:
    BaseCodeExecutor:
    - signature: 'def execute_code(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, code_execution_input: google.adk.code_executors.code_execution_utils.CodeExecutionInput) -> google.adk.code_executors.code_execution_utils.CodeExecutionResult:'
      docstring: "Executes code and return the code execution result.\n\nArgs:\n  invocation_context: The invocation context of the code execution.\n  code_execution_input: The code execution input.\n\nReturns:\n  The code execution result."
  inherited_properties:
    BaseCodeExecutor:
    - signature: 'optimize_data_file: bool'
      docstring: 'If true, extract and process data files from the model request

        and attach them to the code executor.


        Supported data file MimeTypes are [text/csv].

        Default to False.'
    - signature: 'stateful: bool'
      docstring: Whether the code executor is stateful. Default to False.
    - signature: 'error_retry_attempts: int'
      docstring: The number of attempts to retry on consecutive code execution errors. Default to 2.
    - signature: 'code_block_delimiters: typing.List[tuple[str, str]]'
      docstring: "The list of the enclosing delimiters to identify the code blocks.\n\nFor example, the delimiter ('```python\\n', '\\n```') can be\nused to identify code blocks with the following format::\n\n    ```python\n    print(\"hello\")\n    ```"
    - signature: 'execution_result_delimiters: tuple[str, str]'
      docstring: The delimiters to format the code execution result.
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 605
  id: google.adk.code_executors.container_code_executor.ContainerCodeExecutor.__init__
  name: __init__
  file_path: src/google/adk/code_executors/container_code_executor.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the ContainerCodeExecutor.\n\nArgs:\n  base_url: Optional. The base url of the user hosted Docker client.\n  image: The tag of the predefined image or custom image to run on the\n    container. Either docker_path or image must be set.\n  docker_path: The path to the directory containing the Dockerfile. If set,\n    build the image from the dockerfile path instead of using the predefined\n    image. Either docker_path or image must be set.\n  **data: The data to initialize the ContainerCodeExecutor."
  signature: 'def __init__(self, base_url: typing.Optional[str], image: typing.Optional[str], docker_path: typing.Optional[str]):'
- rank: 606
  id: google.adk.code_executors.container_code_executor.ContainerCodeExecutor.execute_code
  name: execute_code
  file_path: src/google/adk/code_executors/container_code_executor.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def execute_code(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, code_execution_input: google.adk.code_executors.code_execution_utils.CodeExecutionInput) -> google.adk.code_executors.code_execution_utils.CodeExecutionResult:'
- rank: 607
  id: google.adk.code_executors.gke_code_executor
  name: gke_code_executor
  file_path: src/google/adk/code_executors/gke_code_executor.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'client: Any'
  - signature: 'config: Any'
  - signature: 'ApiException: Any'
  - signature: 'logger: logging.getLogger'
- rank: 608
  id: google.adk.code_executors.gke_code_executor.GkeCodeExecutor
  name: GkeCodeExecutor
  file_path: src/google/adk/code_executors/gke_code_executor.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Executes Python code in a secure gVisor-sandboxed Pod on GKE.


    This executor securely runs code by dynamically creating a Kubernetes Job for

    each execution request. The user''s code is mounted via a ConfigMap, and the

    Pod is hardened with a strict security context and resource limits.


    Key Features:

    - Sandboxed execution using the gVisor runtime.

    - Ephemeral, per-execution environments using Kubernetes Jobs.

    - Secure-by-default Pod configuration (non-root, no privileges).

    - Automatic garbage collection of completed Jobs and Pods via TTL.

    - Efficient, event-driven waiting using the Kubernetes watch API.


    RBAC Permissions:

    This executor requires a ServiceAccount with specific RBAC permissions. The

    Role granted to the ServiceAccount must include rules to manage Jobs,

    ConfigMaps, and Pod logs. Below is a minimal set of required permissions:


    rules:

    # For creating/deleting code ConfigMaps and patching ownerReferences

    - apiGroups: [""] # Core API Group

    resources: ["configmaps"]

    verbs: ["create", "delete", "get", "patch"]

    # For watching Job completion status

    - apiGroups: ["batch"]

    resources: ["jobs"]

    verbs: ["get", "list", "watch", "create", "delete"]

    # For retrieving logs from the completed Job''s Pod

    - apiGroups: [""] # Core API Group

    resources: ["pods", "pods/log"]

    verbs: ["get", "list"]


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, kubeconfig_path: str | None, kubeconfig_context: str | None):'
  methods:
  - signature: 'def execute_code(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, code_execution_input: google.adk.code_executors.code_execution_utils.CodeExecutionInput) -> google.adk.code_executors.code_execution_utils.CodeExecutionResult:'
    docstring: Orchestrates the secure execution of a code snippet on GKE.
  properties:
  - signature: 'namespace: str'
  - signature: 'image: str'
  - signature: 'timeout_seconds: int'
  - signature: 'cpu_requested: str'
  - signature: 'mem_requested: str'
  - signature: 'cpu_limit: str'
  - signature: 'mem_limit: str'
  - signature: 'kubeconfig_path: str | None'
  - signature: 'kubeconfig_context: str | None'
  inherited_methods:
    BaseCodeExecutor:
    - signature: 'def execute_code(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, code_execution_input: google.adk.code_executors.code_execution_utils.CodeExecutionInput) -> google.adk.code_executors.code_execution_utils.CodeExecutionResult:'
      docstring: "Executes code and return the code execution result.\n\nArgs:\n  invocation_context: The invocation context of the code execution.\n  code_execution_input: The code execution input.\n\nReturns:\n  The code execution result."
  inherited_properties:
    BaseCodeExecutor:
    - signature: 'optimize_data_file: bool'
      docstring: 'If true, extract and process data files from the model request

        and attach them to the code executor.


        Supported data file MimeTypes are [text/csv].

        Default to False.'
    - signature: 'stateful: bool'
      docstring: Whether the code executor is stateful. Default to False.
    - signature: 'error_retry_attempts: int'
      docstring: The number of attempts to retry on consecutive code execution errors. Default to 2.
    - signature: 'code_block_delimiters: typing.List[tuple[str, str]]'
      docstring: "The list of the enclosing delimiters to identify the code blocks.\n\nFor example, the delimiter ('```python\\n', '\\n```') can be\nused to identify code blocks with the following format::\n\n    ```python\n    print(\"hello\")\n    ```"
    - signature: 'execution_result_delimiters: tuple[str, str]'
      docstring: The delimiters to format the code execution result.
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 609
  id: google.adk.code_executors.gke_code_executor.GkeCodeExecutor.__init__
  name: __init__
  file_path: src/google/adk/code_executors/gke_code_executor.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Initializes the executor and the Kubernetes API clients.


    This constructor supports multiple authentication methods:

    1. Explicitly via a kubeconfig file path and context.

    2. Automatically via in-cluster service account (when running in GKE).

    3. Automatically via the default local kubeconfig file (~/.kube/config).'
  signature: 'def __init__(self, kubeconfig_path: str | None, kubeconfig_context: str | None):'
- rank: 610
  id: google.adk.code_executors.gke_code_executor.GkeCodeExecutor.execute_code
  name: execute_code
  file_path: src/google/adk/code_executors/gke_code_executor.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Orchestrates the secure execution of a code snippet on GKE.
  signature: 'def execute_code(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, code_execution_input: google.adk.code_executors.code_execution_utils.CodeExecutionInput) -> google.adk.code_executors.code_execution_utils.CodeExecutionResult:'
- rank: 611
  id: google.adk.code_executors.unsafe_local_code_executor
  name: unsafe_local_code_executor
  file_path: src/google/adk/code_executors/unsafe_local_code_executor.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 612
  id: google.adk.code_executors.unsafe_local_code_executor.UnsafeLocalCodeExecutor
  name: UnsafeLocalCodeExecutor
  file_path: src/google/adk/code_executors/unsafe_local_code_executor.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A code executor that unsafely execute code in the current local context.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self):'
  aliases:
  - google.adk.code_executors.UnsafeLocalCodeExecutor
  methods:
  - signature: 'def execute_code(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, code_execution_input: google.adk.code_executors.code_execution_utils.CodeExecutionInput) -> google.adk.code_executors.code_execution_utils.CodeExecutionResult:'
  properties:
  - signature: 'stateful: bool'
  - signature: 'optimize_data_file: bool'
  inherited_methods:
    BaseCodeExecutor:
    - signature: 'def execute_code(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, code_execution_input: google.adk.code_executors.code_execution_utils.CodeExecutionInput) -> google.adk.code_executors.code_execution_utils.CodeExecutionResult:'
      docstring: "Executes code and return the code execution result.\n\nArgs:\n  invocation_context: The invocation context of the code execution.\n  code_execution_input: The code execution input.\n\nReturns:\n  The code execution result."
  inherited_properties:
    BaseCodeExecutor:
    - signature: 'optimize_data_file: bool'
      docstring: 'If true, extract and process data files from the model request

        and attach them to the code executor.


        Supported data file MimeTypes are [text/csv].

        Default to False.'
    - signature: 'stateful: bool'
      docstring: Whether the code executor is stateful. Default to False.
    - signature: 'error_retry_attempts: int'
      docstring: The number of attempts to retry on consecutive code execution errors. Default to 2.
    - signature: 'code_block_delimiters: typing.List[tuple[str, str]]'
      docstring: "The list of the enclosing delimiters to identify the code blocks.\n\nFor example, the delimiter ('```python\\n', '\\n```') can be\nused to identify code blocks with the following format::\n\n    ```python\n    print(\"hello\")\n    ```"
    - signature: 'execution_result_delimiters: tuple[str, str]'
      docstring: The delimiters to format the code execution result.
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 613
  id: google.adk.code_executors.unsafe_local_code_executor.UnsafeLocalCodeExecutor.__init__
  name: __init__
  file_path: src/google/adk/code_executors/unsafe_local_code_executor.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Initializes the UnsafeLocalCodeExecutor.
  signature: 'def __init__(self):'
- rank: 614
  id: google.adk.code_executors.unsafe_local_code_executor.UnsafeLocalCodeExecutor.execute_code
  name: execute_code
  file_path: src/google/adk/code_executors/unsafe_local_code_executor.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def execute_code(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, code_execution_input: google.adk.code_executors.code_execution_utils.CodeExecutionInput) -> google.adk.code_executors.code_execution_utils.CodeExecutionResult:'
- rank: 615
  id: google.adk.code_executors.vertex_ai_code_executor
  name: vertex_ai_code_executor
  file_path: src/google/adk/code_executors/vertex_ai_code_executor.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '_SUPPORTED_IMAGE_TYPES: Any'
  - signature: '_SUPPORTED_DATA_FILE_TYPES: Any'
  - signature: '_IMPORTED_LIBRARIES: str'
- rank: 616
  id: google.adk.code_executors.vertex_ai_code_executor.VertexAiCodeExecutor
  name: VertexAiCodeExecutor
  file_path: src/google/adk/code_executors/vertex_ai_code_executor.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "A code executor that uses Vertex Code Interpreter Extension to execute code.\n\nAttributes:\n  resource_name: If set, load the existing resource name of the code\n    interpreter extension instead of creating a new one. Format:\n    projects/123/locations/us-central1/extensions/456\n\n[Note: Inherited members from pydantic.BaseModel are omitted.]"
  constructor_signature: 'def __init__(self, resource_name: str):'
  methods:
  - signature: 'def execute_code(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, code_execution_input: google.adk.code_executors.code_execution_utils.CodeExecutionInput) -> google.adk.code_executors.code_execution_utils.CodeExecutionResult:'
  properties:
  - signature: 'resource_name: str'
    docstring: 'If set, load the existing resource name of the code interpreter extension

      instead of creating a new one.

      Format: projects/123/locations/us-central1/extensions/456'
  inherited_methods:
    BaseCodeExecutor:
    - signature: 'def execute_code(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, code_execution_input: google.adk.code_executors.code_execution_utils.CodeExecutionInput) -> google.adk.code_executors.code_execution_utils.CodeExecutionResult:'
      docstring: "Executes code and return the code execution result.\n\nArgs:\n  invocation_context: The invocation context of the code execution.\n  code_execution_input: The code execution input.\n\nReturns:\n  The code execution result."
  inherited_properties:
    BaseCodeExecutor:
    - signature: 'optimize_data_file: bool'
      docstring: 'If true, extract and process data files from the model request

        and attach them to the code executor.


        Supported data file MimeTypes are [text/csv].

        Default to False.'
    - signature: 'stateful: bool'
      docstring: Whether the code executor is stateful. Default to False.
    - signature: 'error_retry_attempts: int'
      docstring: The number of attempts to retry on consecutive code execution errors. Default to 2.
    - signature: 'code_block_delimiters: typing.List[tuple[str, str]]'
      docstring: "The list of the enclosing delimiters to identify the code blocks.\n\nFor example, the delimiter ('```python\\n', '\\n```') can be\nused to identify code blocks with the following format::\n\n    ```python\n    print(\"hello\")\n    ```"
    - signature: 'execution_result_delimiters: tuple[str, str]'
      docstring: The delimiters to format the code execution result.
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 617
  id: google.adk.code_executors.vertex_ai_code_executor.VertexAiCodeExecutor.__init__
  name: __init__
  file_path: src/google/adk/code_executors/vertex_ai_code_executor.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the VertexAiCodeExecutor.\n\nArgs:\n  resource_name: If set, load the existing resource name of the code\n    interpreter extension instead of creating a new one. Format:\n    projects/123/locations/us-central1/extensions/456\n  **data: Additional keyword arguments to be passed to the base class."
  signature: 'def __init__(self, resource_name: str):'
- rank: 618
  id: google.adk.code_executors.vertex_ai_code_executor.VertexAiCodeExecutor.execute_code
  name: execute_code
  file_path: src/google/adk/code_executors/vertex_ai_code_executor.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def execute_code(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, code_execution_input: google.adk.code_executors.code_execution_utils.CodeExecutionInput) -> google.adk.code_executors.code_execution_utils.CodeExecutionResult:'
- rank: 619
  id: google.adk.dependencies
  name: dependencies
  file_path: src/google/adk/dependencies/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 620
  id: google.adk.dependencies.rouge_scorer
  name: rouge_scorer
  file_path: src/google/adk/dependencies/rouge_scorer.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 621
  id: google.adk.dependencies.vertexai
  name: vertexai
  file_path: src/google/adk/dependencies/vertexai.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 622
  id: google.adk.errors
  name: errors
  file_path: src/google/adk/errors/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 623
  id: google.adk.errors.already_exists_error
  name: already_exists_error
  file_path: src/google/adk/errors/already_exists_error.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 624
  id: google.adk.errors.already_exists_error.AlreadyExistsError
  name: AlreadyExistsError
  file_path: src/google/adk/errors/already_exists_error.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Represents an error that occurs when an entity already exists.


    [Note: Inherited members from Exception are omitted.]'
  constructor_signature: 'def __init__(self, message):'
  omitted_inherited_members_from:
  - Exception
- rank: 625
  id: google.adk.errors.already_exists_error.AlreadyExistsError.__init__
  name: __init__
  file_path: src/google/adk/errors/already_exists_error.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the AlreadyExistsError exception.\n\nArgs:\n    message (str): An optional custom message to describe the error."
  signature: 'def __init__(self, message):'
- rank: 626
  id: google.adk.errors.input_validation_error
  name: input_validation_error
  file_path: src/google/adk/errors/input_validation_error.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 627
  id: google.adk.errors.input_validation_error.InputValidationError
  name: InputValidationError
  file_path: src/google/adk/errors/input_validation_error.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Represents an error raised when user input fails validation.


    [Note: Inherited members from ValueError are omitted.]'
  constructor_signature: 'def __init__(self, message):'
  omitted_inherited_members_from:
  - ValueError
- rank: 628
  id: google.adk.errors.input_validation_error.InputValidationError.__init__
  name: __init__
  file_path: src/google/adk/errors/input_validation_error.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the InputValidationError exception.\n\nArgs:\n    message (str): A message describing why the input is invalid."
  signature: 'def __init__(self, message):'
- rank: 629
  id: google.adk.errors.not_found_error
  name: not_found_error
  file_path: src/google/adk/errors/not_found_error.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 630
  id: google.adk.errors.not_found_error.NotFoundError
  name: NotFoundError
  file_path: src/google/adk/errors/not_found_error.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Represents an error that occurs when an entity is not found.


    [Note: Inherited members from Exception are omitted.]'
  constructor_signature: 'def __init__(self, message):'
  omitted_inherited_members_from:
  - Exception
- rank: 631
  id: google.adk.errors.not_found_error.NotFoundError.__init__
  name: __init__
  file_path: src/google/adk/errors/not_found_error.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the NotFoundError exception.\n\nArgs:\n    message (str): An optional custom message to describe the error."
  signature: 'def __init__(self, message):'
- rank: 632
  id: google.adk.evaluation
  name: evaluation
  file_path: src/google/adk/evaluation/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '__all__: Any'
- rank: 633
  id: google.adk.evaluation.agent_evaluator
  name: agent_evaluator
  file_path: src/google/adk/evaluation/agent_evaluator.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def load_json(file_path: str) -> typing.Union[typing.Dict, typing.List]:'
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: 'NUM_RUNS: int'
  - signature: 'TOOL_TRAJECTORY_SCORE_KEY: Any'
  - signature: 'RESPONSE_EVALUATION_SCORE_KEY: Any'
  - signature: 'RESPONSE_MATCH_SCORE_KEY: Any'
  - signature: 'SAFETY_V1_KEY: Any'
  - signature: 'ALLOWED_CRITERIA: Any'
  - signature: 'QUERY_COLUMN: str'
  - signature: 'REFERENCE_COLUMN: str'
  - signature: 'EXPECTED_TOOL_USE_COLUMN: str'
- rank: 634
  id: google.adk.evaluation.agent_evaluator.AgentEvaluator
  name: AgentEvaluator
  file_path: src/google/adk/evaluation/agent_evaluator.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: An evaluator for Agents, mainly intended for helping with test cases.
  methods:
  - signature: 'def find_config_for_test_file(test_file: str) -> google.adk.evaluation.eval_config.EvalConfig:'
    docstring: Find the test_config.json file in the same folder as the test file.
  - signature: 'def evaluate_eval_set(agent_module: str, eval_set: google.adk.evaluation.eval_set.EvalSet, criteria: typing.Optional[dict[str, float]], eval_config: typing.Optional[google.adk.evaluation.eval_config.EvalConfig], num_runs: int, agent_name: typing.Optional[str], print_detailed_results: bool):'
    docstring: "Evaluates an agent using the given EvalSet.\n\nArgs:\n  agent_module: The path to python module that contains the definition of\n    the agent. There is convention in place here, where the code is going to\n    look for 'root_agent' or `get_agent_async` in the loaded module.\n  eval_set: The eval set.\n  criteria: Evaluation criteria, a dictionary of metric names to their\n    respective thresholds. This field is deprecated.\n  eval_config: The evaluation config.\n  num_runs: Number of times all entries in the eval dataset should be\n    assessed.\n  agent_name: The name of the agent, if trying to evaluate something other\n    than root agent. If left empty or none, then root agent is evaluated.\n  print_detailed_results: Whether to print detailed results for each metric\n    evaluation."
  - signature: 'def evaluate(agent_module: str, eval_dataset_file_path_or_dir: str, num_runs: int, agent_name: typing.Optional[str], initial_session_file: typing.Optional[str], print_detailed_results: bool):'
    docstring: "Evaluates an Agent given eval data.\n\nArgs:\n  agent_module: The path to python module that contains the definition of\n    the agent. There is convention in place here, where the code is going to\n    look for 'root_agent' or 'get_agent_async' in the loaded module.\n  eval_dataset_file_path_or_dir: The eval data set. This can be either a\n    string representing full path to the file containing eval dataset, or a\n    directory that is recursively explored for all files that have a\n    `.test.json` suffix.\n  num_runs: Number of times all entries in the eval dataset should be\n    assessed.\n  agent_name: The name of the agent.\n  initial_session_file: File that contains initial session state that is\n    needed by all the evals in the eval dataset.\n  print_detailed_results: Whether to print detailed results for each metric\n    evaluation."
  - signature: 'def migrate_eval_data_to_new_schema(old_eval_data_file: str, new_eval_data_file: str, initial_session_file: typing.Optional[str]):'
    docstring: A utility for migrating eval data to new schema backed by EvalSet.
- rank: 635
  id: google.adk.evaluation.agent_evaluator.AgentEvaluator.evaluate_eval_set
  name: evaluate_eval_set
  file_path: src/google/adk/evaluation/agent_evaluator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Evaluates an agent using the given EvalSet.\n\nArgs:\n  agent_module: The path to python module that contains the definition of\n    the agent. There is convention in place here, where the code is going to\n    look for 'root_agent' or `get_agent_async` in the loaded module.\n  eval_set: The eval set.\n  criteria: Evaluation criteria, a dictionary of metric names to their\n    respective thresholds. This field is deprecated.\n  eval_config: The evaluation config.\n  num_runs: Number of times all entries in the eval dataset should be\n    assessed.\n  agent_name: The name of the agent, if trying to evaluate something other\n    than root agent. If left empty or none, then root agent is evaluated.\n  print_detailed_results: Whether to print detailed results for each metric\n    evaluation."
  signature: 'def evaluate_eval_set(agent_module: str, eval_set: google.adk.evaluation.eval_set.EvalSet, criteria: typing.Optional[dict[str, float]], eval_config: typing.Optional[google.adk.evaluation.eval_config.EvalConfig], num_runs: int, agent_name: typing.Optional[str], print_detailed_results: bool):'
- rank: 636
  id: google.adk.evaluation.agent_evaluator.AgentEvaluator.find_config_for_test_file
  name: find_config_for_test_file
  file_path: src/google/adk/evaluation/agent_evaluator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Find the test_config.json file in the same folder as the test file.
  signature: 'def find_config_for_test_file(test_file: str) -> google.adk.evaluation.eval_config.EvalConfig:'
- rank: 637
  id: google.adk.evaluation.agent_evaluator.AgentEvaluator.migrate_eval_data_to_new_schema
  name: migrate_eval_data_to_new_schema
  file_path: src/google/adk/evaluation/agent_evaluator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: A utility for migrating eval data to new schema backed by EvalSet.
  signature: 'def migrate_eval_data_to_new_schema(old_eval_data_file: str, new_eval_data_file: str, initial_session_file: typing.Optional[str]):'
- rank: 638
  id: google.adk.evaluation.app_details
  name: app_details
  file_path: src/google/adk/evaluation/app_details.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 639
  id: google.adk.evaluation.app_details.AgentDetails
  name: AgentDetails
  file_path: src/google/adk/evaluation/app_details.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Details about the individual agent in the App.


    This could be a root agent or the sub-agents in the Agent Tree.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, name: str, instructions: str = '''', tool_declarations: list[typing.Any] = list()):'
  properties:
  - signature: 'name: str'
    docstring: The name of the Agent that uniquely identifies it in the App.
  - signature: 'instructions: str'
    docstring: The instructions set on the Agent.
  - signature: 'tool_declarations: list[typing.Any]'
    docstring: 'A list of tools available to the Agent.


      At runtime, this contains elements of type genai_types.ToolListUnion.

      We use list[Any] for Pydantic schema generation compatibility.'
  inherited_properties:
    EvalBaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 640
  id: google.adk.evaluation.app_details.AppDetails
  name: AppDetails
  file_path: src/google/adk/evaluation/app_details.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Contains details about the App (the agentic system).


    This structure is only a projection of the actual app. Only details

    that are relevant to the Eval System are captured here.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, agent_details: dict[str, google.adk.evaluation.app_details.AgentDetails] = dict()):'
  methods:
  - signature: 'def get_developer_instructions(self, agent_name: str) -> str:'
    docstring: Returns a string containing the developer instructions.
  - signature: 'def get_tools_by_agent_name(self) -> dict[str, google.genai.types.ToolListUnion]:'
    docstring: Returns a dictionary of tools available to an agent in the App, keyed to the name of the Agent.
  properties:
  - signature: 'agent_details: dict[str, google.adk.evaluation.app_details.AgentDetails]'
    docstring: A mapping from the agent name to the details of that agent.
  inherited_properties:
    EvalBaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 641
  id: google.adk.evaluation.app_details.AppDetails.get_developer_instructions
  name: get_developer_instructions
  file_path: src/google/adk/evaluation/app_details.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns a string containing the developer instructions.
  signature: 'def get_developer_instructions(self, agent_name: str) -> str:'
- rank: 642
  id: google.adk.evaluation.app_details.AppDetails.get_tools_by_agent_name
  name: get_tools_by_agent_name
  file_path: src/google/adk/evaluation/app_details.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns a dictionary of tools available to an agent in the App, keyed to the name of the Agent.
  signature: 'def get_tools_by_agent_name(self) -> dict[str, google.genai.types.ToolListUnion]:'
- rank: 643
  id: google.adk.evaluation.base_eval_service
  name: base_eval_service
  file_path: src/google/adk/evaluation/base_eval_service.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 644
  id: google.adk.evaluation.base_eval_service.BaseEvalService
  name: BaseEvalService
  file_path: src/google/adk/evaluation/base_eval_service.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A service to run Evals for an ADK agent.


    [Note: Inherited members from ABC are omitted.]'
  methods:
  - signature: 'def perform_inference(self, inference_request: google.adk.evaluation.base_eval_service.InferenceRequest) -> typing.AsyncGenerator[google.adk.evaluation.base_eval_service.InferenceResult, None]:'
    docstring: "Returns InferenceResult obtained from the Agent as and when they are available.\n\nArgs:\n  inference_request: The request for generating inferences."
  - signature: 'def evaluate(self, evaluate_request: google.adk.evaluation.base_eval_service.EvaluateRequest) -> typing.AsyncGenerator[google.adk.evaluation.eval_result.EvalCaseResult, None]:'
    docstring: "Returns EvalCaseResult for each item as and when they are available.\n\nArgs:\n  evaluate_request: The request to perform metric evaluations on the\n    inferences."
  omitted_inherited_members_from:
  - ABC
- rank: 645
  id: google.adk.evaluation.base_eval_service.BaseEvalService.evaluate
  name: evaluate
  file_path: src/google/adk/evaluation/base_eval_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Returns EvalCaseResult for each item as and when they are available.\n\nArgs:\n  evaluate_request: The request to perform metric evaluations on the\n    inferences."
  signature: 'def evaluate(self, evaluate_request: google.adk.evaluation.base_eval_service.EvaluateRequest) -> typing.AsyncGenerator[google.adk.evaluation.eval_result.EvalCaseResult, None]:'
- rank: 646
  id: google.adk.evaluation.base_eval_service.BaseEvalService.perform_inference
  name: perform_inference
  file_path: src/google/adk/evaluation/base_eval_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Returns InferenceResult obtained from the Agent as and when they are available.\n\nArgs:\n  inference_request: The request for generating inferences."
  signature: 'def perform_inference(self, inference_request: google.adk.evaluation.base_eval_service.InferenceRequest) -> typing.AsyncGenerator[google.adk.evaluation.base_eval_service.InferenceResult, None]:'
- rank: 647
  id: google.adk.evaluation.base_eval_service.EvaluateConfig
  name: EvaluateConfig
  file_path: src/google/adk/evaluation/base_eval_service.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Contains configurations needed to run evaluations.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, eval_metrics: list[google.adk.evaluation.eval_metrics.EvalMetric], parallelism: int = 4):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'eval_metrics: list[google.adk.evaluation.eval_metrics.EvalMetric]'
  - signature: 'parallelism: int'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 648
  id: google.adk.evaluation.base_eval_service.EvaluateRequest
  name: EvaluateRequest
  file_path: src/google/adk/evaluation/base_eval_service.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, inference_results: list[google.adk.evaluation.base_eval_service.InferenceResult], evaluate_config: google.adk.evaluation.base_eval_service.EvaluateConfig):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'inference_results: list[google.adk.evaluation.base_eval_service.InferenceResult]'
  - signature: 'evaluate_config: google.adk.evaluation.base_eval_service.EvaluateConfig'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 649
  id: google.adk.evaluation.base_eval_service.InferenceConfig
  name: InferenceConfig
  file_path: src/google/adk/evaluation/base_eval_service.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Contains configurations need to run inferences.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, labels: typing.Optional[dict[str, str]] = None, parallelism: int = 4):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'labels: typing.Optional[dict[str, str]]'
  - signature: 'parallelism: int'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 650
  id: google.adk.evaluation.base_eval_service.InferenceRequest
  name: InferenceRequest
  file_path: src/google/adk/evaluation/base_eval_service.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Represent a request to perform inferences for the eval cases in an eval set.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, app_name: str, eval_set_id: str, eval_case_ids: typing.Optional[list[str]] = None, inference_config: google.adk.evaluation.base_eval_service.InferenceConfig):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'app_name: str'
  - signature: 'eval_set_id: str'
  - signature: 'eval_case_ids: typing.Optional[list[str]]'
  - signature: 'inference_config: google.adk.evaluation.base_eval_service.InferenceConfig'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 651
  id: google.adk.evaluation.base_eval_service.InferenceResult
  name: InferenceResult
  file_path: src/google/adk/evaluation/base_eval_service.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Contains inference results for a single eval case.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, app_name: str, eval_set_id: str, eval_case_id: str, inferences: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]] = None, session_id: typing.Optional[str], status: google.adk.evaluation.base_eval_service.InferenceStatus = InferenceStatus.UNKNOWN, error_message: typing.Optional[str] = None):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'app_name: str'
  - signature: 'eval_set_id: str'
  - signature: 'eval_case_id: str'
  - signature: 'inferences: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]]'
  - signature: 'session_id: typing.Optional[str]'
  - signature: 'status: google.adk.evaluation.base_eval_service.InferenceStatus'
  - signature: 'error_message: typing.Optional[str]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 652
  id: google.adk.evaluation.base_eval_service.InferenceStatus
  name: InferenceStatus
  file_path: src/google/adk/evaluation/base_eval_service.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Status of the inference.


    [Note: Inherited members from Enum are omitted.]'
  properties:
  - signature: 'UNKNOWN: int'
  - signature: 'SUCCESS: int'
  - signature: 'FAILURE: int'
  omitted_inherited_members_from:
  - Enum
- rank: 653
  id: google.adk.evaluation.common
  name: common
  file_path: src/google/adk/evaluation/common.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 654
  id: google.adk.evaluation.common.EvalBaseModel
  name: EvalBaseModel
  file_path: src/google/adk/evaluation/common.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 655
  id: google.adk.evaluation.constants
  name: constants
  file_path: src/google/adk/evaluation/constants.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'MISSING_EVAL_DEPENDENCIES_MESSAGE: str'
- rank: 656
  id: google.adk.evaluation.conversation_scenarios
  name: conversation_scenarios
  file_path: src/google/adk/evaluation/conversation_scenarios.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 657
  id: google.adk.evaluation.conversation_scenarios.ConversationScenario
  name: ConversationScenario
  file_path: src/google/adk/evaluation/conversation_scenarios.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Scenario for a conversation between a simulated user and the Agent under test.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, starting_prompt: str, conversation_plan: str):'
  properties:
  - signature: 'starting_prompt: str'
    docstring: 'Starting prompt for the conversation.


      This prompt acts as the fixed first user message that is given to the Agent.

      Any subsequent user messages are obtained by the system that is simulating the

      user.'
  - signature: 'conversation_plan: str'
    docstring: 'A plan that user simulation system needs to follow as it plays out the conversation.


      Example:

      For a Travel Agent that has tools that let it book a flight and car, a sample

      starting prompt could be:


      `I need to book a flight.`


      A conversation plan could look like:


      First, you want to book a one-way flight from SFO to LAX for next Tuesday.

      You prefer a morning flight and your budget is under $150. If the agent finds

      a valid flight, confirm the booking. Once confirmed, your next goal is to rent

      a standard-size car for three days from the airport. Once both tasks are done,

      your overall goal is complete.'
  inherited_properties:
    EvalBaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 658
  id: google.adk.evaluation.conversation_scenarios.ConversationScenarios
  name: ConversationScenarios
  file_path: src/google/adk/evaluation/conversation_scenarios.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A simple container for the list of ConversationScenario.


    Mainly serves the purpose of helping with serialization and deserialization.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, scenarios: list[google.adk.evaluation.conversation_scenarios.ConversationScenario] = list()):'
  properties:
  - signature: 'scenarios: list[google.adk.evaluation.conversation_scenarios.ConversationScenario]'
  inherited_properties:
    EvalBaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 659
  id: google.adk.evaluation.custom_metric_evaluator
  name: custom_metric_evaluator
  file_path: src/google/adk/evaluation/custom_metric_evaluator.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 660
  id: google.adk.evaluation.eval_case
  name: eval_case
  file_path: src/google/adk/evaluation/eval_case.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def get_all_tool_calls(intermediate_data: typing.Optional[google.adk.evaluation.eval_case.IntermediateDataType]) -> list[google.genai.types.FunctionCall]:'
    docstring: A utility method to retrieve tools calls from intermediate data.
  - signature: 'def get_all_tool_responses(intermediate_data: typing.Optional[google.adk.evaluation.eval_case.IntermediateDataType]) -> list[google.genai.types.FunctionResponse]:'
    docstring: A utility method to retrieve tools responses from intermediate data.
  - signature: 'def get_all_tool_calls_with_responses(intermediate_data: typing.Optional[google.adk.evaluation.eval_case.IntermediateDataType]) -> list[google.adk.evaluation.eval_case.ToolCallAndResponse]:'
    docstring: Returns tool calls with the corresponding responses, if available.
  properties:
  - signature: 'IntermediateDataType: typing_extensions.TypeAlias'
  - signature: 'SessionState: typing_extensions.TypeAlias'
  - signature: 'StaticConversation: typing_extensions.TypeAlias'
  - signature: 'ToolCallAndResponse: typing_extensions.TypeAlias'
- rank: 661
  id: google.adk.evaluation.eval_case.EvalCase
  name: EvalCase
  file_path: src/google/adk/evaluation/eval_case.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'An eval case.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, eval_id: str, conversation: typing.Optional[google.adk.evaluation.eval_case.StaticConversation] = None, conversation_scenario: typing.Optional[google.adk.evaluation.conversation_scenarios.ConversationScenario] = None, session_input: typing.Optional[google.adk.evaluation.eval_case.SessionInput] = None, creation_timestamp: float = 0.0, rubrics: typing.Optional[list[google.adk.evaluation.eval_rubrics.Rubric]] = None, final_session_state: typing.Optional[google.adk.evaluation.eval_case.SessionState] = dict()):'
  methods:
  - signature: 'def ensure_conversation_xor_conversation_scenario(self) -> google.adk.evaluation.eval_case.EvalCase:'
  properties:
  - signature: 'eval_id: str'
    docstring: Unique identifier for the evaluation case.
  - signature: 'conversation: typing.Optional[google.adk.evaluation.eval_case.StaticConversation]'
    docstring: "A static conversation between the user and the Agent.\n\n While creating an eval case you should specify either a `conversation` or a\n`conversation_scenario`, but not both."
  - signature: 'conversation_scenario: typing.Optional[google.adk.evaluation.conversation_scenarios.ConversationScenario]'
    docstring: 'A conversation scenario that should be used by a UserSimulator.


      While creating an eval case you should specify either a `conversation` or a

      `conversation_scenario`, but not both.'
  - signature: 'session_input: typing.Optional[google.adk.evaluation.eval_case.SessionInput]'
    docstring: 'Session input that will be passed on to the Agent during eval.

      It is common for Agents state to be initialized to some initial/default value,

      for example, your agent may need to know today''s date.'
  - signature: 'creation_timestamp: float'
    docstring: The time at which this eval case was created.
  - signature: 'rubrics: typing.Optional[list[google.adk.evaluation.eval_rubrics.Rubric]]'
    docstring: A list of rubrics that are applicable to all the invocations in the conversation of this eval case.
  - signature: 'final_session_state: typing.Optional[google.adk.evaluation.eval_case.SessionState]'
    docstring: The expected final session state at the end of the conversation.
  inherited_properties:
    EvalBaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 662
  id: google.adk.evaluation.eval_case.EvalCase.ensure_conversation_xor_conversation_scenario
  name: ensure_conversation_xor_conversation_scenario
  file_path: src/google/adk/evaluation/eval_case.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def ensure_conversation_xor_conversation_scenario(self) -> google.adk.evaluation.eval_case.EvalCase:'
- rank: 663
  id: google.adk.evaluation.eval_case.IntermediateData
  name: IntermediateData
  file_path: src/google/adk/evaluation/eval_case.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Container for intermediate data that an agent would generate as it responds with a final answer.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, tool_uses: list[google.genai.types.FunctionCall] = [], tool_responses: list[google.genai.types.FunctionResponse] = [], intermediate_responses: list[tuple[str, list[google.genai.types.Part]]] = []):'
  properties:
  - signature: 'tool_uses: list[google.genai.types.FunctionCall]'
    docstring: Tool use trajectory in chronological order.
  - signature: 'tool_responses: list[google.genai.types.FunctionResponse]'
    docstring: Tool response trajectory in chronological order.
  - signature: 'intermediate_responses: list[tuple[str, list[google.genai.types.Part]]]'
    docstring: "Intermediate responses generated by sub-agents to convey progress or status\nin a multi-agent system, distinct from the final response.\n\nThis is expressed as a tuple of:\n  - Author: Usually the sub-agent name that generated the intermediate\n    response.\n\n  - A list of Parts that comprise of the response."
  inherited_properties:
    EvalBaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 664
  id: google.adk.evaluation.eval_case.Invocation
  name: Invocation
  file_path: src/google/adk/evaluation/eval_case.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Represents a single invocation.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, user_content: google.genai.types.Content, final_response: typing.Optional[google.genai.types.Content] = None, intermediate_data: typing.Optional[google.adk.evaluation.eval_case.IntermediateDataType] = None, creation_timestamp: float = 0.0, rubrics: typing.Optional[list[google.adk.evaluation.eval_rubrics.Rubric]] = None, app_details: typing.Optional[google.adk.evaluation.app_details.AppDetails] = None):'
  properties:
  - signature: 'invocation_id: str'
    docstring: Unique identifier for the invocation.
  - signature: 'user_content: google.genai.types.Content'
    docstring: Content provided by the user in this invocation.
  - signature: 'final_response: typing.Optional[google.genai.types.Content]'
    docstring: Final response from the agent.
  - signature: 'intermediate_data: typing.Optional[google.adk.evaluation.eval_case.IntermediateDataType]'
    docstring: 'Intermediate steps generated as a part of Agent execution.


      For a multi-agent system, it is also helpful to inspect the route that

      the agent took to generate final response.'
  - signature: 'creation_timestamp: float'
    docstring: Timestamp for the current invocation, primarily intended for debugging purposes.
  - signature: 'rubrics: typing.Optional[list[google.adk.evaluation.eval_rubrics.Rubric]]'
    docstring: A list of rubrics that are applicable to only this invocation.
  - signature: 'app_details: typing.Optional[google.adk.evaluation.app_details.AppDetails]'
    docstring: Details about the App that was used for this invocation.
  inherited_properties:
    EvalBaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 665
  id: google.adk.evaluation.eval_case.InvocationEvent
  name: InvocationEvent
  file_path: src/google/adk/evaluation/eval_case.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'An immutable record representing a specific point in the agent''s invocation.


    It captures agent''s replies, requests to use tools (function calls), and tool

    results.


    This structure is a simple projection of the actual `Event` datamodel that

    is intended for the Eval System.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, author: str, content: typing.Optional[google.genai.types.Content]):'
  properties:
  - signature: 'author: str'
    docstring: The name of the agent that authored/owned this event.
  - signature: 'content: typing.Optional[google.genai.types.Content]'
    docstring: The content of the event.
  inherited_properties:
    EvalBaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 666
  id: google.adk.evaluation.eval_case.InvocationEvents
  name: InvocationEvents
  file_path: src/google/adk/evaluation/eval_case.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A container for events that occur during the course of an invocation.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, invocation_events: list[google.adk.evaluation.eval_case.InvocationEvent] = list()):'
  properties:
  - signature: 'invocation_events: list[google.adk.evaluation.eval_case.InvocationEvent]'
    docstring: A list of invocation events.
  inherited_properties:
    EvalBaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 667
  id: google.adk.evaluation.eval_case.SessionInput
  name: SessionInput
  file_path: src/google/adk/evaluation/eval_case.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Values that help initialize a Session.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, app_name: str, user_id: str, state: google.adk.evaluation.eval_case.SessionState = dict()):'
  properties:
  - signature: 'app_name: str'
    docstring: The name of the app.
  - signature: 'user_id: str'
    docstring: The user id.
  - signature: 'state: google.adk.evaluation.eval_case.SessionState'
    docstring: The state of the session.
  inherited_properties:
    EvalBaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 668
  id: google.adk.evaluation.eval_case.get_all_tool_calls
  name: get_all_tool_calls
  file_path: src/google/adk/evaluation/eval_case.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: A utility method to retrieve tools calls from intermediate data.
  signature: 'def get_all_tool_calls(intermediate_data: typing.Optional[google.adk.evaluation.eval_case.IntermediateDataType]) -> list[google.genai.types.FunctionCall]:'
- rank: 669
  id: google.adk.evaluation.eval_case.get_all_tool_calls_with_responses
  name: get_all_tool_calls_with_responses
  file_path: src/google/adk/evaluation/eval_case.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns tool calls with the corresponding responses, if available.
  signature: 'def get_all_tool_calls_with_responses(intermediate_data: typing.Optional[google.adk.evaluation.eval_case.IntermediateDataType]) -> list[google.adk.evaluation.eval_case.ToolCallAndResponse]:'
- rank: 670
  id: google.adk.evaluation.eval_case.get_all_tool_responses
  name: get_all_tool_responses
  file_path: src/google/adk/evaluation/eval_case.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: A utility method to retrieve tools responses from intermediate data.
  signature: 'def get_all_tool_responses(intermediate_data: typing.Optional[google.adk.evaluation.eval_case.IntermediateDataType]) -> list[google.genai.types.FunctionResponse]:'
- rank: 671
  id: google.adk.evaluation.eval_config
  name: eval_config
  file_path: src/google/adk/evaluation/eval_config.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def get_evaluation_criteria_or_default(eval_config_file_path: typing.Optional[str]) -> google.adk.evaluation.eval_config.EvalConfig:'
    docstring: 'Returns EvalConfig read from the config file, if present.


      Otherwise a default one is returned.'
  - signature: 'def get_eval_metrics_from_config(eval_config: google.adk.evaluation.eval_config.EvalConfig) -> list[google.adk.evaluation.eval_metrics.EvalMetric]:'
    docstring: Returns a list of EvalMetrics mapped from the EvalConfig.
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '_DEFAULT_EVAL_CONFIG: EvalConfig'
- rank: 672
  id: google.adk.evaluation.eval_config.CustomMetricConfig
  name: CustomMetricConfig
  file_path: src/google/adk/evaluation/eval_config.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Configuration for a custom metric.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, code_config: google.adk.agents.common_configs.CodeConfig, metric_info: typing.Optional[google.adk.evaluation.eval_metrics.MetricInfo] = None, description: str = ''''):'
  methods:
  - signature: 'def check_code_config_args(self) -> google.adk.evaluation.eval_config.CustomMetricConfig:'
    docstring: Checks that the code config does not have args.
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'code_config: google.adk.agents.common_configs.CodeConfig'
  - signature: 'metric_info: typing.Optional[google.adk.evaluation.eval_metrics.MetricInfo]'
  - signature: 'description: str'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 673
  id: google.adk.evaluation.eval_config.CustomMetricConfig.check_code_config_args
  name: check_code_config_args
  file_path: src/google/adk/evaluation/eval_config.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Checks that the code config does not have args.
  signature: 'def check_code_config_args(self) -> google.adk.evaluation.eval_config.CustomMetricConfig:'
- rank: 674
  id: google.adk.evaluation.eval_config.EvalConfig
  name: EvalConfig
  file_path: src/google/adk/evaluation/eval_config.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Configurations needed to run an Eval.


    Allows users to specify metrics, their thresholds and other properties.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, criteria: dict[str, typing.Union[google.adk.evaluation.eval_metrics.Threshold, google.adk.evaluation.eval_metrics.BaseCriterion]] = dict(), custom_metrics: typing.Optional[dict[str, google.adk.evaluation.eval_config.CustomMetricConfig]] = None, user_simulator_config: typing.Optional[google.adk.evaluation.simulation.user_simulator.BaseUserSimulatorConfig] = None):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'criteria: dict[str, typing.Union[google.adk.evaluation.eval_metrics.Threshold, google.adk.evaluation.eval_metrics.BaseCriterion]]'
  - signature: 'custom_metrics: typing.Optional[dict[str, google.adk.evaluation.eval_config.CustomMetricConfig]]'
  - signature: 'user_simulator_config: typing.Optional[google.adk.evaluation.simulation.user_simulator.BaseUserSimulatorConfig]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 675
  id: google.adk.evaluation.eval_config.get_eval_metrics_from_config
  name: get_eval_metrics_from_config
  file_path: src/google/adk/evaluation/eval_config.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns a list of EvalMetrics mapped from the EvalConfig.
  signature: 'def get_eval_metrics_from_config(eval_config: google.adk.evaluation.eval_config.EvalConfig) -> list[google.adk.evaluation.eval_metrics.EvalMetric]:'
- rank: 676
  id: google.adk.evaluation.eval_config.get_evaluation_criteria_or_default
  name: get_evaluation_criteria_or_default
  file_path: src/google/adk/evaluation/eval_config.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Returns EvalConfig read from the config file, if present.


    Otherwise a default one is returned.'
  signature: 'def get_evaluation_criteria_or_default(eval_config_file_path: typing.Optional[str]) -> google.adk.evaluation.eval_config.EvalConfig:'
- rank: 677
  id: google.adk.evaluation.eval_metrics
  name: eval_metrics
  file_path: src/google/adk/evaluation/eval_metrics.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'MetricName: typing_extensions.TypeAlias'
  - signature: 'Threshold: typing_extensions.TypeAlias'
- rank: 678
  id: google.adk.evaluation.eval_metrics.BaseCriterion
  name: BaseCriterion
  file_path: src/google/adk/evaluation/eval_metrics.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Base criterion to use for an Eval Metric.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, threshold: google.adk.evaluation.eval_metrics.Threshold):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'threshold: google.adk.evaluation.eval_metrics.Threshold'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 679
  id: google.adk.evaluation.eval_metrics.EvalMetric
  name: EvalMetric
  file_path: src/google/adk/evaluation/eval_metrics.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A metric used to evaluate a particular aspect of an eval case.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, metric_name: str, threshold: typing.Optional[float] = None, criterion: typing.Optional[google.adk.evaluation.eval_metrics.BaseCriterion] = None, custom_function_path: typing.Optional[str] = None):'
  properties:
  - signature: 'metric_name: str'
  - signature: 'threshold: typing.Optional[float]'
  - signature: 'criterion: typing.Optional[google.adk.evaluation.eval_metrics.BaseCriterion]'
  - signature: 'custom_function_path: typing.Optional[str]'
  inherited_properties:
    EvalBaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 680
  id: google.adk.evaluation.eval_metrics.EvalMetricResult
  name: EvalMetricResult
  file_path: src/google/adk/evaluation/eval_metrics.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'The actual computed score/value of a particular EvalMetric.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, metric_name: str, threshold: typing.Optional[float] = None, criterion: typing.Optional[google.adk.evaluation.eval_metrics.BaseCriterion] = None, custom_function_path: typing.Optional[str] = None, score: typing.Optional[float] = None, eval_status: google.adk.evaluation.eval_metrics.EvalStatus, details: google.adk.evaluation.eval_metrics.EvalMetricResultDetails = Factory(EvalMetricResultDetails)):'
  properties:
  - signature: 'score: typing.Optional[float]'
  - signature: 'eval_status: google.adk.evaluation.eval_metrics.EvalStatus'
  - signature: 'details: google.adk.evaluation.eval_metrics.EvalMetricResultDetails'
  inherited_properties:
    EvalMetric:
    - signature: 'metric_name: str'
    - signature: 'threshold: typing.Optional[float]'
    - signature: 'criterion: typing.Optional[google.adk.evaluation.eval_metrics.BaseCriterion]'
    - signature: 'custom_function_path: typing.Optional[str]'
    EvalBaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 681
  id: google.adk.evaluation.eval_metrics.EvalMetricResultDetails
  name: EvalMetricResultDetails
  file_path: src/google/adk/evaluation/eval_metrics.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, rubric_scores: typing.Optional[list[google.adk.evaluation.eval_rubrics.RubricScore]] = None):'
  properties:
  - signature: 'rubric_scores: typing.Optional[list[google.adk.evaluation.eval_rubrics.RubricScore]]'
  inherited_properties:
    EvalBaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 682
  id: google.adk.evaluation.eval_metrics.EvalMetricResultPerInvocation
  name: EvalMetricResultPerInvocation
  file_path: src/google/adk/evaluation/eval_metrics.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Eval metric results per invocation.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, actual_invocation: google.adk.evaluation.eval_case.Invocation, expected_invocation: typing.Optional[google.adk.evaluation.eval_case.Invocation] = None, eval_metric_results: list[google.adk.evaluation.eval_metrics.EvalMetricResult] = []):'
  properties:
  - signature: 'actual_invocation: google.adk.evaluation.eval_case.Invocation'
  - signature: 'expected_invocation: typing.Optional[google.adk.evaluation.eval_case.Invocation]'
  - signature: 'eval_metric_results: list[google.adk.evaluation.eval_metrics.EvalMetricResult]'
  inherited_properties:
    EvalBaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 683
  id: google.adk.evaluation.eval_metrics.EvalStatus
  name: EvalStatus
  file_path: src/google/adk/evaluation/eval_metrics.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from Enum are omitted.]'
  properties:
  - signature: 'PASSED: int'
  - signature: 'FAILED: int'
  - signature: 'NOT_EVALUATED: int'
  omitted_inherited_members_from:
  - Enum
- rank: 684
  id: google.adk.evaluation.eval_metrics.HallucinationsCriterion
  name: HallucinationsCriterion
  file_path: src/google/adk/evaluation/eval_metrics.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Criterion to use when evaluating agents response for hallucinations.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, threshold: google.adk.evaluation.eval_metrics.Threshold, judge_model_options: google.adk.evaluation.eval_metrics.JudgeModelOptions = Factory(JudgeModelOptions), evaluate_intermediate_nl_responses: bool = False):'
  properties:
  - signature: 'judge_model_options: google.adk.evaluation.eval_metrics.JudgeModelOptions'
  - signature: 'evaluate_intermediate_nl_responses: bool'
  inherited_properties:
    BaseCriterion:
    - signature: 'model_config: pydantic.ConfigDict'
    - signature: 'threshold: google.adk.evaluation.eval_metrics.Threshold'
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 685
  id: google.adk.evaluation.eval_metrics.Interval
  name: Interval
  file_path: src/google/adk/evaluation/eval_metrics.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Represents a range of numeric values, e.g. [0 ,1] or (2,3) or [-1, 6).


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, min_value: float, open_at_min: bool = False, max_value: float, open_at_max: bool = False):'
  properties:
  - signature: 'min_value: float'
  - signature: 'open_at_min: bool'
  - signature: 'max_value: float'
  - signature: 'open_at_max: bool'
  inherited_properties:
    EvalBaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 686
  id: google.adk.evaluation.eval_metrics.JudgeModelOptions
  name: JudgeModelOptions
  file_path: src/google/adk/evaluation/eval_metrics.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Options for an eval metric''s judge model.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, judge_model: str = ''gemini-2.5-flash'', judge_model_config: pydantic.json_schema.SkipJsonSchema[typing.Optional[google.genai.types.GenerateContentConfig]] = None, num_samples: int = 5):'
  properties:
  - signature: 'judge_model: str'
  - signature: 'judge_model_config: pydantic.json_schema.SkipJsonSchema[typing.Optional[google.genai.types.GenerateContentConfig]]'
  - signature: 'num_samples: int'
  inherited_properties:
    EvalBaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 687
  id: google.adk.evaluation.eval_metrics.LlmAsAJudgeCriterion
  name: LlmAsAJudgeCriterion
  file_path: src/google/adk/evaluation/eval_metrics.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Criterion when using LLM-As-A-Judge metric.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, threshold: google.adk.evaluation.eval_metrics.Threshold, judge_model_options: google.adk.evaluation.eval_metrics.JudgeModelOptions = Factory(JudgeModelOptions)):'
  properties:
  - signature: 'judge_model_options: google.adk.evaluation.eval_metrics.JudgeModelOptions'
  inherited_properties:
    BaseCriterion:
    - signature: 'model_config: pydantic.ConfigDict'
    - signature: 'threshold: google.adk.evaluation.eval_metrics.Threshold'
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 688
  id: google.adk.evaluation.eval_metrics.LlmBackedUserSimulatorCriterion
  name: LlmBackedUserSimulatorCriterion
  file_path: src/google/adk/evaluation/eval_metrics.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Criterion for LLM-backed User Simulator Evaluators.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, threshold: google.adk.evaluation.eval_metrics.Threshold, judge_model_options: google.adk.evaluation.eval_metrics.JudgeModelOptions = Factory(JudgeModelOptions), stop_signal: str = ''</finished>''):'
  properties:
  - signature: 'stop_signal: str'
  inherited_properties:
    LlmAsAJudgeCriterion:
    - signature: 'judge_model_options: google.adk.evaluation.eval_metrics.JudgeModelOptions'
    BaseCriterion:
    - signature: 'model_config: pydantic.ConfigDict'
    - signature: 'threshold: google.adk.evaluation.eval_metrics.Threshold'
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 689
  id: google.adk.evaluation.eval_metrics.MatchType
  name: MatchType
  file_path: src/google/adk/evaluation/eval_metrics.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'The type of Match between actual and expected tool call trajectories.


    [Note: Inherited members from Enum are omitted.]'
  properties:
  - signature: 'EXACT: int'
    docstring: Requires a perfect match between the actual and expected tool calls.
  - signature: 'IN_ORDER: int'
    docstring: "Requires the actual tool calls to be in the same order as expected tools,\nwith allowance for extra tool calls to have happened.\n\nThis criteria is useful in assuring if certain key actions/tool calls\noccur and in certain order, leaving some scope for other tools calls to\nhappen as well.\n\nExample 1: Set of actual vs expected tool calls that satisfies the criteria:\n\n  Expected tools calls: [T1, T2, T3]\n  Actual tool calls: [T1, T1.1, T2, T2.1, T2.2, T3, T3.1]\n\n  This satisfies, as the tools T1, T2 and T3 happened in the \"Actual\" and in\n  the same order.\n\nExample 2: Set of actual vs expected tool calls that don't satisfy the\ncriteria:\n\n  Expected tools calls: [T1, T2, T3, T4]\n  Actual tool calls: [T1, T1.1, T2, T2.1, T2.2, T3, T3.1]\n\n  While the tool calls T1, T2 and T3 happened in the \"Actual\" and in\n  the same order as \"Expected\", but the tool calls T4 is missing."
  - signature: 'ANY_ORDER: int'
    docstring: "Requires the actual tool calls to be in the any order as expected tools,\nwith allowance for extra tool calls to have happened.\n\nThis criteria is helpful for cases where multiple tool calls about the same\nconcept occur, like your agent issues 5 search queries. You don't really\ncare the order in which the search queries are issues, till they occur.\n\nExample 1: Set of actual vs expected tool calls that satisfies the criteria:\n\n  Expected tools calls: [T1, T2, T3]\n  Actual tool calls: [T2, T2.1, T1, T1.1, T1.2, T3, T3.1]\n\n  This satisfies, as the tools T1, T2 and T3 happened in the \"Actual\" and\n  are also present in expected. Note that the order is different.\n\nExample 2: Set of actual vs expected tool calls that don't satisfy the\ncriteria:\n\n  Expected tools calls: [T1, T2, T3, T4]\n  Actual tool calls: [T1, T1.1, T2, T2.1, T2.2, T3, T3.1]\n\n  While the tool calls T1, T2 and T3 happened in the \"Actual\" and in\n  the same order as \"Expected\", but the tool\
      \ calls T4 is missing."
  omitted_inherited_members_from:
  - Enum
- rank: 690
  id: google.adk.evaluation.eval_metrics.MetricInfo
  name: MetricInfo
  file_path: src/google/adk/evaluation/eval_metrics.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Information about the metric that are used for Evals.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, metric_name: str, description: str = None, metric_value_info: google.adk.evaluation.eval_metrics.MetricValueInfo):'
  properties:
  - signature: 'metric_name: str'
  - signature: 'description: str'
  - signature: 'metric_value_info: google.adk.evaluation.eval_metrics.MetricValueInfo'
  inherited_properties:
    EvalBaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 691
  id: google.adk.evaluation.eval_metrics.MetricInfoProvider
  name: MetricInfoProvider
  file_path: src/google/adk/evaluation/eval_metrics.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Interface for providing MetricInfo.


    [Note: Inherited members from abc.ABC are omitted.]'
  methods:
  - signature: 'def get_metric_info(self) -> google.adk.evaluation.eval_metrics.MetricInfo:'
    docstring: Returns MetricInfo for a given metric.
  omitted_inherited_members_from:
  - abc.ABC
- rank: 692
  id: google.adk.evaluation.eval_metrics.MetricValueInfo
  name: MetricValueInfo
  file_path: src/google/adk/evaluation/eval_metrics.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Information about the type of metric value.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, interval: typing.Optional[google.adk.evaluation.eval_metrics.Interval] = None):'
  properties:
  - signature: 'interval: typing.Optional[google.adk.evaluation.eval_metrics.Interval]'
  inherited_properties:
    EvalBaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 693
  id: google.adk.evaluation.eval_metrics.PrebuiltMetrics
  name: PrebuiltMetrics
  file_path: src/google/adk/evaluation/eval_metrics.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from Enum are omitted.]'
  properties:
  - signature: 'TOOL_TRAJECTORY_AVG_SCORE: str'
  - signature: 'RESPONSE_EVALUATION_SCORE: str'
  - signature: 'RESPONSE_MATCH_SCORE: str'
  - signature: 'SAFETY_V1: str'
  - signature: 'FINAL_RESPONSE_MATCH_V2: str'
  - signature: 'RUBRIC_BASED_FINAL_RESPONSE_QUALITY_V1: str'
  - signature: 'HALLUCINATIONS_V1: str'
  - signature: 'RUBRIC_BASED_TOOL_USE_QUALITY_V1: str'
  - signature: 'PER_TURN_USER_SIMULATOR_QUALITY_V1: str'
  omitted_inherited_members_from:
  - Enum
- rank: 694
  id: google.adk.evaluation.eval_metrics.RubricsBasedCriterion
  name: RubricsBasedCriterion
  file_path: src/google/adk/evaluation/eval_metrics.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Criterion when using a rubric based metric.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, threshold: google.adk.evaluation.eval_metrics.Threshold, judge_model_options: google.adk.evaluation.eval_metrics.JudgeModelOptions = Factory(JudgeModelOptions), rubrics: list[google.adk.evaluation.eval_rubrics.Rubric] = list()):'
  properties:
  - signature: 'judge_model_options: google.adk.evaluation.eval_metrics.JudgeModelOptions'
  - signature: 'rubrics: list[google.adk.evaluation.eval_rubrics.Rubric]'
  inherited_properties:
    BaseCriterion:
    - signature: 'model_config: pydantic.ConfigDict'
    - signature: 'threshold: google.adk.evaluation.eval_metrics.Threshold'
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 695
  id: google.adk.evaluation.eval_metrics.ToolTrajectoryCriterion
  name: ToolTrajectoryCriterion
  file_path: src/google/adk/evaluation/eval_metrics.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Criterion to use when evaluating agent''s tool trajectories with a reference one.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, threshold: google.adk.evaluation.eval_metrics.Threshold, match_type: MatchType = MatchType.EXACT):'
  properties:
  - signature: 'match_type: MatchType'
  inherited_properties:
    BaseCriterion:
    - signature: 'model_config: pydantic.ConfigDict'
    - signature: 'threshold: google.adk.evaluation.eval_metrics.Threshold'
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 696
  id: google.adk.evaluation.eval_result
  name: eval_result
  file_path: src/google/adk/evaluation/eval_result.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 697
  id: google.adk.evaluation.eval_result.EvalCaseResult
  name: EvalCaseResult
  file_path: src/google/adk/evaluation/eval_result.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Case level evaluation results.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, eval_set_file: typing.Optional[str] = None, eval_set_id: str = '''', eval_id: str = '''', final_eval_status: google.adk.evaluation.evaluator.EvalStatus, eval_metric_results: typing.Optional[list[tuple[google.adk.evaluation.eval_metrics.EvalMetric, google.adk.evaluation.eval_metrics.EvalMetricResult]]] = None, overall_eval_metric_results: list[google.adk.evaluation.eval_metrics.EvalMetricResult], eval_metric_result_per_invocation: list[google.adk.evaluation.eval_metrics.EvalMetricResultPerInvocation], session_id: str, session_details: typing.Optional[google.adk.sessions.session.Session] = None, user_id: typing.Optional[str] = None):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'eval_set_file: typing.Optional[str]'
  - signature: 'eval_set_id: str'
    docstring: The eval set id.
  - signature: 'eval_id: str'
    docstring: The eval case id.
  - signature: 'final_eval_status: google.adk.evaluation.evaluator.EvalStatus'
    docstring: Final eval status for this eval case.
  - signature: 'eval_metric_results: typing.Optional[list[tuple[google.adk.evaluation.eval_metrics.EvalMetric, google.adk.evaluation.eval_metrics.EvalMetricResult]]]'
  - signature: 'overall_eval_metric_results: list[google.adk.evaluation.eval_metrics.EvalMetricResult]'
    docstring: Overall result for each metric for the entire eval case.
  - signature: 'eval_metric_result_per_invocation: list[google.adk.evaluation.eval_metrics.EvalMetricResultPerInvocation]'
    docstring: Result for each metric on a per invocation basis.
  - signature: 'session_id: str'
    docstring: Session id of the session generated as result of inferencing/scraping stage of the eval.
  - signature: 'session_details: typing.Optional[google.adk.sessions.session.Session]'
    docstring: Session generated as result of inferencing/scraping stage of the eval.
  - signature: 'user_id: typing.Optional[str]'
    docstring: User id used during inferencing/scraping stage of the eval.
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 698
  id: google.adk.evaluation.eval_result.EvalSetResult
  name: EvalSetResult
  file_path: src/google/adk/evaluation/eval_result.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Eval set level evaluation results.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, eval_set_result_id: str, eval_set_result_name: typing.Optional[str] = None, eval_set_id: str, eval_case_results: list[google.adk.evaluation.eval_result.EvalCaseResult] = list(), creation_timestamp: float = 0.0):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'eval_set_result_id: str'
  - signature: 'eval_set_result_name: typing.Optional[str]'
  - signature: 'eval_set_id: str'
  - signature: 'eval_case_results: list[google.adk.evaluation.eval_result.EvalCaseResult]'
  - signature: 'creation_timestamp: float'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 699
  id: google.adk.evaluation.eval_rubrics
  name: eval_rubrics
  file_path: src/google/adk/evaluation/eval_rubrics.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 700
  id: google.adk.evaluation.eval_rubrics.Rubric
  name: Rubric
  file_path: src/google/adk/evaluation/eval_rubrics.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'This class represents a single Rubric.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, rubric_id: str, rubric_content: google.adk.evaluation.eval_rubrics.RubricContent, description: typing.Optional[str] = None, type: typing.Optional[str] = None):'
  properties:
  - signature: 'rubric_id: str'
  - signature: 'rubric_content: google.adk.evaluation.eval_rubrics.RubricContent'
  - signature: 'description: typing.Optional[str]'
  - signature: 'type: typing.Optional[str]'
  inherited_properties:
    EvalBaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 701
  id: google.adk.evaluation.eval_rubrics.RubricContent
  name: RubricContent
  file_path: src/google/adk/evaluation/eval_rubrics.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'The content of a rubric.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, text_property: typing.Optional[str]):'
  properties:
  - signature: 'text_property: typing.Optional[str]'
  inherited_properties:
    EvalBaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 702
  id: google.adk.evaluation.eval_rubrics.RubricScore
  name: RubricScore
  file_path: src/google/adk/evaluation/eval_rubrics.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'The score obtained after applying the rubric to the Agent''s response.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, rubric_id: str, rationale: typing.Optional[str] = None, score: typing.Optional[float] = None):'
  properties:
  - signature: 'rubric_id: str'
  - signature: 'rationale: typing.Optional[str]'
  - signature: 'score: typing.Optional[float]'
  inherited_properties:
    EvalBaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 703
  id: google.adk.evaluation.eval_set
  name: eval_set
  file_path: src/google/adk/evaluation/eval_set.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 704
  id: google.adk.evaluation.eval_set.EvalSet
  name: EvalSet
  file_path: src/google/adk/evaluation/eval_set.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A set of eval cases.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, eval_set_id: str, name: typing.Optional[str] = None, description: typing.Optional[str] = None, eval_cases: list[google.adk.evaluation.eval_case.EvalCase], creation_timestamp: float = 0.0):'
  properties:
  - signature: 'eval_set_id: str'
    docstring: Unique identifier for the eval set.
  - signature: 'name: typing.Optional[str]'
    docstring: Name of the dataset.
  - signature: 'description: typing.Optional[str]'
    docstring: Description of the dataset.
  - signature: 'eval_cases: list[google.adk.evaluation.eval_case.EvalCase]'
    docstring: 'List of eval cases in the dataset. Each case represents a single

      interaction to be evaluated.'
  - signature: 'creation_timestamp: float'
    docstring: The time at which this eval set was created.
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 705
  id: google.adk.evaluation.eval_set_results_manager
  name: eval_set_results_manager
  file_path: src/google/adk/evaluation/eval_set_results_manager.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 706
  id: google.adk.evaluation.eval_set_results_manager.EvalSetResultsManager
  name: EvalSetResultsManager
  file_path: src/google/adk/evaluation/eval_set_results_manager.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'An interface to manage Eval Set Results.


    [Note: Inherited members from ABC are omitted.]'
  methods:
  - signature: 'def save_eval_set_result(self, app_name: str, eval_set_id: str, eval_case_results: list[google.adk.evaluation.eval_result.EvalCaseResult]) -> None:'
    docstring: Creates and saves a new EvalSetResult given eval_case_results.
  - signature: 'def get_eval_set_result(self, app_name: str, eval_set_result_id: str) -> google.adk.evaluation.eval_result.EvalSetResult:'
    docstring: "Returns the EvalSetResult from app_name and eval_set_result_id.\n\nRaises:\n  NotFoundError: If the EvalSetResult is not found."
  - signature: 'def list_eval_set_results(self, app_name: str) -> list[str]:'
    docstring: Returns the eval result ids that belong to the given app_name.
  omitted_inherited_members_from:
  - ABC
- rank: 707
  id: google.adk.evaluation.eval_set_results_manager.EvalSetResultsManager.get_eval_set_result
  name: get_eval_set_result
  file_path: src/google/adk/evaluation/eval_set_results_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Returns the EvalSetResult from app_name and eval_set_result_id.\n\nRaises:\n  NotFoundError: If the EvalSetResult is not found."
  signature: 'def get_eval_set_result(self, app_name: str, eval_set_result_id: str) -> google.adk.evaluation.eval_result.EvalSetResult:'
- rank: 708
  id: google.adk.evaluation.eval_set_results_manager.EvalSetResultsManager.save_eval_set_result
  name: save_eval_set_result
  file_path: src/google/adk/evaluation/eval_set_results_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Creates and saves a new EvalSetResult given eval_case_results.
  signature: 'def save_eval_set_result(self, app_name: str, eval_set_id: str, eval_case_results: list[google.adk.evaluation.eval_result.EvalCaseResult]) -> None:'
- rank: 709
  id: google.adk.evaluation.eval_sets_manager
  name: eval_sets_manager
  file_path: src/google/adk/evaluation/eval_sets_manager.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 710
  id: google.adk.evaluation.eval_sets_manager.EvalSetsManager
  name: EvalSetsManager
  file_path: src/google/adk/evaluation/eval_sets_manager.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'An interface to manage Eval Sets.


    [Note: Inherited members from ABC are omitted.]'
  methods:
  - signature: 'def get_eval_set(self, app_name: str, eval_set_id: str) -> typing.Optional[google.adk.evaluation.eval_set.EvalSet]:'
    docstring: Returns an EvalSet identified by an app_name and eval_set_id.
  - signature: 'def create_eval_set(self, app_name: str, eval_set_id: str) -> google.adk.evaluation.eval_set.EvalSet:'
    docstring: "Creates and returns an empty EvalSet given the app_name and eval_set_id.\n\nRaises:\n  ValueError: If eval set id is not valid or an eval set already exists. A\n  valid eval set id is string that has one or more of following characters:\n    - Lower case characters\n    - Upper case characters\n    - 0-9\n    - Underscore"
  - signature: 'def list_eval_sets(self, app_name: str) -> list[str]:'
    docstring: "Returns a list of EvalSets that belong to the given app_name.\n\nRaises:\n  NotFoundError: If the app_name doesn't exist."
  - signature: 'def get_eval_case(self, app_name: str, eval_set_id: str, eval_case_id: str) -> typing.Optional[google.adk.evaluation.eval_case.EvalCase]:'
    docstring: Returns an EvalCase if found; otherwise, None.
  - signature: 'def add_eval_case(self, app_name: str, eval_set_id: str, eval_case: google.adk.evaluation.eval_case.EvalCase):'
    docstring: "Adds the given EvalCase to an existing EvalSet identified by app_name and eval_set_id.\n\nRaises:\n  NotFoundError: If the eval set is not found."
  - signature: 'def update_eval_case(self, app_name: str, eval_set_id: str, updated_eval_case: google.adk.evaluation.eval_case.EvalCase):'
    docstring: "Updates an existing EvalCase give the app_name and eval_set_id.\n\nRaises:\n  NotFoundError: If the eval set or the eval case is not found."
  - signature: 'def delete_eval_case(self, app_name: str, eval_set_id: str, eval_case_id: str):'
    docstring: "Deletes the given EvalCase identified by app_name, eval_set_id and eval_case_id.\n\nRaises:\n  NotFoundError: If the eval set or the eval case to delete is not found."
  omitted_inherited_members_from:
  - ABC
- rank: 711
  id: google.adk.evaluation.eval_sets_manager.EvalSetsManager.add_eval_case
  name: add_eval_case
  file_path: src/google/adk/evaluation/eval_sets_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Adds the given EvalCase to an existing EvalSet identified by app_name and eval_set_id.\n\nRaises:\n  NotFoundError: If the eval set is not found."
  signature: 'def add_eval_case(self, app_name: str, eval_set_id: str, eval_case: google.adk.evaluation.eval_case.EvalCase):'
- rank: 712
  id: google.adk.evaluation.eval_sets_manager.EvalSetsManager.create_eval_set
  name: create_eval_set
  file_path: src/google/adk/evaluation/eval_sets_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Creates and returns an empty EvalSet given the app_name and eval_set_id.\n\nRaises:\n  ValueError: If eval set id is not valid or an eval set already exists. A\n  valid eval set id is string that has one or more of following characters:\n    - Lower case characters\n    - Upper case characters\n    - 0-9\n    - Underscore"
  signature: 'def create_eval_set(self, app_name: str, eval_set_id: str) -> google.adk.evaluation.eval_set.EvalSet:'
- rank: 713
  id: google.adk.evaluation.eval_sets_manager.EvalSetsManager.delete_eval_case
  name: delete_eval_case
  file_path: src/google/adk/evaluation/eval_sets_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Deletes the given EvalCase identified by app_name, eval_set_id and eval_case_id.\n\nRaises:\n  NotFoundError: If the eval set or the eval case to delete is not found."
  signature: 'def delete_eval_case(self, app_name: str, eval_set_id: str, eval_case_id: str):'
- rank: 714
  id: google.adk.evaluation.eval_sets_manager.EvalSetsManager.get_eval_case
  name: get_eval_case
  file_path: src/google/adk/evaluation/eval_sets_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns an EvalCase if found; otherwise, None.
  signature: 'def get_eval_case(self, app_name: str, eval_set_id: str, eval_case_id: str) -> typing.Optional[google.adk.evaluation.eval_case.EvalCase]:'
- rank: 715
  id: google.adk.evaluation.eval_sets_manager.EvalSetsManager.list_eval_sets
  name: list_eval_sets
  file_path: src/google/adk/evaluation/eval_sets_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Returns a list of EvalSets that belong to the given app_name.\n\nRaises:\n  NotFoundError: If the app_name doesn't exist."
  signature: 'def list_eval_sets(self, app_name: str) -> list[str]:'
- rank: 716
  id: google.adk.evaluation.eval_sets_manager.EvalSetsManager.update_eval_case
  name: update_eval_case
  file_path: src/google/adk/evaluation/eval_sets_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Updates an existing EvalCase give the app_name and eval_set_id.\n\nRaises:\n  NotFoundError: If the eval set or the eval case is not found."
  signature: 'def update_eval_case(self, app_name: str, eval_set_id: str, updated_eval_case: google.adk.evaluation.eval_case.EvalCase):'
- rank: 717
  id: google.adk.evaluation.evaluation_constants
  name: evaluation_constants
  file_path: src/google/adk/evaluation/evaluation_constants.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 718
  id: google.adk.evaluation.evaluation_constants.EvalConstants
  name: EvalConstants
  file_path: src/google/adk/evaluation/evaluation_constants.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Holds constants for evaluation file constants.
  properties:
  - signature: 'QUERY: str'
  - signature: 'EXPECTED_TOOL_USE: str'
  - signature: 'RESPONSE: str'
  - signature: 'REFERENCE: str'
  - signature: 'TOOL_NAME: str'
  - signature: 'TOOL_INPUT: str'
  - signature: 'MOCK_TOOL_OUTPUT: str'
- rank: 719
  id: google.adk.evaluation.evaluation_generator
  name: evaluation_generator
  file_path: src/google/adk/evaluation/evaluation_generator.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '_USER_AUTHOR: str'
  - signature: '_DEFAULT_AUTHOR: str'
- rank: 720
  id: google.adk.evaluation.evaluation_generator.EvalCaseResponses
  name: EvalCaseResponses
  file_path: src/google/adk/evaluation/evaluation_generator.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Contains multiple responses associated with an EvalCase.


    Multiple responses are a result of repeated requests to generate inferences.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, eval_case: google.adk.evaluation.eval_case.EvalCase, responses: list[list[google.adk.evaluation.eval_case.Invocation]]):'
  properties:
  - signature: 'eval_case: google.adk.evaluation.eval_case.EvalCase'
  - signature: 'responses: list[list[google.adk.evaluation.eval_case.Invocation]]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 721
  id: google.adk.evaluation.evaluation_generator.EvaluationGenerator
  name: EvaluationGenerator
  file_path: src/google/adk/evaluation/evaluation_generator.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Generates evaluation responses for agents.
  methods:
  - signature: 'def generate_responses(eval_set: google.adk.evaluation.eval_set.EvalSet, agent_module_path: str, repeat_num: int, agent_name: str) -> list[google.adk.evaluation.evaluation_generator.EvalCaseResponses]:'
    docstring: "Returns evaluation responses for the given dataset and agent.\n\nArgs:\n  eval_set: The eval set that needs to be scraped for responses.\n  agent_module_path: Path to the module that contains the root agent.\n  repeat_num: Number of time the eval dataset should be repeated. This is\n    usually done to remove uncertainty that a single run may bring.\n  agent_name: The name of the agent that should be evaluated. This is\n    usually the sub-agent."
  - signature: 'def generate_responses_from_session(session_path, eval_dataset):'
    docstring: "Returns evaluation responses by combining session data with eval data.\n\nArgs:\n  session_path: Path to a json file that contains session data.\n  eval_dataset: The eval data set that should be combined with the session\n    data."
  - signature: 'def convert_events_to_eval_invocations(events: list[google.adk.events.event.Event], app_details_per_invocation: typing.Optional[dict[str, google.adk.evaluation.app_details.AppDetails]]) -> list[google.adk.evaluation.eval_case.Invocation]:'
    docstring: Converts a list of events to eval invocations.
- rank: 722
  id: google.adk.evaluation.evaluation_generator.EvaluationGenerator.convert_events_to_eval_invocations
  name: convert_events_to_eval_invocations
  file_path: src/google/adk/evaluation/evaluation_generator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Converts a list of events to eval invocations.
  signature: 'def convert_events_to_eval_invocations(events: list[google.adk.events.event.Event], app_details_per_invocation: typing.Optional[dict[str, google.adk.evaluation.app_details.AppDetails]]) -> list[google.adk.evaluation.eval_case.Invocation]:'
- rank: 723
  id: google.adk.evaluation.evaluation_generator.EvaluationGenerator.generate_responses
  name: generate_responses
  file_path: src/google/adk/evaluation/evaluation_generator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Returns evaluation responses for the given dataset and agent.\n\nArgs:\n  eval_set: The eval set that needs to be scraped for responses.\n  agent_module_path: Path to the module that contains the root agent.\n  repeat_num: Number of time the eval dataset should be repeated. This is\n    usually done to remove uncertainty that a single run may bring.\n  agent_name: The name of the agent that should be evaluated. This is\n    usually the sub-agent."
  signature: 'def generate_responses(eval_set: google.adk.evaluation.eval_set.EvalSet, agent_module_path: str, repeat_num: int, agent_name: str) -> list[google.adk.evaluation.evaluation_generator.EvalCaseResponses]:'
- rank: 724
  id: google.adk.evaluation.evaluation_generator.EvaluationGenerator.generate_responses_from_session
  name: generate_responses_from_session
  file_path: src/google/adk/evaluation/evaluation_generator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Returns evaluation responses by combining session data with eval data.\n\nArgs:\n  session_path: Path to a json file that contains session data.\n  eval_dataset: The eval data set that should be combined with the session\n    data."
  signature: 'def generate_responses_from_session(session_path, eval_dataset):'
- rank: 725
  id: google.adk.evaluation.evaluator
  name: evaluator
  file_path: src/google/adk/evaluation/evaluator.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'EvalStatus: typing_extensions.TypeAlias'
- rank: 726
  id: google.adk.evaluation.evaluator.EvaluationResult
  name: EvaluationResult
  file_path: src/google/adk/evaluation/evaluator.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, overall_score: typing.Optional[float] = None, overall_eval_status: google.adk.evaluation.eval_metrics.EvalStatus = EvalStatus.NOT_EVALUATED, per_invocation_results: list[google.adk.evaluation.evaluator.PerInvocationResult] = [], overall_rubric_scores: typing.Optional[list[google.adk.evaluation.eval_rubrics.RubricScore]] = None):'
  properties:
  - signature: 'overall_score: typing.Optional[float]'
    docstring: Overall score, based on each invocation.
  - signature: 'overall_eval_status: google.adk.evaluation.eval_metrics.EvalStatus'
    docstring: Overall status, based on each invocation.
  - signature: 'per_invocation_results: list[google.adk.evaluation.evaluator.PerInvocationResult]'
    docstring: Detailed results per invocation.
  - signature: 'overall_rubric_scores: typing.Optional[list[google.adk.evaluation.eval_rubrics.RubricScore]]'
    docstring: Overall rubric, based on each invocation.
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 727
  id: google.adk.evaluation.evaluator.Evaluator
  name: Evaluator
  file_path: src/google/adk/evaluation/evaluator.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A metrics evaluator interface.


    [Note: Inherited members from ABC are omitted.]'
  methods:
  - signature: 'def evaluate_invocations(self, actual_invocations: list[google.adk.evaluation.eval_case.Invocation], expected_invocations: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]], conversation_scenario: typing.Optional[google.adk.evaluation.eval_case.ConversationScenario]) -> google.adk.evaluation.evaluator.EvaluationResult:'
    docstring: "Returns EvaluationResult after performing evaluations using actual and expected invocations.\n\nArgs:\n  actual_invocations: These are the invocations that are obtained from the\n    agent under test.\n  expected_invocations: An optional list of invocations, if specified,\n    usually act as a benchmark/golden response. If these are specified\n    usually the expectation is that the length of this list and actual\n    invocation is the same.\n  conversation_scenario: An optional conversation scenario for multi-turn\n    conversations."
  properties:
  - signature: 'criterion_type: typing.ClassVar[type[google.adk.evaluation.eval_metrics.BaseCriterion]]'
  omitted_inherited_members_from:
  - ABC
- rank: 728
  id: google.adk.evaluation.evaluator.Evaluator.evaluate_invocations
  name: evaluate_invocations
  file_path: src/google/adk/evaluation/evaluator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Returns EvaluationResult after performing evaluations using actual and expected invocations.\n\nArgs:\n  actual_invocations: These are the invocations that are obtained from the\n    agent under test.\n  expected_invocations: An optional list of invocations, if specified,\n    usually act as a benchmark/golden response. If these are specified\n    usually the expectation is that the length of this list and actual\n    invocation is the same.\n  conversation_scenario: An optional conversation scenario for multi-turn\n    conversations."
  signature: 'def evaluate_invocations(self, actual_invocations: list[google.adk.evaluation.eval_case.Invocation], expected_invocations: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]], conversation_scenario: typing.Optional[google.adk.evaluation.eval_case.ConversationScenario]) -> google.adk.evaluation.evaluator.EvaluationResult:'
- rank: 729
  id: google.adk.evaluation.evaluator.PerInvocationResult
  name: PerInvocationResult
  file_path: src/google/adk/evaluation/evaluator.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Metric evaluation score per invocation.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, actual_invocation: google.adk.evaluation.eval_case.Invocation, expected_invocation: typing.Optional[google.adk.evaluation.eval_case.Invocation] = None, score: typing.Optional[float] = None, eval_status: google.adk.evaluation.eval_metrics.EvalStatus = EvalStatus.NOT_EVALUATED, rubric_scores: typing.Optional[list[google.adk.evaluation.eval_rubrics.RubricScore]] = None):'
  properties:
  - signature: 'actual_invocation: google.adk.evaluation.eval_case.Invocation'
  - signature: 'expected_invocation: typing.Optional[google.adk.evaluation.eval_case.Invocation]'
  - signature: 'score: typing.Optional[float]'
  - signature: 'eval_status: google.adk.evaluation.eval_metrics.EvalStatus'
  - signature: 'rubric_scores: typing.Optional[list[google.adk.evaluation.eval_rubrics.RubricScore]]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 730
  id: google.adk.evaluation.final_response_match_v1
  name: final_response_match_v1
  file_path: src/google/adk/evaluation/final_response_match_v1.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 731
  id: google.adk.evaluation.final_response_match_v1.RougeEvaluator
  name: RougeEvaluator
  file_path: src/google/adk/evaluation/final_response_match_v1.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Evaluates if agent''s final response matches a golden/expected final response using Rouge_1 metric.


    Value range for this metric is [0,1], with values closer to 1 more desirable.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, eval_metric: google.adk.evaluation.eval_metrics.EvalMetric):'
  methods:
  - signature: 'def evaluate_invocations(self, actual_invocations: list[google.adk.evaluation.eval_case.Invocation], expected_invocations: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]], conversation_scenario: typing.Optional[google.adk.evaluation.eval_case.ConversationScenario]) -> google.adk.evaluation.evaluator.EvaluationResult:'
  inherited_methods:
    Evaluator:
    - signature: 'def evaluate_invocations(self, actual_invocations: list[google.adk.evaluation.eval_case.Invocation], expected_invocations: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]], conversation_scenario: typing.Optional[google.adk.evaluation.eval_case.ConversationScenario]) -> google.adk.evaluation.evaluator.EvaluationResult:'
      docstring: "Returns EvaluationResult after performing evaluations using actual and expected invocations.\n\nArgs:\n  actual_invocations: These are the invocations that are obtained from the\n    agent under test.\n  expected_invocations: An optional list of invocations, if specified,\n    usually act as a benchmark/golden response. If these are specified\n    usually the expectation is that the length of this list and actual\n    invocation is the same.\n  conversation_scenario: An optional conversation scenario for multi-turn\n    conversations."
  inherited_properties:
    Evaluator:
    - signature: 'criterion_type: typing.ClassVar[type[google.adk.evaluation.eval_metrics.BaseCriterion]]'
  omitted_inherited_members_from:
  - ABC
- rank: 732
  id: google.adk.evaluation.final_response_match_v1.RougeEvaluator.evaluate_invocations
  name: evaluate_invocations
  file_path: src/google/adk/evaluation/final_response_match_v1.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def evaluate_invocations(self, actual_invocations: list[google.adk.evaluation.eval_case.Invocation], expected_invocations: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]], conversation_scenario: typing.Optional[google.adk.evaluation.eval_case.ConversationScenario]) -> google.adk.evaluation.evaluator.EvaluationResult:'
- rank: 733
  id: google.adk.evaluation.final_response_match_v2
  name: final_response_match_v2
  file_path: src/google/adk/evaluation/final_response_match_v2.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '_FINAL_RESPONSE_MATCH_V2_PROMPT: str'
- rank: 734
  id: google.adk.evaluation.final_response_match_v2.FinalResponseMatchV2Evaluator
  name: FinalResponseMatchV2Evaluator
  file_path: src/google/adk/evaluation/final_response_match_v2.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'V2 final response match evaluator which uses an LLM to judge responses.


    The evaluator prompts the LLM to output whether the agent final response is

    valid or invalid, hence outputs a score of 0 or 1. Repeated invocation samples

    are aggregated by taking majority vote, and then the overall score is the

    fraction, ranging from 0 to 1, of valid samples. Higher values of overall

    score indicate better final response performance of the agent.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, eval_metric: google.adk.evaluation.eval_metrics.EvalMetric):'
  methods:
  - signature: 'def format_auto_rater_prompt(self, actual_invocation: google.adk.evaluation.eval_case.Invocation, expected_invocation: typing.Optional[google.adk.evaluation.eval_case.Invocation]) -> str:'
  - signature: 'def convert_auto_rater_response_to_score(self, llm_response: google.adk.models.llm_response.LlmResponse) -> google.adk.evaluation.llm_as_judge.AutoRaterScore:'
  - signature: 'def aggregate_per_invocation_samples(self, per_invocation_samples: list[google.adk.evaluation.evaluator.PerInvocationResult]) -> google.adk.evaluation.evaluator.PerInvocationResult:'
    docstring: "Aggregates samples of per-invocation results by taking majority vote.\n\nOnly consider results that were successfully evaluated. In the case of a\ntie, consider the result to be invalid.\n\nArgs:\n  per_invocation_samples: Samples of per-invocation results to aggregate.\n\nReturns:\n  If there is a majority of valid results, return the first valid result.\n  Otherwise, return the first invalid result. If no results were\n  successfully evaluated, return the first sample."
  - signature: 'def aggregate_invocation_results(self, per_invocation_results: list[google.adk.evaluation.evaluator.PerInvocationResult]) -> google.adk.evaluation.evaluator.EvaluationResult:'
    docstring: Computes the fraction of invocation results that are valid.
  properties:
  - signature: 'criterion_type: typing.ClassVar[type[google.adk.evaluation.eval_metrics.LlmAsAJudgeCriterion]]'
  inherited_methods:
    LlmAsJudge:
    - signature: 'def format_auto_rater_prompt(self, actual: google.adk.evaluation.eval_case.Invocation, expected: typing.Optional[google.adk.evaluation.eval_case.Invocation]) -> str:'
      docstring: Formats the auto-rater prompt to evaluate the given invocation.
    - signature: 'def convert_auto_rater_response_to_score(self, auto_rater_response: google.adk.models.llm_response.LlmResponse) -> google.adk.evaluation.llm_as_judge.AutoRaterScore:'
      docstring: Parses auto_rater_response and returns the corresponding score, or None if the score cannot be determined.
    - signature: 'def aggregate_per_invocation_samples(self, per_invocation_samples: list[google.adk.evaluation.evaluator.PerInvocationResult]) -> google.adk.evaluation.evaluator.PerInvocationResult:'
      docstring: Aggregates repeated per-invocation samples to get the final result for the invocation.
    - signature: 'def aggregate_invocation_results(self, per_invocation_results: list[google.adk.evaluation.evaluator.PerInvocationResult]) -> google.adk.evaluation.evaluator.EvaluationResult:'
      docstring: Aggregates the per invocation results to get the overall score.
    - signature: 'def evaluate_invocations(self, actual_invocations: list[google.adk.evaluation.eval_case.Invocation], expected_invocations: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]], conversation_scenario: typing.Optional[google.adk.evaluation.eval_case.ConversationScenario]) -> google.adk.evaluation.evaluator.EvaluationResult:'
    Evaluator:
    - signature: 'def evaluate_invocations(self, actual_invocations: list[google.adk.evaluation.eval_case.Invocation], expected_invocations: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]], conversation_scenario: typing.Optional[google.adk.evaluation.eval_case.ConversationScenario]) -> google.adk.evaluation.evaluator.EvaluationResult:'
      docstring: "Returns EvaluationResult after performing evaluations using actual and expected invocations.\n\nArgs:\n  actual_invocations: These are the invocations that are obtained from the\n    agent under test.\n  expected_invocations: An optional list of invocations, if specified,\n    usually act as a benchmark/golden response. If these are specified\n    usually the expectation is that the length of this list and actual\n    invocation is the same.\n  conversation_scenario: An optional conversation scenario for multi-turn\n    conversations."
  inherited_properties:
    Evaluator:
    - signature: 'criterion_type: typing.ClassVar[type[google.adk.evaluation.eval_metrics.BaseCriterion]]'
  omitted_inherited_members_from:
  - ABC
- rank: 735
  id: google.adk.evaluation.final_response_match_v2.FinalResponseMatchV2Evaluator.__init__
  name: __init__
  file_path: src/google/adk/evaluation/final_response_match_v2.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, eval_metric: google.adk.evaluation.eval_metrics.EvalMetric):'
- rank: 736
  id: google.adk.evaluation.final_response_match_v2.FinalResponseMatchV2Evaluator.aggregate_invocation_results
  name: aggregate_invocation_results
  file_path: src/google/adk/evaluation/final_response_match_v2.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Computes the fraction of invocation results that are valid.
  signature: 'def aggregate_invocation_results(self, per_invocation_results: list[google.adk.evaluation.evaluator.PerInvocationResult]) -> google.adk.evaluation.evaluator.EvaluationResult:'
- rank: 737
  id: google.adk.evaluation.final_response_match_v2.FinalResponseMatchV2Evaluator.aggregate_per_invocation_samples
  name: aggregate_per_invocation_samples
  file_path: src/google/adk/evaluation/final_response_match_v2.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Aggregates samples of per-invocation results by taking majority vote.\n\nOnly consider results that were successfully evaluated. In the case of a\ntie, consider the result to be invalid.\n\nArgs:\n  per_invocation_samples: Samples of per-invocation results to aggregate.\n\nReturns:\n  If there is a majority of valid results, return the first valid result.\n  Otherwise, return the first invalid result. If no results were\n  successfully evaluated, return the first sample."
  signature: 'def aggregate_per_invocation_samples(self, per_invocation_samples: list[google.adk.evaluation.evaluator.PerInvocationResult]) -> google.adk.evaluation.evaluator.PerInvocationResult:'
- rank: 738
  id: google.adk.evaluation.final_response_match_v2.FinalResponseMatchV2Evaluator.convert_auto_rater_response_to_score
  name: convert_auto_rater_response_to_score
  file_path: src/google/adk/evaluation/final_response_match_v2.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def convert_auto_rater_response_to_score(self, llm_response: google.adk.models.llm_response.LlmResponse) -> google.adk.evaluation.llm_as_judge.AutoRaterScore:'
- rank: 739
  id: google.adk.evaluation.final_response_match_v2.FinalResponseMatchV2Evaluator.format_auto_rater_prompt
  name: format_auto_rater_prompt
  file_path: src/google/adk/evaluation/final_response_match_v2.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def format_auto_rater_prompt(self, actual_invocation: google.adk.evaluation.eval_case.Invocation, expected_invocation: typing.Optional[google.adk.evaluation.eval_case.Invocation]) -> str:'
- rank: 740
  id: google.adk.evaluation.gcs_eval_set_results_manager
  name: gcs_eval_set_results_manager
  file_path: src/google/adk/evaluation/gcs_eval_set_results_manager.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '_EVAL_HISTORY_DIR: str'
  - signature: '_EVAL_SET_RESULT_FILE_EXTENSION: str'
- rank: 741
  id: google.adk.evaluation.gcs_eval_set_results_manager.GcsEvalSetResultsManager
  name: GcsEvalSetResultsManager
  file_path: src/google/adk/evaluation/gcs_eval_set_results_manager.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'An EvalSetResultsManager that stores eval results in a GCS bucket.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, bucket_name: str):'
  methods:
  - signature: 'def save_eval_set_result(self, app_name: str, eval_set_id: str, eval_case_results: list[google.adk.evaluation.eval_result.EvalCaseResult]) -> None:'
    docstring: Creates and saves a new EvalSetResult given eval_case_results.
  - signature: 'def get_eval_set_result(self, app_name: str, eval_set_result_id: str) -> google.adk.evaluation.eval_result.EvalSetResult:'
    docstring: Returns an EvalSetResult from app_name and eval_set_result_id.
  - signature: 'def list_eval_set_results(self, app_name: str) -> list[str]:'
    docstring: Returns the eval result ids that belong to the given app_name.
  inherited_methods:
    EvalSetResultsManager:
    - signature: 'def save_eval_set_result(self, app_name: str, eval_set_id: str, eval_case_results: list[google.adk.evaluation.eval_result.EvalCaseResult]) -> None:'
      docstring: Creates and saves a new EvalSetResult given eval_case_results.
    - signature: 'def get_eval_set_result(self, app_name: str, eval_set_result_id: str) -> google.adk.evaluation.eval_result.EvalSetResult:'
      docstring: "Returns the EvalSetResult from app_name and eval_set_result_id.\n\nRaises:\n  NotFoundError: If the EvalSetResult is not found."
    - signature: 'def list_eval_set_results(self, app_name: str) -> list[str]:'
      docstring: Returns the eval result ids that belong to the given app_name.
  omitted_inherited_members_from:
  - ABC
- rank: 742
  id: google.adk.evaluation.gcs_eval_set_results_manager.GcsEvalSetResultsManager.__init__
  name: __init__
  file_path: src/google/adk/evaluation/gcs_eval_set_results_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the GcsEvalSetsManager.\n\nArgs:\n    bucket_name: The name of the bucket to use.\n    **kwargs: Keyword arguments to pass to the Google Cloud Storage client."
  signature: 'def __init__(self, bucket_name: str):'
- rank: 743
  id: google.adk.evaluation.gcs_eval_set_results_manager.GcsEvalSetResultsManager.get_eval_set_result
  name: get_eval_set_result
  file_path: src/google/adk/evaluation/gcs_eval_set_results_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns an EvalSetResult from app_name and eval_set_result_id.
  signature: 'def get_eval_set_result(self, app_name: str, eval_set_result_id: str) -> google.adk.evaluation.eval_result.EvalSetResult:'
- rank: 744
  id: google.adk.evaluation.gcs_eval_set_results_manager.GcsEvalSetResultsManager.list_eval_set_results
  name: list_eval_set_results
  file_path: src/google/adk/evaluation/gcs_eval_set_results_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns the eval result ids that belong to the given app_name.
  signature: 'def list_eval_set_results(self, app_name: str) -> list[str]:'
- rank: 745
  id: google.adk.evaluation.gcs_eval_set_results_manager.GcsEvalSetResultsManager.save_eval_set_result
  name: save_eval_set_result
  file_path: src/google/adk/evaluation/gcs_eval_set_results_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Creates and saves a new EvalSetResult given eval_case_results.
  signature: 'def save_eval_set_result(self, app_name: str, eval_set_id: str, eval_case_results: list[google.adk.evaluation.eval_result.EvalCaseResult]) -> None:'
- rank: 746
  id: google.adk.evaluation.gcs_eval_sets_manager
  name: gcs_eval_sets_manager
  file_path: src/google/adk/evaluation/gcs_eval_sets_manager.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '_EVAL_SETS_DIR: str'
  - signature: '_EVAL_SET_FILE_EXTENSION: str'
- rank: 747
  id: google.adk.evaluation.gcs_eval_sets_manager.GcsEvalSetsManager
  name: GcsEvalSetsManager
  file_path: src/google/adk/evaluation/gcs_eval_sets_manager.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'An EvalSetsManager that stores eval sets in a GCS bucket.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, bucket_name: str):'
  methods:
  - signature: 'def get_eval_set(self, app_name: str, eval_set_id: str) -> typing.Optional[google.adk.evaluation.eval_set.EvalSet]:'
    docstring: Returns an EvalSet identified by an app_name and eval_set_id.
  - signature: 'def create_eval_set(self, app_name: str, eval_set_id: str) -> google.adk.evaluation.eval_set.EvalSet:'
    docstring: "Creates an empty EvalSet and saves it to GCS.\n\nRaises:\n  ValueError: If Eval Set ID is not valid or an eval set already exists."
  - signature: 'def list_eval_sets(self, app_name: str) -> list[str]:'
    docstring: Returns a list of EvalSet ids that belong to the given app_name.
  - signature: 'def get_eval_case(self, app_name: str, eval_set_id: str, eval_case_id: str) -> typing.Optional[google.adk.evaluation.eval_case.EvalCase]:'
    docstring: Returns an EvalCase identified by an app_name, eval_set_id and eval_case_id.
  - signature: 'def add_eval_case(self, app_name: str, eval_set_id: str, eval_case: google.adk.evaluation.eval_case.EvalCase):'
    docstring: "Adds the given EvalCase to an existing EvalSet.\n\nArgs:\n  app_name: The name of the app.\n  eval_set_id: The id of the eval set containing the eval case to update.\n  eval_case: The EvalCase to add.\n\nRaises:\n  NotFoundError: If the eval set is not found.\n  ValueError: If the eval case already exists in the eval set."
  - signature: 'def update_eval_case(self, app_name: str, eval_set_id: str, updated_eval_case: google.adk.evaluation.eval_case.EvalCase):'
    docstring: "Updates an existing EvalCase.\n\nArgs:\n  app_name: The name of the app.\n  eval_set_id: The id of the eval set containing the eval case to update.\n  updated_eval_case: The updated EvalCase. Overwrites the existing EvalCase\n    using the eval_id field.\n\nRaises:\n  NotFoundError: If the eval set or the eval case is not found."
  - signature: 'def delete_eval_case(self, app_name: str, eval_set_id: str, eval_case_id: str):'
    docstring: "Deletes the EvalCase with the given eval_case_id from the given EvalSet.\n\nArgs:\n  app_name: The name of the app.\n  eval_set_id: The id of the eval set containing the eval case to delete.\n  eval_case_id: The id of the eval case to delete.\n\nRaises:\n  NotFoundError: If the eval set or the eval case to delete is not found."
  inherited_methods:
    EvalSetsManager:
    - signature: 'def get_eval_set(self, app_name: str, eval_set_id: str) -> typing.Optional[google.adk.evaluation.eval_set.EvalSet]:'
      docstring: Returns an EvalSet identified by an app_name and eval_set_id.
    - signature: 'def create_eval_set(self, app_name: str, eval_set_id: str) -> google.adk.evaluation.eval_set.EvalSet:'
      docstring: "Creates and returns an empty EvalSet given the app_name and eval_set_id.\n\nRaises:\n  ValueError: If eval set id is not valid or an eval set already exists. A\n  valid eval set id is string that has one or more of following characters:\n    - Lower case characters\n    - Upper case characters\n    - 0-9\n    - Underscore"
    - signature: 'def list_eval_sets(self, app_name: str) -> list[str]:'
      docstring: "Returns a list of EvalSets that belong to the given app_name.\n\nRaises:\n  NotFoundError: If the app_name doesn't exist."
    - signature: 'def get_eval_case(self, app_name: str, eval_set_id: str, eval_case_id: str) -> typing.Optional[google.adk.evaluation.eval_case.EvalCase]:'
      docstring: Returns an EvalCase if found; otherwise, None.
    - signature: 'def add_eval_case(self, app_name: str, eval_set_id: str, eval_case: google.adk.evaluation.eval_case.EvalCase):'
      docstring: "Adds the given EvalCase to an existing EvalSet identified by app_name and eval_set_id.\n\nRaises:\n  NotFoundError: If the eval set is not found."
    - signature: 'def update_eval_case(self, app_name: str, eval_set_id: str, updated_eval_case: google.adk.evaluation.eval_case.EvalCase):'
      docstring: "Updates an existing EvalCase give the app_name and eval_set_id.\n\nRaises:\n  NotFoundError: If the eval set or the eval case is not found."
    - signature: 'def delete_eval_case(self, app_name: str, eval_set_id: str, eval_case_id: str):'
      docstring: "Deletes the given EvalCase identified by app_name, eval_set_id and eval_case_id.\n\nRaises:\n  NotFoundError: If the eval set or the eval case to delete is not found."
  omitted_inherited_members_from:
  - ABC
- rank: 748
  id: google.adk.evaluation.gcs_eval_sets_manager.GcsEvalSetsManager.__init__
  name: __init__
  file_path: src/google/adk/evaluation/gcs_eval_sets_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the GcsEvalSetsManager.\n\nArgs:\n  bucket_name: The name of the bucket to use.\n  **kwargs: Keyword arguments to pass to the Google Cloud Storage client."
  signature: 'def __init__(self, bucket_name: str):'
- rank: 749
  id: google.adk.evaluation.gcs_eval_sets_manager.GcsEvalSetsManager.add_eval_case
  name: add_eval_case
  file_path: src/google/adk/evaluation/gcs_eval_sets_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Adds the given EvalCase to an existing EvalSet.\n\nArgs:\n  app_name: The name of the app.\n  eval_set_id: The id of the eval set containing the eval case to update.\n  eval_case: The EvalCase to add.\n\nRaises:\n  NotFoundError: If the eval set is not found.\n  ValueError: If the eval case already exists in the eval set."
  signature: 'def add_eval_case(self, app_name: str, eval_set_id: str, eval_case: google.adk.evaluation.eval_case.EvalCase):'
- rank: 750
  id: google.adk.evaluation.gcs_eval_sets_manager.GcsEvalSetsManager.create_eval_set
  name: create_eval_set
  file_path: src/google/adk/evaluation/gcs_eval_sets_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Creates an empty EvalSet and saves it to GCS.\n\nRaises:\n  ValueError: If Eval Set ID is not valid or an eval set already exists."
  signature: 'def create_eval_set(self, app_name: str, eval_set_id: str) -> google.adk.evaluation.eval_set.EvalSet:'
- rank: 751
  id: google.adk.evaluation.gcs_eval_sets_manager.GcsEvalSetsManager.delete_eval_case
  name: delete_eval_case
  file_path: src/google/adk/evaluation/gcs_eval_sets_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Deletes the EvalCase with the given eval_case_id from the given EvalSet.\n\nArgs:\n  app_name: The name of the app.\n  eval_set_id: The id of the eval set containing the eval case to delete.\n  eval_case_id: The id of the eval case to delete.\n\nRaises:\n  NotFoundError: If the eval set or the eval case to delete is not found."
  signature: 'def delete_eval_case(self, app_name: str, eval_set_id: str, eval_case_id: str):'
- rank: 752
  id: google.adk.evaluation.gcs_eval_sets_manager.GcsEvalSetsManager.get_eval_case
  name: get_eval_case
  file_path: src/google/adk/evaluation/gcs_eval_sets_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns an EvalCase identified by an app_name, eval_set_id and eval_case_id.
  signature: 'def get_eval_case(self, app_name: str, eval_set_id: str, eval_case_id: str) -> typing.Optional[google.adk.evaluation.eval_case.EvalCase]:'
- rank: 753
  id: google.adk.evaluation.gcs_eval_sets_manager.GcsEvalSetsManager.get_eval_set
  name: get_eval_set
  file_path: src/google/adk/evaluation/gcs_eval_sets_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns an EvalSet identified by an app_name and eval_set_id.
  signature: 'def get_eval_set(self, app_name: str, eval_set_id: str) -> typing.Optional[google.adk.evaluation.eval_set.EvalSet]:'
- rank: 754
  id: google.adk.evaluation.gcs_eval_sets_manager.GcsEvalSetsManager.list_eval_sets
  name: list_eval_sets
  file_path: src/google/adk/evaluation/gcs_eval_sets_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns a list of EvalSet ids that belong to the given app_name.
  signature: 'def list_eval_sets(self, app_name: str) -> list[str]:'
- rank: 755
  id: google.adk.evaluation.gcs_eval_sets_manager.GcsEvalSetsManager.update_eval_case
  name: update_eval_case
  file_path: src/google/adk/evaluation/gcs_eval_sets_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Updates an existing EvalCase.\n\nArgs:\n  app_name: The name of the app.\n  eval_set_id: The id of the eval set containing the eval case to update.\n  updated_eval_case: The updated EvalCase. Overwrites the existing EvalCase\n    using the eval_id field.\n\nRaises:\n  NotFoundError: If the eval set or the eval case is not found."
  signature: 'def update_eval_case(self, app_name: str, eval_set_id: str, updated_eval_case: google.adk.evaluation.eval_case.EvalCase):'
- rank: 756
  id: google.adk.evaluation.hallucinations_v1
  name: hallucinations_v1
  file_path: src/google/adk/evaluation/hallucinations_v1.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: "_HALLUCINATIONS_V1_SEGMENTER_PROMPT: \nYou are a helpful and harmless AI assistant. You will be provided with a model-generated response.\nYour task is to segment the provided response sentence by sentence so that we could analyze each sentence in the future.\n\n**Instructions:**\n1. Overall, you should decompose the whole provided response into individual sentences. You should make sure the output covers ALL the sentences in the provided response block.\n2. You should COPY each sentence as it is, WORD BY WORD. DO NOT modify the sentence or the surrounding punctuation.\n3. If there are bullet points in the response, you should segment each bullet point into DIFFERENT sentences. If one bullet point has sub bullet points, you should further decompose sub bullet points into DIFFERENT sentences.\nFor example, if there are responses like \"it has three criteria: * aaa. * bbb. * ccc\", you should segment them into FOUR sentences: \"it has three criteria\", \"aaa\", \"bbb\", \"\
      ccc\". Bullet points could start with numbers (1/2/3/etc) or symbols like \"*\", \"-\" etc.\n4. When encountering tables, you should include the whole table in ONE sentence output.\n5. Each sentence should be meaningful to further analyze on. DO NOT ONLY put symbols themselves into a sentence.\n6. You should ONLY output segmented sentences in the provided response. DO NOT make up any new sentences.\n\n**Input Format:**\n\nThe input will be the model-generated response:\n* **Response:** The model-generated response to be analyzed.\n\n**Output Format:**\n\nFor each decomposed sentence, wrap them with <sentence> and </sentence> like the following:\n<sentence>...</sentence>\n<sentence>...</sentence>\n\n**Example:**\n\n**Input:**\n\n**Response Begin**\nThere are three kinds of fruits:\n1. Apples are red.\n2. Bananas are green.\n3. Pears are purple.\n\nFor prices:\n* Bananas are cheaper than apples.\n\nEnjoy your fruit!\n**Response End**\n\n**Output:**\n<sentence>There are three kinds of\
      \ fruits:</sentence>\n<sentence>1. Apples are red.</sentence>\n<sentence>2. Bananas are green.</sentence>\n<sentence>3. Pears are purple.</sentence>\n<sentence>For prices:</sentence>\n<sentence>* Bananas are cheaper than apples.</sentence>\n<sentence>Enjoy your fruit!</sentence>\n\n**Now, given the following response, please segment the response into sentences:**\n\n**Input:**\n\n**Response Begin**\n{response}\n**Response End**\n\n**Your Sentence Segmentation Output:**\n.strip"
  - signature: "_HALLUCINATIONS_V1_VALIDATOR_PROMPT: \nYou are a helpful and harmless AI assistant. You will be provided with a textual context and sentences from a model-generated response.\nYour task is to analyze sentence by sentence and classify each sentence according to its relationship with the provided context.\n\n**Instructions:**\n\n1. **Read the textual context carefully.**\n2. **For each sentence, assign one of the following labels:**\n    * **`supported`**: The sentence is entailed by the given context. Provide a supporting excerpt from the context. The supporting except must *fully* entail the sentence.\n    * **`unsupported`**: The sentence is not entailed by the given context. No excerpt is needed for this label.\n    * **`contradictory`**: The sentence is falsified by the given context. Provide a contradicting excerpt from the context.\n    * **`disputed`**: The given context contains both supporting and contradicting information. Provide both supporting and contradicting\
      \ excerpt from the context.\n    * **`not_applicable`**: The sentence does not require factual attribution (e.g., opinions, planning steps, greetings, questions, disclaimers, mathematical calculation).\n3. **For each label, provide a short rationale explaining your decision.** The rationale should be separate from the excerpt.\n4. **Be very strict with your `supported`, `contradictory` and `disputed` decisions.** Unless you can find straightforward, indisputable evidence excepts *in the context* that a sentence is `supported`, `contradictory` or `disputed`, consider it `unsupported`.  You should not employ world knowledge unless it is truly trivial.\n5. \"tool_outputs\" blocks contain code execution results of the \"tool_code\" blocks immediately above them. If any sentence is based on \"tool_outputs\" results, first analyze if the corresponding \"tool_code\" is supported and if the results are error-free. Only if the \"tool_code\" block is supported, you can treat code execution results\
      \ as correct.\n6. If you need to cite multiple supporting excerpts, simply concatenate them. Excerpt could be summary from the context if it is too long.\n\n**Input Format:**\n\nThe input will consist of two parts, clearly separated:\n\n* **Context:**  The textual context used to generate the response.\n* **Sentences:** The sentences from the model-generated response to be analyzed. Each sentence will be wrapped in <sentence>...</sentence>.\n\n**Output Format:**\n\nFor each sentence, output a block of text with the following fields:\n\n* sentence: The sentence being analyzed. Please directly copy the sentence which is provided.\n* label: One of `supported`, `unsupported`, `contradictory`, `disputed` or `not_applicable`.\n* rationale: A brief explanation for the assessment\n* supporting_excerpt: A relevant excerpt from the context that supports the sentence. Only required for `supported` and `disputed` labels.\n* contradicting_excerpt: A relevant excerpt from the context that contradicts\
      \ with the sentence. Only required for `contradictory` and `disputed` labels.\n\n**Example:**\n\n**Input:**\n\n**Context Begin**\nApples are red fruits. Bananas are yellow fruits. Pears are purple fruits. Pears are blue fruits.\n**Context End**\n\n**Sentences Begin**\n<sentence>Apples are red.</sentence>\n<sentence>Bananas are green.</sentence>\n<sentence>Pears are purple.</sentence>\n<sentence>Bananas are cheaper than apples.</sentence>\n<sentence>Enjoy your fruit!</sentence>\n**Sentences End**\n\n**Output:**\nsentence: Apples are red.\nlabel: supported\nrationale: The context explicitly states that apples are red.\nsupporting_excerpt: Apples are red fruits.\ncontradicting_excerpt: null\n\nsentence: Bananas are green.\nlabel: contradictory\nrationale: The context states that bananas are yellow, not green.\nsupporting_excerpt: null\ncontradicting_excerpt: Bananas are yellow fruits.\n\nsentence: Pears are purple.\nlabel: disputed\nrationale: The context states that pears are purple\
      \ but it also states that pears are blue.\nsupporting_excerpt: Pears are purple fruits\ncontradicting_excerpt: Pears are blue fruits\n\nsentence: Bananas are cheaper than apples.\nlabel: unsupported\nrationale: The context does not mention the price of bananas or apples.\nsupporting_excerpt: null\ncontradicting_excerpt: null\n\nsentence: Enjoy your fruit!\nlabel: not_applicable\nrationale: This is a general expression and does not require factual attribution.\nsupporting_excerpt: null\ncontradicting_excerpt: null\n\n**Now, please analyze the following context and sentences:**\n\n**Input:**\n\n**Context Begin**\n{context}\n**Context End**\n\n**Sentences Begin**\n{sentences}\n**Sentences End**\n\n**Output:**\n.strip"
  - signature: '_POSITIVE_LABELS: frozenset'
  - signature: '_NEGATIVE_LABELS: frozenset'
- rank: 757
  id: google.adk.evaluation.hallucinations_v1.EvaluationStep
  name: EvaluationStep
  file_path: src/google/adk/evaluation/hallucinations_v1.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: The context and natural language response to be evaluated at a step.
  constructor_signature: 'def __init__(self, *, context: str, nl_response: str):'
  properties:
  - signature: 'context: str'
  - signature: 'nl_response: str'
- rank: 758
  id: google.adk.evaluation.hallucinations_v1.HallucinationsV1Evaluator
  name: HallucinationsV1Evaluator
  file_path: src/google/adk/evaluation/hallucinations_v1.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Evaluates whether a model response contains any false, contradictory, or unsupported claims.


    The metric follows a two-step process:

    1. Segmenter: Segments the agent response into individual sentences.

    2. Sentence Validator: Evaluates each segmented sentence against the provided

    context for grounding.


    The metric computes the Accuracy Score (AS): the percentage of sentences that

    are supported or not_applicable.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, eval_metric: google.adk.evaluation.eval_metrics.EvalMetric):'
  methods:
  - signature: 'def evaluate_invocations(self, actual_invocations: list[google.adk.evaluation.eval_case.Invocation], expected_invocations: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]], conversation_scenario: typing.Optional[google.adk.evaluation.eval_case.ConversationScenario]) -> google.adk.evaluation.evaluator.EvaluationResult:'
  properties:
  - signature: 'criterion_type: typing.ClassVar[type[google.adk.evaluation.eval_metrics.HallucinationsCriterion]]'
  inherited_methods:
    Evaluator:
    - signature: 'def evaluate_invocations(self, actual_invocations: list[google.adk.evaluation.eval_case.Invocation], expected_invocations: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]], conversation_scenario: typing.Optional[google.adk.evaluation.eval_case.ConversationScenario]) -> google.adk.evaluation.evaluator.EvaluationResult:'
      docstring: "Returns EvaluationResult after performing evaluations using actual and expected invocations.\n\nArgs:\n  actual_invocations: These are the invocations that are obtained from the\n    agent under test.\n  expected_invocations: An optional list of invocations, if specified,\n    usually act as a benchmark/golden response. If these are specified\n    usually the expectation is that the length of this list and actual\n    invocation is the same.\n  conversation_scenario: An optional conversation scenario for multi-turn\n    conversations."
  inherited_properties:
    Evaluator:
    - signature: 'criterion_type: typing.ClassVar[type[google.adk.evaluation.eval_metrics.BaseCriterion]]'
  omitted_inherited_members_from:
  - ABC
- rank: 759
  id: google.adk.evaluation.hallucinations_v1.HallucinationsV1Evaluator.__init__
  name: __init__
  file_path: src/google/adk/evaluation/hallucinations_v1.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, eval_metric: google.adk.evaluation.eval_metrics.EvalMetric):'
- rank: 760
  id: google.adk.evaluation.hallucinations_v1.HallucinationsV1Evaluator.evaluate_invocations
  name: evaluate_invocations
  file_path: src/google/adk/evaluation/hallucinations_v1.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def evaluate_invocations(self, actual_invocations: list[google.adk.evaluation.eval_case.Invocation], expected_invocations: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]], conversation_scenario: typing.Optional[google.adk.evaluation.eval_case.ConversationScenario]) -> google.adk.evaluation.evaluator.EvaluationResult:'
- rank: 761
  id: google.adk.evaluation.in_memory_eval_sets_manager
  name: in_memory_eval_sets_manager
  file_path: src/google/adk/evaluation/in_memory_eval_sets_manager.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 762
  id: google.adk.evaluation.in_memory_eval_sets_manager.InMemoryEvalSetsManager
  name: InMemoryEvalSetsManager
  file_path: src/google/adk/evaluation/in_memory_eval_sets_manager.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'An in-memory implementation of EvalSetsManager using dictionaries.


    You can use this class:

    1) As a part of your testcase.

    2) For cases where other implementations of EvalSetsManager are too expensive

    to use.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self):'
  methods:
  - signature: 'def get_eval_set(self, app_name: str, eval_set_id: str) -> typing.Optional[google.adk.evaluation.eval_set.EvalSet]:'
  - signature: 'def create_eval_set(self, app_name: str, eval_set_id: str):'
  - signature: 'def list_eval_sets(self, app_name: str) -> list[str]:'
  - signature: 'def get_eval_case(self, app_name: str, eval_set_id: str, eval_case_id: str) -> typing.Optional[google.adk.evaluation.eval_case.EvalCase]:'
  - signature: 'def add_eval_case(self, app_name: str, eval_set_id: str, eval_case: google.adk.evaluation.eval_case.EvalCase):'
  - signature: 'def update_eval_case(self, app_name: str, eval_set_id: str, updated_eval_case: google.adk.evaluation.eval_case.EvalCase):'
  - signature: 'def delete_eval_case(self, app_name: str, eval_set_id: str, eval_case_id: str):'
  inherited_methods:
    EvalSetsManager:
    - signature: 'def get_eval_set(self, app_name: str, eval_set_id: str) -> typing.Optional[google.adk.evaluation.eval_set.EvalSet]:'
      docstring: Returns an EvalSet identified by an app_name and eval_set_id.
    - signature: 'def create_eval_set(self, app_name: str, eval_set_id: str) -> google.adk.evaluation.eval_set.EvalSet:'
      docstring: "Creates and returns an empty EvalSet given the app_name and eval_set_id.\n\nRaises:\n  ValueError: If eval set id is not valid or an eval set already exists. A\n  valid eval set id is string that has one or more of following characters:\n    - Lower case characters\n    - Upper case characters\n    - 0-9\n    - Underscore"
    - signature: 'def list_eval_sets(self, app_name: str) -> list[str]:'
      docstring: "Returns a list of EvalSets that belong to the given app_name.\n\nRaises:\n  NotFoundError: If the app_name doesn't exist."
    - signature: 'def get_eval_case(self, app_name: str, eval_set_id: str, eval_case_id: str) -> typing.Optional[google.adk.evaluation.eval_case.EvalCase]:'
      docstring: Returns an EvalCase if found; otherwise, None.
    - signature: 'def add_eval_case(self, app_name: str, eval_set_id: str, eval_case: google.adk.evaluation.eval_case.EvalCase):'
      docstring: "Adds the given EvalCase to an existing EvalSet identified by app_name and eval_set_id.\n\nRaises:\n  NotFoundError: If the eval set is not found."
    - signature: 'def update_eval_case(self, app_name: str, eval_set_id: str, updated_eval_case: google.adk.evaluation.eval_case.EvalCase):'
      docstring: "Updates an existing EvalCase give the app_name and eval_set_id.\n\nRaises:\n  NotFoundError: If the eval set or the eval case is not found."
    - signature: 'def delete_eval_case(self, app_name: str, eval_set_id: str, eval_case_id: str):'
      docstring: "Deletes the given EvalCase identified by app_name, eval_set_id and eval_case_id.\n\nRaises:\n  NotFoundError: If the eval set or the eval case to delete is not found."
  omitted_inherited_members_from:
  - ABC
- rank: 763
  id: google.adk.evaluation.in_memory_eval_sets_manager.InMemoryEvalSetsManager.__init__
  name: __init__
  file_path: src/google/adk/evaluation/in_memory_eval_sets_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self):'
- rank: 764
  id: google.adk.evaluation.in_memory_eval_sets_manager.InMemoryEvalSetsManager.add_eval_case
  name: add_eval_case
  file_path: src/google/adk/evaluation/in_memory_eval_sets_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def add_eval_case(self, app_name: str, eval_set_id: str, eval_case: google.adk.evaluation.eval_case.EvalCase):'
- rank: 765
  id: google.adk.evaluation.in_memory_eval_sets_manager.InMemoryEvalSetsManager.create_eval_set
  name: create_eval_set
  file_path: src/google/adk/evaluation/in_memory_eval_sets_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def create_eval_set(self, app_name: str, eval_set_id: str):'
- rank: 766
  id: google.adk.evaluation.in_memory_eval_sets_manager.InMemoryEvalSetsManager.delete_eval_case
  name: delete_eval_case
  file_path: src/google/adk/evaluation/in_memory_eval_sets_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def delete_eval_case(self, app_name: str, eval_set_id: str, eval_case_id: str):'
- rank: 767
  id: google.adk.evaluation.in_memory_eval_sets_manager.InMemoryEvalSetsManager.get_eval_case
  name: get_eval_case
  file_path: src/google/adk/evaluation/in_memory_eval_sets_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_eval_case(self, app_name: str, eval_set_id: str, eval_case_id: str) -> typing.Optional[google.adk.evaluation.eval_case.EvalCase]:'
- rank: 768
  id: google.adk.evaluation.in_memory_eval_sets_manager.InMemoryEvalSetsManager.list_eval_sets
  name: list_eval_sets
  file_path: src/google/adk/evaluation/in_memory_eval_sets_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def list_eval_sets(self, app_name: str) -> list[str]:'
- rank: 769
  id: google.adk.evaluation.in_memory_eval_sets_manager.InMemoryEvalSetsManager.update_eval_case
  name: update_eval_case
  file_path: src/google/adk/evaluation/in_memory_eval_sets_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def update_eval_case(self, app_name: str, eval_set_id: str, updated_eval_case: google.adk.evaluation.eval_case.EvalCase):'
- rank: 770
  id: google.adk.evaluation.llm_as_judge
  name: llm_as_judge
  file_path: src/google/adk/evaluation/llm_as_judge.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 771
  id: google.adk.evaluation.llm_as_judge.AutoRaterScore
  name: AutoRaterScore
  file_path: src/google/adk/evaluation/llm_as_judge.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, score: typing.Optional[float] = None, rubric_scores: typing.Optional[list[google.adk.evaluation.eval_metrics.RubricScore]] = None):'
  properties:
  - signature: 'score: typing.Optional[float]'
  - signature: 'rubric_scores: typing.Optional[list[google.adk.evaluation.eval_metrics.RubricScore]]'
  inherited_properties:
    EvalBaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 772
  id: google.adk.evaluation.llm_as_judge.LlmAsJudge
  name: LlmAsJudge
  file_path: src/google/adk/evaluation/llm_as_judge.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "Evaluator based on a LLM.\n\nIt is meant to be extended by specific auto-raters for different evaluation\ntasks:\n  - Provide the prompt template, and implement format_auto_rater_prompt to\n    format the auto-rater prompt for a given invocation.\n  - Implement convert_auto_rater_response_to_score to parse the auto-rater\n    response and return the corresponding score.\n  - Implement aggregate_invocation_results to aggregate the per-invocation\n    results to get the overall score.\n  - (Optional) Override aggregate_per_invocation_result_samples to aggregate\n    multiple auto-rater samples of the same invocation.\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, eval_metric: google.adk.evaluation.eval_metrics.EvalMetric, criterion_type: type[google.adk.evaluation.eval_metrics.BaseCriterion], expected_invocations_required):'
  methods:
  - signature: 'def format_auto_rater_prompt(self, actual: google.adk.evaluation.eval_case.Invocation, expected: typing.Optional[google.adk.evaluation.eval_case.Invocation]) -> str:'
    docstring: Formats the auto-rater prompt to evaluate the given invocation.
  - signature: 'def convert_auto_rater_response_to_score(self, auto_rater_response: google.adk.models.llm_response.LlmResponse) -> google.adk.evaluation.llm_as_judge.AutoRaterScore:'
    docstring: Parses auto_rater_response and returns the corresponding score, or None if the score cannot be determined.
  - signature: 'def aggregate_per_invocation_samples(self, per_invocation_samples: list[google.adk.evaluation.evaluator.PerInvocationResult]) -> google.adk.evaluation.evaluator.PerInvocationResult:'
    docstring: Aggregates repeated per-invocation samples to get the final result for the invocation.
  - signature: 'def aggregate_invocation_results(self, per_invocation_results: list[google.adk.evaluation.evaluator.PerInvocationResult]) -> google.adk.evaluation.evaluator.EvaluationResult:'
    docstring: Aggregates the per invocation results to get the overall score.
  - signature: 'def evaluate_invocations(self, actual_invocations: list[google.adk.evaluation.eval_case.Invocation], expected_invocations: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]], conversation_scenario: typing.Optional[google.adk.evaluation.eval_case.ConversationScenario]) -> google.adk.evaluation.evaluator.EvaluationResult:'
  inherited_methods:
    Evaluator:
    - signature: 'def evaluate_invocations(self, actual_invocations: list[google.adk.evaluation.eval_case.Invocation], expected_invocations: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]], conversation_scenario: typing.Optional[google.adk.evaluation.eval_case.ConversationScenario]) -> google.adk.evaluation.evaluator.EvaluationResult:'
      docstring: "Returns EvaluationResult after performing evaluations using actual and expected invocations.\n\nArgs:\n  actual_invocations: These are the invocations that are obtained from the\n    agent under test.\n  expected_invocations: An optional list of invocations, if specified,\n    usually act as a benchmark/golden response. If these are specified\n    usually the expectation is that the length of this list and actual\n    invocation is the same.\n  conversation_scenario: An optional conversation scenario for multi-turn\n    conversations."
  inherited_properties:
    Evaluator:
    - signature: 'criterion_type: typing.ClassVar[type[google.adk.evaluation.eval_metrics.BaseCriterion]]'
  omitted_inherited_members_from:
  - ABC
- rank: 773
  id: google.adk.evaluation.llm_as_judge.LlmAsJudge.__init__
  name: __init__
  file_path: src/google/adk/evaluation/llm_as_judge.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, eval_metric: google.adk.evaluation.eval_metrics.EvalMetric, criterion_type: type[google.adk.evaluation.eval_metrics.BaseCriterion], expected_invocations_required):'
- rank: 774
  id: google.adk.evaluation.llm_as_judge.LlmAsJudge.aggregate_invocation_results
  name: aggregate_invocation_results
  file_path: src/google/adk/evaluation/llm_as_judge.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Aggregates the per invocation results to get the overall score.
  signature: 'def aggregate_invocation_results(self, per_invocation_results: list[google.adk.evaluation.evaluator.PerInvocationResult]) -> google.adk.evaluation.evaluator.EvaluationResult:'
- rank: 775
  id: google.adk.evaluation.llm_as_judge.LlmAsJudge.aggregate_per_invocation_samples
  name: aggregate_per_invocation_samples
  file_path: src/google/adk/evaluation/llm_as_judge.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Aggregates repeated per-invocation samples to get the final result for the invocation.
  signature: 'def aggregate_per_invocation_samples(self, per_invocation_samples: list[google.adk.evaluation.evaluator.PerInvocationResult]) -> google.adk.evaluation.evaluator.PerInvocationResult:'
- rank: 776
  id: google.adk.evaluation.llm_as_judge.LlmAsJudge.convert_auto_rater_response_to_score
  name: convert_auto_rater_response_to_score
  file_path: src/google/adk/evaluation/llm_as_judge.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Parses auto_rater_response and returns the corresponding score, or None if the score cannot be determined.
  signature: 'def convert_auto_rater_response_to_score(self, auto_rater_response: google.adk.models.llm_response.LlmResponse) -> google.adk.evaluation.llm_as_judge.AutoRaterScore:'
- rank: 777
  id: google.adk.evaluation.llm_as_judge.LlmAsJudge.evaluate_invocations
  name: evaluate_invocations
  file_path: src/google/adk/evaluation/llm_as_judge.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def evaluate_invocations(self, actual_invocations: list[google.adk.evaluation.eval_case.Invocation], expected_invocations: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]], conversation_scenario: typing.Optional[google.adk.evaluation.eval_case.ConversationScenario]) -> google.adk.evaluation.evaluator.EvaluationResult:'
- rank: 778
  id: google.adk.evaluation.llm_as_judge.LlmAsJudge.format_auto_rater_prompt
  name: format_auto_rater_prompt
  file_path: src/google/adk/evaluation/llm_as_judge.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Formats the auto-rater prompt to evaluate the given invocation.
  signature: 'def format_auto_rater_prompt(self, actual: google.adk.evaluation.eval_case.Invocation, expected: typing.Optional[google.adk.evaluation.eval_case.Invocation]) -> str:'
- rank: 779
  id: google.adk.evaluation.llm_as_judge_utils
  name: llm_as_judge_utils
  file_path: src/google/adk/evaluation/llm_as_judge_utils.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def get_text_from_content(content: typing.Optional[google.genai.types.Content]) -> typing.Optional[str]:'
  - signature: 'def get_eval_status(score: typing.Optional[float], threshold: float) -> google.adk.evaluation.evaluator.EvalStatus:'
  - signature: 'def get_average_rubric_score(rubric_scores: list[google.adk.evaluation.eval_metrics.RubricScore]) -> typing.Optional[float]:'
    docstring: 'Returns a single score value from the given list of rubric scores.


      It is possible that none of the rubric score actually contain a score value,

      if that happens then None is returned.


      If non-zero score values are present, then a mean value is returned as the

      aggregated value.'
  - signature: 'def get_tool_declarations_as_json_str(app_details: google.adk.evaluation.app_details.AppDetails) -> str:'
    docstring: 'Returns a JSON string representation of Tool declarations.


      The output of this method is usually intended to be sent to the LLM.'
  - signature: 'def get_tool_calls_and_responses_as_json_str(intermediate_data: typing.Optional[google.adk.evaluation.eval_case.IntermediateDataType]) -> str:'
    docstring: 'Returns a JSON string representation of tool calls and corresponding responses.


      The output of this method is usually intended to be sent to the LLM.'
- rank: 780
  id: google.adk.evaluation.llm_as_judge_utils.Label
  name: Label
  file_path: src/google/adk/evaluation/llm_as_judge_utils.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Labels for auto rater response.


    [Note: Inherited members from enum.Enum are omitted.]'
  properties:
  - signature: 'TRUE: str'
  - signature: 'INVALID: str'
  - signature: 'VALID: str'
  - signature: 'PARTIALLY_VALID: Any'
  - signature: 'ALMOST: str'
  - signature: 'FALSE: str'
  - signature: 'NOT_FOUND: str'
  omitted_inherited_members_from:
  - enum.Enum
- rank: 781
  id: google.adk.evaluation.llm_as_judge_utils.get_average_rubric_score
  name: get_average_rubric_score
  file_path: src/google/adk/evaluation/llm_as_judge_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Returns a single score value from the given list of rubric scores.


    It is possible that none of the rubric score actually contain a score value,

    if that happens then None is returned.


    If non-zero score values are present, then a mean value is returned as the

    aggregated value.'
  signature: 'def get_average_rubric_score(rubric_scores: list[google.adk.evaluation.eval_metrics.RubricScore]) -> typing.Optional[float]:'
- rank: 782
  id: google.adk.evaluation.llm_as_judge_utils.get_eval_status
  name: get_eval_status
  file_path: src/google/adk/evaluation/llm_as_judge_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_eval_status(score: typing.Optional[float], threshold: float) -> google.adk.evaluation.evaluator.EvalStatus:'
- rank: 783
  id: google.adk.evaluation.llm_as_judge_utils.get_text_from_content
  name: get_text_from_content
  file_path: src/google/adk/evaluation/llm_as_judge_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_text_from_content(content: typing.Optional[google.genai.types.Content]) -> typing.Optional[str]:'
- rank: 784
  id: google.adk.evaluation.llm_as_judge_utils.get_tool_calls_and_responses_as_json_str
  name: get_tool_calls_and_responses_as_json_str
  file_path: src/google/adk/evaluation/llm_as_judge_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Returns a JSON string representation of tool calls and corresponding responses.


    The output of this method is usually intended to be sent to the LLM.'
  signature: 'def get_tool_calls_and_responses_as_json_str(intermediate_data: typing.Optional[google.adk.evaluation.eval_case.IntermediateDataType]) -> str:'
- rank: 785
  id: google.adk.evaluation.llm_as_judge_utils.get_tool_declarations_as_json_str
  name: get_tool_declarations_as_json_str
  file_path: src/google/adk/evaluation/llm_as_judge_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Returns a JSON string representation of Tool declarations.


    The output of this method is usually intended to be sent to the LLM.'
  signature: 'def get_tool_declarations_as_json_str(app_details: google.adk.evaluation.app_details.AppDetails) -> str:'
- rank: 786
  id: google.adk.evaluation.local_eval_service
  name: local_eval_service
  file_path: src/google/adk/evaluation/local_eval_service.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: 'EVAL_SESSION_ID_PREFIX: str'
- rank: 787
  id: google.adk.evaluation.local_eval_service.LocalEvalService
  name: LocalEvalService
  file_path: src/google/adk/evaluation/local_eval_service.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'An implementation of BaseEvalService, that runs the evals locally.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, root_agent: google.adk.agents.base_agent.BaseAgent, eval_sets_manager: google.adk.evaluation.eval_sets_manager.EvalSetsManager, metric_evaluator_registry: typing.Optional[google.adk.evaluation.metric_evaluator_registry.MetricEvaluatorRegistry], session_service: typing.Optional[google.adk.sessions.base_session_service.BaseSessionService], artifact_service: typing.Optional[google.adk.artifacts.base_artifact_service.BaseArtifactService], eval_set_results_manager: typing.Optional[google.adk.evaluation.eval_set_results_manager.EvalSetResultsManager], session_id_supplier: typing.Callable[[], str], user_simulator_provider: google.adk.evaluation.simulation.user_simulator_provider.UserSimulatorProvider, memory_service: typing.Optional[google.adk.memory.base_memory_service.BaseMemoryService]):'
  methods:
  - signature: 'def perform_inference(self, inference_request: google.adk.evaluation.base_eval_service.InferenceRequest) -> typing.AsyncGenerator[google.adk.evaluation.base_eval_service.InferenceResult, None]:'
    docstring: "Returns InferenceResult obtained from the Agent as and when they are available.\n\nArgs:\n  inference_request: The request for generating inferences."
  - signature: 'def evaluate(self, evaluate_request: google.adk.evaluation.base_eval_service.EvaluateRequest) -> typing.AsyncGenerator[google.adk.evaluation.eval_result.EvalCaseResult, None]:'
    docstring: "Returns EvalCaseResult for each item as and when they are available.\n\nArgs:\n  evaluate_request: The request to perform metric evaluations on the\n    inferences."
  inherited_methods:
    BaseEvalService:
    - signature: 'def perform_inference(self, inference_request: google.adk.evaluation.base_eval_service.InferenceRequest) -> typing.AsyncGenerator[google.adk.evaluation.base_eval_service.InferenceResult, None]:'
      docstring: "Returns InferenceResult obtained from the Agent as and when they are available.\n\nArgs:\n  inference_request: The request for generating inferences."
    - signature: 'def evaluate(self, evaluate_request: google.adk.evaluation.base_eval_service.EvaluateRequest) -> typing.AsyncGenerator[google.adk.evaluation.eval_result.EvalCaseResult, None]:'
      docstring: "Returns EvalCaseResult for each item as and when they are available.\n\nArgs:\n  evaluate_request: The request to perform metric evaluations on the\n    inferences."
  omitted_inherited_members_from:
  - ABC
- rank: 788
  id: google.adk.evaluation.local_eval_service.LocalEvalService.__init__
  name: __init__
  file_path: src/google/adk/evaluation/local_eval_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, root_agent: google.adk.agents.base_agent.BaseAgent, eval_sets_manager: google.adk.evaluation.eval_sets_manager.EvalSetsManager, metric_evaluator_registry: typing.Optional[google.adk.evaluation.metric_evaluator_registry.MetricEvaluatorRegistry], session_service: typing.Optional[google.adk.sessions.base_session_service.BaseSessionService], artifact_service: typing.Optional[google.adk.artifacts.base_artifact_service.BaseArtifactService], eval_set_results_manager: typing.Optional[google.adk.evaluation.eval_set_results_manager.EvalSetResultsManager], session_id_supplier: typing.Callable[[], str], user_simulator_provider: google.adk.evaluation.simulation.user_simulator_provider.UserSimulatorProvider, memory_service: typing.Optional[google.adk.memory.base_memory_service.BaseMemoryService]):'
- rank: 789
  id: google.adk.evaluation.local_eval_service.LocalEvalService.evaluate
  name: evaluate
  file_path: src/google/adk/evaluation/local_eval_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Returns EvalCaseResult for each item as and when they are available.\n\nArgs:\n  evaluate_request: The request to perform metric evaluations on the\n    inferences."
  signature: 'def evaluate(self, evaluate_request: google.adk.evaluation.base_eval_service.EvaluateRequest) -> typing.AsyncGenerator[google.adk.evaluation.eval_result.EvalCaseResult, None]:'
- rank: 790
  id: google.adk.evaluation.local_eval_service.LocalEvalService.perform_inference
  name: perform_inference
  file_path: src/google/adk/evaluation/local_eval_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Returns InferenceResult obtained from the Agent as and when they are available.\n\nArgs:\n  inference_request: The request for generating inferences."
  signature: 'def perform_inference(self, inference_request: google.adk.evaluation.base_eval_service.InferenceRequest) -> typing.AsyncGenerator[google.adk.evaluation.base_eval_service.InferenceResult, None]:'
- rank: 791
  id: google.adk.evaluation.local_eval_set_results_manager
  name: local_eval_set_results_manager
  file_path: src/google/adk/evaluation/local_eval_set_results_manager.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '_ADK_EVAL_HISTORY_DIR: str'
  - signature: '_EVAL_SET_RESULT_FILE_EXTENSION: str'
- rank: 792
  id: google.adk.evaluation.local_eval_set_results_manager.LocalEvalSetResultsManager
  name: LocalEvalSetResultsManager
  file_path: src/google/adk/evaluation/local_eval_set_results_manager.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'An EvalSetResult manager that stores eval set results locally on disk.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, agents_dir: str):'
  methods:
  - signature: 'def save_eval_set_result(self, app_name: str, eval_set_id: str, eval_case_results: list[google.adk.evaluation.eval_result.EvalCaseResult]) -> None:'
    docstring: Creates and saves a new EvalSetResult given eval_case_results.
  - signature: 'def get_eval_set_result(self, app_name: str, eval_set_result_id: str) -> google.adk.evaluation.eval_result.EvalSetResult:'
    docstring: Returns an EvalSetResult identified by app_name and eval_set_result_id.
  - signature: 'def list_eval_set_results(self, app_name: str) -> list[str]:'
    docstring: Returns the eval result ids that belong to the given app_name.
  inherited_methods:
    EvalSetResultsManager:
    - signature: 'def save_eval_set_result(self, app_name: str, eval_set_id: str, eval_case_results: list[google.adk.evaluation.eval_result.EvalCaseResult]) -> None:'
      docstring: Creates and saves a new EvalSetResult given eval_case_results.
    - signature: 'def get_eval_set_result(self, app_name: str, eval_set_result_id: str) -> google.adk.evaluation.eval_result.EvalSetResult:'
      docstring: "Returns the EvalSetResult from app_name and eval_set_result_id.\n\nRaises:\n  NotFoundError: If the EvalSetResult is not found."
    - signature: 'def list_eval_set_results(self, app_name: str) -> list[str]:'
      docstring: Returns the eval result ids that belong to the given app_name.
  omitted_inherited_members_from:
  - ABC
- rank: 793
  id: google.adk.evaluation.local_eval_set_results_manager.LocalEvalSetResultsManager.get_eval_set_result
  name: get_eval_set_result
  file_path: src/google/adk/evaluation/local_eval_set_results_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns an EvalSetResult identified by app_name and eval_set_result_id.
  signature: 'def get_eval_set_result(self, app_name: str, eval_set_result_id: str) -> google.adk.evaluation.eval_result.EvalSetResult:'
- rank: 794
  id: google.adk.evaluation.local_eval_set_results_manager.LocalEvalSetResultsManager.list_eval_set_results
  name: list_eval_set_results
  file_path: src/google/adk/evaluation/local_eval_set_results_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns the eval result ids that belong to the given app_name.
  signature: 'def list_eval_set_results(self, app_name: str) -> list[str]:'
- rank: 795
  id: google.adk.evaluation.local_eval_set_results_manager.LocalEvalSetResultsManager.save_eval_set_result
  name: save_eval_set_result
  file_path: src/google/adk/evaluation/local_eval_set_results_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Creates and saves a new EvalSetResult given eval_case_results.
  signature: 'def save_eval_set_result(self, app_name: str, eval_set_id: str, eval_case_results: list[google.adk.evaluation.eval_result.EvalCaseResult]) -> None:'
- rank: 796
  id: google.adk.evaluation.local_eval_sets_manager
  name: local_eval_sets_manager
  file_path: src/google/adk/evaluation/local_eval_sets_manager.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def convert_eval_set_to_pydantic_schema(eval_set_id: str, eval_set_in_json_format: list[dict[str, typing.Any]]) -> google.adk.evaluation.eval_set.EvalSet:'
    docstring: "Returns a pydantic EvalSet generated from the json representation.\n\n  Args:\n    eval_set_id: Eval set id.\n    eval_set_in_json_format: Eval set specified in JSON format.\n\n  Here is a sample eval set in JSON format:\n[\n  {\n    \"name\": \"roll_17_sided_dice_twice\",\n    \"data\": [\n      {\n        \"query\": \"What can you do?\",\n        \"expected_tool_use\": [],\n        \"expected_intermediate_agent_responses\": [],\n        \"reference\": \"I can roll dice of different sizes and check if a number\n          is prime. I can also use multiple tools in parallel.\\n\"\n      },\n      {\n        \"query\": \"Roll a 17 sided dice twice for me\",\n        \"expected_tool_use\": [\n          {\n            \"tool_name\": \"roll_die\",\n            \"tool_input\": {\n              \"sides\": 17\n            }\n          },\n          {\n            \"tool_name\": \"roll_die\",\n            \"tool_input\": {\n              \"sides\": 17\n            }\n          }\n\
      \        ],\n        \"expected_intermediate_agent_responses\": [],\n        \"reference\": \"I have rolled a 17 sided die twice. The first roll was\n          13 and the second roll was 4.\\n\"\n      }\n    ],\n    \"initial_session\": {\n      \"state\": {},\n      \"app_name\": \"hello_world\",\n      \"user_id\": \"user\"\n    }\n  }\n]"
  - signature: 'def load_eval_set_from_file(eval_set_file_path: str, eval_set_id: str) -> google.adk.evaluation.eval_set.EvalSet:'
    docstring: Returns an EvalSet that is read from the given file.
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '_EVAL_SET_FILE_EXTENSION: str'
- rank: 797
  id: google.adk.evaluation.local_eval_sets_manager.LocalEvalSetsManager
  name: LocalEvalSetsManager
  file_path: src/google/adk/evaluation/local_eval_sets_manager.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'An EvalSets manager that stores eval sets locally on disk.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, agents_dir: str):'
  methods:
  - signature: 'def get_eval_set(self, app_name: str, eval_set_id: str) -> typing.Optional[google.adk.evaluation.eval_set.EvalSet]:'
    docstring: Returns an EvalSet identified by an app_name and eval_set_id.
  - signature: 'def create_eval_set(self, app_name: str, eval_set_id: str) -> google.adk.evaluation.eval_set.EvalSet:'
    docstring: "Creates and returns an empty EvalSet given the app_name and eval_set_id.\n\nRaises:\n  ValueError: If Eval Set ID is not valid or an eval set already exists."
  - signature: 'def list_eval_sets(self, app_name: str) -> list[str]:'
    docstring: "Returns a list of EvalSets that belong to the given app_name.\n\nArgs:\n  app_name: The app name to list the eval sets for.\n\nReturns:\n  A list of EvalSet ids.\n\nRaises:\n  NotFoundError: If the eval directory for the app is not found."
  - signature: 'def get_eval_case(self, app_name: str, eval_set_id: str, eval_case_id: str) -> typing.Optional[google.adk.evaluation.eval_case.EvalCase]:'
    docstring: Returns an EvalCase if found; otherwise, None.
  - signature: 'def add_eval_case(self, app_name: str, eval_set_id: str, eval_case: google.adk.evaluation.eval_case.EvalCase):'
    docstring: "Adds the given EvalCase to an existing EvalSet identified by app_name and eval_set_id.\n\nRaises:\n  NotFoundError: If the eval set is not found."
  - signature: 'def update_eval_case(self, app_name: str, eval_set_id: str, updated_eval_case: google.adk.evaluation.eval_case.EvalCase):'
    docstring: "Updates an existing EvalCase give the app_name and eval_set_id.\n\nRaises:\n  NotFoundError: If the eval set or the eval case is not found."
  - signature: 'def delete_eval_case(self, app_name: str, eval_set_id: str, eval_case_id: str):'
    docstring: "Deletes the given EvalCase identified by app_name, eval_set_id and eval_case_id.\n\nRaises:\n  NotFoundError: If the eval set or the eval case to delete is not found."
  inherited_methods:
    EvalSetsManager:
    - signature: 'def get_eval_set(self, app_name: str, eval_set_id: str) -> typing.Optional[google.adk.evaluation.eval_set.EvalSet]:'
      docstring: Returns an EvalSet identified by an app_name and eval_set_id.
    - signature: 'def create_eval_set(self, app_name: str, eval_set_id: str) -> google.adk.evaluation.eval_set.EvalSet:'
      docstring: "Creates and returns an empty EvalSet given the app_name and eval_set_id.\n\nRaises:\n  ValueError: If eval set id is not valid or an eval set already exists. A\n  valid eval set id is string that has one or more of following characters:\n    - Lower case characters\n    - Upper case characters\n    - 0-9\n    - Underscore"
    - signature: 'def list_eval_sets(self, app_name: str) -> list[str]:'
      docstring: "Returns a list of EvalSets that belong to the given app_name.\n\nRaises:\n  NotFoundError: If the app_name doesn't exist."
    - signature: 'def get_eval_case(self, app_name: str, eval_set_id: str, eval_case_id: str) -> typing.Optional[google.adk.evaluation.eval_case.EvalCase]:'
      docstring: Returns an EvalCase if found; otherwise, None.
    - signature: 'def add_eval_case(self, app_name: str, eval_set_id: str, eval_case: google.adk.evaluation.eval_case.EvalCase):'
      docstring: "Adds the given EvalCase to an existing EvalSet identified by app_name and eval_set_id.\n\nRaises:\n  NotFoundError: If the eval set is not found."
    - signature: 'def update_eval_case(self, app_name: str, eval_set_id: str, updated_eval_case: google.adk.evaluation.eval_case.EvalCase):'
      docstring: "Updates an existing EvalCase give the app_name and eval_set_id.\n\nRaises:\n  NotFoundError: If the eval set or the eval case is not found."
    - signature: 'def delete_eval_case(self, app_name: str, eval_set_id: str, eval_case_id: str):'
      docstring: "Deletes the given EvalCase identified by app_name, eval_set_id and eval_case_id.\n\nRaises:\n  NotFoundError: If the eval set or the eval case to delete is not found."
  omitted_inherited_members_from:
  - ABC
- rank: 798
  id: google.adk.evaluation.local_eval_sets_manager.LocalEvalSetsManager.add_eval_case
  name: add_eval_case
  file_path: src/google/adk/evaluation/local_eval_sets_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Adds the given EvalCase to an existing EvalSet identified by app_name and eval_set_id.\n\nRaises:\n  NotFoundError: If the eval set is not found."
  signature: 'def add_eval_case(self, app_name: str, eval_set_id: str, eval_case: google.adk.evaluation.eval_case.EvalCase):'
- rank: 799
  id: google.adk.evaluation.local_eval_sets_manager.LocalEvalSetsManager.create_eval_set
  name: create_eval_set
  file_path: src/google/adk/evaluation/local_eval_sets_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Creates and returns an empty EvalSet given the app_name and eval_set_id.\n\nRaises:\n  ValueError: If Eval Set ID is not valid or an eval set already exists."
  signature: 'def create_eval_set(self, app_name: str, eval_set_id: str) -> google.adk.evaluation.eval_set.EvalSet:'
- rank: 800
  id: google.adk.evaluation.local_eval_sets_manager.LocalEvalSetsManager.delete_eval_case
  name: delete_eval_case
  file_path: src/google/adk/evaluation/local_eval_sets_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Deletes the given EvalCase identified by app_name, eval_set_id and eval_case_id.\n\nRaises:\n  NotFoundError: If the eval set or the eval case to delete is not found."
  signature: 'def delete_eval_case(self, app_name: str, eval_set_id: str, eval_case_id: str):'
- rank: 801
  id: google.adk.evaluation.local_eval_sets_manager.LocalEvalSetsManager.get_eval_case
  name: get_eval_case
  file_path: src/google/adk/evaluation/local_eval_sets_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns an EvalCase if found; otherwise, None.
  signature: 'def get_eval_case(self, app_name: str, eval_set_id: str, eval_case_id: str) -> typing.Optional[google.adk.evaluation.eval_case.EvalCase]:'
- rank: 802
  id: google.adk.evaluation.local_eval_sets_manager.LocalEvalSetsManager.get_eval_set
  name: get_eval_set
  file_path: src/google/adk/evaluation/local_eval_sets_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns an EvalSet identified by an app_name and eval_set_id.
  signature: 'def get_eval_set(self, app_name: str, eval_set_id: str) -> typing.Optional[google.adk.evaluation.eval_set.EvalSet]:'
- rank: 803
  id: google.adk.evaluation.local_eval_sets_manager.LocalEvalSetsManager.list_eval_sets
  name: list_eval_sets
  file_path: src/google/adk/evaluation/local_eval_sets_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Returns a list of EvalSets that belong to the given app_name.\n\nArgs:\n  app_name: The app name to list the eval sets for.\n\nReturns:\n  A list of EvalSet ids.\n\nRaises:\n  NotFoundError: If the eval directory for the app is not found."
  signature: 'def list_eval_sets(self, app_name: str) -> list[str]:'
- rank: 804
  id: google.adk.evaluation.local_eval_sets_manager.LocalEvalSetsManager.update_eval_case
  name: update_eval_case
  file_path: src/google/adk/evaluation/local_eval_sets_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Updates an existing EvalCase give the app_name and eval_set_id.\n\nRaises:\n  NotFoundError: If the eval set or the eval case is not found."
  signature: 'def update_eval_case(self, app_name: str, eval_set_id: str, updated_eval_case: google.adk.evaluation.eval_case.EvalCase):'
- rank: 805
  id: google.adk.evaluation.local_eval_sets_manager.convert_eval_set_to_pydantic_schema
  name: convert_eval_set_to_pydantic_schema
  file_path: src/google/adk/evaluation/local_eval_sets_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Returns a pydantic EvalSet generated from the json representation.\n\n  Args:\n    eval_set_id: Eval set id.\n    eval_set_in_json_format: Eval set specified in JSON format.\n\n  Here is a sample eval set in JSON format:\n[\n  {\n    \"name\": \"roll_17_sided_dice_twice\",\n    \"data\": [\n      {\n        \"query\": \"What can you do?\",\n        \"expected_tool_use\": [],\n        \"expected_intermediate_agent_responses\": [],\n        \"reference\": \"I can roll dice of different sizes and check if a number\n          is prime. I can also use multiple tools in parallel.\\n\"\n      },\n      {\n        \"query\": \"Roll a 17 sided dice twice for me\",\n        \"expected_tool_use\": [\n          {\n            \"tool_name\": \"roll_die\",\n            \"tool_input\": {\n              \"sides\": 17\n            }\n          },\n          {\n            \"tool_name\": \"roll_die\",\n            \"tool_input\": {\n              \"sides\": 17\n            }\n          }\n \
    \       ],\n        \"expected_intermediate_agent_responses\": [],\n        \"reference\": \"I have rolled a 17 sided die twice. The first roll was\n          13 and the second roll was 4.\\n\"\n      }\n    ],\n    \"initial_session\": {\n      \"state\": {},\n      \"app_name\": \"hello_world\",\n      \"user_id\": \"user\"\n    }\n  }\n]"
  signature: 'def convert_eval_set_to_pydantic_schema(eval_set_id: str, eval_set_in_json_format: list[dict[str, typing.Any]]) -> google.adk.evaluation.eval_set.EvalSet:'
- rank: 806
  id: google.adk.evaluation.local_eval_sets_manager.load_eval_set_from_file
  name: load_eval_set_from_file
  file_path: src/google/adk/evaluation/local_eval_sets_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns an EvalSet that is read from the given file.
  signature: 'def load_eval_set_from_file(eval_set_file_path: str, eval_set_id: str) -> google.adk.evaluation.eval_set.EvalSet:'
- rank: 807
  id: google.adk.evaluation.metric_evaluator_registry
  name: metric_evaluator_registry
  file_path: src/google/adk/evaluation/metric_evaluator_registry.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: 'DEFAULT_METRIC_EVALUATOR_REGISTRY: _get_default_metric_evaluator_registry'
- rank: 808
  id: google.adk.evaluation.metric_evaluator_registry.MetricEvaluatorRegistry
  name: MetricEvaluatorRegistry
  file_path: src/google/adk/evaluation/metric_evaluator_registry.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: A registry for metric Evaluators.
  methods:
  - signature: 'def get_evaluator(self, eval_metric: google.adk.evaluation.eval_metrics.EvalMetric) -> google.adk.evaluation.evaluator.Evaluator:'
    docstring: "Returns an Evaluator for the given metric.\n\nA new instance of the Evaluator is returned.\n\nArgs:\n  eval_metric: The metric for which we need the Evaluator.\n\nRaises:\n  NotFoundError: If there is no evaluator for the metric."
  - signature: 'def register_evaluator(self, metric_info: google.adk.evaluation.eval_metrics.MetricInfo, evaluator: type[google.adk.evaluation.evaluator.Evaluator]):'
    docstring: 'Registers an evaluator given the metric info.


      If a mapping already exist, then it is updated.'
  - signature: 'def get_registered_metrics(self) -> list[google.adk.evaluation.eval_metrics.MetricInfo]:'
    docstring: Returns a list of MetricInfo about the metrics registered so far.
- rank: 809
  id: google.adk.evaluation.metric_evaluator_registry.MetricEvaluatorRegistry.get_evaluator
  name: get_evaluator
  file_path: src/google/adk/evaluation/metric_evaluator_registry.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Returns an Evaluator for the given metric.\n\nA new instance of the Evaluator is returned.\n\nArgs:\n  eval_metric: The metric for which we need the Evaluator.\n\nRaises:\n  NotFoundError: If there is no evaluator for the metric."
  signature: 'def get_evaluator(self, eval_metric: google.adk.evaluation.eval_metrics.EvalMetric) -> google.adk.evaluation.evaluator.Evaluator:'
- rank: 810
  id: google.adk.evaluation.metric_evaluator_registry.MetricEvaluatorRegistry.get_registered_metrics
  name: get_registered_metrics
  file_path: src/google/adk/evaluation/metric_evaluator_registry.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns a list of MetricInfo about the metrics registered so far.
  signature: 'def get_registered_metrics(self) -> list[google.adk.evaluation.eval_metrics.MetricInfo]:'
- rank: 811
  id: google.adk.evaluation.metric_evaluator_registry.MetricEvaluatorRegistry.register_evaluator
  name: register_evaluator
  file_path: src/google/adk/evaluation/metric_evaluator_registry.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Registers an evaluator given the metric info.


    If a mapping already exist, then it is updated.'
  signature: 'def register_evaluator(self, metric_info: google.adk.evaluation.eval_metrics.MetricInfo, evaluator: type[google.adk.evaluation.evaluator.Evaluator]):'
- rank: 812
  id: google.adk.evaluation.metric_info_providers
  name: metric_info_providers
  file_path: src/google/adk/evaluation/metric_info_providers.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 813
  id: google.adk.evaluation.metric_info_providers.FinalResponseMatchV2EvaluatorMetricInfoProvider
  name: FinalResponseMatchV2EvaluatorMetricInfoProvider
  file_path: src/google/adk/evaluation/metric_info_providers.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Metric info provider for FinalResponseMatchV2Evaluator.


    [Note: Inherited members from abc.ABC are omitted.]'
  methods:
  - signature: 'def get_metric_info(self) -> google.adk.evaluation.eval_metrics.MetricInfo:'
  inherited_methods:
    MetricInfoProvider:
    - signature: 'def get_metric_info(self) -> google.adk.evaluation.eval_metrics.MetricInfo:'
      docstring: Returns MetricInfo for a given metric.
  omitted_inherited_members_from:
  - abc.ABC
- rank: 814
  id: google.adk.evaluation.metric_info_providers.FinalResponseMatchV2EvaluatorMetricInfoProvider.get_metric_info
  name: get_metric_info
  file_path: src/google/adk/evaluation/metric_info_providers.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_metric_info(self) -> google.adk.evaluation.eval_metrics.MetricInfo:'
- rank: 815
  id: google.adk.evaluation.metric_info_providers.HallucinationsV1EvaluatorMetricInfoProvider
  name: HallucinationsV1EvaluatorMetricInfoProvider
  file_path: src/google/adk/evaluation/metric_info_providers.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Metric info provider for HallucinationsV1Evaluator.


    [Note: Inherited members from abc.ABC are omitted.]'
  methods:
  - signature: 'def get_metric_info(self) -> google.adk.evaluation.eval_metrics.MetricInfo:'
  inherited_methods:
    MetricInfoProvider:
    - signature: 'def get_metric_info(self) -> google.adk.evaluation.eval_metrics.MetricInfo:'
      docstring: Returns MetricInfo for a given metric.
  omitted_inherited_members_from:
  - abc.ABC
- rank: 816
  id: google.adk.evaluation.metric_info_providers.HallucinationsV1EvaluatorMetricInfoProvider.get_metric_info
  name: get_metric_info
  file_path: src/google/adk/evaluation/metric_info_providers.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_metric_info(self) -> google.adk.evaluation.eval_metrics.MetricInfo:'
- rank: 817
  id: google.adk.evaluation.metric_info_providers.PerTurnUserSimulatorQualityV1MetricInfoProvider
  name: PerTurnUserSimulatorQualityV1MetricInfoProvider
  file_path: src/google/adk/evaluation/metric_info_providers.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Metric info provider for PerTurnUserSimulatorQualityV1.


    [Note: Inherited members from abc.ABC are omitted.]'
  methods:
  - signature: 'def get_metric_info(self) -> google.adk.evaluation.eval_metrics.MetricInfo:'
  inherited_methods:
    MetricInfoProvider:
    - signature: 'def get_metric_info(self) -> google.adk.evaluation.eval_metrics.MetricInfo:'
      docstring: Returns MetricInfo for a given metric.
  omitted_inherited_members_from:
  - abc.ABC
- rank: 818
  id: google.adk.evaluation.metric_info_providers.PerTurnUserSimulatorQualityV1MetricInfoProvider.get_metric_info
  name: get_metric_info
  file_path: src/google/adk/evaluation/metric_info_providers.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_metric_info(self) -> google.adk.evaluation.eval_metrics.MetricInfo:'
- rank: 819
  id: google.adk.evaluation.metric_info_providers.ResponseEvaluatorMetricInfoProvider
  name: ResponseEvaluatorMetricInfoProvider
  file_path: src/google/adk/evaluation/metric_info_providers.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Metric info provider for ResponseEvaluator.


    [Note: Inherited members from abc.ABC are omitted.]'
  constructor_signature: 'def __init__(self, metric_name: str):'
  methods:
  - signature: 'def get_metric_info(self) -> google.adk.evaluation.eval_metrics.MetricInfo:'
    docstring: Returns MetricInfo for the given metric name.
  inherited_methods:
    MetricInfoProvider:
    - signature: 'def get_metric_info(self) -> google.adk.evaluation.eval_metrics.MetricInfo:'
      docstring: Returns MetricInfo for a given metric.
  omitted_inherited_members_from:
  - abc.ABC
- rank: 820
  id: google.adk.evaluation.metric_info_providers.ResponseEvaluatorMetricInfoProvider.get_metric_info
  name: get_metric_info
  file_path: src/google/adk/evaluation/metric_info_providers.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns MetricInfo for the given metric name.
  signature: 'def get_metric_info(self) -> google.adk.evaluation.eval_metrics.MetricInfo:'
- rank: 821
  id: google.adk.evaluation.metric_info_providers.RubricBasedFinalResponseQualityV1EvaluatorMetricInfoProvider
  name: RubricBasedFinalResponseQualityV1EvaluatorMetricInfoProvider
  file_path: src/google/adk/evaluation/metric_info_providers.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Metric info provider for RubricBasedFinalResponseQualityV1Evaluator.


    [Note: Inherited members from abc.ABC are omitted.]'
  methods:
  - signature: 'def get_metric_info(self) -> google.adk.evaluation.eval_metrics.MetricInfo:'
  inherited_methods:
    MetricInfoProvider:
    - signature: 'def get_metric_info(self) -> google.adk.evaluation.eval_metrics.MetricInfo:'
      docstring: Returns MetricInfo for a given metric.
  omitted_inherited_members_from:
  - abc.ABC
- rank: 822
  id: google.adk.evaluation.metric_info_providers.RubricBasedFinalResponseQualityV1EvaluatorMetricInfoProvider.get_metric_info
  name: get_metric_info
  file_path: src/google/adk/evaluation/metric_info_providers.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_metric_info(self) -> google.adk.evaluation.eval_metrics.MetricInfo:'
- rank: 823
  id: google.adk.evaluation.metric_info_providers.RubricBasedToolUseV1EvaluatorMetricInfoProvider
  name: RubricBasedToolUseV1EvaluatorMetricInfoProvider
  file_path: src/google/adk/evaluation/metric_info_providers.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Metric info provider for RubricBasedToolUseV1Evaluator.


    [Note: Inherited members from abc.ABC are omitted.]'
  methods:
  - signature: 'def get_metric_info(self) -> google.adk.evaluation.eval_metrics.MetricInfo:'
  inherited_methods:
    MetricInfoProvider:
    - signature: 'def get_metric_info(self) -> google.adk.evaluation.eval_metrics.MetricInfo:'
      docstring: Returns MetricInfo for a given metric.
  omitted_inherited_members_from:
  - abc.ABC
- rank: 824
  id: google.adk.evaluation.metric_info_providers.RubricBasedToolUseV1EvaluatorMetricInfoProvider.get_metric_info
  name: get_metric_info
  file_path: src/google/adk/evaluation/metric_info_providers.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_metric_info(self) -> google.adk.evaluation.eval_metrics.MetricInfo:'
- rank: 825
  id: google.adk.evaluation.metric_info_providers.SafetyEvaluatorV1MetricInfoProvider
  name: SafetyEvaluatorV1MetricInfoProvider
  file_path: src/google/adk/evaluation/metric_info_providers.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Metric info provider for SafetyEvaluatorV1.


    [Note: Inherited members from abc.ABC are omitted.]'
  methods:
  - signature: 'def get_metric_info(self) -> google.adk.evaluation.eval_metrics.MetricInfo:'
  inherited_methods:
    MetricInfoProvider:
    - signature: 'def get_metric_info(self) -> google.adk.evaluation.eval_metrics.MetricInfo:'
      docstring: Returns MetricInfo for a given metric.
  omitted_inherited_members_from:
  - abc.ABC
- rank: 826
  id: google.adk.evaluation.metric_info_providers.SafetyEvaluatorV1MetricInfoProvider.get_metric_info
  name: get_metric_info
  file_path: src/google/adk/evaluation/metric_info_providers.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_metric_info(self) -> google.adk.evaluation.eval_metrics.MetricInfo:'
- rank: 827
  id: google.adk.evaluation.metric_info_providers.TrajectoryEvaluatorMetricInfoProvider
  name: TrajectoryEvaluatorMetricInfoProvider
  file_path: src/google/adk/evaluation/metric_info_providers.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Metric info provider for TrajectoryEvaluator.


    [Note: Inherited members from abc.ABC are omitted.]'
  methods:
  - signature: 'def get_metric_info(self) -> google.adk.evaluation.eval_metrics.MetricInfo:'
  inherited_methods:
    MetricInfoProvider:
    - signature: 'def get_metric_info(self) -> google.adk.evaluation.eval_metrics.MetricInfo:'
      docstring: Returns MetricInfo for a given metric.
  omitted_inherited_members_from:
  - abc.ABC
- rank: 828
  id: google.adk.evaluation.metric_info_providers.TrajectoryEvaluatorMetricInfoProvider.get_metric_info
  name: get_metric_info
  file_path: src/google/adk/evaluation/metric_info_providers.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_metric_info(self) -> google.adk.evaluation.eval_metrics.MetricInfo:'
- rank: 829
  id: google.adk.evaluation.request_intercepter_plugin
  name: request_intercepter_plugin
  file_path: src/google/adk/evaluation/request_intercepter_plugin.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '_LLM_REQUEST_ID_KEY: str'
- rank: 830
  id: google.adk.evaluation.response_evaluator
  name: response_evaluator
  file_path: src/google/adk/evaluation/response_evaluator.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 831
  id: google.adk.evaluation.response_evaluator.ResponseEvaluator
  name: ResponseEvaluator
  file_path: src/google/adk/evaluation/response_evaluator.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Evaluates Agent''s responses.


    This class supports two metrics:

    1) response_evaluation_score

    This metric evaluates how coherent agent''s response was.


    Value range of this metric is [1,5], with values closer to 5 more desirable.


    2) response_match_score:

    This metric evaluates if agent''s final response matches a golden/expected

    final response using Rouge_1 metric.


    Value range for this metric is [0,1], with values closer to 1 more desirable.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, threshold: typing.Optional[float], metric_name: typing.Optional[str], eval_metric: typing.Optional[google.adk.evaluation.eval_metrics.EvalMetric]):'
  methods:
  - signature: 'def evaluate_invocations(self, actual_invocations: list[google.adk.evaluation.eval_case.Invocation], expected_invocations: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]], conversation_scenario: typing.Optional[google.adk.evaluation.eval_case.ConversationScenario]) -> google.adk.evaluation.evaluator.EvaluationResult:'
  inherited_methods:
    Evaluator:
    - signature: 'def evaluate_invocations(self, actual_invocations: list[google.adk.evaluation.eval_case.Invocation], expected_invocations: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]], conversation_scenario: typing.Optional[google.adk.evaluation.eval_case.ConversationScenario]) -> google.adk.evaluation.evaluator.EvaluationResult:'
      docstring: "Returns EvaluationResult after performing evaluations using actual and expected invocations.\n\nArgs:\n  actual_invocations: These are the invocations that are obtained from the\n    agent under test.\n  expected_invocations: An optional list of invocations, if specified,\n    usually act as a benchmark/golden response. If these are specified\n    usually the expectation is that the length of this list and actual\n    invocation is the same.\n  conversation_scenario: An optional conversation scenario for multi-turn\n    conversations."
  inherited_properties:
    Evaluator:
    - signature: 'criterion_type: typing.ClassVar[type[google.adk.evaluation.eval_metrics.BaseCriterion]]'
  omitted_inherited_members_from:
  - ABC
- rank: 832
  id: google.adk.evaluation.response_evaluator.ResponseEvaluator.__init__
  name: __init__
  file_path: src/google/adk/evaluation/response_evaluator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, threshold: typing.Optional[float], metric_name: typing.Optional[str], eval_metric: typing.Optional[google.adk.evaluation.eval_metrics.EvalMetric]):'
- rank: 833
  id: google.adk.evaluation.response_evaluator.ResponseEvaluator.evaluate_invocations
  name: evaluate_invocations
  file_path: src/google/adk/evaluation/response_evaluator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def evaluate_invocations(self, actual_invocations: list[google.adk.evaluation.eval_case.Invocation], expected_invocations: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]], conversation_scenario: typing.Optional[google.adk.evaluation.eval_case.ConversationScenario]) -> google.adk.evaluation.evaluator.EvaluationResult:'
- rank: 834
  id: google.adk.evaluation.rubric_based_evaluator
  name: rubric_based_evaluator
  file_path: src/google/adk/evaluation/rubric_based_evaluator.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '_PROPERTY_PATTERN: str'
  - signature: '_RATIONALE_PATTERN: str'
  - signature: '_VERDICT_PATTERN: str'
- rank: 835
  id: google.adk.evaluation.rubric_based_evaluator.AutoRaterResponseParser
  name: AutoRaterResponseParser
  file_path: src/google/adk/evaluation/rubric_based_evaluator.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'An interface for parsing auto rater''s response.


    [Note: Inherited members from abc.ABC are omitted.]'
  methods:
  - signature: 'def parse(self, auto_rater_response: str) -> list[google.adk.evaluation.rubric_based_evaluator.RubricResponse]:'
    docstring: Parses the auto rater's response.
  omitted_inherited_members_from:
  - abc.ABC
- rank: 836
  id: google.adk.evaluation.rubric_based_evaluator.DefaultAutoRaterResponseParser
  name: DefaultAutoRaterResponseParser
  file_path: src/google/adk/evaluation/rubric_based_evaluator.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'The default implementation of the AutoRaterResponseParser.


    [Note: Inherited members from abc.ABC are omitted.]'
  methods:
  - signature: 'def parse(self, auto_rater_response: str) -> list[google.adk.evaluation.rubric_based_evaluator.RubricResponse]:'
    docstring: Returns a list of RubricResponse parsed from the AutoRater's response.
  inherited_methods:
    AutoRaterResponseParser:
    - signature: 'def parse(self, auto_rater_response: str) -> list[google.adk.evaluation.rubric_based_evaluator.RubricResponse]:'
      docstring: Parses the auto rater's response.
  omitted_inherited_members_from:
  - abc.ABC
- rank: 837
  id: google.adk.evaluation.rubric_based_evaluator.DefaultAutoRaterResponseParser.parse
  name: parse
  file_path: src/google/adk/evaluation/rubric_based_evaluator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns a list of RubricResponse parsed from the AutoRater's response.
  signature: 'def parse(self, auto_rater_response: str) -> list[google.adk.evaluation.rubric_based_evaluator.RubricResponse]:'
- rank: 838
  id: google.adk.evaluation.rubric_based_evaluator.InvocationResultsSummarizer
  name: InvocationResultsSummarizer
  file_path: src/google/adk/evaluation/rubric_based_evaluator.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'An interface for summarizing per invocation results.


    [Note: Inherited members from abc.ABC are omitted.]'
  methods:
  - signature: 'def summarize(self, per_invocation_results: list[google.adk.evaluation.evaluator.PerInvocationResult], threshold: float) -> google.adk.evaluation.evaluator.EvaluationResult:'
    docstring: Summaries per invocation results into a single result.
  omitted_inherited_members_from:
  - abc.ABC
- rank: 839
  id: google.adk.evaluation.rubric_based_evaluator.InvocationResultsSummarizer.summarize
  name: summarize
  file_path: src/google/adk/evaluation/rubric_based_evaluator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Summaries per invocation results into a single result.
  signature: 'def summarize(self, per_invocation_results: list[google.adk.evaluation.evaluator.PerInvocationResult], threshold: float) -> google.adk.evaluation.evaluator.EvaluationResult:'
- rank: 840
  id: google.adk.evaluation.rubric_based_evaluator.MajorityVotePerInvocationResultsAggregator
  name: MajorityVotePerInvocationResultsAggregator
  file_path: src/google/adk/evaluation/rubric_based_evaluator.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Aggregates per invocation samples using majority vote.


    [Note: Inherited members from abc.ABC are omitted.]'
  methods:
  - signature: 'def aggregate(self, per_invocation_samples: list[google.adk.evaluation.evaluator.PerInvocationResult], threshold: float) -> google.adk.evaluation.evaluator.PerInvocationResult:'
    docstring: "Returns a combined result for the invocation using majority vote.\n\nThis method takes all those samples for a single invocation and combines\nthem to generate one single result for the invocation.\n\nThis method specifically uses majority vote to aggregate scores for a\nrubric. Take following Invocation and Rubric for example:\n\n  Invocation:\n     User: Is it going to be cold in Seattle tomorrow?\n     Weather Agent: No, it will be moderately warm as predicted temperature\n     for Seattle, WA tomorrow is 88F.\n\n  Rubric: Agent's response was concise and to the point.\n\n  We will sample the AutoRater 5 times, and the AutoRater responds\n  with (skipping the rationale field for now):\n    Sample 1:\n      Verdict: Yes\n    Sample 2:\n      Verdict: No\n    Sample 3:\n      Verdict: Yes\n    Sample 4:\n      Verdict: Yes\n    Sample 5:\n      Verdict: No\n\n  This method will use majority vote and combine the results of 5 samples\n  into one, and it will report \"Yes\"\
      \ as the final verdict."
  inherited_methods:
    PerInvocationResultsAggregator:
    - signature: 'def aggregate(self, per_invocation_samples: list[google.adk.evaluation.evaluator.PerInvocationResult], threshold: float) -> google.adk.evaluation.evaluator.PerInvocationResult:'
      docstring: Aggregates per invocation samples into a single result.
  omitted_inherited_members_from:
  - abc.ABC
- rank: 841
  id: google.adk.evaluation.rubric_based_evaluator.MajorityVotePerInvocationResultsAggregator.aggregate
  name: aggregate
  file_path: src/google/adk/evaluation/rubric_based_evaluator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Returns a combined result for the invocation using majority vote.\n\nThis method takes all those samples for a single invocation and combines\nthem to generate one single result for the invocation.\n\nThis method specifically uses majority vote to aggregate scores for a\nrubric. Take following Invocation and Rubric for example:\n\n  Invocation:\n     User: Is it going to be cold in Seattle tomorrow?\n     Weather Agent: No, it will be moderately warm as predicted temperature\n     for Seattle, WA tomorrow is 88F.\n\n  Rubric: Agent's response was concise and to the point.\n\n  We will sample the AutoRater 5 times, and the AutoRater responds\n  with (skipping the rationale field for now):\n    Sample 1:\n      Verdict: Yes\n    Sample 2:\n      Verdict: No\n    Sample 3:\n      Verdict: Yes\n    Sample 4:\n      Verdict: Yes\n    Sample 5:\n      Verdict: No\n\n  This method will use majority vote and combine the results of 5 samples\n  into one, and it will report \"Yes\" as\
    \ the final verdict."
  signature: 'def aggregate(self, per_invocation_samples: list[google.adk.evaluation.evaluator.PerInvocationResult], threshold: float) -> google.adk.evaluation.evaluator.PerInvocationResult:'
- rank: 842
  id: google.adk.evaluation.rubric_based_evaluator.MeanInvocationResultsSummarizer
  name: MeanInvocationResultsSummarizer
  file_path: src/google/adk/evaluation/rubric_based_evaluator.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Summarizes per invocation results using mean score.


    [Note: Inherited members from abc.ABC are omitted.]'
  methods:
  - signature: 'def summarize(self, per_invocation_results: list[google.adk.evaluation.evaluator.PerInvocationResult], threshold: float) -> google.adk.evaluation.evaluator.EvaluationResult:'
    docstring: 'Summarizes per invocation evaluation results into a single score.


      A single eval case can have multiple invocations and the eval metric is

      assessed for each invocation. But, we do want to summarize and make a

      statement on how the eval case as a whole performed on the metric.


      This method helps us aggregate rubric scores across invocation.


      This method calculates the mean score of a rubric across several

      invocations.'
  inherited_methods:
    InvocationResultsSummarizer:
    - signature: 'def summarize(self, per_invocation_results: list[google.adk.evaluation.evaluator.PerInvocationResult], threshold: float) -> google.adk.evaluation.evaluator.EvaluationResult:'
      docstring: Summaries per invocation results into a single result.
  omitted_inherited_members_from:
  - abc.ABC
- rank: 843
  id: google.adk.evaluation.rubric_based_evaluator.MeanInvocationResultsSummarizer.summarize
  name: summarize
  file_path: src/google/adk/evaluation/rubric_based_evaluator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Summarizes per invocation evaluation results into a single score.


    A single eval case can have multiple invocations and the eval metric is

    assessed for each invocation. But, we do want to summarize and make a

    statement on how the eval case as a whole performed on the metric.


    This method helps us aggregate rubric scores across invocation.


    This method calculates the mean score of a rubric across several

    invocations.'
  signature: 'def summarize(self, per_invocation_results: list[google.adk.evaluation.evaluator.PerInvocationResult], threshold: float) -> google.adk.evaluation.evaluator.EvaluationResult:'
- rank: 844
  id: google.adk.evaluation.rubric_based_evaluator.PerInvocationResultsAggregator
  name: PerInvocationResultsAggregator
  file_path: src/google/adk/evaluation/rubric_based_evaluator.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'An interface for aggregating per invocation samples.


    AutoRaters that are backed by an LLM are known to have certain degree of

    unreliability to their responses. In order to counter that we sample the

    autorater more than once for a single invocation.


    The aggregator helps convert those multiple samples into a single result.


    [Note: Inherited members from abc.ABC are omitted.]'
  methods:
  - signature: 'def aggregate(self, per_invocation_samples: list[google.adk.evaluation.evaluator.PerInvocationResult], threshold: float) -> google.adk.evaluation.evaluator.PerInvocationResult:'
    docstring: Aggregates per invocation samples into a single result.
  omitted_inherited_members_from:
  - abc.ABC
- rank: 845
  id: google.adk.evaluation.rubric_based_evaluator.PerInvocationResultsAggregator.aggregate
  name: aggregate
  file_path: src/google/adk/evaluation/rubric_based_evaluator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Aggregates per invocation samples into a single result.
  signature: 'def aggregate(self, per_invocation_samples: list[google.adk.evaluation.evaluator.PerInvocationResult], threshold: float) -> google.adk.evaluation.evaluator.PerInvocationResult:'
- rank: 846
  id: google.adk.evaluation.rubric_based_evaluator.RubricBasedEvaluator
  name: RubricBasedEvaluator
  file_path: src/google/adk/evaluation/rubric_based_evaluator.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A base class for rubric based evaluators.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, eval_metric: google.adk.evaluation.eval_metrics.EvalMetric, criterion_type: type[google.adk.evaluation.eval_metrics.BaseCriterion], auto_rater_response_parser: google.adk.evaluation.rubric_based_evaluator.AutoRaterResponseParser, per_invocation_results_aggregator: google.adk.evaluation.rubric_based_evaluator.PerInvocationResultsAggregator, invocation_results_summarizer: google.adk.evaluation.rubric_based_evaluator.InvocationResultsSummarizer, rubric_type: typing.Optional[str]):'
  methods:
  - signature: 'def create_effective_rubrics_list(self, invocation_rubrics: typing.Optional[list[google.adk.evaluation.eval_rubrics.Rubric]]) -> None:'
  - signature: 'def get_effective_rubrics_list(self) -> list[google.adk.evaluation.eval_rubrics.Rubric]:'
    docstring: Returns the effective rubrics list.
  - signature: 'def convert_auto_rater_response_to_score(self, auto_rater_response: google.adk.models.llm_response.LlmResponse) -> google.adk.evaluation.llm_as_judge.AutoRaterScore:'
    docstring: Returns an AutoRaterScore generated from AutoRater's response.
  - signature: 'def aggregate_per_invocation_samples(self, per_invocation_samples: list[google.adk.evaluation.evaluator.PerInvocationResult]) -> google.adk.evaluation.evaluator.PerInvocationResult:'
    docstring: 'Returns a combined result by aggregating multiple samples for the same invocation.


      AutoRaters that are backed by an LLM are known to have certain degree of

      unreliability to their responses. In order to counter that we sample the

      autorater more than once for a single invocation.


      The aggregator helps convert those multiple samples into a single result.'
  - signature: 'def aggregate_invocation_results(self, per_invocation_results: list[google.adk.evaluation.evaluator.PerInvocationResult]) -> google.adk.evaluation.evaluator.EvaluationResult:'
    docstring: Summarizes per invocation evaluation results into a single score.
  inherited_methods:
    LlmAsJudge:
    - signature: 'def format_auto_rater_prompt(self, actual: google.adk.evaluation.eval_case.Invocation, expected: typing.Optional[google.adk.evaluation.eval_case.Invocation]) -> str:'
      docstring: Formats the auto-rater prompt to evaluate the given invocation.
    - signature: 'def convert_auto_rater_response_to_score(self, auto_rater_response: google.adk.models.llm_response.LlmResponse) -> google.adk.evaluation.llm_as_judge.AutoRaterScore:'
      docstring: Parses auto_rater_response and returns the corresponding score, or None if the score cannot be determined.
    - signature: 'def aggregate_per_invocation_samples(self, per_invocation_samples: list[google.adk.evaluation.evaluator.PerInvocationResult]) -> google.adk.evaluation.evaluator.PerInvocationResult:'
      docstring: Aggregates repeated per-invocation samples to get the final result for the invocation.
    - signature: 'def aggregate_invocation_results(self, per_invocation_results: list[google.adk.evaluation.evaluator.PerInvocationResult]) -> google.adk.evaluation.evaluator.EvaluationResult:'
      docstring: Aggregates the per invocation results to get the overall score.
    - signature: 'def evaluate_invocations(self, actual_invocations: list[google.adk.evaluation.eval_case.Invocation], expected_invocations: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]], conversation_scenario: typing.Optional[google.adk.evaluation.eval_case.ConversationScenario]) -> google.adk.evaluation.evaluator.EvaluationResult:'
    Evaluator:
    - signature: 'def evaluate_invocations(self, actual_invocations: list[google.adk.evaluation.eval_case.Invocation], expected_invocations: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]], conversation_scenario: typing.Optional[google.adk.evaluation.eval_case.ConversationScenario]) -> google.adk.evaluation.evaluator.EvaluationResult:'
      docstring: "Returns EvaluationResult after performing evaluations using actual and expected invocations.\n\nArgs:\n  actual_invocations: These are the invocations that are obtained from the\n    agent under test.\n  expected_invocations: An optional list of invocations, if specified,\n    usually act as a benchmark/golden response. If these are specified\n    usually the expectation is that the length of this list and actual\n    invocation is the same.\n  conversation_scenario: An optional conversation scenario for multi-turn\n    conversations."
  inherited_properties:
    Evaluator:
    - signature: 'criterion_type: typing.ClassVar[type[google.adk.evaluation.eval_metrics.BaseCriterion]]'
  omitted_inherited_members_from:
  - ABC
- rank: 847
  id: google.adk.evaluation.rubric_based_evaluator.RubricBasedEvaluator.__init__
  name: __init__
  file_path: src/google/adk/evaluation/rubric_based_evaluator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the RubricBasedEvaluator.\n\nArgs:\n  eval_metric: The evaluation metric configuration.\n  criterion_type: The type of the criterion used for this evaluator.\n  auto_rater_response_parser: An object that parses the auto-rater's\n    response text and extracts rubric scores.\n  per_invocation_results_aggregator: An object that aggregates multiple\n    samples for a single invocation into a single result. This is useful in\n    cases where the auto-rater is an LLM and multiple samples are generated\n    to account for the unreliability of the LLM.\n  invocation_results_summarizer: An object that summarizes the results of\n    all invocations in an eval case into a single result.\n  rubric_type: Invocation and case level rubrics will be filtered by this\n    type."
  signature: 'def __init__(self, eval_metric: google.adk.evaluation.eval_metrics.EvalMetric, criterion_type: type[google.adk.evaluation.eval_metrics.BaseCriterion], auto_rater_response_parser: google.adk.evaluation.rubric_based_evaluator.AutoRaterResponseParser, per_invocation_results_aggregator: google.adk.evaluation.rubric_based_evaluator.PerInvocationResultsAggregator, invocation_results_summarizer: google.adk.evaluation.rubric_based_evaluator.InvocationResultsSummarizer, rubric_type: typing.Optional[str]):'
- rank: 848
  id: google.adk.evaluation.rubric_based_evaluator.RubricBasedEvaluator.aggregate_invocation_results
  name: aggregate_invocation_results
  file_path: src/google/adk/evaluation/rubric_based_evaluator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Summarizes per invocation evaluation results into a single score.
  signature: 'def aggregate_invocation_results(self, per_invocation_results: list[google.adk.evaluation.evaluator.PerInvocationResult]) -> google.adk.evaluation.evaluator.EvaluationResult:'
- rank: 849
  id: google.adk.evaluation.rubric_based_evaluator.RubricBasedEvaluator.aggregate_per_invocation_samples
  name: aggregate_per_invocation_samples
  file_path: src/google/adk/evaluation/rubric_based_evaluator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Returns a combined result by aggregating multiple samples for the same invocation.


    AutoRaters that are backed by an LLM are known to have certain degree of

    unreliability to their responses. In order to counter that we sample the

    autorater more than once for a single invocation.


    The aggregator helps convert those multiple samples into a single result.'
  signature: 'def aggregate_per_invocation_samples(self, per_invocation_samples: list[google.adk.evaluation.evaluator.PerInvocationResult]) -> google.adk.evaluation.evaluator.PerInvocationResult:'
- rank: 850
  id: google.adk.evaluation.rubric_based_evaluator.RubricBasedEvaluator.convert_auto_rater_response_to_score
  name: convert_auto_rater_response_to_score
  file_path: src/google/adk/evaluation/rubric_based_evaluator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns an AutoRaterScore generated from AutoRater's response.
  signature: 'def convert_auto_rater_response_to_score(self, auto_rater_response: google.adk.models.llm_response.LlmResponse) -> google.adk.evaluation.llm_as_judge.AutoRaterScore:'
- rank: 851
  id: google.adk.evaluation.rubric_based_evaluator.RubricBasedEvaluator.create_effective_rubrics_list
  name: create_effective_rubrics_list
  file_path: src/google/adk/evaluation/rubric_based_evaluator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def create_effective_rubrics_list(self, invocation_rubrics: typing.Optional[list[google.adk.evaluation.eval_rubrics.Rubric]]) -> None:'
- rank: 852
  id: google.adk.evaluation.rubric_based_evaluator.RubricBasedEvaluator.get_effective_rubrics_list
  name: get_effective_rubrics_list
  file_path: src/google/adk/evaluation/rubric_based_evaluator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns the effective rubrics list.
  signature: 'def get_effective_rubrics_list(self) -> list[google.adk.evaluation.eval_rubrics.Rubric]:'
- rank: 853
  id: google.adk.evaluation.rubric_based_evaluator.RubricResponse
  name: RubricResponse
  file_path: src/google/adk/evaluation/rubric_based_evaluator.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Internal data model to represent a rubric''s response from the auto-rater.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, property_text: typing.Optional[str] = None, rationale: typing.Optional[str] = None, score: typing.Optional[float] = None):'
  properties:
  - signature: 'property_text: typing.Optional[str]'
  - signature: 'rationale: typing.Optional[str]'
  - signature: 'score: typing.Optional[float]'
  inherited_properties:
    EvalBaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 854
  id: google.adk.evaluation.rubric_based_final_response_quality_v1
  name: rubric_based_final_response_quality_v1
  file_path: src/google/adk/evaluation/rubric_based_final_response_quality_v1.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '_RUBRIC_BASED_FINAL_RESPONSE_QUALITY_V1_PROMPT: str'
- rank: 855
  id: google.adk.evaluation.rubric_based_final_response_quality_v1.RubricBasedFinalResponseQualityV1Evaluator
  name: RubricBasedFinalResponseQualityV1Evaluator
  file_path: src/google/adk/evaluation/rubric_based_final_response_quality_v1.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'An Evaluator for rubric based assessment of the agent''s final response using a LLM.


    The evaluator uses a set of rubrics to assess the quality of the agent''s

    final response.


    Example: For a weather agent that responds to weather related queries of the

    user, one could specify following rubrics:


    Rubric 1: Agent''s response is direct and to the point.

    Rubric 2: Agent''s response accurately inferred user''s underlying goal from

    ambiguous queries (e.g. "is it a beach weather?" would mean sun, warmth and

    low wind)


    For each rubric, this evaluator will generate a confidence score between 0

    and 1, where 0 means that agent''s response did not satisfy the rubric at all

    and 1 means complete adherence. Value closer to 1 are desirable.


    A combined score using individual rubric confidences will also be generated.

    Like individual rubric confidence scores, the range for this value will be

    between 0 and 1, and it will have the same interpretation.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, eval_metric: google.adk.evaluation.eval_metrics.EvalMetric):'
  methods:
  - signature: 'def format_auto_rater_prompt(self, actual_invocation: google.adk.evaluation.eval_case.Invocation, _: typing.Optional[google.adk.evaluation.eval_case.Invocation]) -> str:'
    docstring: Returns the autorater prompt.
  properties:
  - signature: 'criterion_type: typing.ClassVar[type[google.adk.evaluation.eval_metrics.RubricsBasedCriterion]]'
  - signature: 'RUBRIC_TYPE: typing.ClassVar[str]'
  inherited_methods:
    RubricBasedEvaluator:
    - signature: 'def create_effective_rubrics_list(self, invocation_rubrics: typing.Optional[list[google.adk.evaluation.eval_rubrics.Rubric]]) -> None:'
    - signature: 'def get_effective_rubrics_list(self) -> list[google.adk.evaluation.eval_rubrics.Rubric]:'
      docstring: Returns the effective rubrics list.
    - signature: 'def convert_auto_rater_response_to_score(self, auto_rater_response: google.adk.models.llm_response.LlmResponse) -> google.adk.evaluation.llm_as_judge.AutoRaterScore:'
      docstring: Returns an AutoRaterScore generated from AutoRater's response.
    - signature: 'def aggregate_per_invocation_samples(self, per_invocation_samples: list[google.adk.evaluation.evaluator.PerInvocationResult]) -> google.adk.evaluation.evaluator.PerInvocationResult:'
      docstring: 'Returns a combined result by aggregating multiple samples for the same invocation.


        AutoRaters that are backed by an LLM are known to have certain degree of

        unreliability to their responses. In order to counter that we sample the

        autorater more than once for a single invocation.


        The aggregator helps convert those multiple samples into a single result.'
    - signature: 'def aggregate_invocation_results(self, per_invocation_results: list[google.adk.evaluation.evaluator.PerInvocationResult]) -> google.adk.evaluation.evaluator.EvaluationResult:'
      docstring: Summarizes per invocation evaluation results into a single score.
    LlmAsJudge:
    - signature: 'def format_auto_rater_prompt(self, actual: google.adk.evaluation.eval_case.Invocation, expected: typing.Optional[google.adk.evaluation.eval_case.Invocation]) -> str:'
      docstring: Formats the auto-rater prompt to evaluate the given invocation.
    - signature: 'def convert_auto_rater_response_to_score(self, auto_rater_response: google.adk.models.llm_response.LlmResponse) -> google.adk.evaluation.llm_as_judge.AutoRaterScore:'
      docstring: Parses auto_rater_response and returns the corresponding score, or None if the score cannot be determined.
    - signature: 'def aggregate_per_invocation_samples(self, per_invocation_samples: list[google.adk.evaluation.evaluator.PerInvocationResult]) -> google.adk.evaluation.evaluator.PerInvocationResult:'
      docstring: Aggregates repeated per-invocation samples to get the final result for the invocation.
    - signature: 'def aggregate_invocation_results(self, per_invocation_results: list[google.adk.evaluation.evaluator.PerInvocationResult]) -> google.adk.evaluation.evaluator.EvaluationResult:'
      docstring: Aggregates the per invocation results to get the overall score.
    - signature: 'def evaluate_invocations(self, actual_invocations: list[google.adk.evaluation.eval_case.Invocation], expected_invocations: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]], conversation_scenario: typing.Optional[google.adk.evaluation.eval_case.ConversationScenario]) -> google.adk.evaluation.evaluator.EvaluationResult:'
    Evaluator:
    - signature: 'def evaluate_invocations(self, actual_invocations: list[google.adk.evaluation.eval_case.Invocation], expected_invocations: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]], conversation_scenario: typing.Optional[google.adk.evaluation.eval_case.ConversationScenario]) -> google.adk.evaluation.evaluator.EvaluationResult:'
      docstring: "Returns EvaluationResult after performing evaluations using actual and expected invocations.\n\nArgs:\n  actual_invocations: These are the invocations that are obtained from the\n    agent under test.\n  expected_invocations: An optional list of invocations, if specified,\n    usually act as a benchmark/golden response. If these are specified\n    usually the expectation is that the length of this list and actual\n    invocation is the same.\n  conversation_scenario: An optional conversation scenario for multi-turn\n    conversations."
  inherited_properties:
    Evaluator:
    - signature: 'criterion_type: typing.ClassVar[type[google.adk.evaluation.eval_metrics.BaseCriterion]]'
  omitted_inherited_members_from:
  - ABC
- rank: 856
  id: google.adk.evaluation.rubric_based_final_response_quality_v1.RubricBasedFinalResponseQualityV1Evaluator.__init__
  name: __init__
  file_path: src/google/adk/evaluation/rubric_based_final_response_quality_v1.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, eval_metric: google.adk.evaluation.eval_metrics.EvalMetric):'
- rank: 857
  id: google.adk.evaluation.rubric_based_final_response_quality_v1.RubricBasedFinalResponseQualityV1Evaluator.format_auto_rater_prompt
  name: format_auto_rater_prompt
  file_path: src/google/adk/evaluation/rubric_based_final_response_quality_v1.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns the autorater prompt.
  signature: 'def format_auto_rater_prompt(self, actual_invocation: google.adk.evaluation.eval_case.Invocation, _: typing.Optional[google.adk.evaluation.eval_case.Invocation]) -> str:'
- rank: 858
  id: google.adk.evaluation.rubric_based_tool_use_quality_v1
  name: rubric_based_tool_use_quality_v1
  file_path: src/google/adk/evaluation/rubric_based_tool_use_quality_v1.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '_RUBRIC_BASED_TOOL_USE_QUALITY_V1_PROMPT: str'
- rank: 859
  id: google.adk.evaluation.rubric_based_tool_use_quality_v1.RubricBasedToolUseV1Evaluator
  name: RubricBasedToolUseV1Evaluator
  file_path: src/google/adk/evaluation/rubric_based_tool_use_quality_v1.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'An Evaluator for rubric based assessment of the agent''s usage of Tools.


    Example: Lets take an example of a Weather Agent that has access to two tools:

    1: GeoCoding Tool: Coverts a city name, address or zip code into geographic

    coordinates.

    2: GetWeather Tool: Gets weather for the next 10 days for the given geographic

    coordinates.


    For this agent, one can create following Rubrics that could focus on tool use


    Rubric 1: A call is made to GeoCoding Tool.

    Rubric 2: A call is made to GetWeather Tool.

    Rubric 3: The call to GetWeather Tool happens after the GeoCoding Tool.

    Rubric 4: The input to GeoCoding Tool can be mapped back to user prompt.

    Rubric 5: The input to GetWeather Tool comes from the output of GeoCoding

    Tool.)


    For each rubric, this evaluator will generate a confidence score between 0

    and 1, where 0 means that agent''s response did not satisfy the rubric at all

    and 1 means complete adherence. Value closer to 1 are desirable.


    A combined score using individual rubric confidences will also be generated.

    Like individual rubric confidence scores, the range for this value will be

    between 0 and 1, and it will have the same interpretation.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, eval_metric: google.adk.evaluation.eval_metrics.EvalMetric):'
  methods:
  - signature: 'def format_auto_rater_prompt(self, actual_invocation: google.adk.evaluation.eval_case.Invocation, _: typing.Optional[google.adk.evaluation.eval_case.Invocation]) -> str:'
    docstring: Returns the autorater prompt.
  properties:
  - signature: 'criterion_type: typing.ClassVar[type[google.adk.evaluation.eval_metrics.RubricsBasedCriterion]]'
  - signature: 'RUBRIC_TYPE: typing.ClassVar[str]'
  inherited_methods:
    RubricBasedEvaluator:
    - signature: 'def create_effective_rubrics_list(self, invocation_rubrics: typing.Optional[list[google.adk.evaluation.eval_rubrics.Rubric]]) -> None:'
    - signature: 'def get_effective_rubrics_list(self) -> list[google.adk.evaluation.eval_rubrics.Rubric]:'
      docstring: Returns the effective rubrics list.
    - signature: 'def convert_auto_rater_response_to_score(self, auto_rater_response: google.adk.models.llm_response.LlmResponse) -> google.adk.evaluation.llm_as_judge.AutoRaterScore:'
      docstring: Returns an AutoRaterScore generated from AutoRater's response.
    - signature: 'def aggregate_per_invocation_samples(self, per_invocation_samples: list[google.adk.evaluation.evaluator.PerInvocationResult]) -> google.adk.evaluation.evaluator.PerInvocationResult:'
      docstring: 'Returns a combined result by aggregating multiple samples for the same invocation.


        AutoRaters that are backed by an LLM are known to have certain degree of

        unreliability to their responses. In order to counter that we sample the

        autorater more than once for a single invocation.


        The aggregator helps convert those multiple samples into a single result.'
    - signature: 'def aggregate_invocation_results(self, per_invocation_results: list[google.adk.evaluation.evaluator.PerInvocationResult]) -> google.adk.evaluation.evaluator.EvaluationResult:'
      docstring: Summarizes per invocation evaluation results into a single score.
    LlmAsJudge:
    - signature: 'def format_auto_rater_prompt(self, actual: google.adk.evaluation.eval_case.Invocation, expected: typing.Optional[google.adk.evaluation.eval_case.Invocation]) -> str:'
      docstring: Formats the auto-rater prompt to evaluate the given invocation.
    - signature: 'def convert_auto_rater_response_to_score(self, auto_rater_response: google.adk.models.llm_response.LlmResponse) -> google.adk.evaluation.llm_as_judge.AutoRaterScore:'
      docstring: Parses auto_rater_response and returns the corresponding score, or None if the score cannot be determined.
    - signature: 'def aggregate_per_invocation_samples(self, per_invocation_samples: list[google.adk.evaluation.evaluator.PerInvocationResult]) -> google.adk.evaluation.evaluator.PerInvocationResult:'
      docstring: Aggregates repeated per-invocation samples to get the final result for the invocation.
    - signature: 'def aggregate_invocation_results(self, per_invocation_results: list[google.adk.evaluation.evaluator.PerInvocationResult]) -> google.adk.evaluation.evaluator.EvaluationResult:'
      docstring: Aggregates the per invocation results to get the overall score.
    - signature: 'def evaluate_invocations(self, actual_invocations: list[google.adk.evaluation.eval_case.Invocation], expected_invocations: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]], conversation_scenario: typing.Optional[google.adk.evaluation.eval_case.ConversationScenario]) -> google.adk.evaluation.evaluator.EvaluationResult:'
    Evaluator:
    - signature: 'def evaluate_invocations(self, actual_invocations: list[google.adk.evaluation.eval_case.Invocation], expected_invocations: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]], conversation_scenario: typing.Optional[google.adk.evaluation.eval_case.ConversationScenario]) -> google.adk.evaluation.evaluator.EvaluationResult:'
      docstring: "Returns EvaluationResult after performing evaluations using actual and expected invocations.\n\nArgs:\n  actual_invocations: These are the invocations that are obtained from the\n    agent under test.\n  expected_invocations: An optional list of invocations, if specified,\n    usually act as a benchmark/golden response. If these are specified\n    usually the expectation is that the length of this list and actual\n    invocation is the same.\n  conversation_scenario: An optional conversation scenario for multi-turn\n    conversations."
  inherited_properties:
    Evaluator:
    - signature: 'criterion_type: typing.ClassVar[type[google.adk.evaluation.eval_metrics.BaseCriterion]]'
  omitted_inherited_members_from:
  - ABC
- rank: 860
  id: google.adk.evaluation.rubric_based_tool_use_quality_v1.RubricBasedToolUseV1Evaluator.__init__
  name: __init__
  file_path: src/google/adk/evaluation/rubric_based_tool_use_quality_v1.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, eval_metric: google.adk.evaluation.eval_metrics.EvalMetric):'
- rank: 861
  id: google.adk.evaluation.rubric_based_tool_use_quality_v1.RubricBasedToolUseV1Evaluator.format_auto_rater_prompt
  name: format_auto_rater_prompt
  file_path: src/google/adk/evaluation/rubric_based_tool_use_quality_v1.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns the autorater prompt.
  signature: 'def format_auto_rater_prompt(self, actual_invocation: google.adk.evaluation.eval_case.Invocation, _: typing.Optional[google.adk.evaluation.eval_case.Invocation]) -> str:'
- rank: 862
  id: google.adk.evaluation.safety_evaluator
  name: safety_evaluator
  file_path: src/google/adk/evaluation/safety_evaluator.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 863
  id: google.adk.evaluation.safety_evaluator.SafetyEvaluatorV1
  name: SafetyEvaluatorV1
  file_path: src/google/adk/evaluation/safety_evaluator.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Evaluates safety (harmlessness) of an Agent''s Response.


    The class delegates the responsibility to Vertex Gen AI Eval SDK. The V1

    suffix in the class name is added to convey that there could be other versions

    of the safety metric as well, and those metrics could use a different strategy

    to evaluate safety.


    Using this class requires a GCP project. Please set GOOGLE_CLOUD_PROJECT and

    GOOGLE_CLOUD_LOCATION in your .env file.


    Value range of the metric is [0, 1], with values closer to 1 to be more

    desirable (safe).


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, eval_metric: google.adk.evaluation.eval_metrics.EvalMetric):'
  methods:
  - signature: 'def evaluate_invocations(self, actual_invocations: list[google.adk.evaluation.eval_case.Invocation], expected_invocations: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]], conversation_scenario: typing.Optional[google.adk.evaluation.eval_case.ConversationScenario]) -> google.adk.evaluation.evaluator.EvaluationResult:'
  inherited_methods:
    Evaluator:
    - signature: 'def evaluate_invocations(self, actual_invocations: list[google.adk.evaluation.eval_case.Invocation], expected_invocations: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]], conversation_scenario: typing.Optional[google.adk.evaluation.eval_case.ConversationScenario]) -> google.adk.evaluation.evaluator.EvaluationResult:'
      docstring: "Returns EvaluationResult after performing evaluations using actual and expected invocations.\n\nArgs:\n  actual_invocations: These are the invocations that are obtained from the\n    agent under test.\n  expected_invocations: An optional list of invocations, if specified,\n    usually act as a benchmark/golden response. If these are specified\n    usually the expectation is that the length of this list and actual\n    invocation is the same.\n  conversation_scenario: An optional conversation scenario for multi-turn\n    conversations."
  inherited_properties:
    Evaluator:
    - signature: 'criterion_type: typing.ClassVar[type[google.adk.evaluation.eval_metrics.BaseCriterion]]'
  omitted_inherited_members_from:
  - ABC
- rank: 864
  id: google.adk.evaluation.safety_evaluator.SafetyEvaluatorV1.evaluate_invocations
  name: evaluate_invocations
  file_path: src/google/adk/evaluation/safety_evaluator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def evaluate_invocations(self, actual_invocations: list[google.adk.evaluation.eval_case.Invocation], expected_invocations: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]], conversation_scenario: typing.Optional[google.adk.evaluation.eval_case.ConversationScenario]) -> google.adk.evaluation.evaluator.EvaluationResult:'
- rank: 865
  id: google.adk.evaluation.simulation
  name: simulation
  file_path: src/google/adk/evaluation/simulation/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 866
  id: google.adk.evaluation.simulation.llm_backed_user_simulator
  name: llm_backed_user_simulator
  file_path: src/google/adk/evaluation/simulation/llm_backed_user_simulator.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '_AUTHOR_USER: str'
  - signature: '_STOP_SIGNAL: str'
  - signature: '_DEFAULT_USER_AGENT_INSTRUCTIONS: str'
- rank: 867
  id: google.adk.evaluation.simulation.llm_backed_user_simulator.LlmBackedUserSimulator
  name: LlmBackedUserSimulator
  file_path: src/google/adk/evaluation/simulation/llm_backed_user_simulator.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A UserSimulator that uses an LLM to generate messages on behalf of the user.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, *, config: google.adk.evaluation.simulation.user_simulator.BaseUserSimulatorConfig, conversation_scenario: google.adk.evaluation.conversation_scenarios.ConversationScenario):'
  methods:
  - signature: 'def get_next_user_message(self, events: list[google.adk.events.event.Event]) -> google.adk.evaluation.simulation.user_simulator.NextUserMessage:'
    docstring: "Returns the next user message to send to the agent with help from a LLM.\n\nArgs:\n  events: The unaltered conversation history between the user and the\n    agent(s) under evaluation.\n\nReturns:\n  A NextUserMessage object containing the next user message to send to the\n  agent, or a status indicating why no message was generated.\n\nRaises:\n  RuntimeError: If the user agent fails to generate a message. This is not a\n  valid result for the LLM backed user simulator and is different from the\n  NO_MESSAGE_GENERATED status."
  - signature: 'def get_simulation_evaluator(self) -> typing.Optional[google.adk.evaluation.evaluator.Evaluator]:'
    docstring: Returns an Evaluator that evaluates if the simulation was successful or not.
  properties:
  - signature: 'config_type: typing.ClassVar[type[google.adk.evaluation.simulation.llm_backed_user_simulator.LlmBackedUserSimulatorConfig]]'
  inherited_methods:
    UserSimulator:
    - signature: 'def get_next_user_message(self, events: list[google.adk.events.event.Event]) -> google.adk.evaluation.simulation.user_simulator.NextUserMessage:'
      docstring: "Returns the next user message to send to the agent.\n\nArgs:\n  events: The unaltered conversation history between the user and the\n    agent(s) under evaluation.\n\nReturns:\n  A NextUserMessage object containing the next user message to send to the\n  agent, or a status indicating why no message was generated."
    - signature: 'def get_simulation_evaluator(self) -> typing.Optional[google.adk.evaluation.evaluator.Evaluator]:'
      docstring: Returns an instance of an Evaluator that evaluates if the user simulation was successful or not.
  omitted_inherited_members_from:
  - ABC
- rank: 868
  id: google.adk.evaluation.simulation.llm_backed_user_simulator.LlmBackedUserSimulator.__init__
  name: __init__
  file_path: src/google/adk/evaluation/simulation/llm_backed_user_simulator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, *, config: google.adk.evaluation.simulation.user_simulator.BaseUserSimulatorConfig, conversation_scenario: google.adk.evaluation.conversation_scenarios.ConversationScenario):'
- rank: 869
  id: google.adk.evaluation.simulation.llm_backed_user_simulator.LlmBackedUserSimulator.get_next_user_message
  name: get_next_user_message
  file_path: src/google/adk/evaluation/simulation/llm_backed_user_simulator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Returns the next user message to send to the agent with help from a LLM.\n\nArgs:\n  events: The unaltered conversation history between the user and the\n    agent(s) under evaluation.\n\nReturns:\n  A NextUserMessage object containing the next user message to send to the\n  agent, or a status indicating why no message was generated.\n\nRaises:\n  RuntimeError: If the user agent fails to generate a message. This is not a\n  valid result for the LLM backed user simulator and is different from the\n  NO_MESSAGE_GENERATED status."
  signature: 'def get_next_user_message(self, events: list[google.adk.events.event.Event]) -> google.adk.evaluation.simulation.user_simulator.NextUserMessage:'
- rank: 870
  id: google.adk.evaluation.simulation.llm_backed_user_simulator.LlmBackedUserSimulator.get_simulation_evaluator
  name: get_simulation_evaluator
  file_path: src/google/adk/evaluation/simulation/llm_backed_user_simulator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns an Evaluator that evaluates if the simulation was successful or not.
  signature: 'def get_simulation_evaluator(self) -> typing.Optional[google.adk.evaluation.evaluator.Evaluator]:'
- rank: 871
  id: google.adk.evaluation.simulation.llm_backed_user_simulator.LlmBackedUserSimulatorConfig
  name: LlmBackedUserSimulatorConfig
  file_path: src/google/adk/evaluation/simulation/llm_backed_user_simulator.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Contains configurations required by an LLM backed user simulator.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, model: str = ''gemini-2.5-flash'', model_configuration: google.genai.types.GenerateContentConfig = Factory(lambda: genai_types.GenerateContentConfig(thinking_config=genai_types.ThinkingConfig(include_thoughts=True, thinking_budget=10240))), max_allowed_invocations: int = 20, custom_instructions: typing.Optional[str] = None):'
  methods:
  - signature: 'def validate_custom_instructions(cls, value: typing.Optional[str]) -> typing.Optional[str]:'
  properties:
  - signature: 'model: str'
  - signature: 'model_configuration: google.genai.types.GenerateContentConfig'
  - signature: 'max_allowed_invocations: int'
  - signature: 'custom_instructions: typing.Optional[str]'
  inherited_properties:
    BaseUserSimulatorConfig:
    - signature: 'model_config: pydantic.ConfigDict'
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 872
  id: google.adk.evaluation.simulation.llm_backed_user_simulator.LlmBackedUserSimulatorConfig.validate_custom_instructions
  name: validate_custom_instructions
  file_path: src/google/adk/evaluation/simulation/llm_backed_user_simulator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def validate_custom_instructions(cls, value: typing.Optional[str]) -> typing.Optional[str]:'
- rank: 873
  id: google.adk.evaluation.simulation.per_turn_user_simulator_quality_v1
  name: per_turn_user_simulator_quality_v1
  file_path: src/google/adk/evaluation/simulation/per_turn_user_simulator_quality_v1.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: "_LATEST_TURN_USER_SIMULATOR_EVALUATOR_PROMPT: \nYou are a data scientist tasked with evaluating the quality of a User Simulator that is interacting with an Agent.\nYour task is to determine if the Generated User Response is consistent with:\n  - The Conversation Plan: A list of high-level goals that the User Simulator is expected to achieve in the conversation.\n  - The Conversation History: The exchange between the User Simulator and the Agent so far.\nTo determine this, we provide specific Evaluation Criteria that must be satisfied by the Generated User Response.\n\n# Definition of Conversation Plan\nThe Conversation Plan specifies the goals that the User Simulator must execute.\nThe Conversation Plan also specifies the information and details that are needed to complete the goals.\nThe Conversation Plan is sequential in nature and the User Simulator must ensure the sequence is followed.\n\n# Definition of Conversation History\nThe Conversation History is the actual dialogue\
      \ between the User Simulator and the Agent.\nThe Conversation History may not be complete, but the existing dialogue should adhere to the Conversation Plan.\nThe Conversation History may contain instances where the User Simulator troubleshoots an incorrect/inappropriate response from the Agent in order to enforce the Conversation Plan.\nThe Conversation History is finished only when the User Simulator outputs `{stop_signal}` in its response. If this token is missing, the conversation between the User Simulator and the Agent has not finished, and more turns can be generated.\n\n# Definition of Generated User Response\nThe Generated User Response is a the next user response in the conversation between a User Simulator and an Agent.\nThe Generated User Response was generated by the User Simulator based on a Conversation Plan and Conversation History.\n\n# Evaluation Criteria\nYour task is to evaluate the Generated User Response on a PASS/FAIL basis looking for specific errors.\nThe Generated\
      \ User Response is marked as PASS unless it contains any of the Violations listed below, in which case it is marked as FAIL.\n\n** CONVERSATION_PLAN_FOLLOWED **\nDoes the Generated User Response stick to the Conversation Plan?\n\nMark as FAIL if any of the following Violations occur:\n- The Generated User Response repeats a high-level goal that was already completed in previous turns.\n- The Generated User Response provides details for a high-level goal that was already completed.\n- The Generated User Response response agrees to change the topic or perform a task not listed in the Conversation Plan.\n- The Generated User Response invents a new goal not present in the Conversation Plan.\n- The Generated User Response invents details (e.g., a made-up phone number or address) not provided in the Conversation Plan.\n\n** STOP_CONDITION_FOLLOWED **\nDid the conversation end exactly when it was supposed to?\n\nMark as FAIL if any of the following Violations occur:\n- The conversation should\
      \ have ended, but the Generated User Response did not use `{stop_signal}`.\n- The Generated User Response used `{stop_signal}`, but tasks in the Conversation Plan are still incomplete AND the Agent has not failed.\n- The Agent successfully transferred the User Simulator to a human/live agent, but the Generated User Response continued instead of using `{stop_signal}`.\n\n** USER_GOAL_ORIENTED **\nIs the User Simulator acting naturally, or is it \"data dumping\"?\n\nMark as FAIL if any of the following Violations occur:\n- The Generated User Response provides specific details for a high-level goal (email content, recipient address, phone numbers) BEFORE the Agent has explicitly asked for them.\n- The Generated User Response tries to accomplish more than one high-level task in a single turn.\n\n** LIMITED_TROUBLESHOOTING **\nDoes the User Simulator have the correct amount of patience? (Note: Please check the conversation history and count the number of Agent errors).\n\nMark as FAIL if\
      \ any of the following Violations occur:\n- The Generated User Response ends the conversation immediately after the first Agent error.\n- On the second Agent error, the Generated User Response response continues the conversation without using `{stop_signal}`.\n- After the second Agent error, the Generated User Response tries to continue the conversation or continues addressing errors without using `{stop_signal}`.\n\n** RESPONSIVENESS **\nDoes the User Simulator answer what is asked?\n\nMark as FAIL if any of the following Violations occur:\n- The Agent asked a question (or multiple questions), and the Generated User Response failed to address one or all of them.\n- The Agent asked for information NOT in the Conversation Plan, and the Generated User Response made up an answer instead of stating, e.g., \"I don't know\" or \"I don't have that info.\"\n\n** CORRECTS_AGENT  **\nDoes the User Simulator catch the Agent's mistakes?\n\nMark as FAIL if any of the following Violations occur:\n\
      - The Agent provided incorrect information, but the Generated User Response continued as if it was correct.\n- The Agent made a dangerous assumption (e.g., sending an email without asking for the content first), and the Generated User Response continues without correcting the Agent.\n\n** CONVERSATIONAL_TONE **\nDoes the User Simulator sound like a human?\n\nMark as FAIL if any of the following Violations occur:\n- The Generated User Response uses overly complex sentence structures, or uses technical jargon inappropriately.\n- The Generated User Response is sterile and purely functional (direct commands) with no natural conversational framing.\n- The Generated User Response is too formal in nature, employing overly polite phrases and expressions.\n- The Generated User Response is a \"wall of text\" where a simple sentence would suffice.\n\n# Output Format\nFormat your response in the following JSON format:\n{{\n    \"criteria\": [\n        {{\n          \"name\": \"CRITERIA_NAME_1\"\
      ,\n          \"reasoning\": \"reasoning\",\n          \"passes\": True or False,\n        }},\n        {{\n          \"name\": \"CRITERIA_NAME_2\",\n          \"reasoning\": \"reasoning\",\n          \"passes\": True or False,\n        }},\n        ...\n    ],\n    \"is_valid\": True or False,\n}}\n\n# Conversation Plan\n{conversation_plan}\n\n# Conversation History\n{conversation_history}\n\n# Generated User Response\n{generated_user_response}\n.strip"
- rank: 874
  id: google.adk.evaluation.simulation.per_turn_user_simulator_quality_v1.PerTurnUserSimulatorQualityV1
  name: PerTurnUserSimulatorQualityV1
  file_path: src/google/adk/evaluation/simulation/per_turn_user_simulator_quality_v1.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "Per turn user simulator evaluator.\n\nThis evaluator verifies that the conversation from a user simulator sticks\nto the given conversation scenario:\n- In the first turn, it verifies that the user simulator output the\n  specified starting prompt.\n- For all the other turns, it verifies that the user simulator stuck to the\n  conversation plan.\n- It also verifies that the user simulator finished the conversation\n  appropriately.\nThis evaluator uses an LLM to verify all turns except the first one. It\naggregates repeated invocation samples by taking majority vote. The overall\nscore is the fraction of turns of the conversation before the verifier\ndetects an issue with the user simulator.\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, eval_metric: google.adk.evaluation.eval_metrics.EvalMetric):'
  methods:
  - signature: 'def evaluate_invocations(self, actual_invocations: list[google.adk.evaluation.eval_case.Invocation], expected_invocations: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]], conversation_scenario: typing.Optional[google.adk.evaluation.eval_case.ConversationScenario]) -> google.adk.evaluation.evaluator.EvaluationResult:'
  properties:
  - signature: 'criterion_type: typing.ClassVar[type[google.adk.evaluation.eval_metrics.LlmBackedUserSimulatorCriterion]]'
  inherited_methods:
    Evaluator:
    - signature: 'def evaluate_invocations(self, actual_invocations: list[google.adk.evaluation.eval_case.Invocation], expected_invocations: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]], conversation_scenario: typing.Optional[google.adk.evaluation.eval_case.ConversationScenario]) -> google.adk.evaluation.evaluator.EvaluationResult:'
      docstring: "Returns EvaluationResult after performing evaluations using actual and expected invocations.\n\nArgs:\n  actual_invocations: These are the invocations that are obtained from the\n    agent under test.\n  expected_invocations: An optional list of invocations, if specified,\n    usually act as a benchmark/golden response. If these are specified\n    usually the expectation is that the length of this list and actual\n    invocation is the same.\n  conversation_scenario: An optional conversation scenario for multi-turn\n    conversations."
  inherited_properties:
    Evaluator:
    - signature: 'criterion_type: typing.ClassVar[type[google.adk.evaluation.eval_metrics.BaseCriterion]]'
  omitted_inherited_members_from:
  - ABC
- rank: 875
  id: google.adk.evaluation.simulation.per_turn_user_simulator_quality_v1.PerTurnUserSimulatorQualityV1.__init__
  name: __init__
  file_path: src/google/adk/evaluation/simulation/per_turn_user_simulator_quality_v1.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, eval_metric: google.adk.evaluation.eval_metrics.EvalMetric):'
- rank: 876
  id: google.adk.evaluation.simulation.per_turn_user_simulator_quality_v1.PerTurnUserSimulatorQualityV1.evaluate_invocations
  name: evaluate_invocations
  file_path: src/google/adk/evaluation/simulation/per_turn_user_simulator_quality_v1.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def evaluate_invocations(self, actual_invocations: list[google.adk.evaluation.eval_case.Invocation], expected_invocations: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]], conversation_scenario: typing.Optional[google.adk.evaluation.eval_case.ConversationScenario]) -> google.adk.evaluation.evaluator.EvaluationResult:'
- rank: 877
  id: google.adk.evaluation.simulation.static_user_simulator
  name: static_user_simulator
  file_path: src/google/adk/evaluation/simulation/static_user_simulator.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 878
  id: google.adk.evaluation.simulation.static_user_simulator.StaticUserSimulator
  name: StaticUserSimulator
  file_path: src/google/adk/evaluation/simulation/static_user_simulator.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A UserSimulator that returns a static list of user messages.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, *, static_conversation: google.adk.evaluation.eval_case.StaticConversation):'
  methods:
  - signature: 'def get_next_user_message(self, events: list[google.adk.events.event.Event]) -> google.adk.evaluation.simulation.user_simulator.NextUserMessage:'
    docstring: "Returns the next user message to send to the agent from a static list.\n\nArgs:\n  events: The unaltered conversation history between the user and the\n    agent(s) under evaluation.\n\nReturns:\n  A NextUserMessage object containing the next user message to send to the\n  agent, or a status indicating why no message was generated."
  - signature: 'def get_simulation_evaluator(self) -> typing.Optional[google.adk.evaluation.evaluator.Evaluator]:'
    docstring: The StaticUserSimulator does not require an evaluator.
  inherited_methods:
    UserSimulator:
    - signature: 'def get_next_user_message(self, events: list[google.adk.events.event.Event]) -> google.adk.evaluation.simulation.user_simulator.NextUserMessage:'
      docstring: "Returns the next user message to send to the agent.\n\nArgs:\n  events: The unaltered conversation history between the user and the\n    agent(s) under evaluation.\n\nReturns:\n  A NextUserMessage object containing the next user message to send to the\n  agent, or a status indicating why no message was generated."
    - signature: 'def get_simulation_evaluator(self) -> typing.Optional[google.adk.evaluation.evaluator.Evaluator]:'
      docstring: Returns an instance of an Evaluator that evaluates if the user simulation was successful or not.
  omitted_inherited_members_from:
  - ABC
- rank: 879
  id: google.adk.evaluation.simulation.static_user_simulator.StaticUserSimulator.__init__
  name: __init__
  file_path: src/google/adk/evaluation/simulation/static_user_simulator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, *, static_conversation: google.adk.evaluation.eval_case.StaticConversation):'
- rank: 880
  id: google.adk.evaluation.simulation.static_user_simulator.StaticUserSimulator.get_next_user_message
  name: get_next_user_message
  file_path: src/google/adk/evaluation/simulation/static_user_simulator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Returns the next user message to send to the agent from a static list.\n\nArgs:\n  events: The unaltered conversation history between the user and the\n    agent(s) under evaluation.\n\nReturns:\n  A NextUserMessage object containing the next user message to send to the\n  agent, or a status indicating why no message was generated."
  signature: 'def get_next_user_message(self, events: list[google.adk.events.event.Event]) -> google.adk.evaluation.simulation.user_simulator.NextUserMessage:'
- rank: 881
  id: google.adk.evaluation.simulation.static_user_simulator.StaticUserSimulator.get_simulation_evaluator
  name: get_simulation_evaluator
  file_path: src/google/adk/evaluation/simulation/static_user_simulator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: The StaticUserSimulator does not require an evaluator.
  signature: 'def get_simulation_evaluator(self) -> typing.Optional[google.adk.evaluation.evaluator.Evaluator]:'
- rank: 882
  id: google.adk.evaluation.simulation.user_simulator
  name: user_simulator
  file_path: src/google/adk/evaluation/simulation/user_simulator.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 883
  id: google.adk.evaluation.simulation.user_simulator.BaseUserSimulatorConfig
  name: BaseUserSimulatorConfig
  file_path: src/google/adk/evaluation/simulation/user_simulator.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Base class for configurations pertaining to user simulator.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 884
  id: google.adk.evaluation.simulation.user_simulator.NextUserMessage
  name: NextUserMessage
  file_path: src/google/adk/evaluation/simulation/user_simulator.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, status: google.adk.evaluation.simulation.user_simulator.Status, user_message: typing.Optional[google.genai.types.Content] = None):'
  methods:
  - signature: 'def ensure_user_message_iff_success(self) -> google.adk.evaluation.simulation.user_simulator.NextUserMessage:'
  properties:
  - signature: 'status: google.adk.evaluation.simulation.user_simulator.Status'
  - signature: 'user_message: typing.Optional[google.genai.types.Content]'
  inherited_properties:
    EvalBaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 885
  id: google.adk.evaluation.simulation.user_simulator.NextUserMessage.ensure_user_message_iff_success
  name: ensure_user_message_iff_success
  file_path: src/google/adk/evaluation/simulation/user_simulator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def ensure_user_message_iff_success(self) -> google.adk.evaluation.simulation.user_simulator.NextUserMessage:'
- rank: 886
  id: google.adk.evaluation.simulation.user_simulator.Status
  name: Status
  file_path: src/google/adk/evaluation/simulation/user_simulator.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'The resulting status of get_next_user_message().


    [Note: Inherited members from enum.Enum are omitted.]'
  properties:
  - signature: 'SUCCESS: str'
  - signature: 'TURN_LIMIT_REACHED: str'
  - signature: 'STOP_SIGNAL_DETECTED: str'
  - signature: 'NO_MESSAGE_GENERATED: str'
  omitted_inherited_members_from:
  - enum.Enum
- rank: 887
  id: google.adk.evaluation.simulation.user_simulator.UserSimulator
  name: UserSimulator
  file_path: src/google/adk/evaluation/simulation/user_simulator.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A user simulator for the purposes of automating interaction with an Agent.


    Typically, you must create one user simulator instance per eval case.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, config: google.adk.evaluation.simulation.user_simulator.BaseUserSimulatorConfig, config_type: type[google.adk.evaluation.simulation.user_simulator.BaseUserSimulatorConfig]):'
  methods:
  - signature: 'def get_next_user_message(self, events: list[google.adk.events.event.Event]) -> google.adk.evaluation.simulation.user_simulator.NextUserMessage:'
    docstring: "Returns the next user message to send to the agent.\n\nArgs:\n  events: The unaltered conversation history between the user and the\n    agent(s) under evaluation.\n\nReturns:\n  A NextUserMessage object containing the next user message to send to the\n  agent, or a status indicating why no message was generated."
  - signature: 'def get_simulation_evaluator(self) -> typing.Optional[google.adk.evaluation.evaluator.Evaluator]:'
    docstring: Returns an instance of an Evaluator that evaluates if the user simulation was successful or not.
  omitted_inherited_members_from:
  - ABC
- rank: 888
  id: google.adk.evaluation.simulation.user_simulator.UserSimulator.__init__
  name: __init__
  file_path: src/google/adk/evaluation/simulation/user_simulator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, config: google.adk.evaluation.simulation.user_simulator.BaseUserSimulatorConfig, config_type: type[google.adk.evaluation.simulation.user_simulator.BaseUserSimulatorConfig]):'
- rank: 889
  id: google.adk.evaluation.simulation.user_simulator.UserSimulator.get_next_user_message
  name: get_next_user_message
  file_path: src/google/adk/evaluation/simulation/user_simulator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Returns the next user message to send to the agent.\n\nArgs:\n  events: The unaltered conversation history between the user and the\n    agent(s) under evaluation.\n\nReturns:\n  A NextUserMessage object containing the next user message to send to the\n  agent, or a status indicating why no message was generated."
  signature: 'def get_next_user_message(self, events: list[google.adk.events.event.Event]) -> google.adk.evaluation.simulation.user_simulator.NextUserMessage:'
- rank: 890
  id: google.adk.evaluation.simulation.user_simulator.UserSimulator.get_simulation_evaluator
  name: get_simulation_evaluator
  file_path: src/google/adk/evaluation/simulation/user_simulator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns an instance of an Evaluator that evaluates if the user simulation was successful or not.
  signature: 'def get_simulation_evaluator(self) -> typing.Optional[google.adk.evaluation.evaluator.Evaluator]:'
- rank: 891
  id: google.adk.evaluation.simulation.user_simulator_provider
  name: user_simulator_provider
  file_path: src/google/adk/evaluation/simulation/user_simulator_provider.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 892
  id: google.adk.evaluation.simulation.user_simulator_provider.UserSimulatorProvider
  name: UserSimulatorProvider
  file_path: src/google/adk/evaluation/simulation/user_simulator_provider.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Provides a UserSimulator instance per EvalCase, mixing configuration data

    from the EvalConfig with per-EvalCase conversation data.'
  constructor_signature: 'def __init__(self, user_simulator_config: typing.Optional[google.adk.evaluation.simulation.user_simulator.BaseUserSimulatorConfig]):'
  methods:
  - signature: 'def provide(self, eval_case: google.adk.evaluation.eval_case.EvalCase) -> google.adk.evaluation.simulation.user_simulator.UserSimulator:'
    docstring: "Provide an appropriate user simulator based on the type of conversation data in the EvalCase\n\nArgs:\n  eval_case: An EvalCase containing a `conversation` xor a\n    `conversation_scenario`.\n\nReturns:\n  A StaticUserSimulator or an LlmBackedUserSimulator based on the type of\n  the conversation data.\n\nRaises:\n  ValueError: If no conversation data or multiple types of conversation data\n  are provided."
- rank: 893
  id: google.adk.evaluation.simulation.user_simulator_provider.UserSimulatorProvider.__init__
  name: __init__
  file_path: src/google/adk/evaluation/simulation/user_simulator_provider.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, user_simulator_config: typing.Optional[google.adk.evaluation.simulation.user_simulator.BaseUserSimulatorConfig]):'
- rank: 894
  id: google.adk.evaluation.simulation.user_simulator_provider.UserSimulatorProvider.provide
  name: provide
  file_path: src/google/adk/evaluation/simulation/user_simulator_provider.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Provide an appropriate user simulator based on the type of conversation data in the EvalCase\n\nArgs:\n  eval_case: An EvalCase containing a `conversation` xor a\n    `conversation_scenario`.\n\nReturns:\n  A StaticUserSimulator or an LlmBackedUserSimulator based on the type of\n  the conversation data.\n\nRaises:\n  ValueError: If no conversation data or multiple types of conversation data\n  are provided."
  signature: 'def provide(self, eval_case: google.adk.evaluation.eval_case.EvalCase) -> google.adk.evaluation.simulation.user_simulator.UserSimulator:'
- rank: 895
  id: google.adk.evaluation.trajectory_evaluator
  name: trajectory_evaluator
  file_path: src/google/adk/evaluation/trajectory_evaluator.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 896
  id: google.adk.evaluation.trajectory_evaluator.TrajectoryEvaluator
  name: TrajectoryEvaluator
  file_path: src/google/adk/evaluation/trajectory_evaluator.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "Evaluates tool use trajectories for accuracy.\n\nThis evaluator compares the sequence of tools called by the agent against a\nlist of expected calls and computes an average score based on one of the match\ntypes: `EXACT`, `IN_ORDER`, or `ANY_ORDER`.\n\nFor each invocation being evaluated, this evaluator compares the list of\ntool calls produced by the agent with the list of expected tool calls using\none of three match types. If the tool calls match based on the selected match\ntype, a score of 1.0 is awarded for that invocation, otherwise the score is\n0.0. The final value is the average of these scores across all\ninvocations in the eval case.\n\nThe comparison can be done using one of following match types:\n  - `EXACT`: Requires a perfect match between the actual and expected tool\n    calls, with no extra or missing tool calls.\n  - `IN_ORDER`: Requires all tool calls from the expected list to be present\n    in the actual list, in the same order, but allows for other\
    \ tool calls\n    to appear in between.\n  - `ANY_ORDER`: Requires all tool calls from the expected list to be\n    present in the actual list, in any order, and allows for other tool\n    calls to appear in between.\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, threshold: typing.Optional[float], eval_metric: typing.Optional[google.adk.evaluation.eval_metrics.EvalMetric]):'
  methods:
  - signature: 'def evaluate_invocations(self, actual_invocations: list[google.adk.evaluation.eval_case.Invocation], expected_invocations: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]], conversation_scenario: typing.Optional[google.adk.evaluation.eval_case.ConversationScenario]) -> google.adk.evaluation.evaluator.EvaluationResult:'
    docstring: Returns EvaluationResult after performing evaluations using actual and expected invocations.
  properties:
  - signature: 'criterion_type: typing.ClassVar[type[google.adk.evaluation.eval_metrics.ToolTrajectoryCriterion]]'
  inherited_methods:
    Evaluator:
    - signature: 'def evaluate_invocations(self, actual_invocations: list[google.adk.evaluation.eval_case.Invocation], expected_invocations: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]], conversation_scenario: typing.Optional[google.adk.evaluation.eval_case.ConversationScenario]) -> google.adk.evaluation.evaluator.EvaluationResult:'
      docstring: "Returns EvaluationResult after performing evaluations using actual and expected invocations.\n\nArgs:\n  actual_invocations: These are the invocations that are obtained from the\n    agent under test.\n  expected_invocations: An optional list of invocations, if specified,\n    usually act as a benchmark/golden response. If these are specified\n    usually the expectation is that the length of this list and actual\n    invocation is the same.\n  conversation_scenario: An optional conversation scenario for multi-turn\n    conversations."
  inherited_properties:
    Evaluator:
    - signature: 'criterion_type: typing.ClassVar[type[google.adk.evaluation.eval_metrics.BaseCriterion]]'
  omitted_inherited_members_from:
  - ABC
- rank: 897
  id: google.adk.evaluation.trajectory_evaluator.TrajectoryEvaluator.__init__
  name: __init__
  file_path: src/google/adk/evaluation/trajectory_evaluator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, threshold: typing.Optional[float], eval_metric: typing.Optional[google.adk.evaluation.eval_metrics.EvalMetric]):'
- rank: 898
  id: google.adk.evaluation.trajectory_evaluator.TrajectoryEvaluator.evaluate_invocations
  name: evaluate_invocations
  file_path: src/google/adk/evaluation/trajectory_evaluator.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns EvaluationResult after performing evaluations using actual and expected invocations.
  signature: 'def evaluate_invocations(self, actual_invocations: list[google.adk.evaluation.eval_case.Invocation], expected_invocations: typing.Optional[list[google.adk.evaluation.eval_case.Invocation]], conversation_scenario: typing.Optional[google.adk.evaluation.eval_case.ConversationScenario]) -> google.adk.evaluation.evaluator.EvaluationResult:'
- rank: 899
  id: google.adk.evaluation.vertex_ai_eval_facade
  name: vertex_ai_eval_facade
  file_path: src/google/adk/evaluation/vertex_ai_eval_facade.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: '_ERROR_MESSAGE_SUFFIX: str'
- rank: 900
  id: google.adk.events
  name: events
  file_path: src/google/adk/events/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: '__all__: Any'
- rank: 901
  id: google.adk.events.event
  name: event
  file_path: src/google/adk/events/event.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 902
  id: google.adk.events.event.Event.get_function_calls
  name: get_function_calls
  file_path: src/google/adk/events/event.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns the function calls in the event.
  signature: 'def get_function_calls(self) -> list[google.genai.types.FunctionCall]:'
- rank: 903
  id: google.adk.events.event.Event.get_function_responses
  name: get_function_responses
  file_path: src/google/adk/events/event.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns the function responses in the event.
  signature: 'def get_function_responses(self) -> list[google.genai.types.FunctionResponse]:'
- rank: 904
  id: google.adk.events.event.Event.has_trailing_code_execution_result
  name: has_trailing_code_execution_result
  file_path: src/google/adk/events/event.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns whether the event has a trailing code execution result.
  signature: 'def has_trailing_code_execution_result(self) -> bool:'
- rank: 905
  id: google.adk.events.event.Event.is_final_response
  name: is_final_response
  file_path: src/google/adk/events/event.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Returns whether the event is the final response of an agent.


    NOTE: This method is ONLY for use by Agent Development Kit.


    Note that when multiple agents participate in one invocation, there could be

    one event has `is_final_response()` as True for each participating agent.'
  signature: 'def is_final_response(self) -> bool:'
- rank: 906
  id: google.adk.events.event.Event.model_post_init
  name: model_post_init
  file_path: src/google/adk/events/event.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Post initialization logic for the event.
  signature: 'def model_post_init(self, __context):'
- rank: 907
  id: google.adk.events.event_actions
  name: event_actions
  file_path: src/google/adk/events/event_actions.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 908
  id: google.adk.events.event_actions.EventCompaction
  name: EventCompaction
  file_path: src/google/adk/events/event_actions.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'The compaction of the events.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, start_timestamp: float, end_timestamp: float, compacted_content: google.genai.types.Content):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
    docstring: The pydantic model config.
  - signature: 'start_timestamp: float'
    docstring: The start timestamp of the compacted events, in seconds.
  - signature: 'end_timestamp: float'
    docstring: The end timestamp of the compacted events, in seconds.
  - signature: 'compacted_content: google.genai.types.Content'
    docstring: The compacted content of the events.
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 909
  id: google.adk.examples
  name: examples
  file_path: src/google/adk/examples/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: '__all__: Any'
- rank: 910
  id: google.adk.examples.base_example_provider
  name: base_example_provider
  file_path: src/google/adk/examples/base_example_provider.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 911
  id: google.adk.examples.base_example_provider.BaseExampleProvider
  name: BaseExampleProvider
  file_path: src/google/adk/examples/base_example_provider.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Base class for example providers.


    This class defines the interface for providing examples for a given query.


    [Note: Inherited members from abc.ABC are omitted.]'
  methods:
  - signature: 'def get_examples(self, query: str) -> list[google.adk.examples.example.Example]:'
    docstring: "Returns a list of examples for a given query.\n\nArgs:\n    query: The query to get examples for.\n\nReturns:\n    A list of Example objects."
  omitted_inherited_members_from:
  - abc.ABC
- rank: 912
  id: google.adk.examples.base_example_provider.BaseExampleProvider.get_examples
  name: get_examples
  file_path: src/google/adk/examples/base_example_provider.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Returns a list of examples for a given query.\n\nArgs:\n    query: The query to get examples for.\n\nReturns:\n    A list of Example objects."
  signature: 'def get_examples(self, query: str) -> list[google.adk.examples.example.Example]:'
- rank: 913
  id: google.adk.examples.example
  name: example
  file_path: src/google/adk/examples/example.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 914
  id: google.adk.examples.example_util
  name: example_util
  file_path: src/google/adk/examples/example_util.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def convert_examples_to_text(examples: list[google.adk.examples.example.Example], model: typing.Optional[str]) -> str:'
    docstring: Converts a list of examples to a string that can be used in a system instruction.
  - signature: 'def build_example_si(examples: typing.Union[list[google.adk.examples.example.Example], google.adk.examples.base_example_provider.BaseExampleProvider], query: str, model: typing.Optional[str]) -> str:'
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '_EXAMPLES_INTRO: str'
  - signature: '_EXAMPLES_END: str'
  - signature: '_EXAMPLE_START: str'
  - signature: '_EXAMPLE_END: str'
  - signature: '_USER_PREFIX: str'
  - signature: '_MODEL_PREFIX: str'
  - signature: '_FUNCTION_PREFIX: str'
  - signature: '_FUNCTION_CALL_PREFIX: str'
  - signature: '_FUNCTION_CALL_SUFFIX: str'
  - signature: '_FUNCTION_RESPONSE_PREFIX: str'
  - signature: '_FUNCTION_RESPONSE_SUFFIX: str'
- rank: 915
  id: google.adk.examples.example_util.build_example_si
  name: build_example_si
  file_path: src/google/adk/examples/example_util.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def build_example_si(examples: typing.Union[list[google.adk.examples.example.Example], google.adk.examples.base_example_provider.BaseExampleProvider], query: str, model: typing.Optional[str]) -> str:'
- rank: 916
  id: google.adk.examples.example_util.convert_examples_to_text
  name: convert_examples_to_text
  file_path: src/google/adk/examples/example_util.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Converts a list of examples to a string that can be used in a system instruction.
  signature: 'def convert_examples_to_text(examples: list[google.adk.examples.example.Example], model: typing.Optional[str]) -> str:'
- rank: 917
  id: google.adk.examples.vertex_ai_example_store
  name: vertex_ai_example_store
  file_path: src/google/adk/examples/vertex_ai_example_store.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 918
  id: google.adk.examples.vertex_ai_example_store.VertexAiExampleStore
  name: VertexAiExampleStore
  file_path: src/google/adk/examples/vertex_ai_example_store.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Provides examples from Vertex example store.


    [Note: Inherited members from abc.ABC are omitted.]'
  constructor_signature: 'def __init__(self, examples_store_name: str):'
  methods:
  - signature: 'def get_examples(self, query: str) -> list[google.adk.examples.example.Example]:'
  inherited_methods:
    BaseExampleProvider:
    - signature: 'def get_examples(self, query: str) -> list[google.adk.examples.example.Example]:'
      docstring: "Returns a list of examples for a given query.\n\nArgs:\n    query: The query to get examples for.\n\nReturns:\n    A list of Example objects."
  omitted_inherited_members_from:
  - abc.ABC
- rank: 919
  id: google.adk.examples.vertex_ai_example_store.VertexAiExampleStore.__init__
  name: __init__
  file_path: src/google/adk/examples/vertex_ai_example_store.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the VertexAiExampleStore.\n\nArgs:\n    examples_store_name: The resource name of the vertex example store, in\n      the format of\n      ``projects/{project}/locations/{location}/exampleStores/{example_store}``."
  signature: 'def __init__(self, examples_store_name: str):'
- rank: 920
  id: google.adk.examples.vertex_ai_example_store.VertexAiExampleStore.get_examples
  name: get_examples
  file_path: src/google/adk/examples/vertex_ai_example_store.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_examples(self, query: str) -> list[google.adk.examples.example.Example]:'
- rank: 921
  id: google.adk.features
  name: features
  file_path: src/google/adk/features/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: '__all__: Any'
- rank: 922
  id: google.adk.flows
  name: flows
  file_path: src/google/adk/flows/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 923
  id: google.adk.flows.llm_flows
  name: llm_flows
  file_path: src/google/adk/flows/llm_flows/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 924
  id: google.adk.flows.llm_flows.agent_transfer
  name: agent_transfer
  file_path: src/google/adk/flows/llm_flows/agent_transfer.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Handles agent transfer for LLM flow.
  properties:
  - signature: 'request_processor: _AgentTransferLlmRequestProcessor'
  - signature: 'line_break: str'
- rank: 925
  id: google.adk.flows.llm_flows.audio_cache_manager
  name: audio_cache_manager
  file_path: src/google/adk/flows/llm_flows/audio_cache_manager.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 926
  id: google.adk.flows.llm_flows.audio_cache_manager.AudioCacheConfig
  name: AudioCacheConfig
  file_path: src/google/adk/flows/llm_flows/audio_cache_manager.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Configuration for audio caching behavior.
  constructor_signature: 'def __init__(self, max_cache_size_bytes: int, max_cache_duration_seconds: float, auto_flush_threshold: int):'
- rank: 927
  id: google.adk.flows.llm_flows.audio_cache_manager.AudioCacheConfig.__init__
  name: __init__
  file_path: src/google/adk/flows/llm_flows/audio_cache_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initialize audio cache configuration.\n\nArgs:\n  max_cache_size_bytes: Maximum cache size in bytes before auto-flush.\n  max_cache_duration_seconds: Maximum duration to keep data in cache.\n  auto_flush_threshold: Number of chunks that triggers auto-flush."
  signature: 'def __init__(self, max_cache_size_bytes: int, max_cache_duration_seconds: float, auto_flush_threshold: int):'
- rank: 928
  id: google.adk.flows.llm_flows.audio_cache_manager.AudioCacheManager
  name: AudioCacheManager
  file_path: src/google/adk/flows/llm_flows/audio_cache_manager.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Manages audio caching and flushing for live streaming flows.
  constructor_signature: 'def __init__(self, config: AudioCacheConfig | None):'
  methods:
  - signature: 'def cache_audio(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, audio_blob: google.genai.types.Blob, cache_type: str) -> None:'
    docstring: "Cache incoming user or outgoing model audio data.\n\nArgs:\n  invocation_context: The current invocation context.\n  audio_blob: The audio data to cache.\n  cache_type: Type of audio to cache, either 'input' or 'output'.\n\nRaises:\n  ValueError: If cache_type is not 'input' or 'output'."
  - signature: 'def flush_caches(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, flush_user_audio: bool, flush_model_audio: bool) -> list[google.adk.events.event.Event]:'
    docstring: "Flush audio caches to artifact services.\n\nThe multimodality data is saved in artifact service in the format of\naudio file. The file data reference is added to the session as an event.\nThe audio file follows the naming convention: artifact_ref =\nf\"artifact://{invocation_context.app_name}/{invocation_context.user_id}/\n{invocation_context.session.id}/_adk_live/{filename}#{revision_id}\"\n\nNote: video data is not supported yet.\n\nArgs:\n  invocation_context: The invocation context containing audio caches.\n  flush_user_audio: Whether to flush the input (user) audio cache.\n  flush_model_audio: Whether to flush the output (model) audio cache.\n\nReturns:\n  A list of Event objects created from the flushed caches."
  - signature: 'def get_cache_stats(self, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> dict[str, int]:'
    docstring: "Get statistics about current cache state.\n\nArgs:\n  invocation_context: The invocation context.\n\nReturns:\n  Dictionary containing cache statistics."
- rank: 929
  id: google.adk.flows.llm_flows.audio_cache_manager.AudioCacheManager.__init__
  name: __init__
  file_path: src/google/adk/flows/llm_flows/audio_cache_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initialize the audio cache manager.\n\nArgs:\n  config: Configuration for audio caching behavior."
  signature: 'def __init__(self, config: AudioCacheConfig | None):'
- rank: 930
  id: google.adk.flows.llm_flows.audio_cache_manager.AudioCacheManager.cache_audio
  name: cache_audio
  file_path: src/google/adk/flows/llm_flows/audio_cache_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Cache incoming user or outgoing model audio data.\n\nArgs:\n  invocation_context: The current invocation context.\n  audio_blob: The audio data to cache.\n  cache_type: Type of audio to cache, either 'input' or 'output'.\n\nRaises:\n  ValueError: If cache_type is not 'input' or 'output'."
  signature: 'def cache_audio(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, audio_blob: google.genai.types.Blob, cache_type: str) -> None:'
- rank: 931
  id: google.adk.flows.llm_flows.audio_cache_manager.AudioCacheManager.flush_caches
  name: flush_caches
  file_path: src/google/adk/flows/llm_flows/audio_cache_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Flush audio caches to artifact services.\n\nThe multimodality data is saved in artifact service in the format of\naudio file. The file data reference is added to the session as an event.\nThe audio file follows the naming convention: artifact_ref =\nf\"artifact://{invocation_context.app_name}/{invocation_context.user_id}/\n{invocation_context.session.id}/_adk_live/{filename}#{revision_id}\"\n\nNote: video data is not supported yet.\n\nArgs:\n  invocation_context: The invocation context containing audio caches.\n  flush_user_audio: Whether to flush the input (user) audio cache.\n  flush_model_audio: Whether to flush the output (model) audio cache.\n\nReturns:\n  A list of Event objects created from the flushed caches."
  signature: 'def flush_caches(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, flush_user_audio: bool, flush_model_audio: bool) -> list[google.adk.events.event.Event]:'
- rank: 932
  id: google.adk.flows.llm_flows.audio_cache_manager.AudioCacheManager.get_cache_stats
  name: get_cache_stats
  file_path: src/google/adk/flows/llm_flows/audio_cache_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Get statistics about current cache state.\n\nArgs:\n  invocation_context: The invocation context.\n\nReturns:\n  Dictionary containing cache statistics."
  signature: 'def get_cache_stats(self, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> dict[str, int]:'
- rank: 933
  id: google.adk.flows.llm_flows.audio_transcriber
  name: audio_transcriber
  file_path: src/google/adk/flows/llm_flows/audio_transcriber.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 934
  id: google.adk.flows.llm_flows.audio_transcriber.AudioTranscriber
  name: AudioTranscriber
  file_path: src/google/adk/flows/llm_flows/audio_transcriber.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Transcribes audio using Google Cloud Speech-to-Text.
  constructor_signature: 'def __init__(self, init_client):'
  methods:
  - signature: 'def transcribe_file(self, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> list[google.genai.types.Content]:'
    docstring: "Transcribe audio, bundling consecutive segments from the same speaker.\n\nThe ordering of speakers will be preserved. Audio blobs will be merged for\nthe same speaker as much as we can do reduce the transcription latency.\n\nArgs:\n    invocation_context: The invocation context to access the transcription\n      cache.\n\nReturns:\n    A list of Content objects containing the transcribed text."
- rank: 935
  id: google.adk.flows.llm_flows.audio_transcriber.AudioTranscriber.transcribe_file
  name: transcribe_file
  file_path: src/google/adk/flows/llm_flows/audio_transcriber.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Transcribe audio, bundling consecutive segments from the same speaker.\n\nThe ordering of speakers will be preserved. Audio blobs will be merged for\nthe same speaker as much as we can do reduce the transcription latency.\n\nArgs:\n    invocation_context: The invocation context to access the transcription\n      cache.\n\nReturns:\n    A list of Content objects containing the transcribed text."
  signature: 'def transcribe_file(self, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> list[google.genai.types.Content]:'
- rank: 936
  id: google.adk.flows.llm_flows.auto_flow
  name: auto_flow
  file_path: src/google/adk/flows/llm_flows/auto_flow.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Implementation of AutoFlow.
- rank: 937
  id: google.adk.flows.llm_flows.auto_flow.AutoFlow
  name: AutoFlow
  file_path: src/google/adk/flows/llm_flows/auto_flow.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'AutoFlow is SingleFlow with agent transfer capability.


    Agent transfer is allowed in the following direction:


    1. from parent to sub-agent;

    2. from sub-agent to parent;

    3. from sub-agent to its peer agents;


    For peer-agent transfers, it''s only enabled when all below conditions are met:


    - The parent agent is also an LlmAgent.

    - `disallow_transfer_to_peers` option of this agent is False (default).


    Depending on the target agent type, the transfer may be automatically

    reversed. (see Runner._find_agent_to_run method for which agent will remain

    active to handle next user message.)


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self):'
  inherited_methods:
    BaseLlmFlow:
    - signature: 'def run_live(self, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
      docstring: Runs the flow using live api.
    - signature: 'def run_async(self, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
      docstring: Runs the flow.
  omitted_inherited_members_from:
  - ABC
- rank: 938
  id: google.adk.flows.llm_flows.base_llm_flow
  name: base_llm_flow
  file_path: src/google/adk/flows/llm_flows/base_llm_flow.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'TOOLSET_AUTH_CREDENTIAL_ID_PREFIX: str'
  - signature: 'logger: logging.getLogger'
  - signature: '_ADK_AGENT_NAME_LABEL_KEY: str'
  - signature: 'DEFAULT_TRANSFER_AGENT_DELAY: float'
  - signature: 'DEFAULT_TASK_COMPLETION_DELAY: float'
  - signature: 'DEFAULT_ENABLE_CACHE_STATISTICS: bool'
- rank: 939
  id: google.adk.flows.llm_flows.base_llm_flow.BaseLlmFlow
  name: BaseLlmFlow
  file_path: src/google/adk/flows/llm_flows/base_llm_flow.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A basic flow that calls the LLM in a loop until a final response is generated.


    This flow ends when it transfers to another agent.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self):'
  methods:
  - signature: 'def run_live(self, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
    docstring: Runs the flow using live api.
  - signature: 'def run_async(self, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
    docstring: Runs the flow.
  omitted_inherited_members_from:
  - ABC
- rank: 940
  id: google.adk.flows.llm_flows.base_llm_flow.BaseLlmFlow.__init__
  name: __init__
  file_path: src/google/adk/flows/llm_flows/base_llm_flow.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self):'
- rank: 941
  id: google.adk.flows.llm_flows.base_llm_flow.BaseLlmFlow.run_async
  name: run_async
  file_path: src/google/adk/flows/llm_flows/base_llm_flow.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Runs the flow.
  signature: 'def run_async(self, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
- rank: 942
  id: google.adk.flows.llm_flows.base_llm_flow.BaseLlmFlow.run_live
  name: run_live
  file_path: src/google/adk/flows/llm_flows/base_llm_flow.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Runs the flow using live api.
  signature: 'def run_live(self, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
- rank: 943
  id: google.adk.flows.llm_flows.basic
  name: basic
  file_path: src/google/adk/flows/llm_flows/basic.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Handles basic information to build the LLM request.
  properties:
  - signature: 'request_processor: _BasicLlmRequestProcessor'
- rank: 944
  id: google.adk.flows.llm_flows.contents
  name: contents
  file_path: src/google/adk/flows/llm_flows/contents.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: 'request_processor: _ContentLlmRequestProcessor'
- rank: 945
  id: google.adk.flows.llm_flows.context_cache_processor
  name: context_cache_processor
  file_path: src/google/adk/flows/llm_flows/context_cache_processor.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Context cache processor for LLM requests.
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: 'request_processor: ContextCacheRequestProcessor'
- rank: 946
  id: google.adk.flows.llm_flows.context_cache_processor.ContextCacheRequestProcessor
  name: ContextCacheRequestProcessor
  file_path: src/google/adk/flows/llm_flows/context_cache_processor.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Request processor that enables context caching for LLM requests.


    This processor sets up context caching configuration for agents that have

    context caching enabled and finds the latest cache metadata from session

    events. The actual cache management is handled by the model-specific cache

    managers (e.g., GeminiContextCacheManager).


    [Note: Inherited members from BaseLlmRequestProcessor are omitted.]'
  methods:
  - signature: 'def run_async(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
    docstring: "Process LLM request to enable context caching.\n\nArgs:\n    invocation_context: Invocation context containing agent and session info\n    llm_request: Request to process for caching\n\nYields:\n    Event: No events are yielded by this processor"
  omitted_inherited_members_from:
  - BaseLlmRequestProcessor
- rank: 947
  id: google.adk.flows.llm_flows.context_cache_processor.ContextCacheRequestProcessor.run_async
  name: run_async
  file_path: src/google/adk/flows/llm_flows/context_cache_processor.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Process LLM request to enable context caching.\n\nArgs:\n    invocation_context: Invocation context containing agent and session info\n    llm_request: Request to process for caching\n\nYields:\n    Event: No events are yielded by this processor"
  signature: 'def run_async(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
- rank: 948
  id: google.adk.flows.llm_flows.functions
  name: functions
  file_path: src/google/adk/flows/llm_flows/functions.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Handles function calling for LLM flow.
  methods:
  - signature: 'def generate_client_function_call_id() -> str:'
  - signature: 'def populate_client_function_call_id(model_response_event: google.adk.events.event.Event) -> None:'
  - signature: 'def remove_client_function_call_id(content: typing.Optional[google.genai.types.Content]) -> None:'
    docstring: "Removes ADK-generated function call IDs from content before sending to LLM.\n\nStrips client-side function call/response IDs that start with 'adk-' prefix\nto avoid sending internal tracking IDs to the model.\n\nArgs:\n  content: Content containing function calls/responses to clean."
  - signature: 'def get_long_running_function_calls(function_calls: list[google.genai.types.FunctionCall], tools_dict: dict[str, google.adk.tools.base_tool.BaseTool]) -> set[str]:'
  - signature: 'def build_auth_request_event(invocation_context: google.adk.agents.invocation_context.InvocationContext, auth_requests: typing.Dict[str, google.adk.auth.auth_tool.AuthConfig], *, author: typing.Optional[str]=None, role: typing.Optional[str]=None) -> google.adk.events.event.Event:'
    docstring: "Builds an auth request event with function calls for each auth request.\n\nThis is a shared helper used by both tool-level auth (when a tool requests\nauth during execution) and toolset-level auth (before tool listing).\n\nArgs:\n  invocation_context: The invocation context.\n  auth_requests: Dict mapping function_call_id to AuthConfig.\n  author: The event author. Defaults to agent name.\n  role: The content role. Defaults to None.\n\nReturns:\n  Event with auth request function calls."
  - signature: 'def generate_auth_event(invocation_context: google.adk.agents.invocation_context.InvocationContext, function_response_event: google.adk.events.event.Event) -> typing.Optional[google.adk.events.event.Event]:'
    docstring: "Generates an auth request event from a function response event.\n\nThis is used for tool-level auth where a tool requests credentials during\nexecution.\n\nArgs:\n  invocation_context: The invocation context.\n  function_response_event: The function response event with auth requests.\n\nReturns:\n  Event with auth request function calls, or None if no auth requested."
  - signature: 'def generate_request_confirmation_event(invocation_context: google.adk.agents.invocation_context.InvocationContext, function_call_event: google.adk.events.event.Event, function_response_event: google.adk.events.event.Event) -> typing.Optional[google.adk.events.event.Event]:'
    docstring: Generates a request confirmation event from a function response event.
  - signature: 'def handle_function_calls_async(invocation_context: google.adk.agents.invocation_context.InvocationContext, function_call_event: google.adk.events.event.Event, tools_dict: dict[str, google.adk.tools.base_tool.BaseTool], filters: typing.Optional[set[str]], tool_confirmation_dict: typing.Optional[dict[str, google.adk.tools.tool_confirmation.ToolConfirmation]]) -> typing.Optional[google.adk.events.event.Event]:'
    docstring: Calls the functions and returns the function response event.
  - signature: 'def handle_function_call_list_async(invocation_context: google.adk.agents.invocation_context.InvocationContext, function_calls: list[google.genai.types.FunctionCall], tools_dict: dict[str, google.adk.tools.base_tool.BaseTool], filters: typing.Optional[set[str]], tool_confirmation_dict: typing.Optional[dict[str, google.adk.tools.tool_confirmation.ToolConfirmation]]) -> typing.Optional[google.adk.events.event.Event]:'
    docstring: Calls the functions and returns the function response event.
  - signature: 'def handle_function_calls_live(invocation_context: google.adk.agents.invocation_context.InvocationContext, function_call_event: google.adk.events.event.Event, tools_dict: dict[str, google.adk.tools.base_tool.BaseTool]) -> google.adk.events.event.Event:'
    docstring: Calls the functions and returns the function response event.
  - signature: 'def deep_merge_dicts(d1: dict, d2: dict) -> dict:'
    docstring: Recursively merges d2 into d1.
  - signature: 'def merge_parallel_function_response_events(function_response_events: list[google.adk.events.event.Event]) -> google.adk.events.event.Event:'
  - signature: 'def find_matching_function_call(events: list[google.adk.events.event.Event]) -> typing.Optional[google.adk.events.event.Event]:'
    docstring: Finds the function call event that matches the function response id of the last event.
  properties:
  - signature: 'AF_FUNCTION_CALL_ID_PREFIX: str'
  - signature: 'REQUEST_EUC_FUNCTION_CALL_NAME: str'
  - signature: 'REQUEST_CONFIRMATION_FUNCTION_CALL_NAME: str'
  - signature: 'REQUEST_INPUT_FUNCTION_CALL_NAME: str'
  - signature: 'logger: logging.getLogger'
  - signature: '_TOOL_THREAD_POOLS: dict[int, concurrent.futures.ThreadPoolExecutor]'
  - signature: '_TOOL_THREAD_POOL_LOCK: threading.Lock'
- rank: 949
  id: google.adk.flows.llm_flows.functions.build_auth_request_event
  name: build_auth_request_event
  file_path: src/google/adk/flows/llm_flows/functions.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Builds an auth request event with function calls for each auth request.\n\nThis is a shared helper used by both tool-level auth (when a tool requests\nauth during execution) and toolset-level auth (before tool listing).\n\nArgs:\n  invocation_context: The invocation context.\n  auth_requests: Dict mapping function_call_id to AuthConfig.\n  author: The event author. Defaults to agent name.\n  role: The content role. Defaults to None.\n\nReturns:\n  Event with auth request function calls."
  signature: 'def build_auth_request_event(invocation_context: google.adk.agents.invocation_context.InvocationContext, auth_requests: typing.Dict[str, google.adk.auth.auth_tool.AuthConfig], *, author: typing.Optional[str]=None, role: typing.Optional[str]=None) -> google.adk.events.event.Event:'
- rank: 950
  id: google.adk.flows.llm_flows.functions.deep_merge_dicts
  name: deep_merge_dicts
  file_path: src/google/adk/flows/llm_flows/functions.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Recursively merges d2 into d1.
  signature: 'def deep_merge_dicts(d1: dict, d2: dict) -> dict:'
- rank: 951
  id: google.adk.flows.llm_flows.functions.find_matching_function_call
  name: find_matching_function_call
  file_path: src/google/adk/flows/llm_flows/functions.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Finds the function call event that matches the function response id of the last event.
  signature: 'def find_matching_function_call(events: list[google.adk.events.event.Event]) -> typing.Optional[google.adk.events.event.Event]:'
- rank: 952
  id: google.adk.flows.llm_flows.functions.generate_auth_event
  name: generate_auth_event
  file_path: src/google/adk/flows/llm_flows/functions.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Generates an auth request event from a function response event.\n\nThis is used for tool-level auth where a tool requests credentials during\nexecution.\n\nArgs:\n  invocation_context: The invocation context.\n  function_response_event: The function response event with auth requests.\n\nReturns:\n  Event with auth request function calls, or None if no auth requested."
  signature: 'def generate_auth_event(invocation_context: google.adk.agents.invocation_context.InvocationContext, function_response_event: google.adk.events.event.Event) -> typing.Optional[google.adk.events.event.Event]:'
- rank: 953
  id: google.adk.flows.llm_flows.functions.generate_request_confirmation_event
  name: generate_request_confirmation_event
  file_path: src/google/adk/flows/llm_flows/functions.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Generates a request confirmation event from a function response event.
  signature: 'def generate_request_confirmation_event(invocation_context: google.adk.agents.invocation_context.InvocationContext, function_call_event: google.adk.events.event.Event, function_response_event: google.adk.events.event.Event) -> typing.Optional[google.adk.events.event.Event]:'
- rank: 954
  id: google.adk.flows.llm_flows.functions.get_long_running_function_calls
  name: get_long_running_function_calls
  file_path: src/google/adk/flows/llm_flows/functions.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_long_running_function_calls(function_calls: list[google.genai.types.FunctionCall], tools_dict: dict[str, google.adk.tools.base_tool.BaseTool]) -> set[str]:'
- rank: 955
  id: google.adk.flows.llm_flows.functions.handle_function_call_list_async
  name: handle_function_call_list_async
  file_path: src/google/adk/flows/llm_flows/functions.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Calls the functions and returns the function response event.
  signature: 'def handle_function_call_list_async(invocation_context: google.adk.agents.invocation_context.InvocationContext, function_calls: list[google.genai.types.FunctionCall], tools_dict: dict[str, google.adk.tools.base_tool.BaseTool], filters: typing.Optional[set[str]], tool_confirmation_dict: typing.Optional[dict[str, google.adk.tools.tool_confirmation.ToolConfirmation]]) -> typing.Optional[google.adk.events.event.Event]:'
- rank: 956
  id: google.adk.flows.llm_flows.functions.handle_function_calls_async
  name: handle_function_calls_async
  file_path: src/google/adk/flows/llm_flows/functions.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Calls the functions and returns the function response event.
  signature: 'def handle_function_calls_async(invocation_context: google.adk.agents.invocation_context.InvocationContext, function_call_event: google.adk.events.event.Event, tools_dict: dict[str, google.adk.tools.base_tool.BaseTool], filters: typing.Optional[set[str]], tool_confirmation_dict: typing.Optional[dict[str, google.adk.tools.tool_confirmation.ToolConfirmation]]) -> typing.Optional[google.adk.events.event.Event]:'
- rank: 957
  id: google.adk.flows.llm_flows.functions.handle_function_calls_live
  name: handle_function_calls_live
  file_path: src/google/adk/flows/llm_flows/functions.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Calls the functions and returns the function response event.
  signature: 'def handle_function_calls_live(invocation_context: google.adk.agents.invocation_context.InvocationContext, function_call_event: google.adk.events.event.Event, tools_dict: dict[str, google.adk.tools.base_tool.BaseTool]) -> google.adk.events.event.Event:'
- rank: 958
  id: google.adk.flows.llm_flows.functions.merge_parallel_function_response_events
  name: merge_parallel_function_response_events
  file_path: src/google/adk/flows/llm_flows/functions.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def merge_parallel_function_response_events(function_response_events: list[google.adk.events.event.Event]) -> google.adk.events.event.Event:'
- rank: 959
  id: google.adk.flows.llm_flows.functions.populate_client_function_call_id
  name: populate_client_function_call_id
  file_path: src/google/adk/flows/llm_flows/functions.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def populate_client_function_call_id(model_response_event: google.adk.events.event.Event) -> None:'
- rank: 960
  id: google.adk.flows.llm_flows.functions.remove_client_function_call_id
  name: remove_client_function_call_id
  file_path: src/google/adk/flows/llm_flows/functions.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Removes ADK-generated function call IDs from content before sending to LLM.\n\nStrips client-side function call/response IDs that start with 'adk-' prefix\nto avoid sending internal tracking IDs to the model.\n\nArgs:\n  content: Content containing function calls/responses to clean."
  signature: 'def remove_client_function_call_id(content: typing.Optional[google.genai.types.Content]) -> None:'
- rank: 961
  id: google.adk.flows.llm_flows.identity
  name: identity
  file_path: src/google/adk/flows/llm_flows/identity.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Gives the agent identity from the framework.
  properties:
  - signature: 'request_processor: _IdentityLlmRequestProcessor'
- rank: 962
  id: google.adk.flows.llm_flows.instructions
  name: instructions
  file_path: src/google/adk/flows/llm_flows/instructions.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Handles instructions and global instructions for LLM flow.
  properties:
  - signature: 'request_processor: _InstructionsLlmRequestProcessor'
- rank: 963
  id: google.adk.flows.llm_flows.interactions_processor
  name: interactions_processor
  file_path: src/google/adk/flows/llm_flows/interactions_processor.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Interactions API processor for LLM requests.
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: 'request_processor: InteractionsRequestProcessor'
- rank: 964
  id: google.adk.flows.llm_flows.interactions_processor.InteractionsRequestProcessor
  name: InteractionsRequestProcessor
  file_path: src/google/adk/flows/llm_flows/interactions_processor.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Request processor for Interactions API stateful conversations.

    This processor extracts the previous_interaction_id from session events

    to enable stateful conversation chaining via the Interactions API.

    The actual content filtering (retaining only latest user messages) is

    done in the Gemini class when using the Interactions API.


    [Note: Inherited members from BaseLlmRequestProcessor are omitted.]'
  methods:
  - signature: 'def run_async(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
    docstring: "Process LLM request to extract previous_interaction_id.\nArgs:\n    invocation_context: Invocation context containing agent and session info\n    llm_request: Request to process\nYields:\n    Event: No events are yielded by this processor"
  omitted_inherited_members_from:
  - BaseLlmRequestProcessor
- rank: 965
  id: google.adk.flows.llm_flows.interactions_processor.InteractionsRequestProcessor.run_async
  name: run_async
  file_path: src/google/adk/flows/llm_flows/interactions_processor.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Process LLM request to extract previous_interaction_id.\nArgs:\n    invocation_context: Invocation context containing agent and session info\n    llm_request: Request to process\nYields:\n    Event: No events are yielded by this processor"
  signature: 'def run_async(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
- rank: 966
  id: google.adk.flows.llm_flows.request_confirmation
  name: request_confirmation
  file_path: src/google/adk/flows/llm_flows/request_confirmation.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: 'request_processor: _RequestConfirmationLlmRequestProcessor'
- rank: 967
  id: google.adk.flows.llm_flows.single_flow
  name: single_flow
  file_path: src/google/adk/flows/llm_flows/single_flow.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Implementation of single flow.
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 968
  id: google.adk.flows.llm_flows.single_flow.SingleFlow
  name: SingleFlow
  file_path: src/google/adk/flows/llm_flows/single_flow.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'SingleFlow is the LLM flows that handles tools calls.


    A single flow only consider an agent itself and tools.

    No sub-agents are allowed for single flow.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self):'
  inherited_methods:
    BaseLlmFlow:
    - signature: 'def run_live(self, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
      docstring: Runs the flow using live api.
    - signature: 'def run_async(self, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
      docstring: Runs the flow.
  omitted_inherited_members_from:
  - ABC
- rank: 969
  id: google.adk.flows.llm_flows.single_flow.SingleFlow.__init__
  name: __init__
  file_path: src/google/adk/flows/llm_flows/single_flow.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self):'
- rank: 970
  id: google.adk.flows.llm_flows.transcription_manager
  name: transcription_manager
  file_path: src/google/adk/flows/llm_flows/transcription_manager.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 971
  id: google.adk.flows.llm_flows.transcription_manager.TranscriptionManager
  name: TranscriptionManager
  file_path: src/google/adk/flows/llm_flows/transcription_manager.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Manages transcription events for live streaming flows.
  methods:
  - signature: 'def handle_input_transcription(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, transcription: google.genai.types.Transcription) -> None:'
    docstring: "Handle user input transcription events.\n\nArgs:\n  invocation_context: The current invocation context.\n  transcription: The transcription data from user input."
  - signature: 'def handle_output_transcription(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, transcription: google.genai.types.Transcription) -> None:'
    docstring: "Handle model output transcription events.\n\nArgs:\n  invocation_context: The current invocation context.\n  transcription: The transcription data from model output."
  - signature: 'def get_transcription_stats(self, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> dict[str, int]:'
    docstring: "Get statistics about transcription events in the session.\n\nArgs:\n  invocation_context: The current invocation context.\n\nReturns:\n  Dictionary containing transcription statistics."
- rank: 972
  id: google.adk.flows.llm_flows.transcription_manager.TranscriptionManager.get_transcription_stats
  name: get_transcription_stats
  file_path: src/google/adk/flows/llm_flows/transcription_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Get statistics about transcription events in the session.\n\nArgs:\n  invocation_context: The current invocation context.\n\nReturns:\n  Dictionary containing transcription statistics."
  signature: 'def get_transcription_stats(self, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> dict[str, int]:'
- rank: 973
  id: google.adk.flows.llm_flows.transcription_manager.TranscriptionManager.handle_input_transcription
  name: handle_input_transcription
  file_path: src/google/adk/flows/llm_flows/transcription_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Handle user input transcription events.\n\nArgs:\n  invocation_context: The current invocation context.\n  transcription: The transcription data from user input."
  signature: 'def handle_input_transcription(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, transcription: google.genai.types.Transcription) -> None:'
- rank: 974
  id: google.adk.flows.llm_flows.transcription_manager.TranscriptionManager.handle_output_transcription
  name: handle_output_transcription
  file_path: src/google/adk/flows/llm_flows/transcription_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Handle model output transcription events.\n\nArgs:\n  invocation_context: The current invocation context.\n  transcription: The transcription data from model output."
  signature: 'def handle_output_transcription(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, transcription: google.genai.types.Transcription) -> None:'
- rank: 975
  id: google.adk.memory
  name: memory
  file_path: src/google/adk/memory/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '__all__: Any'
- rank: 976
  id: google.adk.memory.base_memory_service
  name: base_memory_service
  file_path: src/google/adk/memory/base_memory_service.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 977
  id: google.adk.memory.base_memory_service.BaseMemoryService
  name: BaseMemoryService
  file_path: src/google/adk/memory/base_memory_service.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Base class for memory services.


    The service provides functionalities to ingest sessions into memory so that

    the memory can be used for user queries.


    [Note: Inherited members from ABC are omitted.]'
  aliases:
  - google.adk.memory.BaseMemoryService
  methods:
  - signature: 'def add_session_to_memory(self, session: google.adk.sessions.session.Session):'
    docstring: "Adds a session to the memory service.\n\nA session may be added multiple times during its lifetime.\n\nArgs:\n    session: The session to add."
  - signature: 'def search_memory(self, *, app_name: str, user_id: str, query: str) -> google.adk.memory.base_memory_service.SearchMemoryResponse:'
    docstring: "Searches for sessions that match the query.\n\nArgs:\n    app_name: The name of the application.\n    user_id: The id of the user.\n    query: The query to search for.\n\nReturns:\n    A SearchMemoryResponse containing the matching memories."
  omitted_inherited_members_from:
  - ABC
- rank: 978
  id: google.adk.memory.base_memory_service.BaseMemoryService.add_session_to_memory
  name: add_session_to_memory
  file_path: src/google/adk/memory/base_memory_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Adds a session to the memory service.\n\nA session may be added multiple times during its lifetime.\n\nArgs:\n    session: The session to add."
  signature: 'def add_session_to_memory(self, session: google.adk.sessions.session.Session):'
- rank: 979
  id: google.adk.memory.base_memory_service.BaseMemoryService.search_memory
  name: search_memory
  file_path: src/google/adk/memory/base_memory_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Searches for sessions that match the query.\n\nArgs:\n    app_name: The name of the application.\n    user_id: The id of the user.\n    query: The query to search for.\n\nReturns:\n    A SearchMemoryResponse containing the matching memories."
  signature: 'def search_memory(self, *, app_name: str, user_id: str, query: str) -> google.adk.memory.base_memory_service.SearchMemoryResponse:'
- rank: 980
  id: google.adk.memory.in_memory_memory_service
  name: in_memory_memory_service
  file_path: src/google/adk/memory/in_memory_memory_service.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 981
  id: google.adk.memory.in_memory_memory_service.InMemoryMemoryService
  name: InMemoryMemoryService
  file_path: src/google/adk/memory/in_memory_memory_service.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'An in-memory memory service for prototyping purpose only.


    Uses keyword matching instead of semantic search.


    This class is thread-safe, however, it should be used for testing and

    development only.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self):'
  methods:
  - signature: 'def add_session_to_memory(self, session: google.adk.sessions.session.Session):'
  - signature: 'def search_memory(self, *, app_name: str, user_id: str, query: str) -> google.adk.memory.base_memory_service.SearchMemoryResponse:'
  inherited_methods:
    BaseMemoryService:
    - signature: 'def add_session_to_memory(self, session: google.adk.sessions.session.Session):'
      docstring: "Adds a session to the memory service.\n\nA session may be added multiple times during its lifetime.\n\nArgs:\n    session: The session to add."
    - signature: 'def search_memory(self, *, app_name: str, user_id: str, query: str) -> google.adk.memory.base_memory_service.SearchMemoryResponse:'
      docstring: "Searches for sessions that match the query.\n\nArgs:\n    app_name: The name of the application.\n    user_id: The id of the user.\n    query: The query to search for.\n\nReturns:\n    A SearchMemoryResponse containing the matching memories."
  omitted_inherited_members_from:
  - ABC
- rank: 982
  id: google.adk.memory.in_memory_memory_service.InMemoryMemoryService.__init__
  name: __init__
  file_path: src/google/adk/memory/in_memory_memory_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self):'
- rank: 983
  id: google.adk.memory.in_memory_memory_service.InMemoryMemoryService.add_session_to_memory
  name: add_session_to_memory
  file_path: src/google/adk/memory/in_memory_memory_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def add_session_to_memory(self, session: google.adk.sessions.session.Session):'
- rank: 984
  id: google.adk.memory.in_memory_memory_service.InMemoryMemoryService.search_memory
  name: search_memory
  file_path: src/google/adk/memory/in_memory_memory_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def search_memory(self, *, app_name: str, user_id: str, query: str) -> google.adk.memory.base_memory_service.SearchMemoryResponse:'
- rank: 985
  id: google.adk.memory.memory_entry
  name: memory_entry
  file_path: src/google/adk/memory/memory_entry.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 986
  id: google.adk.memory.vertex_ai_memory_bank_service
  name: vertex_ai_memory_bank_service
  file_path: src/google/adk/memory/vertex_ai_memory_bank_service.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 987
  id: google.adk.memory.vertex_ai_memory_bank_service.VertexAiMemoryBankService
  name: VertexAiMemoryBankService
  file_path: src/google/adk/memory/vertex_ai_memory_bank_service.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Implementation of the BaseMemoryService using Vertex AI Memory Bank.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, project: typing.Optional[str], location: typing.Optional[str], agent_engine_id: typing.Optional[str], *, express_mode_api_key: typing.Optional[str]=None):'
  methods:
  - signature: 'def add_session_to_memory(self, session: google.adk.sessions.session.Session):'
  - signature: 'def search_memory(self, *, app_name: str, user_id: str, query: str):'
  inherited_methods:
    BaseMemoryService:
    - signature: 'def add_session_to_memory(self, session: google.adk.sessions.session.Session):'
      docstring: "Adds a session to the memory service.\n\nA session may be added multiple times during its lifetime.\n\nArgs:\n    session: The session to add."
    - signature: 'def search_memory(self, *, app_name: str, user_id: str, query: str) -> google.adk.memory.base_memory_service.SearchMemoryResponse:'
      docstring: "Searches for sessions that match the query.\n\nArgs:\n    app_name: The name of the application.\n    user_id: The id of the user.\n    query: The query to search for.\n\nReturns:\n    A SearchMemoryResponse containing the matching memories."
  omitted_inherited_members_from:
  - ABC
- rank: 988
  id: google.adk.memory.vertex_ai_memory_bank_service.VertexAiMemoryBankService.__init__
  name: __init__
  file_path: src/google/adk/memory/vertex_ai_memory_bank_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes a VertexAiMemoryBankService.\n\nArgs:\n  project: The project ID of the Memory Bank to use.\n  location: The location of the Memory Bank to use.\n  agent_engine_id: The ID of the agent engine to use for the Memory Bank,\n    e.g. '456' in\n    'projects/my-project/locations/us-central1/reasoningEngines/456'. To\n    extract from api_resource.name, use:\n    ``agent_engine.api_resource.name.split('/')[-1]``\n  express_mode_api_key: The API key to use for Express Mode. If not\n    provided, the API key from the GOOGLE_API_KEY environment variable will\n    be used. It will only be used if GOOGLE_GENAI_USE_VERTEXAI is true. Do\n    not use Google AI Studio API key for this field. For more details, visit\n    https://cloud.google.com/vertex-ai/generative-ai/docs/start/express-mode/overview"
  signature: 'def __init__(self, project: typing.Optional[str], location: typing.Optional[str], agent_engine_id: typing.Optional[str], *, express_mode_api_key: typing.Optional[str]=None):'
- rank: 989
  id: google.adk.memory.vertex_ai_memory_bank_service.VertexAiMemoryBankService.add_session_to_memory
  name: add_session_to_memory
  file_path: src/google/adk/memory/vertex_ai_memory_bank_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def add_session_to_memory(self, session: google.adk.sessions.session.Session):'
- rank: 990
  id: google.adk.memory.vertex_ai_memory_bank_service.VertexAiMemoryBankService.search_memory
  name: search_memory
  file_path: src/google/adk/memory/vertex_ai_memory_bank_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def search_memory(self, *, app_name: str, user_id: str, query: str):'
- rank: 991
  id: google.adk.memory.vertex_ai_rag_memory_service
  name: vertex_ai_rag_memory_service
  file_path: src/google/adk/memory/vertex_ai_rag_memory_service.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 992
  id: google.adk.memory.vertex_ai_rag_memory_service.VertexAiRagMemoryService
  name: VertexAiRagMemoryService
  file_path: src/google/adk/memory/vertex_ai_rag_memory_service.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A memory service that uses Vertex AI RAG for storage and retrieval.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, rag_corpus: typing.Optional[str], similarity_top_k: typing.Optional[int], vector_distance_threshold: float):'
  methods:
  - signature: 'def add_session_to_memory(self, session: google.adk.sessions.session.Session):'
  - signature: 'def search_memory(self, *, app_name: str, user_id: str, query: str) -> google.adk.memory.base_memory_service.SearchMemoryResponse:'
    docstring: Searches for sessions that match the query using rag.retrieval_query.
  inherited_methods:
    BaseMemoryService:
    - signature: 'def add_session_to_memory(self, session: google.adk.sessions.session.Session):'
      docstring: "Adds a session to the memory service.\n\nA session may be added multiple times during its lifetime.\n\nArgs:\n    session: The session to add."
    - signature: 'def search_memory(self, *, app_name: str, user_id: str, query: str) -> google.adk.memory.base_memory_service.SearchMemoryResponse:'
      docstring: "Searches for sessions that match the query.\n\nArgs:\n    app_name: The name of the application.\n    user_id: The id of the user.\n    query: The query to search for.\n\nReturns:\n    A SearchMemoryResponse containing the matching memories."
  omitted_inherited_members_from:
  - ABC
- rank: 993
  id: google.adk.memory.vertex_ai_rag_memory_service.VertexAiRagMemoryService.__init__
  name: __init__
  file_path: src/google/adk/memory/vertex_ai_rag_memory_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes a VertexAiRagMemoryService.\n\nArgs:\n    rag_corpus: The name of the Vertex AI RAG corpus to use. Format:\n      ``projects/{project}/locations/{location}/ragCorpora/{rag_corpus_id}``\n      or ``{rag_corpus_id}``\n    similarity_top_k: The number of contexts to retrieve.\n    vector_distance_threshold: Only returns contexts with vector distance\n      smaller than the threshold."
  signature: 'def __init__(self, rag_corpus: typing.Optional[str], similarity_top_k: typing.Optional[int], vector_distance_threshold: float):'
- rank: 994
  id: google.adk.memory.vertex_ai_rag_memory_service.VertexAiRagMemoryService.add_session_to_memory
  name: add_session_to_memory
  file_path: src/google/adk/memory/vertex_ai_rag_memory_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def add_session_to_memory(self, session: google.adk.sessions.session.Session):'
- rank: 995
  id: google.adk.memory.vertex_ai_rag_memory_service.VertexAiRagMemoryService.search_memory
  name: search_memory
  file_path: src/google/adk/memory/vertex_ai_rag_memory_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Searches for sessions that match the query using rag.retrieval_query.
  signature: 'def search_memory(self, *, app_name: str, user_id: str, query: str) -> google.adk.memory.base_memory_service.SearchMemoryResponse:'
- rank: 996
  id: google.adk.models
  name: models
  file_path: src/google/adk/models/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Defines the interface to support a model.
  properties:
  - signature: '__all__: Any'
- rank: 997
  id: google.adk.models.anthropic_llm
  name: anthropic_llm
  file_path: src/google/adk/models/anthropic_llm.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Anthropic integration for Claude models.
  methods:
  - signature: 'def to_claude_role(role: typing.Optional[str]) -> typing.Literal[user, assistant]:'
  - signature: 'def to_google_genai_finish_reason(anthropic_stop_reason: typing.Optional[str]) -> google.genai.types.FinishReason:'
  - signature: 'def part_to_message_block(part: google.genai.types.Part) -> typing.Union[anthropic.types.TextBlockParam, anthropic.types.ImageBlockParam, anthropic.types.ToolUseBlockParam, anthropic.types.ToolResultBlockParam]:'
  - signature: 'def content_to_message_param(content: google.genai.types.Content) -> anthropic.types.MessageParam:'
  - signature: 'def content_block_to_part(content_block: anthropic.types.ContentBlock) -> google.genai.types.Part:'
  - signature: 'def message_to_generate_content_response(message: anthropic.types.Message) -> google.adk.models.llm_response.LlmResponse:'
  - signature: 'def function_declaration_to_tool_param(function_declaration: google.genai.types.FunctionDeclaration) -> anthropic.types.ToolParam:'
    docstring: Converts a function declaration to an Anthropic tool param.
  properties:
  - signature: '__all__: Any'
  - signature: 'logger: logging.getLogger'
- rank: 998
  id: google.adk.models.anthropic_llm.AnthropicLlm
  name: AnthropicLlm
  file_path: src/google/adk/models/anthropic_llm.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "Integration with Claude models via the Anthropic API.\n\nAttributes:\n  model: The name of the Claude model.\n  max_tokens: The maximum number of tokens to generate.\n\n[Note: Inherited members from pydantic.BaseModel are omitted.]"
  constructor_signature: 'def __init__(self, *, model: str, max_tokens: int = 8192):'
  methods:
  - signature: 'def supported_models(cls) -> list[str]:'
  - signature: 'def generate_content_async(self, llm_request: google.adk.models.llm_request.LlmRequest, stream: bool) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
  properties:
  - signature: 'model: str'
  - signature: 'max_tokens: int'
  inherited_methods:
    BaseLlm:
    - signature: 'def supported_models(cls) -> list[str]:'
      docstring: Returns a list of supported models in regex for LlmRegistry.
    - signature: 'def generate_content_async(self, llm_request: google.adk.models.llm_request.LlmRequest, stream: bool) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
      docstring: "Generates content for a single model turn.\n\n    This method handles Server-Sent Events (SSE) streaming for unidirectional\n    content generation. For bidirectional streaming (e.g., Gemini Live API),\n    use the `connect()` method instead.\n\n    Args:\n      llm_request: LlmRequest, the request to send to the LLM.\n      stream: bool = False, whether to enable SSE streaming mode.\n\n    Yields:\n      LlmResponse objects representing the model's response for one turn.\n\n      **Non-streaming mode (stream=False):**\n\n        Yields exactly one LlmResponse containing the complete model output\n        (text, function calls, bytes, etc.). This response has `partial=False`.\n\n      **Streaming mode (stream=True):**\n\n        Yields multiple LlmResponse objects as chunks arrive:\n\n        - Intermediate chunks: `partial=True` (progressive updates)\n        - Final chunk: `partial=False` (aggregated content from entire turn,\n          identical to stream=False output)\n\
        \        - Text consolidation: Consecutive text parts of the same type\n          (thought/non-thought) SHOULD merge without separator, but client\n          code must not rely on this - unconsolidated parts are unusual but also\n          valid\n\n      **Common content in partial chunks:**\n\n        All intermediate chunks have `partial=True` regardless of content type.\n        Common examples include:\n\n        - Text: Streams incrementally as tokens arrive\n        - Function calls: May arrive in separate chunks\n        - Bytes (e.g., images): Typically arrive as single chunk, interleaved\n          with text\n        - Thoughts: Stream incrementally when thinking_config is enabled\n\n      **Examples:**\n\n      1. Simple text streaming::\n\n           LlmResponse(partial=True,  parts=[\"The weather\"])\n           LlmResponse(partial=True,  parts=[\" in Tokyo is\"])\n           LlmResponse(partial=True,  parts=[\" sunny.\"])\n           LlmResponse(partial=False, parts=[\"\
        The weather in Tokyo is sunny.\"])\n\n      2. Text + function call::\n\n           LlmResponse(partial=True,  parts=[Text(\"Let me check...\")])\n           LlmResponse(partial=True,  parts=[FunctionCall(\"get_weather\", ...)])\n           LlmResponse(partial=False, parts=[Text(\"Let me check...\"),\n                                             FunctionCall(\"get_weather\", ...)])\n\n      3. Parallel function calls across chunks::\n\n           LlmResponse(partial=True,  parts=[Text(\"Checking both cities...\")])\n           LlmResponse(partial=True,  parts=[FunctionCall(\"get_weather\", Tokyo)])\n           LlmResponse(partial=True,  parts=[FunctionCall(\"get_weather\", NYC)])\n           LlmResponse(partial=False, parts=[Text(\"Checking both cities...\"),\n                                             FunctionCall(\"get_weather\", Tokyo),\n                                             FunctionCall(\"get_weather\", NYC)])\n\n      4. Text + bytes (image generation with gemini-2.5-flash-image)::\n\
        \n           LlmResponse(partial=True,  parts=[Text(\"Here's an image of a dog.\")])\n           LlmResponse(partial=True,  parts=[Text(\"\n\")])\n           LlmResponse(partial=True,  parts=[Blob(image/png, 1.6MB)])\n           LlmResponse(partial=True,  parts=[Text(\"It carries a bone\")])\n           LlmResponse(partial=True,  parts=[Text(\" and running around.\")])\n           LlmResponse(partial=False, parts=[Text(\"Here's an image of a dog.\n\"),\n                                             Blob(image/png, 1.6MB),\n                                             Text(\"It carries a bone and running around.\")])\n\n         Note: Consecutive text parts before and after blob merge separately.\n\n      5. Text with thinking (gemini-2.5-flash with thinking_config)::\n\n           LlmResponse(partial=True,  parts=[Thought(\"Let me analyze...\")])\n           LlmResponse(partial=True,  parts=[Thought(\"The user wants...\")])\n           LlmResponse(partial=True,  parts=[Text(\"Based\
        \ on my analysis,\")])\n           LlmResponse(partial=True,  parts=[Text(\" the answer is 42.\")])\n           LlmResponse(partial=False, parts=[Thought(\"Let me analyze...The user wants...\"),\n                                             Text(\"Based on my analysis, the answer is 42.\")])\n\n         Note: Consecutive parts of same type merge (thoughts\u2192thought, text\u2192text).\n\n      **Important:** All yielded responses represent one logical model turn.\n      The final response with `partial=False` should be identical to the\n      response that would be received with `stream=False`.\n    "
    - signature: 'def connect(self, llm_request: google.adk.models.llm_request.LlmRequest) -> google.adk.models.base_llm_connection.BaseLlmConnection:'
      docstring: "Creates a live connection to the LLM.\n\nArgs:\n  llm_request: LlmRequest, the request to send to the LLM.\n\nReturns:\n  BaseLlmConnection, the connection to the LLM."
  inherited_properties:
    BaseLlm:
    - signature: 'model_config: pydantic.ConfigDict'
      docstring: The pydantic model config.
    - signature: 'model: str'
      docstring: The name of the LLM, e.g. gemini-2.5-flash or gemini-2.5-pro.
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 999
  id: google.adk.models.anthropic_llm.AnthropicLlm.generate_content_async
  name: generate_content_async
  file_path: src/google/adk/models/anthropic_llm.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def generate_content_async(self, llm_request: google.adk.models.llm_request.LlmRequest, stream: bool) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
- rank: 1000
  id: google.adk.models.anthropic_llm.ClaudeRequest
  name: ClaudeRequest
  file_path: src/google/adk/models/anthropic_llm.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, system_instruction: str, messages: typing.Iterable[anthropic.types.MessageParam], tools: list[anthropic.types.ToolParam]):'
  properties:
  - signature: 'system_instruction: str'
  - signature: 'messages: typing.Iterable[anthropic.types.MessageParam]'
  - signature: 'tools: list[anthropic.types.ToolParam]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1001
  id: google.adk.models.anthropic_llm.content_block_to_part
  name: content_block_to_part
  file_path: src/google/adk/models/anthropic_llm.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def content_block_to_part(content_block: anthropic.types.ContentBlock) -> google.genai.types.Part:'
- rank: 1002
  id: google.adk.models.anthropic_llm.content_to_message_param
  name: content_to_message_param
  file_path: src/google/adk/models/anthropic_llm.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def content_to_message_param(content: google.genai.types.Content) -> anthropic.types.MessageParam:'
- rank: 1003
  id: google.adk.models.anthropic_llm.function_declaration_to_tool_param
  name: function_declaration_to_tool_param
  file_path: src/google/adk/models/anthropic_llm.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Converts a function declaration to an Anthropic tool param.
  signature: 'def function_declaration_to_tool_param(function_declaration: google.genai.types.FunctionDeclaration) -> anthropic.types.ToolParam:'
- rank: 1004
  id: google.adk.models.anthropic_llm.message_to_generate_content_response
  name: message_to_generate_content_response
  file_path: src/google/adk/models/anthropic_llm.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def message_to_generate_content_response(message: anthropic.types.Message) -> google.adk.models.llm_response.LlmResponse:'
- rank: 1005
  id: google.adk.models.anthropic_llm.part_to_message_block
  name: part_to_message_block
  file_path: src/google/adk/models/anthropic_llm.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def part_to_message_block(part: google.genai.types.Part) -> typing.Union[anthropic.types.TextBlockParam, anthropic.types.ImageBlockParam, anthropic.types.ToolUseBlockParam, anthropic.types.ToolResultBlockParam]:'
- rank: 1006
  id: google.adk.models.anthropic_llm.to_claude_role
  name: to_claude_role
  file_path: src/google/adk/models/anthropic_llm.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def to_claude_role(role: typing.Optional[str]) -> typing.Literal[user, assistant]:'
- rank: 1007
  id: google.adk.models.anthropic_llm.to_google_genai_finish_reason
  name: to_google_genai_finish_reason
  file_path: src/google/adk/models/anthropic_llm.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def to_google_genai_finish_reason(anthropic_stop_reason: typing.Optional[str]) -> google.genai.types.FinishReason:'
- rank: 1008
  id: google.adk.models.apigee_llm
  name: apigee_llm
  file_path: src/google/adk/models/apigee_llm.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '_APIGEE_PROXY_URL_ENV_VARIABLE_NAME: str'
  - signature: '_GOOGLE_GENAI_USE_VERTEXAI_ENV_VARIABLE_NAME: str'
  - signature: '_PROJECT_ENV_VARIABLE_NAME: str'
  - signature: '_LOCATION_ENV_VARIABLE_NAME: str'
- rank: 1009
  id: google.adk.models.apigee_llm.ApigeeLlm
  name: ApigeeLlm
  file_path: src/google/adk/models/apigee_llm.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "A BaseLlm implementation for calling Apigee proxy.\n\nAttributes:\n  model: The name of the Gemini model.\n\n[Note: Inherited members from pydantic.BaseModel are omitted.]"
  constructor_signature: 'def __init__(self, *, model: str, proxy_url: str | None=None, custom_headers: dict[str, str] | None=None, retry_options: typing.Optional[google.genai.types.HttpRetryOptions]=None):'
  methods:
  - signature: 'def supported_models(cls) -> list[str]:'
    docstring: "Provides the list of supported models.\n\nReturns:\n  A list of supported models."
  - signature: 'def api_client(self) -> google.genai.Client:'
    docstring: "Provides the api client.\n\nReturns:\n  The api client."
  inherited_methods:
    Gemini:
    - signature: 'def supported_models(cls) -> list[str]:'
      docstring: "Provides the list of supported models.\n\nReturns:\n  A list of supported models."
    - signature: 'def generate_content_async(self, llm_request: google.adk.models.llm_request.LlmRequest, stream: bool) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
      docstring: "Sends a request to the Gemini model.\n\nArgs:\n  llm_request: LlmRequest, the request to send to the Gemini model.\n  stream: bool = False, whether to do streaming call.\n\nYields:\n  LlmResponse: The model response."
    - signature: 'def api_client(self) -> google.genai.Client:'
      docstring: "Provides the api client.\n\nReturns:\n  The api client."
    - signature: 'def connect(self, llm_request: google.adk.models.llm_request.LlmRequest) -> google.adk.models.base_llm_connection.BaseLlmConnection:'
      docstring: "Connects to the Gemini model and returns an llm connection.\n\nArgs:\n  llm_request: LlmRequest, the request to send to the Gemini model.\n\nYields:\n  BaseLlmConnection, the connection to the Gemini model."
    BaseLlm:
    - signature: 'def supported_models(cls) -> list[str]:'
      docstring: Returns a list of supported models in regex for LlmRegistry.
    - signature: 'def generate_content_async(self, llm_request: google.adk.models.llm_request.LlmRequest, stream: bool) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
      docstring: "Generates content for a single model turn.\n\n    This method handles Server-Sent Events (SSE) streaming for unidirectional\n    content generation. For bidirectional streaming (e.g., Gemini Live API),\n    use the `connect()` method instead.\n\n    Args:\n      llm_request: LlmRequest, the request to send to the LLM.\n      stream: bool = False, whether to enable SSE streaming mode.\n\n    Yields:\n      LlmResponse objects representing the model's response for one turn.\n\n      **Non-streaming mode (stream=False):**\n\n        Yields exactly one LlmResponse containing the complete model output\n        (text, function calls, bytes, etc.). This response has `partial=False`.\n\n      **Streaming mode (stream=True):**\n\n        Yields multiple LlmResponse objects as chunks arrive:\n\n        - Intermediate chunks: `partial=True` (progressive updates)\n        - Final chunk: `partial=False` (aggregated content from entire turn,\n          identical to stream=False output)\n\
        \        - Text consolidation: Consecutive text parts of the same type\n          (thought/non-thought) SHOULD merge without separator, but client\n          code must not rely on this - unconsolidated parts are unusual but also\n          valid\n\n      **Common content in partial chunks:**\n\n        All intermediate chunks have `partial=True` regardless of content type.\n        Common examples include:\n\n        - Text: Streams incrementally as tokens arrive\n        - Function calls: May arrive in separate chunks\n        - Bytes (e.g., images): Typically arrive as single chunk, interleaved\n          with text\n        - Thoughts: Stream incrementally when thinking_config is enabled\n\n      **Examples:**\n\n      1. Simple text streaming::\n\n           LlmResponse(partial=True,  parts=[\"The weather\"])\n           LlmResponse(partial=True,  parts=[\" in Tokyo is\"])\n           LlmResponse(partial=True,  parts=[\" sunny.\"])\n           LlmResponse(partial=False, parts=[\"\
        The weather in Tokyo is sunny.\"])\n\n      2. Text + function call::\n\n           LlmResponse(partial=True,  parts=[Text(\"Let me check...\")])\n           LlmResponse(partial=True,  parts=[FunctionCall(\"get_weather\", ...)])\n           LlmResponse(partial=False, parts=[Text(\"Let me check...\"),\n                                             FunctionCall(\"get_weather\", ...)])\n\n      3. Parallel function calls across chunks::\n\n           LlmResponse(partial=True,  parts=[Text(\"Checking both cities...\")])\n           LlmResponse(partial=True,  parts=[FunctionCall(\"get_weather\", Tokyo)])\n           LlmResponse(partial=True,  parts=[FunctionCall(\"get_weather\", NYC)])\n           LlmResponse(partial=False, parts=[Text(\"Checking both cities...\"),\n                                             FunctionCall(\"get_weather\", Tokyo),\n                                             FunctionCall(\"get_weather\", NYC)])\n\n      4. Text + bytes (image generation with gemini-2.5-flash-image)::\n\
        \n           LlmResponse(partial=True,  parts=[Text(\"Here's an image of a dog.\")])\n           LlmResponse(partial=True,  parts=[Text(\"\n\")])\n           LlmResponse(partial=True,  parts=[Blob(image/png, 1.6MB)])\n           LlmResponse(partial=True,  parts=[Text(\"It carries a bone\")])\n           LlmResponse(partial=True,  parts=[Text(\" and running around.\")])\n           LlmResponse(partial=False, parts=[Text(\"Here's an image of a dog.\n\"),\n                                             Blob(image/png, 1.6MB),\n                                             Text(\"It carries a bone and running around.\")])\n\n         Note: Consecutive text parts before and after blob merge separately.\n\n      5. Text with thinking (gemini-2.5-flash with thinking_config)::\n\n           LlmResponse(partial=True,  parts=[Thought(\"Let me analyze...\")])\n           LlmResponse(partial=True,  parts=[Thought(\"The user wants...\")])\n           LlmResponse(partial=True,  parts=[Text(\"Based\
        \ on my analysis,\")])\n           LlmResponse(partial=True,  parts=[Text(\" the answer is 42.\")])\n           LlmResponse(partial=False, parts=[Thought(\"Let me analyze...The user wants...\"),\n                                             Text(\"Based on my analysis, the answer is 42.\")])\n\n         Note: Consecutive parts of same type merge (thoughts\u2192thought, text\u2192text).\n\n      **Important:** All yielded responses represent one logical model turn.\n      The final response with `partial=False` should be identical to the\n      response that would be received with `stream=False`.\n    "
    - signature: 'def connect(self, llm_request: google.adk.models.llm_request.LlmRequest) -> google.adk.models.base_llm_connection.BaseLlmConnection:'
      docstring: "Creates a live connection to the LLM.\n\nArgs:\n  llm_request: LlmRequest, the request to send to the LLM.\n\nReturns:\n  BaseLlmConnection, the connection to the LLM."
  inherited_properties:
    Gemini:
    - signature: 'model: str'
    - signature: 'speech_config: typing.Optional[google.genai.types.SpeechConfig]'
    - signature: 'use_interactions_api: bool'
      docstring: "Whether to use the interactions API for model invocation.\n\nWhen enabled, uses the interactions API (client.aio.interactions.create())\ninstead of the traditional generate_content API. The interactions API\nprovides stateful conversation capabilities, allowing you to chain\ninteractions using previous_interaction_id instead of sending full history.\nThe response format will be converted to match the existing LlmResponse\nstructure for compatibility.\n\nSample:\n```python\nagent = Agent(\n  model=Gemini(use_interactions_api=True)\n)\n```"
    - signature: 'retry_options: typing.Optional[google.genai.types.HttpRetryOptions]'
      docstring: "Allow Gemini to retry failed responses.\n\nSample:\n```python\nfrom google.genai import types\n\n# ...\n\nagent = Agent(\n  model=Gemini(\n    retry_options=types.HttpRetryOptions(initial_delay=1, attempts=2),\n  )\n)\n```"
    BaseLlm:
    - signature: 'model_config: pydantic.ConfigDict'
      docstring: The pydantic model config.
    - signature: 'model: str'
      docstring: The name of the LLM, e.g. gemini-2.5-flash or gemini-2.5-pro.
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1010
  id: google.adk.models.apigee_llm.ApigeeLlm.__init__
  name: __init__
  file_path: src/google/adk/models/apigee_llm.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the Apigee LLM backend.\n\nArgs:\n  model: The model string specifies the LLM provider (e.g., Vertex AI,\n    Gemini), API version, and the model ID. Supported format:\n    `apigee/[<provider>/][<version>/]<model_id>`\n\n    Components\n      `provider` (optional): `vertex_ai` or `gemini`. If omitted, behavior\n        depends on the `GOOGLE_GENAI_USE_VERTEXAI` environment variable. If\n        that is not set to TRUE or 1, it defaults to `gemini`. `provider`\n        takes precedence over `GOOGLE_GENAI_USE_VERTEXAI`.\n      `version` (optional): The API version (e.g., `v1`, `v1beta`). If\n        omitted, the default version for the provider is used.\n      `model_id` (required): The model identifier (e.g.,\n        `gemini-2.5-flash`).\n\n    Examples\n      - `apigee/gemini-2.5-flash`\n      - `apigee/v1/gemini-2.5-flash`\n      - `apigee/vertex_ai/gemini-2.5-flash`\n      - `apigee/gemini/v1/gemini-2.5-flash`\n      - `apigee/vertex_ai/v1beta/gemini-2.5-flash`\n\
    \n  proxy_url: The URL of the Apigee proxy.\n  custom_headers: A dictionary of headers to be sent with the request.\n  retry_options: Allow google-genai to retry failed responses."
  signature: 'def __init__(self, *, model: str, proxy_url: str | None=None, custom_headers: dict[str, str] | None=None, retry_options: typing.Optional[google.genai.types.HttpRetryOptions]=None):'
- rank: 1011
  id: google.adk.models.apigee_llm.ApigeeLlm.api_client
  name: api_client
  file_path: src/google/adk/models/apigee_llm.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Provides the api client.\n\nReturns:\n  The api client."
  signature: 'def api_client(self) -> google.genai.Client:'
- rank: 1012
  id: google.adk.models.apigee_llm.ApigeeLlm.supported_models
  name: supported_models
  file_path: src/google/adk/models/apigee_llm.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Provides the list of supported models.\n\nReturns:\n  A list of supported models."
  signature: 'def supported_models(cls) -> list[str]:'
- rank: 1013
  id: google.adk.models.base_llm
  name: base_llm
  file_path: src/google/adk/models/base_llm.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1014
  id: google.adk.models.base_llm.BaseLlm
  name: BaseLlm
  file_path: src/google/adk/models/base_llm.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'The BaseLLM class.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, model: str):'
  methods:
  - signature: 'def supported_models(cls) -> list[str]:'
    docstring: Returns a list of supported models in regex for LlmRegistry.
  - signature: 'def generate_content_async(self, llm_request: google.adk.models.llm_request.LlmRequest, stream: bool) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
    docstring: "Generates content for a single model turn.\n\n    This method handles Server-Sent Events (SSE) streaming for unidirectional\n    content generation. For bidirectional streaming (e.g., Gemini Live API),\n    use the `connect()` method instead.\n\n    Args:\n      llm_request: LlmRequest, the request to send to the LLM.\n      stream: bool = False, whether to enable SSE streaming mode.\n\n    Yields:\n      LlmResponse objects representing the model's response for one turn.\n\n      **Non-streaming mode (stream=False):**\n\n        Yields exactly one LlmResponse containing the complete model output\n        (text, function calls, bytes, etc.). This response has `partial=False`.\n\n      **Streaming mode (stream=True):**\n\n        Yields multiple LlmResponse objects as chunks arrive:\n\n        - Intermediate chunks: `partial=True` (progressive updates)\n        - Final chunk: `partial=False` (aggregated content from entire turn,\n          identical to stream=False output)\n\
      \        - Text consolidation: Consecutive text parts of the same type\n          (thought/non-thought) SHOULD merge without separator, but client\n          code must not rely on this - unconsolidated parts are unusual but also\n          valid\n\n      **Common content in partial chunks:**\n\n        All intermediate chunks have `partial=True` regardless of content type.\n        Common examples include:\n\n        - Text: Streams incrementally as tokens arrive\n        - Function calls: May arrive in separate chunks\n        - Bytes (e.g., images): Typically arrive as single chunk, interleaved\n          with text\n        - Thoughts: Stream incrementally when thinking_config is enabled\n\n      **Examples:**\n\n      1. Simple text streaming::\n\n           LlmResponse(partial=True,  parts=[\"The weather\"])\n           LlmResponse(partial=True,  parts=[\" in Tokyo is\"])\n           LlmResponse(partial=True,  parts=[\" sunny.\"])\n           LlmResponse(partial=False, parts=[\"\
      The weather in Tokyo is sunny.\"])\n\n      2. Text + function call::\n\n           LlmResponse(partial=True,  parts=[Text(\"Let me check...\")])\n           LlmResponse(partial=True,  parts=[FunctionCall(\"get_weather\", ...)])\n           LlmResponse(partial=False, parts=[Text(\"Let me check...\"),\n                                             FunctionCall(\"get_weather\", ...)])\n\n      3. Parallel function calls across chunks::\n\n           LlmResponse(partial=True,  parts=[Text(\"Checking both cities...\")])\n           LlmResponse(partial=True,  parts=[FunctionCall(\"get_weather\", Tokyo)])\n           LlmResponse(partial=True,  parts=[FunctionCall(\"get_weather\", NYC)])\n           LlmResponse(partial=False, parts=[Text(\"Checking both cities...\"),\n                                             FunctionCall(\"get_weather\", Tokyo),\n                                             FunctionCall(\"get_weather\", NYC)])\n\n      4. Text + bytes (image generation with gemini-2.5-flash-image)::\n\
      \n           LlmResponse(partial=True,  parts=[Text(\"Here's an image of a dog.\")])\n           LlmResponse(partial=True,  parts=[Text(\"\n\")])\n           LlmResponse(partial=True,  parts=[Blob(image/png, 1.6MB)])\n           LlmResponse(partial=True,  parts=[Text(\"It carries a bone\")])\n           LlmResponse(partial=True,  parts=[Text(\" and running around.\")])\n           LlmResponse(partial=False, parts=[Text(\"Here's an image of a dog.\n\"),\n                                             Blob(image/png, 1.6MB),\n                                             Text(\"It carries a bone and running around.\")])\n\n         Note: Consecutive text parts before and after blob merge separately.\n\n      5. Text with thinking (gemini-2.5-flash with thinking_config)::\n\n           LlmResponse(partial=True,  parts=[Thought(\"Let me analyze...\")])\n           LlmResponse(partial=True,  parts=[Thought(\"The user wants...\")])\n           LlmResponse(partial=True,  parts=[Text(\"Based\
      \ on my analysis,\")])\n           LlmResponse(partial=True,  parts=[Text(\" the answer is 42.\")])\n           LlmResponse(partial=False, parts=[Thought(\"Let me analyze...The user wants...\"),\n                                             Text(\"Based on my analysis, the answer is 42.\")])\n\n         Note: Consecutive parts of same type merge (thoughts\u2192thought, text\u2192text).\n\n      **Important:** All yielded responses represent one logical model turn.\n      The final response with `partial=False` should be identical to the\n      response that would be received with `stream=False`.\n    "
  - signature: 'def connect(self, llm_request: google.adk.models.llm_request.LlmRequest) -> google.adk.models.base_llm_connection.BaseLlmConnection:'
    docstring: "Creates a live connection to the LLM.\n\nArgs:\n  llm_request: LlmRequest, the request to send to the LLM.\n\nReturns:\n  BaseLlmConnection, the connection to the LLM."
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
    docstring: The pydantic model config.
  - signature: 'model: str'
    docstring: The name of the LLM, e.g. gemini-2.5-flash or gemini-2.5-pro.
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1015
  id: google.adk.models.base_llm.BaseLlm.connect
  name: connect
  file_path: src/google/adk/models/base_llm.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Creates a live connection to the LLM.\n\nArgs:\n  llm_request: LlmRequest, the request to send to the LLM.\n\nReturns:\n  BaseLlmConnection, the connection to the LLM."
  signature: 'def connect(self, llm_request: google.adk.models.llm_request.LlmRequest) -> google.adk.models.base_llm_connection.BaseLlmConnection:'
- rank: 1016
  id: google.adk.models.base_llm.BaseLlm.generate_content_async
  name: generate_content_async
  file_path: src/google/adk/models/base_llm.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Generates content for a single model turn.\n\n    This method handles Server-Sent Events (SSE) streaming for unidirectional\n    content generation. For bidirectional streaming (e.g., Gemini Live API),\n    use the `connect()` method instead.\n\n    Args:\n      llm_request: LlmRequest, the request to send to the LLM.\n      stream: bool = False, whether to enable SSE streaming mode.\n\n    Yields:\n      LlmResponse objects representing the model's response for one turn.\n\n      **Non-streaming mode (stream=False):**\n\n        Yields exactly one LlmResponse containing the complete model output\n        (text, function calls, bytes, etc.). This response has `partial=False`.\n\n      **Streaming mode (stream=True):**\n\n        Yields multiple LlmResponse objects as chunks arrive:\n\n        - Intermediate chunks: `partial=True` (progressive updates)\n        - Final chunk: `partial=False` (aggregated content from entire turn,\n          identical to stream=False output)\n\
    \        - Text consolidation: Consecutive text parts of the same type\n          (thought/non-thought) SHOULD merge without separator, but client\n          code must not rely on this - unconsolidated parts are unusual but also\n          valid\n\n      **Common content in partial chunks:**\n\n        All intermediate chunks have `partial=True` regardless of content type.\n        Common examples include:\n\n        - Text: Streams incrementally as tokens arrive\n        - Function calls: May arrive in separate chunks\n        - Bytes (e.g., images): Typically arrive as single chunk, interleaved\n          with text\n        - Thoughts: Stream incrementally when thinking_config is enabled\n\n      **Examples:**\n\n      1. Simple text streaming::\n\n           LlmResponse(partial=True,  parts=[\"The weather\"])\n           LlmResponse(partial=True,  parts=[\" in Tokyo is\"])\n           LlmResponse(partial=True,  parts=[\" sunny.\"])\n           LlmResponse(partial=False, parts=[\"\
    The weather in Tokyo is sunny.\"])\n\n      2. Text + function call::\n\n           LlmResponse(partial=True,  parts=[Text(\"Let me check...\")])\n           LlmResponse(partial=True,  parts=[FunctionCall(\"get_weather\", ...)])\n           LlmResponse(partial=False, parts=[Text(\"Let me check...\"),\n                                             FunctionCall(\"get_weather\", ...)])\n\n      3. Parallel function calls across chunks::\n\n           LlmResponse(partial=True,  parts=[Text(\"Checking both cities...\")])\n           LlmResponse(partial=True,  parts=[FunctionCall(\"get_weather\", Tokyo)])\n           LlmResponse(partial=True,  parts=[FunctionCall(\"get_weather\", NYC)])\n           LlmResponse(partial=False, parts=[Text(\"Checking both cities...\"),\n                                             FunctionCall(\"get_weather\", Tokyo),\n                                             FunctionCall(\"get_weather\", NYC)])\n\n      4. Text + bytes (image generation with gemini-2.5-flash-image)::\n\
    \n           LlmResponse(partial=True,  parts=[Text(\"Here's an image of a dog.\")])\n           LlmResponse(partial=True,  parts=[Text(\"\n\")])\n           LlmResponse(partial=True,  parts=[Blob(image/png, 1.6MB)])\n           LlmResponse(partial=True,  parts=[Text(\"It carries a bone\")])\n           LlmResponse(partial=True,  parts=[Text(\" and running around.\")])\n           LlmResponse(partial=False, parts=[Text(\"Here's an image of a dog.\n\"),\n                                             Blob(image/png, 1.6MB),\n                                             Text(\"It carries a bone and running around.\")])\n\n         Note: Consecutive text parts before and after blob merge separately.\n\n      5. Text with thinking (gemini-2.5-flash with thinking_config)::\n\n           LlmResponse(partial=True,  parts=[Thought(\"Let me analyze...\")])\n           LlmResponse(partial=True,  parts=[Thought(\"The user wants...\")])\n           LlmResponse(partial=True,  parts=[Text(\"Based on\
    \ my analysis,\")])\n           LlmResponse(partial=True,  parts=[Text(\" the answer is 42.\")])\n           LlmResponse(partial=False, parts=[Thought(\"Let me analyze...The user wants...\"),\n                                             Text(\"Based on my analysis, the answer is 42.\")])\n\n         Note: Consecutive parts of same type merge (thoughts\u2192thought, text\u2192text).\n\n      **Important:** All yielded responses represent one logical model turn.\n      The final response with `partial=False` should be identical to the\n      response that would be received with `stream=False`.\n    "
  signature: 'def generate_content_async(self, llm_request: google.adk.models.llm_request.LlmRequest, stream: bool) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
- rank: 1017
  id: google.adk.models.base_llm_connection
  name: base_llm_connection
  file_path: src/google/adk/models/base_llm_connection.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1018
  id: google.adk.models.base_llm_connection.BaseLlmConnection
  name: BaseLlmConnection
  file_path: src/google/adk/models/base_llm_connection.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: The base class for a live model connection.
  methods:
  - signature: 'def send_history(self, history: list[google.genai.types.Content]):'
    docstring: "Sends the conversation history to the model.\n\nYou call this method right after setting up the model connection.\nThe model will respond if the last content is from user; otherwise, it will\nwait for new user input before responding.\n\nArgs:\n  history: The conversation history to send to the model."
  - signature: 'def send_content(self, content: google.genai.types.Content):'
    docstring: "Sends a user content to the model.\n\nThe model will respond immediately upon receiving the content.\nIf you send function responses, all parts in the content should be function\nresponses.\n\nArgs:\n  content: The content to send to the model."
  - signature: 'def send_realtime(self, blob: google.genai.types.Blob):'
    docstring: "Sends a chunk of audio or a frame of video to the model in realtime.\n\nThe model may not respond immediately upon receiving the blob. It will do\nvoice activity detection and decide when to respond.\n\nArgs:\n  blob: The blob to send to the model."
  - signature: 'def receive(self) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
    docstring: "Receives the model response using the llm server connection.\n\nArgs: None.\n\nYields:\n  LlmResponse: The model response."
  - signature: 'def close(self):'
    docstring: Closes the llm server connection.
- rank: 1019
  id: google.adk.models.base_llm_connection.BaseLlmConnection.receive
  name: receive
  file_path: src/google/adk/models/base_llm_connection.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Receives the model response using the llm server connection.\n\nArgs: None.\n\nYields:\n  LlmResponse: The model response."
  signature: 'def receive(self) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
- rank: 1020
  id: google.adk.models.base_llm_connection.BaseLlmConnection.send_content
  name: send_content
  file_path: src/google/adk/models/base_llm_connection.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Sends a user content to the model.\n\nThe model will respond immediately upon receiving the content.\nIf you send function responses, all parts in the content should be function\nresponses.\n\nArgs:\n  content: The content to send to the model."
  signature: 'def send_content(self, content: google.genai.types.Content):'
- rank: 1021
  id: google.adk.models.base_llm_connection.BaseLlmConnection.send_history
  name: send_history
  file_path: src/google/adk/models/base_llm_connection.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Sends the conversation history to the model.\n\nYou call this method right after setting up the model connection.\nThe model will respond if the last content is from user; otherwise, it will\nwait for new user input before responding.\n\nArgs:\n  history: The conversation history to send to the model."
  signature: 'def send_history(self, history: list[google.genai.types.Content]):'
- rank: 1022
  id: google.adk.models.base_llm_connection.BaseLlmConnection.send_realtime
  name: send_realtime
  file_path: src/google/adk/models/base_llm_connection.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Sends a chunk of audio or a frame of video to the model in realtime.\n\nThe model may not respond immediately upon receiving the blob. It will do\nvoice activity detection and decide when to respond.\n\nArgs:\n  blob: The blob to send to the model."
  signature: 'def send_realtime(self, blob: google.genai.types.Blob):'
- rank: 1023
  id: google.adk.models.cache_metadata
  name: cache_metadata
  file_path: src/google/adk/models/cache_metadata.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1024
  id: google.adk.models.cache_metadata.CacheMetadata
  name: CacheMetadata
  file_path: src/google/adk/models/cache_metadata.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "Metadata for context cache associated with LLM responses.\n\nThis class stores cache identification, usage tracking, and lifecycle\ninformation for a particular cache instance. It can be in two states:\n\n1. Active cache state: cache_name is set, all fields populated\n2. Fingerprint-only state: cache_name is None, only fingerprint and\n   contents_count are set for prefix matching\n\nToken counts (cached and total) are available in the LlmResponse.usage_metadata\nand should be accessed from there to avoid duplication.\n\nAttributes:\n    cache_name: The full resource name of the cached content (e.g.,\n        'projects/123/locations/us-central1/cachedContents/456').\n        None when no active cache exists (fingerprint-only state).\n    expire_time: Unix timestamp when the cache expires. None when no\n        active cache exists.\n    fingerprint: Hash of cacheable contents (instruction + tools + contents).\n        Always present for prefix matching.\n    invocations_used:\
    \ Number of invocations this cache has been used for.\n        None when no active cache exists.\n    contents_count: Number of contents. When active cache exists, this is\n        the count of cached contents. When no active cache exists, this is\n        the total count of contents in the request.\n    created_at: Unix timestamp when the cache was created. None when\n        no active cache exists.\n\n[Note: Inherited members from pydantic.BaseModel are omitted.]"
  constructor_signature: 'def __init__(self, *, cache_name: typing.Optional[str] = None, expire_time: typing.Optional[float] = None, fingerprint: str, invocations_used: typing.Optional[int] = None, contents_count: int, created_at: typing.Optional[float] = None):'
  methods:
  - signature: 'def expire_soon(self) -> bool:'
    docstring: Check if the cache will expire soon (with 2-minute buffer).
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'cache_name: typing.Optional[str]'
  - signature: 'expire_time: typing.Optional[float]'
  - signature: 'fingerprint: str'
  - signature: 'invocations_used: typing.Optional[int]'
  - signature: 'contents_count: int'
  - signature: 'created_at: typing.Optional[float]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1025
  id: google.adk.models.cache_metadata.CacheMetadata.expire_soon
  name: expire_soon
  file_path: src/google/adk/models/cache_metadata.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Check if the cache will expire soon (with 2-minute buffer).
  signature: 'def expire_soon(self) -> bool:'
- rank: 1026
  id: google.adk.models.gemini_context_cache_manager
  name: gemini_context_cache_manager
  file_path: src/google/adk/models/gemini_context_cache_manager.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Manages context cache lifecycle for Gemini models.
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 1027
  id: google.adk.models.gemini_context_cache_manager.GeminiContextCacheManager
  name: GeminiContextCacheManager
  file_path: src/google/adk/models/gemini_context_cache_manager.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Manages context cache lifecycle for Gemini models.


    This manager handles cache creation, validation, cleanup, and metadata

    population for Gemini context caching. It uses content hashing to determine

    cache compatibility and implements efficient caching strategies.'
  constructor_signature: 'def __init__(self, genai_client: google.genai.Client):'
  methods:
  - signature: 'def handle_context_caching(self, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[google.adk.models.cache_metadata.CacheMetadata]:'
    docstring: "Handle context caching for Gemini models.\n\nValidates existing cache or creates a new one if needed. Applies\nthe cache to the request by setting cached_content and removing cached\ncontents from the request.\n\nArgs:\n    llm_request: Request that may contain cache config and metadata.\n                Modified in-place to use the cache.\n\nReturns:\n    Cache metadata to be included in response, or None if caching failed"
  - signature: 'def cleanup_cache(self, cache_name: str) -> None:'
    docstring: "Clean up cache by deleting it.\n\nArgs:\n    cache_name: Name of cache to delete"
  - signature: 'def populate_cache_metadata_in_response(self, llm_response: google.adk.models.llm_response.LlmResponse, cache_metadata: google.adk.models.cache_metadata.CacheMetadata) -> None:'
    docstring: "Populate cache metadata in LLM response.\n\nArgs:\n    llm_response: Response to populate metadata in\n    cache_metadata: Cache metadata to copy into response"
- rank: 1028
  id: google.adk.models.gemini_context_cache_manager.GeminiContextCacheManager.__init__
  name: __init__
  file_path: src/google/adk/models/gemini_context_cache_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initialize cache manager with shared client.\n\nArgs:\n    genai_client: The GenAI client to use for cache operations."
  signature: 'def __init__(self, genai_client: google.genai.Client):'
- rank: 1029
  id: google.adk.models.gemini_context_cache_manager.GeminiContextCacheManager.cleanup_cache
  name: cleanup_cache
  file_path: src/google/adk/models/gemini_context_cache_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Clean up cache by deleting it.\n\nArgs:\n    cache_name: Name of cache to delete"
  signature: 'def cleanup_cache(self, cache_name: str) -> None:'
- rank: 1030
  id: google.adk.models.gemini_context_cache_manager.GeminiContextCacheManager.handle_context_caching
  name: handle_context_caching
  file_path: src/google/adk/models/gemini_context_cache_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Handle context caching for Gemini models.\n\nValidates existing cache or creates a new one if needed. Applies\nthe cache to the request by setting cached_content and removing cached\ncontents from the request.\n\nArgs:\n    llm_request: Request that may contain cache config and metadata.\n                Modified in-place to use the cache.\n\nReturns:\n    Cache metadata to be included in response, or None if caching failed"
  signature: 'def handle_context_caching(self, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[google.adk.models.cache_metadata.CacheMetadata]:'
- rank: 1031
  id: google.adk.models.gemini_context_cache_manager.GeminiContextCacheManager.populate_cache_metadata_in_response
  name: populate_cache_metadata_in_response
  file_path: src/google/adk/models/gemini_context_cache_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Populate cache metadata in LLM response.\n\nArgs:\n    llm_response: Response to populate metadata in\n    cache_metadata: Cache metadata to copy into response"
  signature: 'def populate_cache_metadata_in_response(self, llm_response: google.adk.models.llm_response.LlmResponse, cache_metadata: google.adk.models.cache_metadata.CacheMetadata) -> None:'
- rank: 1032
  id: google.adk.models.gemini_llm_connection
  name: gemini_llm_connection
  file_path: src/google/adk/models/gemini_llm_connection.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: 'RealtimeInput: Any'
- rank: 1033
  id: google.adk.models.gemini_llm_connection.GeminiLlmConnection
  name: GeminiLlmConnection
  file_path: src/google/adk/models/gemini_llm_connection.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: The Gemini model connection.
  constructor_signature: 'def __init__(self, gemini_session: google.genai.live.AsyncSession, api_backend: google.adk.utils.variant_utils.GoogleLLMVariant, model_version: str | None):'
  methods:
  - signature: 'def send_history(self, history: list[google.genai.types.Content]):'
    docstring: "Sends the conversation history to the gemini model.\n\nYou call this method right after setting up the model connection.\nThe model will respond if the last content is from user; otherwise, it will\nwait for new user input before responding.\n\nArgs:\n  history: The conversation history to send to the model."
  - signature: 'def send_content(self, content: google.genai.types.Content):'
    docstring: "Sends a user content to the gemini model.\n\nThe model will respond immediately upon receiving the content.\nIf you send function responses, all parts in the content should be function\nresponses.\n\nArgs:\n  content: The content to send to the model."
  - signature: 'def send_realtime(self, input: google.adk.models.gemini_llm_connection.RealtimeInput):'
    docstring: "Sends a chunk of audio or a frame of video to the model in realtime.\n\nArgs:\n  input: The input to send to the model."
  - signature: 'def receive(self) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
    docstring: "Receives the model response using the llm server connection.\n\nYields:\n  LlmResponse: The model response."
  - signature: 'def close(self):'
    docstring: Closes the llm server connection.
  inherited_methods:
    BaseLlmConnection:
    - signature: 'def send_history(self, history: list[google.genai.types.Content]):'
      docstring: "Sends the conversation history to the model.\n\nYou call this method right after setting up the model connection.\nThe model will respond if the last content is from user; otherwise, it will\nwait for new user input before responding.\n\nArgs:\n  history: The conversation history to send to the model."
    - signature: 'def send_content(self, content: google.genai.types.Content):'
      docstring: "Sends a user content to the model.\n\nThe model will respond immediately upon receiving the content.\nIf you send function responses, all parts in the content should be function\nresponses.\n\nArgs:\n  content: The content to send to the model."
    - signature: 'def send_realtime(self, blob: google.genai.types.Blob):'
      docstring: "Sends a chunk of audio or a frame of video to the model in realtime.\n\nThe model may not respond immediately upon receiving the blob. It will do\nvoice activity detection and decide when to respond.\n\nArgs:\n  blob: The blob to send to the model."
    - signature: 'def receive(self) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
      docstring: "Receives the model response using the llm server connection.\n\nArgs: None.\n\nYields:\n  LlmResponse: The model response."
    - signature: 'def close(self):'
      docstring: Closes the llm server connection.
- rank: 1034
  id: google.adk.models.gemini_llm_connection.GeminiLlmConnection.__init__
  name: __init__
  file_path: src/google/adk/models/gemini_llm_connection.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, gemini_session: google.genai.live.AsyncSession, api_backend: google.adk.utils.variant_utils.GoogleLLMVariant, model_version: str | None):'
- rank: 1035
  id: google.adk.models.gemini_llm_connection.GeminiLlmConnection.close
  name: close
  file_path: src/google/adk/models/gemini_llm_connection.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Closes the llm server connection.
  signature: 'def close(self):'
- rank: 1036
  id: google.adk.models.gemini_llm_connection.GeminiLlmConnection.receive
  name: receive
  file_path: src/google/adk/models/gemini_llm_connection.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Receives the model response using the llm server connection.\n\nYields:\n  LlmResponse: The model response."
  signature: 'def receive(self) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
- rank: 1037
  id: google.adk.models.gemini_llm_connection.GeminiLlmConnection.send_content
  name: send_content
  file_path: src/google/adk/models/gemini_llm_connection.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Sends a user content to the gemini model.\n\nThe model will respond immediately upon receiving the content.\nIf you send function responses, all parts in the content should be function\nresponses.\n\nArgs:\n  content: The content to send to the model."
  signature: 'def send_content(self, content: google.genai.types.Content):'
- rank: 1038
  id: google.adk.models.gemini_llm_connection.GeminiLlmConnection.send_history
  name: send_history
  file_path: src/google/adk/models/gemini_llm_connection.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Sends the conversation history to the gemini model.\n\nYou call this method right after setting up the model connection.\nThe model will respond if the last content is from user; otherwise, it will\nwait for new user input before responding.\n\nArgs:\n  history: The conversation history to send to the model."
  signature: 'def send_history(self, history: list[google.genai.types.Content]):'
- rank: 1039
  id: google.adk.models.gemini_llm_connection.GeminiLlmConnection.send_realtime
  name: send_realtime
  file_path: src/google/adk/models/gemini_llm_connection.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Sends a chunk of audio or a frame of video to the model in realtime.\n\nArgs:\n  input: The input to send to the model."
  signature: 'def send_realtime(self, input: google.adk.models.gemini_llm_connection.RealtimeInput):'
- rank: 1040
  id: google.adk.models.gemma_llm
  name: gemma_llm
  file_path: src/google/adk/models/gemma_llm.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: 'LiteLlm: NoneType'
- rank: 1041
  id: google.adk.models.gemma_llm.Gemma
  name: Gemma
  file_path: src/google/adk/models/gemma_llm.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Integration for Gemma models exposed via the Gemini API.


    Only Gemma 3 models are supported at this time. For agentic use cases,

    use of gemma-3-27b-it and gemma-3-12b-it are strongly recommended.


    For full documentation, see: https://ai.google.dev/gemma/docs/core/


    NOTE: Gemma does **NOT** support system instructions. Any system instructions

    will be replaced with an initial *user* prompt in the LLM request. If system

    instructions change over the course of agent execution, the initial content

    **SHOULD** be replaced. Special care is warranted here.

    See:

    https://ai.google.dev/gemma/docs/core/prompt-structure#system-instructions


    NOTE: Gemma''s function calling support is limited. It does not have full

    access to the

    same built-in tools as Gemini. It also does not have special API support for

    tools and

    functions. Rather, tools must be passed in via a `user` prompt, and extracted

    from model

    responses based on approximate shape.


    NOTE: Vertex AI API support for Gemma is not currently included. This **ONLY**

    supports

    usage via the Gemini API.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, model: str, speech_config: typing.Optional[google.genai.types.SpeechConfig] = None, use_interactions_api: bool = False, retry_options: typing.Optional[google.genai.types.HttpRetryOptions] = None):'
  methods:
  - signature: 'def supported_models(cls) -> list[str]:'
    docstring: 'Provides the list of supported models.


      Returns:

      A list of supported models.'
  - signature: 'def generate_content_async(self, llm_request: google.adk.models.llm_request.LlmRequest, stream: bool) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
    docstring: "Sends a request to the Gemma model.\n\nArgs:\n  llm_request: LlmRequest, the request to send to the Gemini model.\n  stream: bool = False, whether to do streaming call.\n\nYields:\n  LlmResponse: The model response."
  properties:
  - signature: 'model: str'
  inherited_methods:
    Gemini:
    - signature: 'def supported_models(cls) -> list[str]:'
      docstring: "Provides the list of supported models.\n\nReturns:\n  A list of supported models."
    - signature: 'def generate_content_async(self, llm_request: google.adk.models.llm_request.LlmRequest, stream: bool) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
      docstring: "Sends a request to the Gemini model.\n\nArgs:\n  llm_request: LlmRequest, the request to send to the Gemini model.\n  stream: bool = False, whether to do streaming call.\n\nYields:\n  LlmResponse: The model response."
    - signature: 'def api_client(self) -> google.genai.Client:'
      docstring: "Provides the api client.\n\nReturns:\n  The api client."
    - signature: 'def connect(self, llm_request: google.adk.models.llm_request.LlmRequest) -> google.adk.models.base_llm_connection.BaseLlmConnection:'
      docstring: "Connects to the Gemini model and returns an llm connection.\n\nArgs:\n  llm_request: LlmRequest, the request to send to the Gemini model.\n\nYields:\n  BaseLlmConnection, the connection to the Gemini model."
    BaseLlm:
    - signature: 'def supported_models(cls) -> list[str]:'
      docstring: Returns a list of supported models in regex for LlmRegistry.
    - signature: 'def generate_content_async(self, llm_request: google.adk.models.llm_request.LlmRequest, stream: bool) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
      docstring: "Generates content for a single model turn.\n\n    This method handles Server-Sent Events (SSE) streaming for unidirectional\n    content generation. For bidirectional streaming (e.g., Gemini Live API),\n    use the `connect()` method instead.\n\n    Args:\n      llm_request: LlmRequest, the request to send to the LLM.\n      stream: bool = False, whether to enable SSE streaming mode.\n\n    Yields:\n      LlmResponse objects representing the model's response for one turn.\n\n      **Non-streaming mode (stream=False):**\n\n        Yields exactly one LlmResponse containing the complete model output\n        (text, function calls, bytes, etc.). This response has `partial=False`.\n\n      **Streaming mode (stream=True):**\n\n        Yields multiple LlmResponse objects as chunks arrive:\n\n        - Intermediate chunks: `partial=True` (progressive updates)\n        - Final chunk: `partial=False` (aggregated content from entire turn,\n          identical to stream=False output)\n\
        \        - Text consolidation: Consecutive text parts of the same type\n          (thought/non-thought) SHOULD merge without separator, but client\n          code must not rely on this - unconsolidated parts are unusual but also\n          valid\n\n      **Common content in partial chunks:**\n\n        All intermediate chunks have `partial=True` regardless of content type.\n        Common examples include:\n\n        - Text: Streams incrementally as tokens arrive\n        - Function calls: May arrive in separate chunks\n        - Bytes (e.g., images): Typically arrive as single chunk, interleaved\n          with text\n        - Thoughts: Stream incrementally when thinking_config is enabled\n\n      **Examples:**\n\n      1. Simple text streaming::\n\n           LlmResponse(partial=True,  parts=[\"The weather\"])\n           LlmResponse(partial=True,  parts=[\" in Tokyo is\"])\n           LlmResponse(partial=True,  parts=[\" sunny.\"])\n           LlmResponse(partial=False, parts=[\"\
        The weather in Tokyo is sunny.\"])\n\n      2. Text + function call::\n\n           LlmResponse(partial=True,  parts=[Text(\"Let me check...\")])\n           LlmResponse(partial=True,  parts=[FunctionCall(\"get_weather\", ...)])\n           LlmResponse(partial=False, parts=[Text(\"Let me check...\"),\n                                             FunctionCall(\"get_weather\", ...)])\n\n      3. Parallel function calls across chunks::\n\n           LlmResponse(partial=True,  parts=[Text(\"Checking both cities...\")])\n           LlmResponse(partial=True,  parts=[FunctionCall(\"get_weather\", Tokyo)])\n           LlmResponse(partial=True,  parts=[FunctionCall(\"get_weather\", NYC)])\n           LlmResponse(partial=False, parts=[Text(\"Checking both cities...\"),\n                                             FunctionCall(\"get_weather\", Tokyo),\n                                             FunctionCall(\"get_weather\", NYC)])\n\n      4. Text + bytes (image generation with gemini-2.5-flash-image)::\n\
        \n           LlmResponse(partial=True,  parts=[Text(\"Here's an image of a dog.\")])\n           LlmResponse(partial=True,  parts=[Text(\"\n\")])\n           LlmResponse(partial=True,  parts=[Blob(image/png, 1.6MB)])\n           LlmResponse(partial=True,  parts=[Text(\"It carries a bone\")])\n           LlmResponse(partial=True,  parts=[Text(\" and running around.\")])\n           LlmResponse(partial=False, parts=[Text(\"Here's an image of a dog.\n\"),\n                                             Blob(image/png, 1.6MB),\n                                             Text(\"It carries a bone and running around.\")])\n\n         Note: Consecutive text parts before and after blob merge separately.\n\n      5. Text with thinking (gemini-2.5-flash with thinking_config)::\n\n           LlmResponse(partial=True,  parts=[Thought(\"Let me analyze...\")])\n           LlmResponse(partial=True,  parts=[Thought(\"The user wants...\")])\n           LlmResponse(partial=True,  parts=[Text(\"Based\
        \ on my analysis,\")])\n           LlmResponse(partial=True,  parts=[Text(\" the answer is 42.\")])\n           LlmResponse(partial=False, parts=[Thought(\"Let me analyze...The user wants...\"),\n                                             Text(\"Based on my analysis, the answer is 42.\")])\n\n         Note: Consecutive parts of same type merge (thoughts\u2192thought, text\u2192text).\n\n      **Important:** All yielded responses represent one logical model turn.\n      The final response with `partial=False` should be identical to the\n      response that would be received with `stream=False`.\n    "
    - signature: 'def connect(self, llm_request: google.adk.models.llm_request.LlmRequest) -> google.adk.models.base_llm_connection.BaseLlmConnection:'
      docstring: "Creates a live connection to the LLM.\n\nArgs:\n  llm_request: LlmRequest, the request to send to the LLM.\n\nReturns:\n  BaseLlmConnection, the connection to the LLM."
  inherited_properties:
    Gemini:
    - signature: 'model: str'
    - signature: 'speech_config: typing.Optional[google.genai.types.SpeechConfig]'
    - signature: 'use_interactions_api: bool'
      docstring: "Whether to use the interactions API for model invocation.\n\nWhen enabled, uses the interactions API (client.aio.interactions.create())\ninstead of the traditional generate_content API. The interactions API\nprovides stateful conversation capabilities, allowing you to chain\ninteractions using previous_interaction_id instead of sending full history.\nThe response format will be converted to match the existing LlmResponse\nstructure for compatibility.\n\nSample:\n```python\nagent = Agent(\n  model=Gemini(use_interactions_api=True)\n)\n```"
    - signature: 'retry_options: typing.Optional[google.genai.types.HttpRetryOptions]'
      docstring: "Allow Gemini to retry failed responses.\n\nSample:\n```python\nfrom google.genai import types\n\n# ...\n\nagent = Agent(\n  model=Gemini(\n    retry_options=types.HttpRetryOptions(initial_delay=1, attempts=2),\n  )\n)\n```"
    BaseLlm:
    - signature: 'model_config: pydantic.ConfigDict'
      docstring: The pydantic model config.
    - signature: 'model: str'
      docstring: The name of the LLM, e.g. gemini-2.5-flash or gemini-2.5-pro.
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1042
  id: google.adk.models.gemma_llm.Gemma.generate_content_async
  name: generate_content_async
  file_path: src/google/adk/models/gemma_llm.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Sends a request to the Gemma model.\n\nArgs:\n  llm_request: LlmRequest, the request to send to the Gemini model.\n  stream: bool = False, whether to do streaming call.\n\nYields:\n  LlmResponse: The model response."
  signature: 'def generate_content_async(self, llm_request: google.adk.models.llm_request.LlmRequest, stream: bool) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
- rank: 1043
  id: google.adk.models.gemma_llm.Gemma.supported_models
  name: supported_models
  file_path: src/google/adk/models/gemma_llm.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Provides the list of supported models.


    Returns:

    A list of supported models.'
  signature: 'def supported_models(cls) -> list[str]:'
- rank: 1044
  id: google.adk.models.gemma_llm.Gemma3Ollama
  name: Gemma3Ollama
  file_path: src/google/adk/models/gemma_llm.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "Integration for Gemma 3 models running locally via Ollama.\n\nThis enables fully local agent workflows using Gemma 3 models.\nRequires Ollama to be running with a Gemma 3 model pulled.\n\nExample:\n  ollama pull gemma3:12b\n  model = Gemma3Ollama(model=\"ollama/gemma3:12b\")\n\n[Note: Inherited members from pydantic.BaseModel are omitted.]"
  constructor_signature: 'def __init__(self, model: str):'
  methods:
  - signature: 'def supported_models(cls) -> list[str]:'
  - signature: 'def generate_content_async(self, llm_request: google.adk.models.llm_request.LlmRequest, stream: bool) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
    docstring: "Sends a request to Gemma via Ollama/LiteLLM.\n\nArgs:\n  llm_request: LlmRequest, the request to send.\n  stream: bool = False, whether to do streaming call.\n\nYields:\n  LlmResponse: The model response."
  inherited_methods:
    LiteLlm:
    - signature: 'def generate_content_async(self, llm_request: google.adk.models.llm_request.LlmRequest, stream: bool) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
      docstring: "Generates content asynchronously.\n\nArgs:\n  llm_request: LlmRequest, the request to send to the LiteLlm model.\n  stream: bool = False, whether to do streaming call.\n\nYields:\n  LlmResponse: The model response."
    - signature: 'def supported_models(cls) -> list[str]:'
      docstring: "Provides the list of supported models.\n\nThis registers common provider prefixes. LiteLlm can handle many more,\nbut these patterns activate the integration for the most common use cases.\nSee https://docs.litellm.ai/docs/providers for a full list.\n\nReturns:\n  A list of supported models."
    BaseLlm:
    - signature: 'def supported_models(cls) -> list[str]:'
      docstring: Returns a list of supported models in regex for LlmRegistry.
    - signature: 'def generate_content_async(self, llm_request: google.adk.models.llm_request.LlmRequest, stream: bool) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
      docstring: "Generates content for a single model turn.\n\n    This method handles Server-Sent Events (SSE) streaming for unidirectional\n    content generation. For bidirectional streaming (e.g., Gemini Live API),\n    use the `connect()` method instead.\n\n    Args:\n      llm_request: LlmRequest, the request to send to the LLM.\n      stream: bool = False, whether to enable SSE streaming mode.\n\n    Yields:\n      LlmResponse objects representing the model's response for one turn.\n\n      **Non-streaming mode (stream=False):**\n\n        Yields exactly one LlmResponse containing the complete model output\n        (text, function calls, bytes, etc.). This response has `partial=False`.\n\n      **Streaming mode (stream=True):**\n\n        Yields multiple LlmResponse objects as chunks arrive:\n\n        - Intermediate chunks: `partial=True` (progressive updates)\n        - Final chunk: `partial=False` (aggregated content from entire turn,\n          identical to stream=False output)\n\
        \        - Text consolidation: Consecutive text parts of the same type\n          (thought/non-thought) SHOULD merge without separator, but client\n          code must not rely on this - unconsolidated parts are unusual but also\n          valid\n\n      **Common content in partial chunks:**\n\n        All intermediate chunks have `partial=True` regardless of content type.\n        Common examples include:\n\n        - Text: Streams incrementally as tokens arrive\n        - Function calls: May arrive in separate chunks\n        - Bytes (e.g., images): Typically arrive as single chunk, interleaved\n          with text\n        - Thoughts: Stream incrementally when thinking_config is enabled\n\n      **Examples:**\n\n      1. Simple text streaming::\n\n           LlmResponse(partial=True,  parts=[\"The weather\"])\n           LlmResponse(partial=True,  parts=[\" in Tokyo is\"])\n           LlmResponse(partial=True,  parts=[\" sunny.\"])\n           LlmResponse(partial=False, parts=[\"\
        The weather in Tokyo is sunny.\"])\n\n      2. Text + function call::\n\n           LlmResponse(partial=True,  parts=[Text(\"Let me check...\")])\n           LlmResponse(partial=True,  parts=[FunctionCall(\"get_weather\", ...)])\n           LlmResponse(partial=False, parts=[Text(\"Let me check...\"),\n                                             FunctionCall(\"get_weather\", ...)])\n\n      3. Parallel function calls across chunks::\n\n           LlmResponse(partial=True,  parts=[Text(\"Checking both cities...\")])\n           LlmResponse(partial=True,  parts=[FunctionCall(\"get_weather\", Tokyo)])\n           LlmResponse(partial=True,  parts=[FunctionCall(\"get_weather\", NYC)])\n           LlmResponse(partial=False, parts=[Text(\"Checking both cities...\"),\n                                             FunctionCall(\"get_weather\", Tokyo),\n                                             FunctionCall(\"get_weather\", NYC)])\n\n      4. Text + bytes (image generation with gemini-2.5-flash-image)::\n\
        \n           LlmResponse(partial=True,  parts=[Text(\"Here's an image of a dog.\")])\n           LlmResponse(partial=True,  parts=[Text(\"\n\")])\n           LlmResponse(partial=True,  parts=[Blob(image/png, 1.6MB)])\n           LlmResponse(partial=True,  parts=[Text(\"It carries a bone\")])\n           LlmResponse(partial=True,  parts=[Text(\" and running around.\")])\n           LlmResponse(partial=False, parts=[Text(\"Here's an image of a dog.\n\"),\n                                             Blob(image/png, 1.6MB),\n                                             Text(\"It carries a bone and running around.\")])\n\n         Note: Consecutive text parts before and after blob merge separately.\n\n      5. Text with thinking (gemini-2.5-flash with thinking_config)::\n\n           LlmResponse(partial=True,  parts=[Thought(\"Let me analyze...\")])\n           LlmResponse(partial=True,  parts=[Thought(\"The user wants...\")])\n           LlmResponse(partial=True,  parts=[Text(\"Based\
        \ on my analysis,\")])\n           LlmResponse(partial=True,  parts=[Text(\" the answer is 42.\")])\n           LlmResponse(partial=False, parts=[Thought(\"Let me analyze...The user wants...\"),\n                                             Text(\"Based on my analysis, the answer is 42.\")])\n\n         Note: Consecutive parts of same type merge (thoughts\u2192thought, text\u2192text).\n\n      **Important:** All yielded responses represent one logical model turn.\n      The final response with `partial=False` should be identical to the\n      response that would be received with `stream=False`.\n    "
    - signature: 'def connect(self, llm_request: google.adk.models.llm_request.LlmRequest) -> google.adk.models.base_llm_connection.BaseLlmConnection:'
      docstring: "Creates a live connection to the LLM.\n\nArgs:\n  llm_request: LlmRequest, the request to send to the LLM.\n\nReturns:\n  BaseLlmConnection, the connection to the LLM."
  inherited_properties:
    LiteLlm:
    - signature: 'llm_client: google.adk.models.lite_llm.LiteLLMClient'
      docstring: The LLM client to use for the model.
    BaseLlm:
    - signature: 'model_config: pydantic.ConfigDict'
      docstring: The pydantic model config.
    - signature: 'model: str'
      docstring: The name of the LLM, e.g. gemini-2.5-flash or gemini-2.5-pro.
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1045
  id: google.adk.models.gemma_llm.Gemma3Ollama.generate_content_async
  name: generate_content_async
  file_path: src/google/adk/models/gemma_llm.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Sends a request to Gemma via Ollama/LiteLLM.\n\nArgs:\n  llm_request: LlmRequest, the request to send.\n  stream: bool = False, whether to do streaming call.\n\nYields:\n  LlmResponse: The model response."
  signature: 'def generate_content_async(self, llm_request: google.adk.models.llm_request.LlmRequest, stream: bool) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
- rank: 1046
  id: google.adk.models.gemma_llm.Gemma3Ollama.supported_models
  name: supported_models
  file_path: src/google/adk/models/gemma_llm.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def supported_models(cls) -> list[str]:'
- rank: 1047
  id: google.adk.models.gemma_llm.GemmaFunctionCallModel
  name: GemmaFunctionCallModel
  file_path: src/google/adk/models/gemma_llm.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Flexible Pydantic model for parsing inline Gemma function call responses.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, name: str, parameters: dict[str, typing.Any]):'
  properties:
  - signature: 'name: str'
  - signature: 'parameters: dict[str, typing.Any]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1048
  id: google.adk.models.gemma_llm.GemmaFunctionCallingMixin
  name: GemmaFunctionCallingMixin
  file_path: src/google/adk/models/gemma_llm.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Mixin providing function calling support for Gemma models.


    Gemma models don''t have native function calling support, so this mixin

    provides the logic to:

    1. Convert function declarations to system instruction prompts

    2. Convert function call/response parts to text in the conversation

    3. Extract function calls from model text responses'
- rank: 1049
  id: google.adk.models.google_llm
  name: google_llm
  file_path: src/google/adk/models/google_llm.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '_NEW_LINE: str'
  - signature: '_EXCLUDED_PART_FIELD: Any'
  - signature: '_RESOURCE_EXHAUSTED_POSSIBLE_FIX_MESSAGE: str'
- rank: 1050
  id: google.adk.models.google_llm.Gemini.api_client
  name: api_client
  file_path: src/google/adk/models/google_llm.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Provides the api client.\n\nReturns:\n  The api client."
  signature: 'def api_client(self) -> google.genai.Client:'
- rank: 1051
  id: google.adk.models.google_llm.Gemini.connect
  name: connect
  file_path: src/google/adk/models/google_llm.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Connects to the Gemini model and returns an llm connection.\n\nArgs:\n  llm_request: LlmRequest, the request to send to the Gemini model.\n\nYields:\n  BaseLlmConnection, the connection to the Gemini model."
  signature: 'def connect(self, llm_request: google.adk.models.llm_request.LlmRequest) -> google.adk.models.base_llm_connection.BaseLlmConnection:'
- rank: 1052
  id: google.adk.models.google_llm.Gemini.generate_content_async
  name: generate_content_async
  file_path: src/google/adk/models/google_llm.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Sends a request to the Gemini model.\n\nArgs:\n  llm_request: LlmRequest, the request to send to the Gemini model.\n  stream: bool = False, whether to do streaming call.\n\nYields:\n  LlmResponse: The model response."
  signature: 'def generate_content_async(self, llm_request: google.adk.models.llm_request.LlmRequest, stream: bool) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
- rank: 1053
  id: google.adk.models.google_llm.Gemini.supported_models
  name: supported_models
  file_path: src/google/adk/models/google_llm.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Provides the list of supported models.\n\nReturns:\n  A list of supported models."
  signature: 'def supported_models(cls) -> list[str]:'
- rank: 1054
  id: google.adk.models.interactions_utils
  name: interactions_utils
  file_path: src/google/adk/models/interactions_utils.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: "Utilities for the Interactions API integration.\n\nThis module provides both conversion utilities and the main entry point\nfor generating content via the Interactions API. It includes:\n\n- Type conversion functions between ADK types and Interactions API types\n- The `generate_content_via_interactions` async generator that handles the\n  complete flow of sending requests and processing responses\n- Request/response logging utilities for debugging\n- Support for both streaming and non-streaming modes\n\nThe Interactions API provides stateful conversation capabilities, allowing\nchained interactions using previous_interaction_id instead of sending full\nconversation history."
  methods:
  - signature: 'def convert_part_to_interaction_content(part: google.genai.types.Part) -> typing.Optional[dict]:'
    docstring: "Convert a types.Part to an interaction content dict.\n\nArgs:\n  part: The Part object to convert.\n\nReturns:\n  A dictionary representing the interaction content, or None if\n  the part type is not supported."
  - signature: 'def convert_content_to_turn(content: google.genai.types.Content) -> google.genai._interactions.types.turn_param.TurnParam:'
    docstring: "Convert a types.Content to a TurnParam dict for interactions API.\n\nArgs:\n  content: The Content object to convert.\n\nReturns:\n  A TurnParam dictionary for the interactions API."
  - signature: 'def convert_contents_to_turns(contents: list[google.genai.types.Content]) -> list[google.genai._interactions.types.turn_param.TurnParam]:'
    docstring: "Convert a list of Content objects to interactions API input format.\n\nArgs:\n  contents: The list of Content objects to convert.\n\nReturns:\n  A list of TurnParam dictionaries for the interactions API."
  - signature: 'def convert_tools_config_to_interactions_format(config: google.genai.types.GenerateContentConfig) -> list[google.genai._interactions.types.tool_param.ToolParam]:'
    docstring: "Convert tools from GenerateContentConfig to interactions API format.\n\nArgs:\n  config: The GenerateContentConfig containing tools to convert.\n\nReturns:\n  A list of ToolParam dictionaries for the interactions API."
  - signature: 'def convert_interaction_output_to_part(output: google.genai._interactions.types.interaction.Output) -> typing.Optional[google.genai.types.Part]:'
    docstring: "Convert an interaction output content to a types.Part.\n\nArgs:\n  output: The interaction output object to convert.\n\nReturns:\n  A types.Part object, or None if the output type is not supported."
  - signature: 'def convert_interaction_to_llm_response(interaction: google.genai.interactions_types.Interaction) -> google.adk.models.llm_response.LlmResponse:'
    docstring: "Convert an Interaction response to an LlmResponse.\n\nArgs:\n  interaction: The Interaction response object from the API.\n\nReturns:\n  An LlmResponse object with the converted data."
  - signature: 'def convert_interaction_event_to_llm_response(event: google.genai.interactions_types.InteractionSSEEvent, aggregated_parts: list[google.genai.types.Part], interaction_id: typing.Optional[str]) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
    docstring: "Convert an InteractionSSEEvent to an LlmResponse for streaming.\n\nArgs:\n  event: The streaming event from interactions API.\n  aggregated_parts: List to accumulate parts across events.\n  interaction_id: The interaction ID to include in responses.\n\nReturns:\n  LlmResponse if this event produces one, None otherwise."
  - signature: 'def build_generation_config(config: google.genai.types.GenerateContentConfig) -> dict[str, typing.Any]:'
    docstring: "Build generation config dict for interactions API.\n\nArgs:\n  config: The GenerateContentConfig to extract parameters from.\n\nReturns:\n  A dictionary containing generation configuration parameters."
  - signature: 'def extract_system_instruction(config: google.genai.types.GenerateContentConfig) -> typing.Optional[str]:'
    docstring: "Extract system instruction as a string from config.\n\nArgs:\n  config: The GenerateContentConfig containing the system instruction.\n\nReturns:\n  The system instruction as a string, or None if not present."
  - signature: 'def build_interactions_request_log(model: str, input_turns: list[google.genai._interactions.types.turn_param.TurnParam], system_instruction: typing.Optional[str], tools: typing.Optional[list[google.genai._interactions.types.tool_param.ToolParam]], generation_config: typing.Optional[dict[str, typing.Any]], previous_interaction_id: typing.Optional[str], stream: bool) -> str:'
    docstring: "Build a log string for an interactions API request.\n\nArgs:\n  model: The model name.\n  input_turns: The input turns to send.\n  system_instruction: The system instruction.\n  tools: The tools configuration.\n  generation_config: The generation config.\n  previous_interaction_id: The previous interaction ID for chaining.\n  stream: Whether streaming is enabled.\n\nReturns:\n  A formatted log string describing the request."
  - signature: 'def build_interactions_response_log(interaction: google.genai.interactions_types.Interaction) -> str:'
    docstring: "Build a log string for an interactions API response.\n\nArgs:\n  interaction: The Interaction response object.\n\nReturns:\n  A formatted log string describing the response."
  - signature: 'def build_interactions_event_log(event: google.genai.interactions_types.InteractionSSEEvent) -> str:'
    docstring: "Build a log string for an interactions API streaming event.\n\nArgs:\n  event: The streaming event from interactions API.\n\nReturns:\n  A formatted log string describing the event."
  - signature: 'def generate_content_via_interactions(api_client: google.genai.Client, llm_request: google.adk.models.llm_request.LlmRequest, stream: bool) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
    docstring: "Generate content using the interactions API.\n\nThe interactions API provides stateful conversation capabilities. When\nprevious_interaction_id is set in the request, the API chains interactions\ninstead of requiring full conversation history.\n\nNote: Context caching is not used with the Interactions API since it\nmaintains conversation state via previous_interaction_id.\n\nArgs:\n  api_client: The Google GenAI client.\n  llm_request: The LLM request to send.\n  stream: Whether to stream the response.\n\nYields:\n  LlmResponse objects converted from interaction responses."
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '_NEW_LINE: str'
- rank: 1055
  id: google.adk.models.interactions_utils.build_generation_config
  name: build_generation_config
  file_path: src/google/adk/models/interactions_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Build generation config dict for interactions API.\n\nArgs:\n  config: The GenerateContentConfig to extract parameters from.\n\nReturns:\n  A dictionary containing generation configuration parameters."
  signature: 'def build_generation_config(config: google.genai.types.GenerateContentConfig) -> dict[str, typing.Any]:'
- rank: 1056
  id: google.adk.models.interactions_utils.build_interactions_event_log
  name: build_interactions_event_log
  file_path: src/google/adk/models/interactions_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Build a log string for an interactions API streaming event.\n\nArgs:\n  event: The streaming event from interactions API.\n\nReturns:\n  A formatted log string describing the event."
  signature: 'def build_interactions_event_log(event: google.genai.interactions_types.InteractionSSEEvent) -> str:'
- rank: 1057
  id: google.adk.models.interactions_utils.build_interactions_request_log
  name: build_interactions_request_log
  file_path: src/google/adk/models/interactions_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Build a log string for an interactions API request.\n\nArgs:\n  model: The model name.\n  input_turns: The input turns to send.\n  system_instruction: The system instruction.\n  tools: The tools configuration.\n  generation_config: The generation config.\n  previous_interaction_id: The previous interaction ID for chaining.\n  stream: Whether streaming is enabled.\n\nReturns:\n  A formatted log string describing the request."
  signature: 'def build_interactions_request_log(model: str, input_turns: list[google.genai._interactions.types.turn_param.TurnParam], system_instruction: typing.Optional[str], tools: typing.Optional[list[google.genai._interactions.types.tool_param.ToolParam]], generation_config: typing.Optional[dict[str, typing.Any]], previous_interaction_id: typing.Optional[str], stream: bool) -> str:'
- rank: 1058
  id: google.adk.models.interactions_utils.build_interactions_response_log
  name: build_interactions_response_log
  file_path: src/google/adk/models/interactions_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Build a log string for an interactions API response.\n\nArgs:\n  interaction: The Interaction response object.\n\nReturns:\n  A formatted log string describing the response."
  signature: 'def build_interactions_response_log(interaction: google.genai.interactions_types.Interaction) -> str:'
- rank: 1059
  id: google.adk.models.interactions_utils.convert_content_to_turn
  name: convert_content_to_turn
  file_path: src/google/adk/models/interactions_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Convert a types.Content to a TurnParam dict for interactions API.\n\nArgs:\n  content: The Content object to convert.\n\nReturns:\n  A TurnParam dictionary for the interactions API."
  signature: 'def convert_content_to_turn(content: google.genai.types.Content) -> google.genai._interactions.types.turn_param.TurnParam:'
- rank: 1060
  id: google.adk.models.interactions_utils.convert_contents_to_turns
  name: convert_contents_to_turns
  file_path: src/google/adk/models/interactions_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Convert a list of Content objects to interactions API input format.\n\nArgs:\n  contents: The list of Content objects to convert.\n\nReturns:\n  A list of TurnParam dictionaries for the interactions API."
  signature: 'def convert_contents_to_turns(contents: list[google.genai.types.Content]) -> list[google.genai._interactions.types.turn_param.TurnParam]:'
- rank: 1061
  id: google.adk.models.interactions_utils.convert_interaction_event_to_llm_response
  name: convert_interaction_event_to_llm_response
  file_path: src/google/adk/models/interactions_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Convert an InteractionSSEEvent to an LlmResponse for streaming.\n\nArgs:\n  event: The streaming event from interactions API.\n  aggregated_parts: List to accumulate parts across events.\n  interaction_id: The interaction ID to include in responses.\n\nReturns:\n  LlmResponse if this event produces one, None otherwise."
  signature: 'def convert_interaction_event_to_llm_response(event: google.genai.interactions_types.InteractionSSEEvent, aggregated_parts: list[google.genai.types.Part], interaction_id: typing.Optional[str]) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
- rank: 1062
  id: google.adk.models.interactions_utils.convert_interaction_output_to_part
  name: convert_interaction_output_to_part
  file_path: src/google/adk/models/interactions_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Convert an interaction output content to a types.Part.\n\nArgs:\n  output: The interaction output object to convert.\n\nReturns:\n  A types.Part object, or None if the output type is not supported."
  signature: 'def convert_interaction_output_to_part(output: google.genai._interactions.types.interaction.Output) -> typing.Optional[google.genai.types.Part]:'
- rank: 1063
  id: google.adk.models.interactions_utils.convert_interaction_to_llm_response
  name: convert_interaction_to_llm_response
  file_path: src/google/adk/models/interactions_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Convert an Interaction response to an LlmResponse.\n\nArgs:\n  interaction: The Interaction response object from the API.\n\nReturns:\n  An LlmResponse object with the converted data."
  signature: 'def convert_interaction_to_llm_response(interaction: google.genai.interactions_types.Interaction) -> google.adk.models.llm_response.LlmResponse:'
- rank: 1064
  id: google.adk.models.interactions_utils.convert_part_to_interaction_content
  name: convert_part_to_interaction_content
  file_path: src/google/adk/models/interactions_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Convert a types.Part to an interaction content dict.\n\nArgs:\n  part: The Part object to convert.\n\nReturns:\n  A dictionary representing the interaction content, or None if\n  the part type is not supported."
  signature: 'def convert_part_to_interaction_content(part: google.genai.types.Part) -> typing.Optional[dict]:'
- rank: 1065
  id: google.adk.models.interactions_utils.convert_tools_config_to_interactions_format
  name: convert_tools_config_to_interactions_format
  file_path: src/google/adk/models/interactions_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Convert tools from GenerateContentConfig to interactions API format.\n\nArgs:\n  config: The GenerateContentConfig containing tools to convert.\n\nReturns:\n  A list of ToolParam dictionaries for the interactions API."
  signature: 'def convert_tools_config_to_interactions_format(config: google.genai.types.GenerateContentConfig) -> list[google.genai._interactions.types.tool_param.ToolParam]:'
- rank: 1066
  id: google.adk.models.interactions_utils.extract_system_instruction
  name: extract_system_instruction
  file_path: src/google/adk/models/interactions_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Extract system instruction as a string from config.\n\nArgs:\n  config: The GenerateContentConfig containing the system instruction.\n\nReturns:\n  The system instruction as a string, or None if not present."
  signature: 'def extract_system_instruction(config: google.genai.types.GenerateContentConfig) -> typing.Optional[str]:'
- rank: 1067
  id: google.adk.models.interactions_utils.generate_content_via_interactions
  name: generate_content_via_interactions
  file_path: src/google/adk/models/interactions_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Generate content using the interactions API.\n\nThe interactions API provides stateful conversation capabilities. When\nprevious_interaction_id is set in the request, the API chains interactions\ninstead of requiring full conversation history.\n\nNote: Context caching is not used with the Interactions API since it\nmaintains conversation state via previous_interaction_id.\n\nArgs:\n  api_client: The Google GenAI client.\n  llm_request: The LLM request to send.\n  stream: Whether to stream the response.\n\nYields:\n  LlmResponse objects converted from interaction responses."
  signature: 'def generate_content_via_interactions(api_client: google.genai.Client, llm_request: google.adk.models.llm_request.LlmRequest, stream: bool) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
- rank: 1068
  id: google.adk.models.lite_llm
  name: lite_llm
  file_path: src/google/adk/models/lite_llm.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'litellm: NoneType'
  - signature: 'acompletion: NoneType'
  - signature: 'ChatCompletionAssistantMessage: NoneType'
  - signature: 'ChatCompletionAssistantToolCall: NoneType'
  - signature: 'ChatCompletionMessageToolCall: NoneType'
  - signature: 'ChatCompletionSystemMessage: NoneType'
  - signature: 'ChatCompletionToolMessage: NoneType'
  - signature: 'ChatCompletionUserMessage: NoneType'
  - signature: 'completion: NoneType'
  - signature: 'CustomStreamWrapper: NoneType'
  - signature: 'Function: NoneType'
  - signature: 'Message: NoneType'
  - signature: 'ModelResponse: NoneType'
  - signature: 'OpenAIMessageContent: NoneType'
  - signature: 'logger: logging.getLogger'
  - signature: '_NEW_LINE: str'
  - signature: '_EXCLUDED_PART_FIELD: Any'
  - signature: '_LITELLM_STRUCTURED_TYPES: Any'
  - signature: '_JSON_DECODER: json.JSONDecoder'
  - signature: '_MEDIA_URL_CONTENT_TYPE_BY_MAJOR_MIME_TYPE: Any'
  - signature: '_FINISH_REASON_MAPPING: Any'
  - signature: '_SUPPORTED_FILE_CONTENT_MIME_TYPES: frozenset'
  - signature: '_FILE_ID_REQUIRED_PROVIDERS: frozenset'
  - signature: '_MISSING_TOOL_RESULT_MESSAGE: str'
  - signature: '_LITELLM_IMPORTED: bool'
  - signature: '_LITELLM_GLOBAL_SYMBOLS: Any'
  - signature: '_DEFAULT_MIME_TYPE: str'
  - signature: 'TYPE_LABELS: Any'
- rank: 1069
  id: google.adk.models.lite_llm.ChatCompletionFileUrlObject
  name: ChatCompletionFileUrlObject
  file_path: src/google/adk/models/lite_llm.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from TypedDict are omitted.]'
  properties:
  - signature: 'file_data: str'
  - signature: 'file_id: str'
  - signature: 'format: str'
  omitted_inherited_members_from:
  - TypedDict
- rank: 1070
  id: google.adk.models.lite_llm.FunctionChunk
  name: FunctionChunk
  file_path: src/google/adk/models/lite_llm.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, id: typing.Optional[str], name: typing.Optional[str], args: typing.Optional[str], index: typing.Optional[int] = 0):'
  properties:
  - signature: 'id: typing.Optional[str]'
  - signature: 'name: typing.Optional[str]'
  - signature: 'args: typing.Optional[str]'
  - signature: 'index: typing.Optional[int]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1071
  id: google.adk.models.lite_llm.LiteLLMClient
  name: LiteLLMClient
  file_path: src/google/adk/models/lite_llm.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Provides acompletion method (for better testability).
  methods:
  - signature: 'def acompletion(self, model, messages, tools) -> typing.Union[litellm.ModelResponse, litellm.CustomStreamWrapper]:'
    docstring: "Asynchronously calls acompletion.\n\nArgs:\n  model: The model name.\n  messages: The messages to send to the model.\n  tools: The tools to use for the model.\n  **kwargs: Additional arguments to pass to acompletion.\n\nReturns:\n  The model response as a message."
  - signature: 'def completion(self, model, messages, tools, stream) -> typing.Union[litellm.ModelResponse, litellm.CustomStreamWrapper]:'
    docstring: "Synchronously calls completion. This is used for streaming only.\n\nArgs:\n  model: The model to use.\n  messages: The messages to send.\n  tools: The tools to use for the model.\n  stream: Whether to stream the response.\n  **kwargs: Additional arguments to pass to completion.\n\nReturns:\n  The response from the model."
- rank: 1072
  id: google.adk.models.lite_llm.LiteLLMClient.acompletion
  name: acompletion
  file_path: src/google/adk/models/lite_llm.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Asynchronously calls acompletion.\n\nArgs:\n  model: The model name.\n  messages: The messages to send to the model.\n  tools: The tools to use for the model.\n  **kwargs: Additional arguments to pass to acompletion.\n\nReturns:\n  The model response as a message."
  signature: 'def acompletion(self, model, messages, tools) -> typing.Union[litellm.ModelResponse, litellm.CustomStreamWrapper]:'
- rank: 1073
  id: google.adk.models.lite_llm.LiteLLMClient.completion
  name: completion
  file_path: src/google/adk/models/lite_llm.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Synchronously calls completion. This is used for streaming only.\n\nArgs:\n  model: The model to use.\n  messages: The messages to send.\n  tools: The tools to use for the model.\n  stream: Whether to stream the response.\n  **kwargs: Additional arguments to pass to completion.\n\nReturns:\n  The response from the model."
  signature: 'def completion(self, model, messages, tools, stream) -> typing.Union[litellm.ModelResponse, litellm.CustomStreamWrapper]:'
- rank: 1074
  id: google.adk.models.lite_llm.LiteLlm.__init__
  name: __init__
  file_path: src/google/adk/models/lite_llm.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the LiteLlm class.\n\nArgs:\n  model: The name of the LiteLlm model.\n  **kwargs: Additional arguments to pass to the litellm completion api."
  signature: 'def __init__(self, model: str):'
- rank: 1075
  id: google.adk.models.lite_llm.LiteLlm.generate_content_async
  name: generate_content_async
  file_path: src/google/adk/models/lite_llm.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Generates content asynchronously.\n\nArgs:\n  llm_request: LlmRequest, the request to send to the LiteLlm model.\n  stream: bool = False, whether to do streaming call.\n\nYields:\n  LlmResponse: The model response."
  signature: 'def generate_content_async(self, llm_request: google.adk.models.llm_request.LlmRequest, stream: bool) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
- rank: 1076
  id: google.adk.models.lite_llm.LiteLlm.supported_models
  name: supported_models
  file_path: src/google/adk/models/lite_llm.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Provides the list of supported models.\n\nThis registers common provider prefixes. LiteLlm can handle many more,\nbut these patterns activate the integration for the most common use cases.\nSee https://docs.litellm.ai/docs/providers for a full list.\n\nReturns:\n  A list of supported models."
  signature: 'def supported_models(cls) -> list[str]:'
- rank: 1077
  id: google.adk.models.lite_llm.ReasoningChunk
  name: ReasoningChunk
  file_path: src/google/adk/models/lite_llm.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, parts: typing.List[google.genai.types.Part]):'
  properties:
  - signature: 'parts: typing.List[google.genai.types.Part]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1078
  id: google.adk.models.lite_llm.TextChunk
  name: TextChunk
  file_path: src/google/adk/models/lite_llm.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, text: str):'
  properties:
  - signature: 'text: str'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1079
  id: google.adk.models.lite_llm.UsageMetadataChunk
  name: UsageMetadataChunk
  file_path: src/google/adk/models/lite_llm.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, prompt_tokens: int, completion_tokens: int, total_tokens: int, cached_prompt_tokens: int = 0):'
  properties:
  - signature: 'prompt_tokens: int'
  - signature: 'completion_tokens: int'
  - signature: 'total_tokens: int'
  - signature: 'cached_prompt_tokens: int'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1080
  id: google.adk.models.llm_request
  name: llm_request
  file_path: src/google/adk/models/llm_request.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1081
  id: google.adk.models.llm_request.LlmRequest
  name: LlmRequest
  file_path: src/google/adk/models/llm_request.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "LLM request class that allows passing in tools, output schema and system\n\ninstructions to the model.\n\nAttributes:\n  model: The model name.\n  contents: The contents to send to the model.\n  config: Additional config for the generate content request.\n  tools_dict: The tools dictionary.\n  cache_config: Context cache configuration for this request.\n  cache_metadata: Cache metadata from previous requests, used for cache management.\n\n[Note: Inherited members from pydantic.BaseModel are omitted.]"
  constructor_signature: 'def __init__(self, *, model: typing.Optional[str] = None, contents: list[google.genai.types.Content] = list(), config: google.genai.types.GenerateContentConfig = Factory(types.GenerateContentConfig), live_connect_config: google.genai.types.LiveConnectConfig = Factory(types.LiveConnectConfig), tools_dict: dict[str, google.adk.tools.base_tool.BaseTool] = dict(), cache_config: typing.Optional[google.adk.agents.context_cache_config.ContextCacheConfig] = None, cache_metadata: typing.Optional[google.adk.models.cache_metadata.CacheMetadata] = None, cacheable_contents_token_count: typing.Optional[int] = None, previous_interaction_id: typing.Optional[str] = None):'
  methods:
  - signature: 'def append_instructions(self, instructions: typing.Union[list[str], google.genai.types.Content]) -> list[google.genai.types.Content]:'
    docstring: "Appends instructions to the system instruction.\n\nArgs:\n  instructions: The instructions to append. Can be:\n    - list[str]: Strings to append/concatenate to system instruction\n    - types.Content: Content object to append to system instruction\n\nReturns:\n  List of user contents from non-text parts (when instructions is types.Content\n  with non-text parts). Empty list otherwise.\n\nNote: Model API requires system_instruction to be a string. Non-text parts\nin Content are processed with references in system_instruction and returned\nas user contents.\n\nBehavior:\n  - list[str]: concatenates with existing system_instruction using \\n\\n\n  - types.Content: extracts text parts with references to non-text parts,\n    returns non-text parts as user contents"
  - signature: 'def append_tools(self, tools: list[google.adk.tools.base_tool.BaseTool]) -> None:'
    docstring: "Appends tools to the request.\n\nArgs:\n  tools: The tools to append."
  - signature: 'def set_output_schema(self, base_model: type[pydantic.BaseModel]) -> None:'
    docstring: "Sets the output schema for the request.\n\nArgs:\n  base_model: The pydantic base model to set the output schema to."
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
    docstring: The pydantic model config.
  - signature: 'model: typing.Optional[str]'
    docstring: The model name.
  - signature: 'contents: list[google.genai.types.Content]'
    docstring: The contents to send to the model.
  - signature: 'config: google.genai.types.GenerateContentConfig'
  - signature: 'live_connect_config: google.genai.types.LiveConnectConfig'
    docstring: 'Additional config for the generate content request.


      tools in generate_content_config should not be set.'
  - signature: 'tools_dict: dict[str, google.adk.tools.base_tool.BaseTool]'
    docstring: The tools dictionary.
  - signature: 'cache_config: typing.Optional[google.adk.agents.context_cache_config.ContextCacheConfig]'
    docstring: Context cache configuration for this request.
  - signature: 'cache_metadata: typing.Optional[google.adk.models.cache_metadata.CacheMetadata]'
    docstring: Cache metadata from previous requests, used for cache management.
  - signature: 'cacheable_contents_token_count: typing.Optional[int]'
    docstring: Token count from previous request's prompt, used for cache size validation.
  - signature: 'previous_interaction_id: typing.Optional[str]'
    docstring: 'The ID of the previous interaction for stateful conversations.


      When using the interactions API, this ID is used to chain interactions

      together, allowing the API to maintain conversation state without sending

      the full history.'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1082
  id: google.adk.models.llm_request.LlmRequest.append_instructions
  name: append_instructions
  file_path: src/google/adk/models/llm_request.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Appends instructions to the system instruction.\n\nArgs:\n  instructions: The instructions to append. Can be:\n    - list[str]: Strings to append/concatenate to system instruction\n    - types.Content: Content object to append to system instruction\n\nReturns:\n  List of user contents from non-text parts (when instructions is types.Content\n  with non-text parts). Empty list otherwise.\n\nNote: Model API requires system_instruction to be a string. Non-text parts\nin Content are processed with references in system_instruction and returned\nas user contents.\n\nBehavior:\n  - list[str]: concatenates with existing system_instruction using \\n\\n\n  - types.Content: extracts text parts with references to non-text parts,\n    returns non-text parts as user contents"
  signature: 'def append_instructions(self, instructions: typing.Union[list[str], google.genai.types.Content]) -> list[google.genai.types.Content]:'
- rank: 1083
  id: google.adk.models.llm_request.LlmRequest.append_tools
  name: append_tools
  file_path: src/google/adk/models/llm_request.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Appends tools to the request.\n\nArgs:\n  tools: The tools to append."
  signature: 'def append_tools(self, tools: list[google.adk.tools.base_tool.BaseTool]) -> None:'
- rank: 1084
  id: google.adk.models.llm_request.LlmRequest.set_output_schema
  name: set_output_schema
  file_path: src/google/adk/models/llm_request.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Sets the output schema for the request.\n\nArgs:\n  base_model: The pydantic base model to set the output schema to."
  signature: 'def set_output_schema(self, base_model: type[pydantic.BaseModel]) -> None:'
- rank: 1085
  id: google.adk.models.llm_response
  name: llm_response
  file_path: src/google/adk/models/llm_response.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1086
  id: google.adk.models.llm_response.LlmResponse.create
  name: create
  file_path: src/google/adk/models/llm_response.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Creates an LlmResponse from a GenerateContentResponse.\n\nArgs:\n  generate_content_response: The GenerateContentResponse to create the\n    LlmResponse from.\n\nReturns:\n  The LlmResponse."
  signature: 'def create(generate_content_response: google.genai.types.GenerateContentResponse) -> google.adk.models.llm_response.LlmResponse:'
- rank: 1087
  id: google.adk.models.registry
  name: registry
  file_path: src/google/adk/models/registry.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: The registry class for model.
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '_llm_registry_dict: dict[str, type[google.adk.models.base_llm.BaseLlm]]'
- rank: 1088
  id: google.adk.models.registry.LLMRegistry
  name: LLMRegistry
  file_path: src/google/adk/models/registry.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Registry for LLMs.
  aliases:
  - google.adk.models.LLMRegistry
  methods:
  - signature: 'def new_llm(model: str) -> google.adk.models.base_llm.BaseLlm:'
    docstring: "Creates a new LLM instance.\n\nArgs:\n    model: The model name.\n\nReturns:\n    The LLM instance."
  - signature: 'def register(llm_cls: type[google.adk.models.base_llm.BaseLlm]):'
    docstring: "Registers a new LLM class.\n\nArgs:\n    llm_cls: The class that implements the model."
  - signature: 'def resolve(model: str) -> type[google.adk.models.base_llm.BaseLlm]:'
    docstring: "Resolves the model to a BaseLlm subclass.\n\nArgs:\n    model: The model name.\n\nReturns:\n    The BaseLlm subclass.\nRaises:\n    ValueError: If the model is not found."
- rank: 1089
  id: google.adk.models.registry.LLMRegistry.new_llm
  name: new_llm
  file_path: src/google/adk/models/registry.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Creates a new LLM instance.\n\nArgs:\n    model: The model name.\n\nReturns:\n    The LLM instance."
  signature: 'def new_llm(model: str) -> google.adk.models.base_llm.BaseLlm:'
- rank: 1090
  id: google.adk.models.registry.LLMRegistry.register
  name: register
  file_path: src/google/adk/models/registry.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Registers a new LLM class.\n\nArgs:\n    llm_cls: The class that implements the model."
  signature: 'def register(llm_cls: type[google.adk.models.base_llm.BaseLlm]):'
- rank: 1091
  id: google.adk.models.registry.LLMRegistry.resolve
  name: resolve
  file_path: src/google/adk/models/registry.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Resolves the model to a BaseLlm subclass.\n\nArgs:\n    model: The model name.\n\nReturns:\n    The BaseLlm subclass.\nRaises:\n    ValueError: If the model is not found."
  signature: 'def resolve(model: str) -> type[google.adk.models.base_llm.BaseLlm]:'
- rank: 1092
  id: google.adk.optimization
  name: optimization
  file_path: src/google/adk/optimization/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1093
  id: google.adk.optimization.agent_optimizer
  name: agent_optimizer
  file_path: src/google/adk/optimization/agent_optimizer.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1094
  id: google.adk.optimization.agent_optimizer.AgentOptimizer
  name: AgentOptimizer
  file_path: src/google/adk/optimization/agent_optimizer.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Base class for agent optimizers.


    [Note: Inherited members from ABC are omitted.]'
  methods:
  - signature: 'def optimize(self, initial_agent: google.adk.agents.llm_agent.Agent, sampler: google.adk.optimization.sampler.Sampler[google.adk.optimization.data_types.SamplingResult]) -> google.adk.optimization.data_types.OptimizerResult[google.adk.optimization.data_types.AgentWithScores]:'
    docstring: "Runs the optimizer.\n\nArgs:\n  initial_agent: The initial agent to be optimized.\n  sampler: The interface used to get training and validation example UIDs,\n    request agent evaluations, and get useful data for optimizing the agent.\n\nReturns:\n  The final result of the optimization process, containing the optimized\n  agent instances along with their corresponding scores on the validation\n  examples and any optimization metadata."
  omitted_inherited_members_from:
  - ABC
- rank: 1095
  id: google.adk.optimization.agent_optimizer.AgentOptimizer.optimize
  name: optimize
  file_path: src/google/adk/optimization/agent_optimizer.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Runs the optimizer.\n\nArgs:\n  initial_agent: The initial agent to be optimized.\n  sampler: The interface used to get training and validation example UIDs,\n    request agent evaluations, and get useful data for optimizing the agent.\n\nReturns:\n  The final result of the optimization process, containing the optimized\n  agent instances along with their corresponding scores on the validation\n  examples and any optimization metadata."
  signature: 'def optimize(self, initial_agent: google.adk.agents.llm_agent.Agent, sampler: google.adk.optimization.sampler.Sampler[google.adk.optimization.data_types.SamplingResult]) -> google.adk.optimization.data_types.OptimizerResult[google.adk.optimization.data_types.AgentWithScores]:'
- rank: 1096
  id: google.adk.optimization.data_types
  name: data_types
  file_path: src/google/adk/optimization/data_types.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'SamplingResult: typing.TypeVar'
  - signature: 'AgentWithScores: typing.TypeVar'
- rank: 1097
  id: google.adk.optimization.data_types.BaseAgentWithScores
  name: BaseAgentWithScores
  file_path: src/google/adk/optimization/data_types.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'An optimized agent with its scores.


    Optimizers may use the overall_score field and can return custom metrics by

    sub-classing this class.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, optimized_agent: google.adk.agents.llm_agent.Agent, overall_score: typing.Optional[float] = None):'
  properties:
  - signature: 'optimized_agent: google.adk.agents.llm_agent.Agent'
  - signature: 'overall_score: typing.Optional[float]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1098
  id: google.adk.optimization.data_types.BaseSamplingResult
  name: BaseSamplingResult
  file_path: src/google/adk/optimization/data_types.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Base class for evaluation results of the candidate agent on the batch of examples.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, scores: dict[str, float]):'
  properties:
  - signature: 'scores: dict[str, float]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1099
  id: google.adk.optimization.data_types.OptimizerResult
  name: OptimizerResult
  file_path: src/google/adk/optimization/data_types.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Base class for optimizer final results.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, optimized_agents: list[google.adk.optimization.data_types.AgentWithScores]):'
  properties:
  - signature: 'optimized_agents: list[google.adk.optimization.data_types.AgentWithScores]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1100
  id: google.adk.optimization.data_types.UnstructuredSamplingResult
  name: UnstructuredSamplingResult
  file_path: src/google/adk/optimization/data_types.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Evaluation result providing per-example unstructured evaluation data.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, scores: dict[str, float], data: typing.Optional[dict[str, dict[str, typing.Any]]] = None):'
  properties:
  - signature: 'data: typing.Optional[dict[str, dict[str, typing.Any]]]'
  inherited_properties:
    BaseSamplingResult:
    - signature: 'scores: dict[str, float]'
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1101
  id: google.adk.optimization.sampler
  name: sampler
  file_path: src/google/adk/optimization/sampler.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1102
  id: google.adk.optimization.sampler.Sampler
  name: Sampler
  file_path: src/google/adk/optimization/sampler.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Base class for agent optimizers to sample and score candidate agents.


    The developer must implement this interface for their evaluation service to

    work with the optimizer. The optimizer will call the sample_and_score method

    to get evaluation results for the candidate agent on the batch of examples.


    [Note: Inherited members from ABC are omitted.]'
  methods:
  - signature: 'def get_train_example_ids(self) -> list[str]:'
    docstring: Returns the UIDs of examples to use for training the agent.
  - signature: 'def get_validation_example_ids(self) -> list[str]:'
    docstring: Returns the UIDs of examples to use for validating the optimized agent.
  - signature: 'def sample_and_score(self, candidate: google.adk.agents.llm_agent.Agent, example_set: typing.Literal[train, validation], batch: typing.Optional[list[str]], capture_full_eval_data: bool) -> google.adk.optimization.data_types.SamplingResult:'
    docstring: "Evaluates the candidate agent on the batch of examples.\n\nArgs:\n  candidate: The candidate agent to be evaluated.\n  example_set: The set of examples to evaluate the candidate agent on.\n    Possible values are \"train\" and \"validation\".\n  batch: List of UIDs of examples to evaluate the candidate agent on. If not\n    provided, all examples from the chosen set will be used.\n  capture_full_eval_data: If false, it is enough to only calculate the\n    scores for each example. If true, this method should also capture all\n    other data required for optimizing the agent (e.g., outputs,\n    trajectories, and tool calls).\n\nReturns:\n  The evaluation results, containing the scores for each example and (if\n  requested) other data required for optimization."
  omitted_inherited_members_from:
  - ABC
- rank: 1103
  id: google.adk.optimization.sampler.Sampler.sample_and_score
  name: sample_and_score
  file_path: src/google/adk/optimization/sampler.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Evaluates the candidate agent on the batch of examples.\n\nArgs:\n  candidate: The candidate agent to be evaluated.\n  example_set: The set of examples to evaluate the candidate agent on.\n    Possible values are \"train\" and \"validation\".\n  batch: List of UIDs of examples to evaluate the candidate agent on. If not\n    provided, all examples from the chosen set will be used.\n  capture_full_eval_data: If false, it is enough to only calculate the\n    scores for each example. If true, this method should also capture all\n    other data required for optimizing the agent (e.g., outputs,\n    trajectories, and tool calls).\n\nReturns:\n  The evaluation results, containing the scores for each example and (if\n  requested) other data required for optimization."
  signature: 'def sample_and_score(self, candidate: google.adk.agents.llm_agent.Agent, example_set: typing.Literal[train, validation], batch: typing.Optional[list[str]], capture_full_eval_data: bool) -> google.adk.optimization.data_types.SamplingResult:'
- rank: 1104
  id: google.adk.planners
  name: planners
  file_path: src/google/adk/planners/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: '__all__: Any'
- rank: 1105
  id: google.adk.planners.base_planner
  name: base_planner
  file_path: src/google/adk/planners/base_planner.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1106
  id: google.adk.planners.base_planner.BasePlanner
  name: BasePlanner
  file_path: src/google/adk/planners/base_planner.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Abstract base class for all planners.


    The planner allows the agent to generate plans for the queries to guide its

    action.


    [Note: Inherited members from ABC are omitted.]'
  methods:
  - signature: 'def build_planning_instruction(self, readonly_context: google.adk.agents.readonly_context.ReadonlyContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[str]:'
    docstring: "Builds the system instruction to be appended to the LLM request for planning.\n\nArgs:\n    readonly_context: The readonly context of the invocation.\n    llm_request: The LLM request. Readonly.\n\nReturns:\n    The planning system instruction, or None if no instruction is needed."
  - signature: 'def process_planning_response(self, callback_context: google.adk.agents.callback_context.CallbackContext, response_parts: typing.List[google.genai.types.Part]) -> typing.Optional[typing.List[google.genai.types.Part]]:'
    docstring: "Processes the LLM response for planning.\n\nArgs:\n    callback_context: The callback context of the invocation.\n    response_parts: The LLM response parts. Readonly.\n\nReturns:\n    The processed response parts, or None if no processing is needed."
  omitted_inherited_members_from:
  - ABC
- rank: 1107
  id: google.adk.planners.base_planner.BasePlanner.build_planning_instruction
  name: build_planning_instruction
  file_path: src/google/adk/planners/base_planner.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Builds the system instruction to be appended to the LLM request for planning.\n\nArgs:\n    readonly_context: The readonly context of the invocation.\n    llm_request: The LLM request. Readonly.\n\nReturns:\n    The planning system instruction, or None if no instruction is needed."
  signature: 'def build_planning_instruction(self, readonly_context: google.adk.agents.readonly_context.ReadonlyContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[str]:'
- rank: 1108
  id: google.adk.planners.base_planner.BasePlanner.process_planning_response
  name: process_planning_response
  file_path: src/google/adk/planners/base_planner.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Processes the LLM response for planning.\n\nArgs:\n    callback_context: The callback context of the invocation.\n    response_parts: The LLM response parts. Readonly.\n\nReturns:\n    The processed response parts, or None if no processing is needed."
  signature: 'def process_planning_response(self, callback_context: google.adk.agents.callback_context.CallbackContext, response_parts: typing.List[google.genai.types.Part]) -> typing.Optional[typing.List[google.genai.types.Part]]:'
- rank: 1109
  id: google.adk.planners.built_in_planner
  name: built_in_planner
  file_path: src/google/adk/planners/built_in_planner.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 1110
  id: google.adk.planners.built_in_planner.BuiltInPlanner.__init__
  name: __init__
  file_path: src/google/adk/planners/built_in_planner.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the built-in planner.\n\nArgs:\n  thinking_config: Config for model built-in thinking features. An error\n    will be returned if this field is set for models that don't support\n    thinking."
  signature: 'def __init__(self, *, thinking_config: google.genai.types.ThinkingConfig):'
- rank: 1111
  id: google.adk.planners.built_in_planner.BuiltInPlanner.apply_thinking_config
  name: apply_thinking_config
  file_path: src/google/adk/planners/built_in_planner.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Applies the thinking config to the LLM request.\n\nArgs:\n  llm_request: The LLM request to apply the thinking config to."
  signature: 'def apply_thinking_config(self, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
- rank: 1112
  id: google.adk.planners.built_in_planner.BuiltInPlanner.build_planning_instruction
  name: build_planning_instruction
  file_path: src/google/adk/planners/built_in_planner.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def build_planning_instruction(self, readonly_context: google.adk.agents.readonly_context.ReadonlyContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[str]:'
- rank: 1113
  id: google.adk.planners.built_in_planner.BuiltInPlanner.process_planning_response
  name: process_planning_response
  file_path: src/google/adk/planners/built_in_planner.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def process_planning_response(self, callback_context: google.adk.agents.callback_context.CallbackContext, response_parts: typing.List[google.genai.types.Part]) -> typing.Optional[typing.List[google.genai.types.Part]]:'
- rank: 1114
  id: google.adk.planners.plan_re_act_planner
  name: plan_re_act_planner
  file_path: src/google/adk/planners/plan_re_act_planner.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'PLANNING_TAG: str'
  - signature: 'REPLANNING_TAG: str'
  - signature: 'REASONING_TAG: str'
  - signature: 'ACTION_TAG: str'
  - signature: 'FINAL_ANSWER_TAG: str'
- rank: 1115
  id: google.adk.planners.plan_re_act_planner.PlanReActPlanner
  name: PlanReActPlanner
  file_path: src/google/adk/planners/plan_re_act_planner.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Plan-Re-Act planner that constrains the LLM response to generate a plan before any action/observation.


    Note: this planner does not require the model to support built-in thinking

    features or setting the thinking config.


    [Note: Inherited members from ABC are omitted.]'
  aliases:
  - google.adk.planners.PlanReActPlanner
  methods:
  - signature: 'def build_planning_instruction(self, readonly_context: google.adk.agents.readonly_context.ReadonlyContext, llm_request: google.adk.models.llm_request.LlmRequest) -> str:'
  - signature: 'def process_planning_response(self, callback_context: google.adk.agents.callback_context.CallbackContext, response_parts: typing.List[google.genai.types.Part]) -> typing.Optional[typing.List[google.genai.types.Part]]:'
  inherited_methods:
    BasePlanner:
    - signature: 'def build_planning_instruction(self, readonly_context: google.adk.agents.readonly_context.ReadonlyContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[str]:'
      docstring: "Builds the system instruction to be appended to the LLM request for planning.\n\nArgs:\n    readonly_context: The readonly context of the invocation.\n    llm_request: The LLM request. Readonly.\n\nReturns:\n    The planning system instruction, or None if no instruction is needed."
    - signature: 'def process_planning_response(self, callback_context: google.adk.agents.callback_context.CallbackContext, response_parts: typing.List[google.genai.types.Part]) -> typing.Optional[typing.List[google.genai.types.Part]]:'
      docstring: "Processes the LLM response for planning.\n\nArgs:\n    callback_context: The callback context of the invocation.\n    response_parts: The LLM response parts. Readonly.\n\nReturns:\n    The processed response parts, or None if no processing is needed."
  omitted_inherited_members_from:
  - ABC
- rank: 1116
  id: google.adk.planners.plan_re_act_planner.PlanReActPlanner.build_planning_instruction
  name: build_planning_instruction
  file_path: src/google/adk/planners/plan_re_act_planner.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def build_planning_instruction(self, readonly_context: google.adk.agents.readonly_context.ReadonlyContext, llm_request: google.adk.models.llm_request.LlmRequest) -> str:'
- rank: 1117
  id: google.adk.planners.plan_re_act_planner.PlanReActPlanner.process_planning_response
  name: process_planning_response
  file_path: src/google/adk/planners/plan_re_act_planner.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def process_planning_response(self, callback_context: google.adk.agents.callback_context.CallbackContext, response_parts: typing.List[google.genai.types.Part]) -> typing.Optional[typing.List[google.genai.types.Part]]:'
- rank: 1118
  id: google.adk.platform
  name: platform
  file_path: src/google/adk/platform/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1119
  id: google.adk.platform.thread
  name: thread
  file_path: src/google/adk/platform/thread.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def create_thread(target: typing.Callable[Ellipsis, None]):'
    docstring: Creates a thread.
  properties:
  - signature: 'internal_thread: NoneType'
- rank: 1120
  id: google.adk.platform.thread.create_thread
  name: create_thread
  file_path: src/google/adk/platform/thread.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Creates a thread.
  signature: 'def create_thread(target: typing.Callable[Ellipsis, None]):'
- rank: 1121
  id: google.adk.plugins
  name: plugins
  file_path: src/google/adk/plugins/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: '__all__: Any'
- rank: 1122
  id: google.adk.plugins.base_plugin
  name: base_plugin
  file_path: src/google/adk/plugins/base_plugin.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'T: typing.TypeVar'
- rank: 1123
  id: google.adk.plugins.base_plugin.BasePlugin
  name: BasePlugin
  file_path: src/google/adk/plugins/base_plugin.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "Base class for creating plugins.\n\nPlugins provide a structured way to intercept and modify agent, tool, and\nLLM behaviors at critical execution points in a callback manner. While agent\ncallbacks apply to a particular agent, plugins applies globally to all\nagents added in the runner. Plugins are best used for adding custom behaviors\nlike logging, monitoring, caching, or modifying requests and responses at key\nstages.\n\nA plugin can implement one or more methods of callbacks, but should not\nimplement the same method of callback for multiple times.\n\nRelation with [Agent callbacks](https://google.github.io/adk-docs/callbacks/):\n\n**Execution Order**\nSimilar to Agent callbacks, Plugins are executed in the order they are\nregistered. However, Plugin and Agent Callbacks are executed sequentially,\nwith Plugins takes precedence over agent callbacks. When the callback in a\nplugin returns a value, it will short circuit all remaining plugins and\nagent callbacks, causing\
    \ all remaining plugins and agent callbacks\nto be skipped.\n\n**Change Propagation**\nPlugins and agent callbacks can both modify the value of the input parameters,\nincluding agent input, tool input, and LLM request/response, etc. They work in\nthe exactly same way. The modifications will be visible and passed to the next\ncallback in the chain. For example, if a plugin modifies the tool input with\nbefore_tool_callback, the modified tool input will be passed to the\nbefore_tool_callback of the next plugin, and further passed to the agent\ncallbacks if not short-circuited.\n\nTo use a plugin, implement the desired callback methods and pass an instance\nof your custom plugin class to the ADK Runner.\n\nExamples:\n    A simple plugin that logs every tool call.\n\n    >>> class ToolLoggerPlugin(BasePlugin):\n    ..   def __init__(self):\n    ..     super().__init__(name=\"tool_logger\")\n    ..\n    ..   async def before_tool_callback(\n    ..       self, *, tool: BaseTool, tool_args:\
    \ dict[str, Any],\n    tool_context:\n    ToolContext\n    ..   ):\n    ..     print(f\"[{self.name}] Calling tool '{tool.name}' with args:\n    {tool_args}\")\n    ..\n    ..   async def after_tool_callback(\n    ..       self, *, tool: BaseTool, tool_args: dict, tool_context:\n    ToolContext, result: dict\n    ..   ):\n    ..     print(f\"[{self.name}] Tool '{tool.name}' finished with result:\n    {result}\")\n    ..\n    >>> # Add the plugin to ADK Runner\n    >>> # runner = Runner(\n    >>> #     ...\n    >>> #     plugins=[ToolLoggerPlugin(), AgentPolicyPlugin()],\n    >>> # )\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, name: str):'
  methods:
  - signature: 'def on_user_message_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, user_message: google.genai.types.Content) -> typing.Optional[google.genai.types.Content]:'
    docstring: "Callback executed when a user message is received before an invocation starts.\n\nThis callback helps logging and modifying the user message before the\nrunner starts the invocation.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n  user_message: The message content input by user.\n\nReturns:\n  An optional `types.Content` to be returned to the ADK. Returning a\n  value to replace the user message. Returning `None` to proceed\n  normally."
  - signature: 'def before_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.Optional[google.genai.types.Content]:'
    docstring: "Callback executed before the ADK runner runs.\n\nThis is the first callback to be called in the lifecycle, ideal for global\nsetup or initialization tasks.\n\nArgs:\n  invocation_context: The context for the entire invocation, containing\n    session information, the root agent, etc.\n\nReturns:\n  An optional `Event` to be returned to the ADK. Returning a value to\n  halt execution of the runner and ends the runner with that event. Return\n  `None` to proceed normally."
  - signature: 'def on_event_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, event: google.adk.events.event.Event) -> typing.Optional[google.adk.events.event.Event]:'
    docstring: "Callback executed after an event is yielded from runner.\n\nThis is the ideal place to make modification to the event before the event\nis handled by the underlying agent app.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n  event: The event raised by the runner.\n\nReturns:\n  An optional value. A non-`None` return may be used by the framework to\n  modify or replace the response. Returning `None` allows the original\n  response to be used."
  - signature: 'def after_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> None:'
    docstring: "Callback executed after an ADK runner run has completed.\n\nThis is the final callback in the ADK lifecycle, suitable for cleanup, final\nlogging, or reporting tasks.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n\nReturns:\n  None"
  - signature: 'def close(self) -> None:'
    docstring: 'Method executed when the runner is closed.


      This method is used for cleanup tasks such as closing network connections

      or releasing resources.'
  - signature: 'def before_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
    docstring: "Callback executed before an agent's primary logic is invoked.\n\nThis callback can be used for logging, setup, or to short-circuit the\nagent's execution by returning a value.\n\nArgs:\n  agent: The agent that is about to run.\n  callback_context: The context for the agent invocation.\n\nReturns:\n  An optional `types.Content` object. If a value is returned, it will bypass\n  the agent's callbacks and its execution, and return this value directly.\n  Returning `None` allows the agent to proceed normally."
  - signature: 'def after_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
    docstring: "Callback executed after an agent's primary logic has completed.\n\nArgs:\n  agent: The agent that has just run.\n  callback_context: The context for the agent invocation.\n\nReturns:\n  An optional `types.Content` object. The content to return to the user.\n  When the content is present, the provided content will be used as agent\n  response and appended to event history as agent response."
  - signature: 'def before_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
    docstring: "Callback executed before a request is sent to the model.\n\nThis provides an opportunity to inspect, log, or modify the `LlmRequest`\nobject. It can also be used to implement caching by returning a cached\n`LlmResponse`, which would skip the actual model call.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_request: The prepared request object to be sent to the model.\n\nReturns:\n  An optional value. The interpretation of a non-`None` trigger an early\n  exit and returns the response immediately. Returning `None` allows the LLM\n  request to proceed normally."
  - signature: 'def after_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_response: google.adk.models.llm_response.LlmResponse) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
    docstring: "Callback executed after a response is received from the model.\n\nThis is the ideal place to log model responses, collect metrics on token\nusage, or perform post-processing on the raw `LlmResponse`.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_response: The response object received from the model.\n\nReturns:\n  An optional value. A non-`None` return may be used by the framework to\n  modify or replace the response. Returning `None` allows the original\n  response to be used."
  - signature: 'def on_model_error_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest, error: Exception) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
    docstring: "Callback executed when a model call encounters an error.\n\nThis callback provides an opportunity to handle model errors gracefully,\npotentially providing alternative responses or recovery mechanisms.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_request: The request that was sent to the model when the error\n    occurred.\n  error: The exception that was raised during model execution.\n\nReturns:\n  An optional LlmResponse. If an LlmResponse is returned, it will be used\n  instead of propagating the error. Returning `None` allows the original\n  error to be raised."
  - signature: 'def before_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Optional[dict]:'
    docstring: "Callback executed before a tool is called.\n\nThis callback is useful for logging tool usage, input validation, or\nmodifying the arguments before they are passed to the tool.\n\nArgs:\n  tool: The tool instance that is about to be executed.\n  tool_args: The dictionary of arguments to be used for invoking the tool.\n  tool_context: The context specific to the tool execution.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will stop the tool\n  execution and return this response immediately. Returning `None` uses the\n  original, unmodified arguments."
  - signature: 'def after_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, result: dict) -> typing.Optional[dict]:'
    docstring: "Callback executed after a tool has been called.\n\nThis callback allows for inspecting, logging, or modifying the result\nreturned by a tool.\n\nArgs:\n  tool: The tool instance that has just been executed.\n  tool_args: The original arguments that were passed to the tool.\n  tool_context: The context specific to the tool execution.\n  result: The dictionary returned by the tool invocation.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will **replace**\n  the original result from the tool. This allows for post-processing or\n  altering tool outputs. Returning `None` uses the original, unmodified\n  result."
  - signature: 'def on_tool_error_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, error: Exception) -> typing.Optional[dict]:'
    docstring: "Callback executed when a tool call encounters an error.\n\nThis callback provides an opportunity to handle tool errors gracefully,\npotentially providing alternative responses or recovery mechanisms.\n\nArgs:\n  tool: The tool instance that encountered an error.\n  tool_args: The arguments that were passed to the tool.\n  tool_context: The context specific to the tool execution.\n  error: The exception that was raised during tool execution.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will be used as\n  the tool response instead of propagating the error. Returning `None`\n  allows the original error to be raised."
  omitted_inherited_members_from:
  - ABC
- rank: 1124
  id: google.adk.plugins.base_plugin.BasePlugin.__init__
  name: __init__
  file_path: src/google/adk/plugins/base_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the plugin.\n\nArgs:\n  name: A unique identifier for this plugin instance."
  signature: 'def __init__(self, name: str):'
- rank: 1125
  id: google.adk.plugins.base_plugin.BasePlugin.after_agent_callback
  name: after_agent_callback
  file_path: src/google/adk/plugins/base_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Callback executed after an agent's primary logic has completed.\n\nArgs:\n  agent: The agent that has just run.\n  callback_context: The context for the agent invocation.\n\nReturns:\n  An optional `types.Content` object. The content to return to the user.\n  When the content is present, the provided content will be used as agent\n  response and appended to event history as agent response."
  signature: 'def after_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
- rank: 1126
  id: google.adk.plugins.base_plugin.BasePlugin.after_model_callback
  name: after_model_callback
  file_path: src/google/adk/plugins/base_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Callback executed after a response is received from the model.\n\nThis is the ideal place to log model responses, collect metrics on token\nusage, or perform post-processing on the raw `LlmResponse`.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_response: The response object received from the model.\n\nReturns:\n  An optional value. A non-`None` return may be used by the framework to\n  modify or replace the response. Returning `None` allows the original\n  response to be used."
  signature: 'def after_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_response: google.adk.models.llm_response.LlmResponse) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
- rank: 1127
  id: google.adk.plugins.base_plugin.BasePlugin.after_run_callback
  name: after_run_callback
  file_path: src/google/adk/plugins/base_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Callback executed after an ADK runner run has completed.\n\nThis is the final callback in the ADK lifecycle, suitable for cleanup, final\nlogging, or reporting tasks.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n\nReturns:\n  None"
  signature: 'def after_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> None:'
- rank: 1128
  id: google.adk.plugins.base_plugin.BasePlugin.after_tool_callback
  name: after_tool_callback
  file_path: src/google/adk/plugins/base_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Callback executed after a tool has been called.\n\nThis callback allows for inspecting, logging, or modifying the result\nreturned by a tool.\n\nArgs:\n  tool: The tool instance that has just been executed.\n  tool_args: The original arguments that were passed to the tool.\n  tool_context: The context specific to the tool execution.\n  result: The dictionary returned by the tool invocation.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will **replace**\n  the original result from the tool. This allows for post-processing or\n  altering tool outputs. Returning `None` uses the original, unmodified\n  result."
  signature: 'def after_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, result: dict) -> typing.Optional[dict]:'
- rank: 1129
  id: google.adk.plugins.base_plugin.BasePlugin.before_agent_callback
  name: before_agent_callback
  file_path: src/google/adk/plugins/base_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Callback executed before an agent's primary logic is invoked.\n\nThis callback can be used for logging, setup, or to short-circuit the\nagent's execution by returning a value.\n\nArgs:\n  agent: The agent that is about to run.\n  callback_context: The context for the agent invocation.\n\nReturns:\n  An optional `types.Content` object. If a value is returned, it will bypass\n  the agent's callbacks and its execution, and return this value directly.\n  Returning `None` allows the agent to proceed normally."
  signature: 'def before_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
- rank: 1130
  id: google.adk.plugins.base_plugin.BasePlugin.before_model_callback
  name: before_model_callback
  file_path: src/google/adk/plugins/base_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Callback executed before a request is sent to the model.\n\nThis provides an opportunity to inspect, log, or modify the `LlmRequest`\nobject. It can also be used to implement caching by returning a cached\n`LlmResponse`, which would skip the actual model call.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_request: The prepared request object to be sent to the model.\n\nReturns:\n  An optional value. The interpretation of a non-`None` trigger an early\n  exit and returns the response immediately. Returning `None` allows the LLM\n  request to proceed normally."
  signature: 'def before_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
- rank: 1131
  id: google.adk.plugins.base_plugin.BasePlugin.before_run_callback
  name: before_run_callback
  file_path: src/google/adk/plugins/base_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Callback executed before the ADK runner runs.\n\nThis is the first callback to be called in the lifecycle, ideal for global\nsetup or initialization tasks.\n\nArgs:\n  invocation_context: The context for the entire invocation, containing\n    session information, the root agent, etc.\n\nReturns:\n  An optional `Event` to be returned to the ADK. Returning a value to\n  halt execution of the runner and ends the runner with that event. Return\n  `None` to proceed normally."
  signature: 'def before_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.Optional[google.genai.types.Content]:'
- rank: 1132
  id: google.adk.plugins.base_plugin.BasePlugin.before_tool_callback
  name: before_tool_callback
  file_path: src/google/adk/plugins/base_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Callback executed before a tool is called.\n\nThis callback is useful for logging tool usage, input validation, or\nmodifying the arguments before they are passed to the tool.\n\nArgs:\n  tool: The tool instance that is about to be executed.\n  tool_args: The dictionary of arguments to be used for invoking the tool.\n  tool_context: The context specific to the tool execution.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will stop the tool\n  execution and return this response immediately. Returning `None` uses the\n  original, unmodified arguments."
  signature: 'def before_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Optional[dict]:'
- rank: 1133
  id: google.adk.plugins.base_plugin.BasePlugin.close
  name: close
  file_path: src/google/adk/plugins/base_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Method executed when the runner is closed.


    This method is used for cleanup tasks such as closing network connections

    or releasing resources.'
  signature: 'def close(self) -> None:'
- rank: 1134
  id: google.adk.plugins.base_plugin.BasePlugin.on_event_callback
  name: on_event_callback
  file_path: src/google/adk/plugins/base_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Callback executed after an event is yielded from runner.\n\nThis is the ideal place to make modification to the event before the event\nis handled by the underlying agent app.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n  event: The event raised by the runner.\n\nReturns:\n  An optional value. A non-`None` return may be used by the framework to\n  modify or replace the response. Returning `None` allows the original\n  response to be used."
  signature: 'def on_event_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, event: google.adk.events.event.Event) -> typing.Optional[google.adk.events.event.Event]:'
- rank: 1135
  id: google.adk.plugins.base_plugin.BasePlugin.on_model_error_callback
  name: on_model_error_callback
  file_path: src/google/adk/plugins/base_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Callback executed when a model call encounters an error.\n\nThis callback provides an opportunity to handle model errors gracefully,\npotentially providing alternative responses or recovery mechanisms.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_request: The request that was sent to the model when the error\n    occurred.\n  error: The exception that was raised during model execution.\n\nReturns:\n  An optional LlmResponse. If an LlmResponse is returned, it will be used\n  instead of propagating the error. Returning `None` allows the original\n  error to be raised."
  signature: 'def on_model_error_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest, error: Exception) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
- rank: 1136
  id: google.adk.plugins.base_plugin.BasePlugin.on_tool_error_callback
  name: on_tool_error_callback
  file_path: src/google/adk/plugins/base_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Callback executed when a tool call encounters an error.\n\nThis callback provides an opportunity to handle tool errors gracefully,\npotentially providing alternative responses or recovery mechanisms.\n\nArgs:\n  tool: The tool instance that encountered an error.\n  tool_args: The arguments that were passed to the tool.\n  tool_context: The context specific to the tool execution.\n  error: The exception that was raised during tool execution.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will be used as\n  the tool response instead of propagating the error. Returning `None`\n  allows the original error to be raised."
  signature: 'def on_tool_error_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, error: Exception) -> typing.Optional[dict]:'
- rank: 1137
  id: google.adk.plugins.base_plugin.BasePlugin.on_user_message_callback
  name: on_user_message_callback
  file_path: src/google/adk/plugins/base_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Callback executed when a user message is received before an invocation starts.\n\nThis callback helps logging and modifying the user message before the\nrunner starts the invocation.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n  user_message: The message content input by user.\n\nReturns:\n  An optional `types.Content` to be returned to the ADK. Returning a\n  value to replace the user message. Returning `None` to proceed\n  normally."
  signature: 'def on_user_message_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, user_message: google.genai.types.Content) -> typing.Optional[google.genai.types.Content]:'
- rank: 1138
  id: google.adk.plugins.bigquery_agent_analytics_plugin
  name: bigquery_agent_analytics_plugin
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def to_arrow_schema(bq_schema_list: list[google.cloud.bigquery.schema.SchemaField]) -> typing.Optional[pyarrow.Schema]:'
    docstring: "Converts a list of BigQuery SchemaFields to a PyArrow Schema.\n\nArgs:\n    bq_schema_list: list of bigquery.SchemaField objects.\n\nReturns:\n    pa.Schema or None if conversion fails."
  properties:
  - signature: 'logger: logging.Logger'
  - signature: 'tracer: opentelemetry.trace.get_tracer'
  - signature: '_GRPC_DEADLINE_EXCEEDED: int'
  - signature: '_GRPC_INTERNAL: int'
  - signature: '_GRPC_UNAVAILABLE: int'
  - signature: '_BQ_TO_ARROW_SCALARS: types.MappingProxyType'
  - signature: '_BQ_FIELD_TYPE_TO_ARROW_FIELD_METADATA: Any'
  - signature: '_STRUCT_TYPES: Any'
  - signature: '_root_agent_name_ctx: contextvars.ContextVar'
  - signature: '_span_stack_ctx: contextvars.ContextVar[list[opentelemetry.trace.Span]]'
  - signature: '_span_token_stack_ctx: contextvars.ContextVar[list[opentelemetry.trace.Token]]'
  - signature: '_span_first_token_times_ctx: contextvars.ContextVar[dict[str, float]]'
  - signature: '_span_map_ctx: contextvars.ContextVar[dict[str, opentelemetry.trace.Span]]'
  - signature: '_span_id_stack_ctx: contextvars.ContextVar[list[str]]'
  - signature: '_span_start_time_ctx: contextvars.ContextVar[dict[str, int]]'
  - signature: '_span_ownership_stack_ctx: contextvars.ContextVar[list[bool]]'
  - signature: '_SHUTDOWN_SENTINEL: object'
- rank: 1139
  id: google.adk.plugins.bigquery_agent_analytics_plugin.BatchProcessor
  name: BatchProcessor
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Handles asynchronous batching and writing of events to BigQuery.
  constructor_signature: 'def __init__(self, write_client: google.cloud.bigquery_storage_v1.services.big_query_write.async_client.BigQueryWriteAsyncClient, arrow_schema: pyarrow.Schema, write_stream: str, batch_size: int, flush_interval: float, retry_config: google.adk.plugins.bigquery_agent_analytics_plugin.RetryConfig, queue_max_size: int, shutdown_timeout: float):'
  methods:
  - signature: 'def flush(self) -> None:'
    docstring: Flushes the queue by waiting for it to be empty.
  - signature: 'def start(self):'
    docstring: Starts the batch writer worker task.
  - signature: 'def append(self, row: dict[str, typing.Any]) -> None:'
    docstring: "Appends a row to the queue for batching.\n\nArgs:\n    row: Dictionary representing a single row."
  - signature: 'def shutdown(self, timeout: float) -> None:'
    docstring: "Shuts down the BatchProcessor, draining the queue.\n\nArgs:\n    timeout: Maximum time to wait for the queue to drain."
  - signature: 'def close(self) -> None:'
    docstring: Closes the processor and flushes remaining items.
- rank: 1140
  id: google.adk.plugins.bigquery_agent_analytics_plugin.BatchProcessor.__init__
  name: __init__
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the instance.\n\nArgs:\n    write_client: BigQueryWriteAsyncClient for writing rows.\n    arrow_schema: PyArrow schema for serialization.\n    write_stream: BigQuery write stream name.\n    batch_size: Number of rows per batch.\n    flush_interval: Max time to wait before flushing a batch.\n    retry_config: Retry configuration.\n    queue_max_size: Max size of the in-memory queue.\n    shutdown_timeout: Max time to wait for shutdown."
  signature: 'def __init__(self, write_client: google.cloud.bigquery_storage_v1.services.big_query_write.async_client.BigQueryWriteAsyncClient, arrow_schema: pyarrow.Schema, write_stream: str, batch_size: int, flush_interval: float, retry_config: google.adk.plugins.bigquery_agent_analytics_plugin.RetryConfig, queue_max_size: int, shutdown_timeout: float):'
- rank: 1141
  id: google.adk.plugins.bigquery_agent_analytics_plugin.BatchProcessor.append
  name: append
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Appends a row to the queue for batching.\n\nArgs:\n    row: Dictionary representing a single row."
  signature: 'def append(self, row: dict[str, typing.Any]) -> None:'
- rank: 1142
  id: google.adk.plugins.bigquery_agent_analytics_plugin.BatchProcessor.close
  name: close
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Closes the processor and flushes remaining items.
  signature: 'def close(self) -> None:'
- rank: 1143
  id: google.adk.plugins.bigquery_agent_analytics_plugin.BatchProcessor.flush
  name: flush
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Flushes the queue by waiting for it to be empty.
  signature: 'def flush(self) -> None:'
- rank: 1144
  id: google.adk.plugins.bigquery_agent_analytics_plugin.BatchProcessor.shutdown
  name: shutdown
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Shuts down the BatchProcessor, draining the queue.\n\nArgs:\n    timeout: Maximum time to wait for the queue to drain."
  signature: 'def shutdown(self, timeout: float) -> None:'
- rank: 1145
  id: google.adk.plugins.bigquery_agent_analytics_plugin.BatchProcessor.start
  name: start
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Starts the batch writer worker task.
  signature: 'def start(self):'
- rank: 1146
  id: google.adk.plugins.bigquery_agent_analytics_plugin.BigQueryAgentAnalyticsPlugin
  name: BigQueryAgentAnalyticsPlugin
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'BigQuery Agent Analytics Plugin (v2.0 using Write API).


    Logs agent events (LLM requests, tool calls, etc.) to BigQuery for analytics.

    Uses the BigQuery Write API for efficient, asynchronous, and reliable logging.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, project_id: str, dataset_id: str, table_id: typing.Optional[str], config: typing.Optional[google.adk.plugins.bigquery_agent_analytics_plugin.BigQueryLoggerConfig], location: str) -> None:'
  methods:
  - signature: 'def flush(self) -> None:'
    docstring: 'Flushes any pending events to BigQuery.


      Flushes the processor associated with the CURRENT loop.'
  - signature: 'def shutdown(self, timeout: float | None) -> None:'
    docstring: "Shuts down the plugin and releases resources.\n\nArgs:\n    timeout: Maximum time to wait for the queue to drain."
  - signature: 'def on_user_message_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, user_message: google.genai.types.Content) -> None:'
    docstring: "Parity with V1: Logs USER_MESSAGE_RECEIVED event.\n\nArgs:\n    invocation_context: The context of the current invocation.\n    user_message: The message content received from the user."
  - signature: 'def on_state_change_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, state_delta: dict[str, typing.Any]) -> None:'
    docstring: "Logs state changes (state_delta) to BigQuery.\n\nArgs:\n    callback_context: The callback context.\n    state_delta: The change in state to log.\n    **kwargs: Additional arguments."
  - signature: 'def before_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> None:'
    docstring: "Callback before the agent run starts.\n\nArgs:\n    invocation_context: The context of the current invocation."
  - signature: 'def after_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> None:'
    docstring: "Callback after the agent run completes.\n\nArgs:\n    invocation_context: The context of the current invocation."
  - signature: 'def before_agent_callback(self, *, agent: typing.Any, callback_context: google.adk.agents.callback_context.CallbackContext) -> None:'
    docstring: "Callback before an agent starts processing.\n\nArgs:\n    agent: The agent instance.\n    callback_context: The callback context."
  - signature: 'def after_agent_callback(self, *, agent: typing.Any, callback_context: google.adk.agents.callback_context.CallbackContext) -> None:'
    docstring: "Callback after an agent completes processing.\n\nArgs:\n    agent: The agent instance.\n    callback_context: The callback context."
  - signature: 'def before_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
    docstring: 'Callback before LLM call.


      Logs the LLM request details including:

      1. Prompt content

      2. System instruction (if available)


      The content is formatted as ''Prompt: {prompt} | System Prompt:

      {system_prompt}''.'
  - signature: 'def after_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_response: google.adk.models.llm_response.LlmResponse) -> None:'
    docstring: "Callback after LLM call.\n\nLogs the LLM response details including:\n1. Response content\n2. Token usage (if available)\n\nThe content is formatted as 'Response: {content} | Usage: {usage}'.\n\nArgs:\n    callback_context: The callback context.\n    llm_response: The LLM response object."
  - signature: 'def on_model_error_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, error: Exception) -> None:'
    docstring: "Callback on LLM error.\n\nArgs:\n    callback_context: The callback context.\n    error: The exception that occurred.\n    **kwargs: Additional arguments."
  - signature: 'def before_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> None:'
    docstring: "Callback before tool execution.\n\nArgs:\n    tool: The tool being executed.\n    tool_args: The arguments passed to the tool.\n    tool_context: The tool context."
  - signature: 'def after_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, result: dict[str, typing.Any]) -> None:'
    docstring: "Callback after tool execution.\n\nArgs:\n    tool: The tool that was executed.\n    tool_args: The arguments passed to the tool.\n    tool_context: The tool context.\n    result: The response from the tool."
  - signature: 'def on_tool_error_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, error: Exception) -> None:'
    docstring: "Callback on tool error.\n\nArgs:\n    tool: The tool that failed.\n    tool_args: The arguments passed to the tool.\n    tool_context: The tool context.\n    error: The exception that occurred.\n    **kwargs: Additional arguments."
  properties:
  - signature: 'batch_processor: NoneType'
  - signature: 'write_client: NoneType'
  - signature: 'write_stream: NoneType'
  inherited_methods:
    BasePlugin:
    - signature: 'def on_user_message_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, user_message: google.genai.types.Content) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed when a user message is received before an invocation starts.\n\nThis callback helps logging and modifying the user message before the\nrunner starts the invocation.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n  user_message: The message content input by user.\n\nReturns:\n  An optional `types.Content` to be returned to the ADK. Returning a\n  value to replace the user message. Returning `None` to proceed\n  normally."
    - signature: 'def before_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed before the ADK runner runs.\n\nThis is the first callback to be called in the lifecycle, ideal for global\nsetup or initialization tasks.\n\nArgs:\n  invocation_context: The context for the entire invocation, containing\n    session information, the root agent, etc.\n\nReturns:\n  An optional `Event` to be returned to the ADK. Returning a value to\n  halt execution of the runner and ends the runner with that event. Return\n  `None` to proceed normally."
    - signature: 'def on_event_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, event: google.adk.events.event.Event) -> typing.Optional[google.adk.events.event.Event]:'
      docstring: "Callback executed after an event is yielded from runner.\n\nThis is the ideal place to make modification to the event before the event\nis handled by the underlying agent app.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n  event: The event raised by the runner.\n\nReturns:\n  An optional value. A non-`None` return may be used by the framework to\n  modify or replace the response. Returning `None` allows the original\n  response to be used."
    - signature: 'def after_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> None:'
      docstring: "Callback executed after an ADK runner run has completed.\n\nThis is the final callback in the ADK lifecycle, suitable for cleanup, final\nlogging, or reporting tasks.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n\nReturns:\n  None"
    - signature: 'def close(self) -> None:'
      docstring: 'Method executed when the runner is closed.


        This method is used for cleanup tasks such as closing network connections

        or releasing resources.'
    - signature: 'def before_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed before an agent's primary logic is invoked.\n\nThis callback can be used for logging, setup, or to short-circuit the\nagent's execution by returning a value.\n\nArgs:\n  agent: The agent that is about to run.\n  callback_context: The context for the agent invocation.\n\nReturns:\n  An optional `types.Content` object. If a value is returned, it will bypass\n  the agent's callbacks and its execution, and return this value directly.\n  Returning `None` allows the agent to proceed normally."
    - signature: 'def after_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed after an agent's primary logic has completed.\n\nArgs:\n  agent: The agent that has just run.\n  callback_context: The context for the agent invocation.\n\nReturns:\n  An optional `types.Content` object. The content to return to the user.\n  When the content is present, the provided content will be used as agent\n  response and appended to event history as agent response."
    - signature: 'def before_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed before a request is sent to the model.\n\nThis provides an opportunity to inspect, log, or modify the `LlmRequest`\nobject. It can also be used to implement caching by returning a cached\n`LlmResponse`, which would skip the actual model call.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_request: The prepared request object to be sent to the model.\n\nReturns:\n  An optional value. The interpretation of a non-`None` trigger an early\n  exit and returns the response immediately. Returning `None` allows the LLM\n  request to proceed normally."
    - signature: 'def after_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_response: google.adk.models.llm_response.LlmResponse) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed after a response is received from the model.\n\nThis is the ideal place to log model responses, collect metrics on token\nusage, or perform post-processing on the raw `LlmResponse`.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_response: The response object received from the model.\n\nReturns:\n  An optional value. A non-`None` return may be used by the framework to\n  modify or replace the response. Returning `None` allows the original\n  response to be used."
    - signature: 'def on_model_error_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest, error: Exception) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed when a model call encounters an error.\n\nThis callback provides an opportunity to handle model errors gracefully,\npotentially providing alternative responses or recovery mechanisms.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_request: The request that was sent to the model when the error\n    occurred.\n  error: The exception that was raised during model execution.\n\nReturns:\n  An optional LlmResponse. If an LlmResponse is returned, it will be used\n  instead of propagating the error. Returning `None` allows the original\n  error to be raised."
    - signature: 'def before_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Optional[dict]:'
      docstring: "Callback executed before a tool is called.\n\nThis callback is useful for logging tool usage, input validation, or\nmodifying the arguments before they are passed to the tool.\n\nArgs:\n  tool: The tool instance that is about to be executed.\n  tool_args: The dictionary of arguments to be used for invoking the tool.\n  tool_context: The context specific to the tool execution.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will stop the tool\n  execution and return this response immediately. Returning `None` uses the\n  original, unmodified arguments."
    - signature: 'def after_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, result: dict) -> typing.Optional[dict]:'
      docstring: "Callback executed after a tool has been called.\n\nThis callback allows for inspecting, logging, or modifying the result\nreturned by a tool.\n\nArgs:\n  tool: The tool instance that has just been executed.\n  tool_args: The original arguments that were passed to the tool.\n  tool_context: The context specific to the tool execution.\n  result: The dictionary returned by the tool invocation.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will **replace**\n  the original result from the tool. This allows for post-processing or\n  altering tool outputs. Returning `None` uses the original, unmodified\n  result."
    - signature: 'def on_tool_error_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, error: Exception) -> typing.Optional[dict]:'
      docstring: "Callback executed when a tool call encounters an error.\n\nThis callback provides an opportunity to handle tool errors gracefully,\npotentially providing alternative responses or recovery mechanisms.\n\nArgs:\n  tool: The tool instance that encountered an error.\n  tool_args: The arguments that were passed to the tool.\n  tool_context: The context specific to the tool execution.\n  error: The exception that was raised during tool execution.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will be used as\n  the tool response instead of propagating the error. Returning `None`\n  allows the original error to be raised."
  omitted_inherited_members_from:
  - ABC
- rank: 1147
  id: google.adk.plugins.bigquery_agent_analytics_plugin.BigQueryAgentAnalyticsPlugin.__init__
  name: __init__
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the instance.\n\nArgs:\n    project_id: Google Cloud project ID.\n    dataset_id: BigQuery dataset ID.\n    table_id: BigQuery table ID (optional, overrides config).\n    config: BigQueryLoggerConfig (optional).\n    location: BigQuery location (default: \"US\").\n    **kwargs: Additional configuration parameters for BigQueryLoggerConfig."
  signature: 'def __init__(self, project_id: str, dataset_id: str, table_id: typing.Optional[str], config: typing.Optional[google.adk.plugins.bigquery_agent_analytics_plugin.BigQueryLoggerConfig], location: str) -> None:'
- rank: 1148
  id: google.adk.plugins.bigquery_agent_analytics_plugin.BigQueryAgentAnalyticsPlugin.after_agent_callback
  name: after_agent_callback
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Callback after an agent completes processing.\n\nArgs:\n    agent: The agent instance.\n    callback_context: The callback context."
  signature: 'def after_agent_callback(self, *, agent: typing.Any, callback_context: google.adk.agents.callback_context.CallbackContext) -> None:'
- rank: 1149
  id: google.adk.plugins.bigquery_agent_analytics_plugin.BigQueryAgentAnalyticsPlugin.after_model_callback
  name: after_model_callback
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Callback after LLM call.\n\nLogs the LLM response details including:\n1. Response content\n2. Token usage (if available)\n\nThe content is formatted as 'Response: {content} | Usage: {usage}'.\n\nArgs:\n    callback_context: The callback context.\n    llm_response: The LLM response object."
  signature: 'def after_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_response: google.adk.models.llm_response.LlmResponse) -> None:'
- rank: 1150
  id: google.adk.plugins.bigquery_agent_analytics_plugin.BigQueryAgentAnalyticsPlugin.after_run_callback
  name: after_run_callback
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Callback after the agent run completes.\n\nArgs:\n    invocation_context: The context of the current invocation."
  signature: 'def after_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> None:'
- rank: 1151
  id: google.adk.plugins.bigquery_agent_analytics_plugin.BigQueryAgentAnalyticsPlugin.after_tool_callback
  name: after_tool_callback
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Callback after tool execution.\n\nArgs:\n    tool: The tool that was executed.\n    tool_args: The arguments passed to the tool.\n    tool_context: The tool context.\n    result: The response from the tool."
  signature: 'def after_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, result: dict[str, typing.Any]) -> None:'
- rank: 1152
  id: google.adk.plugins.bigquery_agent_analytics_plugin.BigQueryAgentAnalyticsPlugin.before_agent_callback
  name: before_agent_callback
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Callback before an agent starts processing.\n\nArgs:\n    agent: The agent instance.\n    callback_context: The callback context."
  signature: 'def before_agent_callback(self, *, agent: typing.Any, callback_context: google.adk.agents.callback_context.CallbackContext) -> None:'
- rank: 1153
  id: google.adk.plugins.bigquery_agent_analytics_plugin.BigQueryAgentAnalyticsPlugin.before_model_callback
  name: before_model_callback
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Callback before LLM call.


    Logs the LLM request details including:

    1. Prompt content

    2. System instruction (if available)


    The content is formatted as ''Prompt: {prompt} | System Prompt:

    {system_prompt}''.'
  signature: 'def before_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
- rank: 1154
  id: google.adk.plugins.bigquery_agent_analytics_plugin.BigQueryAgentAnalyticsPlugin.before_run_callback
  name: before_run_callback
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Callback before the agent run starts.\n\nArgs:\n    invocation_context: The context of the current invocation."
  signature: 'def before_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> None:'
- rank: 1155
  id: google.adk.plugins.bigquery_agent_analytics_plugin.BigQueryAgentAnalyticsPlugin.before_tool_callback
  name: before_tool_callback
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Callback before tool execution.\n\nArgs:\n    tool: The tool being executed.\n    tool_args: The arguments passed to the tool.\n    tool_context: The tool context."
  signature: 'def before_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> None:'
- rank: 1156
  id: google.adk.plugins.bigquery_agent_analytics_plugin.BigQueryAgentAnalyticsPlugin.flush
  name: flush
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Flushes any pending events to BigQuery.


    Flushes the processor associated with the CURRENT loop.'
  signature: 'def flush(self) -> None:'
- rank: 1157
  id: google.adk.plugins.bigquery_agent_analytics_plugin.BigQueryAgentAnalyticsPlugin.on_model_error_callback
  name: on_model_error_callback
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Callback on LLM error.\n\nArgs:\n    callback_context: The callback context.\n    error: The exception that occurred.\n    **kwargs: Additional arguments."
  signature: 'def on_model_error_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, error: Exception) -> None:'
- rank: 1158
  id: google.adk.plugins.bigquery_agent_analytics_plugin.BigQueryAgentAnalyticsPlugin.on_state_change_callback
  name: on_state_change_callback
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Logs state changes (state_delta) to BigQuery.\n\nArgs:\n    callback_context: The callback context.\n    state_delta: The change in state to log.\n    **kwargs: Additional arguments."
  signature: 'def on_state_change_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, state_delta: dict[str, typing.Any]) -> None:'
- rank: 1159
  id: google.adk.plugins.bigquery_agent_analytics_plugin.BigQueryAgentAnalyticsPlugin.on_tool_error_callback
  name: on_tool_error_callback
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Callback on tool error.\n\nArgs:\n    tool: The tool that failed.\n    tool_args: The arguments passed to the tool.\n    tool_context: The tool context.\n    error: The exception that occurred.\n    **kwargs: Additional arguments."
  signature: 'def on_tool_error_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, error: Exception) -> None:'
- rank: 1160
  id: google.adk.plugins.bigquery_agent_analytics_plugin.BigQueryAgentAnalyticsPlugin.on_user_message_callback
  name: on_user_message_callback
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Parity with V1: Logs USER_MESSAGE_RECEIVED event.\n\nArgs:\n    invocation_context: The context of the current invocation.\n    user_message: The message content received from the user."
  signature: 'def on_user_message_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, user_message: google.genai.types.Content) -> None:'
- rank: 1161
  id: google.adk.plugins.bigquery_agent_analytics_plugin.BigQueryAgentAnalyticsPlugin.shutdown
  name: shutdown
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Shuts down the plugin and releases resources.\n\nArgs:\n    timeout: Maximum time to wait for the queue to drain."
  signature: 'def shutdown(self, timeout: float | None) -> None:'
- rank: 1162
  id: google.adk.plugins.bigquery_agent_analytics_plugin.BigQueryLoggerConfig
  name: BigQueryLoggerConfig
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "Configuration for the BigQueryAgentAnalyticsPlugin.\n\nAttributes:\n    enabled: Whether logging is enabled.\n    event_allowlist: list of event types to log. If None, all are allowed.\n    event_denylist: list of event types to ignore.\n    max_content_length: Max length for text content before truncation.\n    table_id: BigQuery table ID.\n    clustering_fields: Fields to cluster the table by.\n    log_multi_modal_content: Whether to log detailed content parts.\n    retry_config: Retry configuration for writes.\n    batch_size: Number of rows per batch.\n    batch_flush_interval: Max time to wait before flushing a batch.\n    shutdown_timeout: Max time to wait for shutdown.\n    queue_max_size: Max size of the in-memory queue.\n    content_formatter: Optional custom formatter for content."
  constructor_signature: 'def __init__(self, *, enabled: bool = True, event_allowlist: list[str] | None = None, event_denylist: list[str] | None = None, max_content_length: int = 500 * 1024, table_id: str = ''agent_events_v2'', clustering_fields: list[str] = Factory(lambda: [''event_type'', ''agent'', ''user_id'']), log_multi_modal_content: bool = True, retry_config: google.adk.plugins.bigquery_agent_analytics_plugin.RetryConfig = Factory(RetryConfig), batch_size: int = 1, batch_flush_interval: float = 1.0, shutdown_timeout: float = 10.0, queue_max_size: int = 10000, content_formatter: typing.Optional[typing.Callable[[Any, str], typing.Any]] = None, gcs_bucket_name: typing.Optional[str] = None, connection_id: typing.Optional[str] = None, log_session_metadata: bool = True, custom_tags: dict[str, typing.Any] = dict()):'
  properties:
  - signature: 'enabled: bool'
  - signature: 'event_allowlist: list[str] | None'
  - signature: 'event_denylist: list[str] | None'
  - signature: 'max_content_length: int'
  - signature: 'table_id: str'
  - signature: 'clustering_fields: list[str]'
  - signature: 'log_multi_modal_content: bool'
  - signature: 'retry_config: google.adk.plugins.bigquery_agent_analytics_plugin.RetryConfig'
  - signature: 'batch_size: int'
  - signature: 'batch_flush_interval: float'
  - signature: 'shutdown_timeout: float'
  - signature: 'queue_max_size: int'
  - signature: 'content_formatter: typing.Optional[typing.Callable[[Any, str], typing.Any]]'
  - signature: 'gcs_bucket_name: typing.Optional[str]'
  - signature: 'connection_id: typing.Optional[str]'
  - signature: 'log_session_metadata: bool'
  - signature: 'custom_tags: dict[str, typing.Any]'
- rank: 1163
  id: google.adk.plugins.bigquery_agent_analytics_plugin.ContentParser
  name: ContentParser
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Parses content for logging with length limits and structure normalization.
  constructor_signature: 'def __init__(self, max_length: int) -> None:'
- rank: 1164
  id: google.adk.plugins.bigquery_agent_analytics_plugin.ContentParser.__init__
  name: __init__
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the instance.\n\nArgs:\n    max_length: Maximum length for text content."
  signature: 'def __init__(self, max_length: int) -> None:'
- rank: 1165
  id: google.adk.plugins.bigquery_agent_analytics_plugin.GCSOffloader
  name: GCSOffloader
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Offloads content to GCS.
  constructor_signature: 'def __init__(self, project_id: str, bucket_name: str, executor: concurrent.futures.ThreadPoolExecutor, storage_client: typing.Optional[google.cloud.storage.Client]):'
  methods:
  - signature: 'def upload_content(self, data: bytes | str, content_type: str, path: str) -> str:'
    docstring: Async wrapper around blocking GCS upload.
- rank: 1166
  id: google.adk.plugins.bigquery_agent_analytics_plugin.GCSOffloader.__init__
  name: __init__
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, project_id: str, bucket_name: str, executor: concurrent.futures.ThreadPoolExecutor, storage_client: typing.Optional[google.cloud.storage.Client]):'
- rank: 1167
  id: google.adk.plugins.bigquery_agent_analytics_plugin.GCSOffloader.upload_content
  name: upload_content
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Async wrapper around blocking GCS upload.
  signature: 'def upload_content(self, data: bytes | str, content_type: str, path: str) -> str:'
- rank: 1168
  id: google.adk.plugins.bigquery_agent_analytics_plugin.HybridContentParser
  name: HybridContentParser
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Parses content and offloads large/binary parts to GCS.
  constructor_signature: 'def __init__(self, offloader: typing.Optional[google.adk.plugins.bigquery_agent_analytics_plugin.GCSOffloader], trace_id: str, span_id: str, max_length: int, connection_id: typing.Optional[str]):'
  methods:
  - signature: 'def parse(self, content: typing.Any) -> tuple[typing.Any, list[dict[str, typing.Any]], bool]:'
    docstring: Parses content into JSON payload and content parts, potentially offloading to GCS.
- rank: 1169
  id: google.adk.plugins.bigquery_agent_analytics_plugin.HybridContentParser.__init__
  name: __init__
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, offloader: typing.Optional[google.adk.plugins.bigquery_agent_analytics_plugin.GCSOffloader], trace_id: str, span_id: str, max_length: int, connection_id: typing.Optional[str]):'
- rank: 1170
  id: google.adk.plugins.bigquery_agent_analytics_plugin.HybridContentParser.parse
  name: parse
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Parses content into JSON payload and content parts, potentially offloading to GCS.
  signature: 'def parse(self, content: typing.Any) -> tuple[typing.Any, list[dict[str, typing.Any]], bool]:'
- rank: 1171
  id: google.adk.plugins.bigquery_agent_analytics_plugin.RetryConfig
  name: RetryConfig
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "Configuration for retrying failed BigQuery write operations.\n\nAttributes:\n    max_retries: Maximum number of retry attempts.\n    initial_delay: Initial delay between retries in seconds.\n    multiplier: Multiplier for exponential backoff.\n    max_delay: Maximum delay between retries in seconds."
  constructor_signature: 'def __init__(self, *, max_retries: int = 3, initial_delay: float = 1.0, multiplier: float = 2.0, max_delay: float = 10.0):'
  properties:
  - signature: 'max_retries: int'
  - signature: 'initial_delay: float'
  - signature: 'multiplier: float'
  - signature: 'max_delay: float'
- rank: 1172
  id: google.adk.plugins.bigquery_agent_analytics_plugin.TraceManager
  name: TraceManager
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Manages OpenTelemetry-style trace and span context using contextvars.
  methods:
  - signature: 'def init_trace(callback_context: google.adk.agents.callback_context.CallbackContext) -> None:'
  - signature: 'def get_trace_id(callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[str]:'
    docstring: Gets the trace ID from the current span or invocation_id.
  - signature: 'def push_span(callback_context: google.adk.agents.callback_context.CallbackContext, span_name: typing.Optional[str]) -> str:'
    docstring: 'Starts a new span and pushes it onto the stack.


      If OTel is not configured (returning non-recording spans), a UUID fallback

      is generated to ensure span_id and parent_span_id are populated in logs.'
  - signature: 'def attach_current_span(callback_context: google.adk.agents.callback_context.CallbackContext) -> str:'
    docstring: Attaches the current OTEL span to the stack without owning it.
  - signature: 'def pop_span() -> tuple[typing.Optional[str], typing.Optional[int]]:'
    docstring: Ends the current span and pops it from the stack.
  - signature: 'def get_current_span_and_parent() -> tuple[typing.Optional[str], typing.Optional[str]]:'
    docstring: Gets current span_id and parent span_id from OTEL context or fallback stack.
  - signature: 'def get_current_span_id() -> typing.Optional[str]:'
    docstring: Gets current span_id from OTEL context or fallback stack.
  - signature: 'def get_root_agent_name() -> typing.Optional[str]:'
  - signature: 'def get_start_time(span_id: str) -> typing.Optional[float]:'
    docstring: Gets start time of a span by ID.
  - signature: 'def record_first_token(span_id: str) -> bool:'
    docstring: Records the current time as first token time if not already recorded.
  - signature: 'def get_first_token_time(span_id: str) -> typing.Optional[float]:'
    docstring: Gets the recorded first token time.
- rank: 1173
  id: google.adk.plugins.bigquery_agent_analytics_plugin.TraceManager.attach_current_span
  name: attach_current_span
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Attaches the current OTEL span to the stack without owning it.
  signature: 'def attach_current_span(callback_context: google.adk.agents.callback_context.CallbackContext) -> str:'
- rank: 1174
  id: google.adk.plugins.bigquery_agent_analytics_plugin.TraceManager.get_current_span_and_parent
  name: get_current_span_and_parent
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Gets current span_id and parent span_id from OTEL context or fallback stack.
  signature: 'def get_current_span_and_parent() -> tuple[typing.Optional[str], typing.Optional[str]]:'
- rank: 1175
  id: google.adk.plugins.bigquery_agent_analytics_plugin.TraceManager.get_current_span_id
  name: get_current_span_id
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Gets current span_id from OTEL context or fallback stack.
  signature: 'def get_current_span_id() -> typing.Optional[str]:'
- rank: 1176
  id: google.adk.plugins.bigquery_agent_analytics_plugin.TraceManager.get_first_token_time
  name: get_first_token_time
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Gets the recorded first token time.
  signature: 'def get_first_token_time(span_id: str) -> typing.Optional[float]:'
- rank: 1177
  id: google.adk.plugins.bigquery_agent_analytics_plugin.TraceManager.get_start_time
  name: get_start_time
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Gets start time of a span by ID.
  signature: 'def get_start_time(span_id: str) -> typing.Optional[float]:'
- rank: 1178
  id: google.adk.plugins.bigquery_agent_analytics_plugin.TraceManager.get_trace_id
  name: get_trace_id
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Gets the trace ID from the current span or invocation_id.
  signature: 'def get_trace_id(callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[str]:'
- rank: 1179
  id: google.adk.plugins.bigquery_agent_analytics_plugin.TraceManager.init_trace
  name: init_trace
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def init_trace(callback_context: google.adk.agents.callback_context.CallbackContext) -> None:'
- rank: 1180
  id: google.adk.plugins.bigquery_agent_analytics_plugin.TraceManager.pop_span
  name: pop_span
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Ends the current span and pops it from the stack.
  signature: 'def pop_span() -> tuple[typing.Optional[str], typing.Optional[int]]:'
- rank: 1181
  id: google.adk.plugins.bigquery_agent_analytics_plugin.TraceManager.push_span
  name: push_span
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Starts a new span and pushes it onto the stack.


    If OTel is not configured (returning non-recording spans), a UUID fallback

    is generated to ensure span_id and parent_span_id are populated in logs.'
  signature: 'def push_span(callback_context: google.adk.agents.callback_context.CallbackContext, span_name: typing.Optional[str]) -> str:'
- rank: 1182
  id: google.adk.plugins.bigquery_agent_analytics_plugin.TraceManager.record_first_token
  name: record_first_token
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Records the current time as first token time if not already recorded.
  signature: 'def record_first_token(span_id: str) -> bool:'
- rank: 1183
  id: google.adk.plugins.bigquery_agent_analytics_plugin.to_arrow_schema
  name: to_arrow_schema
  file_path: src/google/adk/plugins/bigquery_agent_analytics_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Converts a list of BigQuery SchemaFields to a PyArrow Schema.\n\nArgs:\n    bq_schema_list: list of bigquery.SchemaField objects.\n\nReturns:\n    pa.Schema or None if conversion fails."
  signature: 'def to_arrow_schema(bq_schema_list: list[google.cloud.bigquery.schema.SchemaField]) -> typing.Optional[pyarrow.Schema]:'
- rank: 1184
  id: google.adk.plugins.context_filter_plugin
  name: context_filter_plugin
  file_path: src/google/adk/plugins/context_filter_plugin.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 1185
  id: google.adk.plugins.context_filter_plugin.ContextFilterPlugin
  name: ContextFilterPlugin
  file_path: src/google/adk/plugins/context_filter_plugin.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A plugin that filters the LLM context to reduce its size.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, num_invocations_to_keep: typing.Optional[int], custom_filter: typing.Optional[typing.Callable[[list[types.Content]], list[google.genai.types.Content]]], name: str):'
  methods:
  - signature: 'def before_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
    docstring: Filters the LLM request's context before it is sent to the model.
  inherited_methods:
    BasePlugin:
    - signature: 'def on_user_message_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, user_message: google.genai.types.Content) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed when a user message is received before an invocation starts.\n\nThis callback helps logging and modifying the user message before the\nrunner starts the invocation.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n  user_message: The message content input by user.\n\nReturns:\n  An optional `types.Content` to be returned to the ADK. Returning a\n  value to replace the user message. Returning `None` to proceed\n  normally."
    - signature: 'def before_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed before the ADK runner runs.\n\nThis is the first callback to be called in the lifecycle, ideal for global\nsetup or initialization tasks.\n\nArgs:\n  invocation_context: The context for the entire invocation, containing\n    session information, the root agent, etc.\n\nReturns:\n  An optional `Event` to be returned to the ADK. Returning a value to\n  halt execution of the runner and ends the runner with that event. Return\n  `None` to proceed normally."
    - signature: 'def on_event_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, event: google.adk.events.event.Event) -> typing.Optional[google.adk.events.event.Event]:'
      docstring: "Callback executed after an event is yielded from runner.\n\nThis is the ideal place to make modification to the event before the event\nis handled by the underlying agent app.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n  event: The event raised by the runner.\n\nReturns:\n  An optional value. A non-`None` return may be used by the framework to\n  modify or replace the response. Returning `None` allows the original\n  response to be used."
    - signature: 'def after_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> None:'
      docstring: "Callback executed after an ADK runner run has completed.\n\nThis is the final callback in the ADK lifecycle, suitable for cleanup, final\nlogging, or reporting tasks.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n\nReturns:\n  None"
    - signature: 'def close(self) -> None:'
      docstring: 'Method executed when the runner is closed.


        This method is used for cleanup tasks such as closing network connections

        or releasing resources.'
    - signature: 'def before_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed before an agent's primary logic is invoked.\n\nThis callback can be used for logging, setup, or to short-circuit the\nagent's execution by returning a value.\n\nArgs:\n  agent: The agent that is about to run.\n  callback_context: The context for the agent invocation.\n\nReturns:\n  An optional `types.Content` object. If a value is returned, it will bypass\n  the agent's callbacks and its execution, and return this value directly.\n  Returning `None` allows the agent to proceed normally."
    - signature: 'def after_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed after an agent's primary logic has completed.\n\nArgs:\n  agent: The agent that has just run.\n  callback_context: The context for the agent invocation.\n\nReturns:\n  An optional `types.Content` object. The content to return to the user.\n  When the content is present, the provided content will be used as agent\n  response and appended to event history as agent response."
    - signature: 'def before_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed before a request is sent to the model.\n\nThis provides an opportunity to inspect, log, or modify the `LlmRequest`\nobject. It can also be used to implement caching by returning a cached\n`LlmResponse`, which would skip the actual model call.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_request: The prepared request object to be sent to the model.\n\nReturns:\n  An optional value. The interpretation of a non-`None` trigger an early\n  exit and returns the response immediately. Returning `None` allows the LLM\n  request to proceed normally."
    - signature: 'def after_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_response: google.adk.models.llm_response.LlmResponse) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed after a response is received from the model.\n\nThis is the ideal place to log model responses, collect metrics on token\nusage, or perform post-processing on the raw `LlmResponse`.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_response: The response object received from the model.\n\nReturns:\n  An optional value. A non-`None` return may be used by the framework to\n  modify or replace the response. Returning `None` allows the original\n  response to be used."
    - signature: 'def on_model_error_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest, error: Exception) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed when a model call encounters an error.\n\nThis callback provides an opportunity to handle model errors gracefully,\npotentially providing alternative responses or recovery mechanisms.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_request: The request that was sent to the model when the error\n    occurred.\n  error: The exception that was raised during model execution.\n\nReturns:\n  An optional LlmResponse. If an LlmResponse is returned, it will be used\n  instead of propagating the error. Returning `None` allows the original\n  error to be raised."
    - signature: 'def before_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Optional[dict]:'
      docstring: "Callback executed before a tool is called.\n\nThis callback is useful for logging tool usage, input validation, or\nmodifying the arguments before they are passed to the tool.\n\nArgs:\n  tool: The tool instance that is about to be executed.\n  tool_args: The dictionary of arguments to be used for invoking the tool.\n  tool_context: The context specific to the tool execution.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will stop the tool\n  execution and return this response immediately. Returning `None` uses the\n  original, unmodified arguments."
    - signature: 'def after_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, result: dict) -> typing.Optional[dict]:'
      docstring: "Callback executed after a tool has been called.\n\nThis callback allows for inspecting, logging, or modifying the result\nreturned by a tool.\n\nArgs:\n  tool: The tool instance that has just been executed.\n  tool_args: The original arguments that were passed to the tool.\n  tool_context: The context specific to the tool execution.\n  result: The dictionary returned by the tool invocation.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will **replace**\n  the original result from the tool. This allows for post-processing or\n  altering tool outputs. Returning `None` uses the original, unmodified\n  result."
    - signature: 'def on_tool_error_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, error: Exception) -> typing.Optional[dict]:'
      docstring: "Callback executed when a tool call encounters an error.\n\nThis callback provides an opportunity to handle tool errors gracefully,\npotentially providing alternative responses or recovery mechanisms.\n\nArgs:\n  tool: The tool instance that encountered an error.\n  tool_args: The arguments that were passed to the tool.\n  tool_context: The context specific to the tool execution.\n  error: The exception that was raised during tool execution.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will be used as\n  the tool response instead of propagating the error. Returning `None`\n  allows the original error to be raised."
  omitted_inherited_members_from:
  - ABC
- rank: 1186
  id: google.adk.plugins.context_filter_plugin.ContextFilterPlugin.__init__
  name: __init__
  file_path: src/google/adk/plugins/context_filter_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the context management plugin.\n\nArgs:\n  num_invocations_to_keep: The number of last invocations to keep. An\n    invocation starts with one or more consecutive user messages and can\n    contain multiple model turns (e.g. tool calls) until the next user\n    message starts a new invocation.\n  custom_filter: A function to filter the context.\n  name: The name of the plugin instance."
  signature: 'def __init__(self, num_invocations_to_keep: typing.Optional[int], custom_filter: typing.Optional[typing.Callable[[list[types.Content]], list[google.genai.types.Content]]], name: str):'
- rank: 1187
  id: google.adk.plugins.context_filter_plugin.ContextFilterPlugin.before_model_callback
  name: before_model_callback
  file_path: src/google/adk/plugins/context_filter_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Filters the LLM request's context before it is sent to the model.
  signature: 'def before_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
- rank: 1188
  id: google.adk.plugins.debug_logging_plugin
  name: debug_logging_plugin
  file_path: src/google/adk/plugins/debug_logging_plugin.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Debug logging plugin for capturing complete interaction data to a file.
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 1189
  id: google.adk.plugins.debug_logging_plugin.DebugLoggingPlugin
  name: DebugLoggingPlugin
  file_path: src/google/adk/plugins/debug_logging_plugin.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "A plugin that captures complete debug information to a file.\n\nThis plugin records detailed interaction data including:\n- LLM requests (model, system instruction, contents, tools)\n- LLM responses (content, usage metadata, errors)\n- Function calls with arguments\n- Function responses with results\n- Events yielded from the runner\n- Session state at the end of each invocation\n\nThe output is written as YAML format for human readability. Each invocation\nis appended to the file as a separate YAML document (separated by ---).\nThis format is easy to read and can be shared for debugging purposes.\n\nExample:\n    >>> debug_plugin = DebugLoggingPlugin(output_path=\"/tmp/adk_debug.yaml\")\n    >>> runner = Runner(\n    ...     agent=my_agent,\n    ...     plugins=[debug_plugin],\n    ... )\n\nAttributes:\n    output_path: Path to the output file. Defaults to \"adk_debug.yaml\".\n    include_session_state: Whether to include session state in the output.\n    include_system_instruction:\
    \ Whether to include system instructions.\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, *, name: str=''debug_logging_plugin'', output_path: str=''adk_debug.yaml'', include_session_state: bool=True, include_system_instruction: bool=True):'
  methods:
  - signature: 'def on_user_message_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, user_message: google.genai.types.Content) -> types.Content | None:'
    docstring: Log user message and invocation start.
  - signature: 'def before_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> types.Content | None:'
    docstring: Initialize debug state for this invocation.
  - signature: 'def on_event_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, event: google.adk.events.event.Event) -> Event | None:'
    docstring: Log events yielded from the runner.
  - signature: 'def after_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> None:'
    docstring: Finalize and write debug data to file.
  - signature: 'def before_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> types.Content | None:'
    docstring: Log agent execution start.
  - signature: 'def after_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> types.Content | None:'
    docstring: Log agent execution completion.
  - signature: 'def before_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest) -> LlmResponse | None:'
    docstring: Log LLM request before sending to model.
  - signature: 'def after_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_response: google.adk.models.llm_response.LlmResponse) -> LlmResponse | None:'
    docstring: Log LLM response after receiving from model.
  - signature: 'def on_model_error_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest, error: Exception) -> LlmResponse | None:'
    docstring: Log LLM error.
  - signature: 'def before_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> dict[str, Any] | None:'
    docstring: Log tool execution start.
  - signature: 'def after_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, result: dict[str, typing.Any]) -> dict[str, Any] | None:'
    docstring: Log tool execution completion.
  - signature: 'def on_tool_error_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, error: Exception) -> dict[str, Any] | None:'
    docstring: Log tool error.
  inherited_methods:
    BasePlugin:
    - signature: 'def on_user_message_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, user_message: google.genai.types.Content) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed when a user message is received before an invocation starts.\n\nThis callback helps logging and modifying the user message before the\nrunner starts the invocation.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n  user_message: The message content input by user.\n\nReturns:\n  An optional `types.Content` to be returned to the ADK. Returning a\n  value to replace the user message. Returning `None` to proceed\n  normally."
    - signature: 'def before_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed before the ADK runner runs.\n\nThis is the first callback to be called in the lifecycle, ideal for global\nsetup or initialization tasks.\n\nArgs:\n  invocation_context: The context for the entire invocation, containing\n    session information, the root agent, etc.\n\nReturns:\n  An optional `Event` to be returned to the ADK. Returning a value to\n  halt execution of the runner and ends the runner with that event. Return\n  `None` to proceed normally."
    - signature: 'def on_event_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, event: google.adk.events.event.Event) -> typing.Optional[google.adk.events.event.Event]:'
      docstring: "Callback executed after an event is yielded from runner.\n\nThis is the ideal place to make modification to the event before the event\nis handled by the underlying agent app.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n  event: The event raised by the runner.\n\nReturns:\n  An optional value. A non-`None` return may be used by the framework to\n  modify or replace the response. Returning `None` allows the original\n  response to be used."
    - signature: 'def after_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> None:'
      docstring: "Callback executed after an ADK runner run has completed.\n\nThis is the final callback in the ADK lifecycle, suitable for cleanup, final\nlogging, or reporting tasks.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n\nReturns:\n  None"
    - signature: 'def close(self) -> None:'
      docstring: 'Method executed when the runner is closed.


        This method is used for cleanup tasks such as closing network connections

        or releasing resources.'
    - signature: 'def before_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed before an agent's primary logic is invoked.\n\nThis callback can be used for logging, setup, or to short-circuit the\nagent's execution by returning a value.\n\nArgs:\n  agent: The agent that is about to run.\n  callback_context: The context for the agent invocation.\n\nReturns:\n  An optional `types.Content` object. If a value is returned, it will bypass\n  the agent's callbacks and its execution, and return this value directly.\n  Returning `None` allows the agent to proceed normally."
    - signature: 'def after_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed after an agent's primary logic has completed.\n\nArgs:\n  agent: The agent that has just run.\n  callback_context: The context for the agent invocation.\n\nReturns:\n  An optional `types.Content` object. The content to return to the user.\n  When the content is present, the provided content will be used as agent\n  response and appended to event history as agent response."
    - signature: 'def before_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed before a request is sent to the model.\n\nThis provides an opportunity to inspect, log, or modify the `LlmRequest`\nobject. It can also be used to implement caching by returning a cached\n`LlmResponse`, which would skip the actual model call.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_request: The prepared request object to be sent to the model.\n\nReturns:\n  An optional value. The interpretation of a non-`None` trigger an early\n  exit and returns the response immediately. Returning `None` allows the LLM\n  request to proceed normally."
    - signature: 'def after_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_response: google.adk.models.llm_response.LlmResponse) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed after a response is received from the model.\n\nThis is the ideal place to log model responses, collect metrics on token\nusage, or perform post-processing on the raw `LlmResponse`.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_response: The response object received from the model.\n\nReturns:\n  An optional value. A non-`None` return may be used by the framework to\n  modify or replace the response. Returning `None` allows the original\n  response to be used."
    - signature: 'def on_model_error_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest, error: Exception) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed when a model call encounters an error.\n\nThis callback provides an opportunity to handle model errors gracefully,\npotentially providing alternative responses or recovery mechanisms.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_request: The request that was sent to the model when the error\n    occurred.\n  error: The exception that was raised during model execution.\n\nReturns:\n  An optional LlmResponse. If an LlmResponse is returned, it will be used\n  instead of propagating the error. Returning `None` allows the original\n  error to be raised."
    - signature: 'def before_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Optional[dict]:'
      docstring: "Callback executed before a tool is called.\n\nThis callback is useful for logging tool usage, input validation, or\nmodifying the arguments before they are passed to the tool.\n\nArgs:\n  tool: The tool instance that is about to be executed.\n  tool_args: The dictionary of arguments to be used for invoking the tool.\n  tool_context: The context specific to the tool execution.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will stop the tool\n  execution and return this response immediately. Returning `None` uses the\n  original, unmodified arguments."
    - signature: 'def after_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, result: dict) -> typing.Optional[dict]:'
      docstring: "Callback executed after a tool has been called.\n\nThis callback allows for inspecting, logging, or modifying the result\nreturned by a tool.\n\nArgs:\n  tool: The tool instance that has just been executed.\n  tool_args: The original arguments that were passed to the tool.\n  tool_context: The context specific to the tool execution.\n  result: The dictionary returned by the tool invocation.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will **replace**\n  the original result from the tool. This allows for post-processing or\n  altering tool outputs. Returning `None` uses the original, unmodified\n  result."
    - signature: 'def on_tool_error_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, error: Exception) -> typing.Optional[dict]:'
      docstring: "Callback executed when a tool call encounters an error.\n\nThis callback provides an opportunity to handle tool errors gracefully,\npotentially providing alternative responses or recovery mechanisms.\n\nArgs:\n  tool: The tool instance that encountered an error.\n  tool_args: The arguments that were passed to the tool.\n  tool_context: The context specific to the tool execution.\n  error: The exception that was raised during tool execution.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will be used as\n  the tool response instead of propagating the error. Returning `None`\n  allows the original error to be raised."
  omitted_inherited_members_from:
  - ABC
- rank: 1190
  id: google.adk.plugins.debug_logging_plugin.DebugLoggingPlugin.__init__
  name: __init__
  file_path: src/google/adk/plugins/debug_logging_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initialize the debug logging plugin.\n\nArgs:\n  name: The name of the plugin instance.\n  output_path: Path to the output file. Defaults to \"adk_debug.yaml\".\n  include_session_state: Whether to include session state snapshot.\n  include_system_instruction: Whether to include full system instructions."
  signature: 'def __init__(self, *, name: str=''debug_logging_plugin'', output_path: str=''adk_debug.yaml'', include_session_state: bool=True, include_system_instruction: bool=True):'
- rank: 1191
  id: google.adk.plugins.debug_logging_plugin.DebugLoggingPlugin.after_agent_callback
  name: after_agent_callback
  file_path: src/google/adk/plugins/debug_logging_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Log agent execution completion.
  signature: 'def after_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> types.Content | None:'
- rank: 1192
  id: google.adk.plugins.debug_logging_plugin.DebugLoggingPlugin.after_model_callback
  name: after_model_callback
  file_path: src/google/adk/plugins/debug_logging_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Log LLM response after receiving from model.
  signature: 'def after_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_response: google.adk.models.llm_response.LlmResponse) -> LlmResponse | None:'
- rank: 1193
  id: google.adk.plugins.debug_logging_plugin.DebugLoggingPlugin.after_run_callback
  name: after_run_callback
  file_path: src/google/adk/plugins/debug_logging_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Finalize and write debug data to file.
  signature: 'def after_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> None:'
- rank: 1194
  id: google.adk.plugins.debug_logging_plugin.DebugLoggingPlugin.after_tool_callback
  name: after_tool_callback
  file_path: src/google/adk/plugins/debug_logging_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Log tool execution completion.
  signature: 'def after_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, result: dict[str, typing.Any]) -> dict[str, Any] | None:'
- rank: 1195
  id: google.adk.plugins.debug_logging_plugin.DebugLoggingPlugin.before_agent_callback
  name: before_agent_callback
  file_path: src/google/adk/plugins/debug_logging_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Log agent execution start.
  signature: 'def before_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> types.Content | None:'
- rank: 1196
  id: google.adk.plugins.debug_logging_plugin.DebugLoggingPlugin.before_model_callback
  name: before_model_callback
  file_path: src/google/adk/plugins/debug_logging_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Log LLM request before sending to model.
  signature: 'def before_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest) -> LlmResponse | None:'
- rank: 1197
  id: google.adk.plugins.debug_logging_plugin.DebugLoggingPlugin.before_run_callback
  name: before_run_callback
  file_path: src/google/adk/plugins/debug_logging_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Initialize debug state for this invocation.
  signature: 'def before_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> types.Content | None:'
- rank: 1198
  id: google.adk.plugins.debug_logging_plugin.DebugLoggingPlugin.before_tool_callback
  name: before_tool_callback
  file_path: src/google/adk/plugins/debug_logging_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Log tool execution start.
  signature: 'def before_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> dict[str, Any] | None:'
- rank: 1199
  id: google.adk.plugins.debug_logging_plugin.DebugLoggingPlugin.on_event_callback
  name: on_event_callback
  file_path: src/google/adk/plugins/debug_logging_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Log events yielded from the runner.
  signature: 'def on_event_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, event: google.adk.events.event.Event) -> Event | None:'
- rank: 1200
  id: google.adk.plugins.debug_logging_plugin.DebugLoggingPlugin.on_model_error_callback
  name: on_model_error_callback
  file_path: src/google/adk/plugins/debug_logging_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Log LLM error.
  signature: 'def on_model_error_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest, error: Exception) -> LlmResponse | None:'
- rank: 1201
  id: google.adk.plugins.debug_logging_plugin.DebugLoggingPlugin.on_tool_error_callback
  name: on_tool_error_callback
  file_path: src/google/adk/plugins/debug_logging_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Log tool error.
  signature: 'def on_tool_error_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, error: Exception) -> dict[str, Any] | None:'
- rank: 1202
  id: google.adk.plugins.debug_logging_plugin.DebugLoggingPlugin.on_user_message_callback
  name: on_user_message_callback
  file_path: src/google/adk/plugins/debug_logging_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Log user message and invocation start.
  signature: 'def on_user_message_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, user_message: google.genai.types.Content) -> types.Content | None:'
- rank: 1203
  id: google.adk.plugins.global_instruction_plugin
  name: global_instruction_plugin
  file_path: src/google/adk/plugins/global_instruction_plugin.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1204
  id: google.adk.plugins.global_instruction_plugin.GlobalInstructionPlugin
  name: GlobalInstructionPlugin
  file_path: src/google/adk/plugins/global_instruction_plugin.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Plugin that provides global instructions functionality at the App level.


    This plugin replaces the deprecated global_instruction field on LlmAgent.

    Global instructions are applied to all agents in the application, providing

    a consistent way to set application-wide instructions, identity, or

    personality.


    The plugin operates through the before_model_callback, allowing it to modify

    LLM requests before they are sent to the model.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, global_instruction: typing.Union[str, google.adk.agents.llm_agent.InstructionProvider], name: str) -> None:'
  methods:
  - signature: 'def before_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
    docstring: "Apply global instructions to the LLM request.\n\nThis callback is executed before each request is sent to the model,\nallowing the plugin to inject global instructions into the request.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_request: The prepared request object to be sent to the model.\n\nReturns:\n  None to allow the LLM request to proceed normally."
  inherited_methods:
    BasePlugin:
    - signature: 'def on_user_message_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, user_message: google.genai.types.Content) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed when a user message is received before an invocation starts.\n\nThis callback helps logging and modifying the user message before the\nrunner starts the invocation.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n  user_message: The message content input by user.\n\nReturns:\n  An optional `types.Content` to be returned to the ADK. Returning a\n  value to replace the user message. Returning `None` to proceed\n  normally."
    - signature: 'def before_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed before the ADK runner runs.\n\nThis is the first callback to be called in the lifecycle, ideal for global\nsetup or initialization tasks.\n\nArgs:\n  invocation_context: The context for the entire invocation, containing\n    session information, the root agent, etc.\n\nReturns:\n  An optional `Event` to be returned to the ADK. Returning a value to\n  halt execution of the runner and ends the runner with that event. Return\n  `None` to proceed normally."
    - signature: 'def on_event_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, event: google.adk.events.event.Event) -> typing.Optional[google.adk.events.event.Event]:'
      docstring: "Callback executed after an event is yielded from runner.\n\nThis is the ideal place to make modification to the event before the event\nis handled by the underlying agent app.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n  event: The event raised by the runner.\n\nReturns:\n  An optional value. A non-`None` return may be used by the framework to\n  modify or replace the response. Returning `None` allows the original\n  response to be used."
    - signature: 'def after_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> None:'
      docstring: "Callback executed after an ADK runner run has completed.\n\nThis is the final callback in the ADK lifecycle, suitable for cleanup, final\nlogging, or reporting tasks.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n\nReturns:\n  None"
    - signature: 'def close(self) -> None:'
      docstring: 'Method executed when the runner is closed.


        This method is used for cleanup tasks such as closing network connections

        or releasing resources.'
    - signature: 'def before_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed before an agent's primary logic is invoked.\n\nThis callback can be used for logging, setup, or to short-circuit the\nagent's execution by returning a value.\n\nArgs:\n  agent: The agent that is about to run.\n  callback_context: The context for the agent invocation.\n\nReturns:\n  An optional `types.Content` object. If a value is returned, it will bypass\n  the agent's callbacks and its execution, and return this value directly.\n  Returning `None` allows the agent to proceed normally."
    - signature: 'def after_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed after an agent's primary logic has completed.\n\nArgs:\n  agent: The agent that has just run.\n  callback_context: The context for the agent invocation.\n\nReturns:\n  An optional `types.Content` object. The content to return to the user.\n  When the content is present, the provided content will be used as agent\n  response and appended to event history as agent response."
    - signature: 'def before_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed before a request is sent to the model.\n\nThis provides an opportunity to inspect, log, or modify the `LlmRequest`\nobject. It can also be used to implement caching by returning a cached\n`LlmResponse`, which would skip the actual model call.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_request: The prepared request object to be sent to the model.\n\nReturns:\n  An optional value. The interpretation of a non-`None` trigger an early\n  exit and returns the response immediately. Returning `None` allows the LLM\n  request to proceed normally."
    - signature: 'def after_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_response: google.adk.models.llm_response.LlmResponse) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed after a response is received from the model.\n\nThis is the ideal place to log model responses, collect metrics on token\nusage, or perform post-processing on the raw `LlmResponse`.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_response: The response object received from the model.\n\nReturns:\n  An optional value. A non-`None` return may be used by the framework to\n  modify or replace the response. Returning `None` allows the original\n  response to be used."
    - signature: 'def on_model_error_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest, error: Exception) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed when a model call encounters an error.\n\nThis callback provides an opportunity to handle model errors gracefully,\npotentially providing alternative responses or recovery mechanisms.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_request: The request that was sent to the model when the error\n    occurred.\n  error: The exception that was raised during model execution.\n\nReturns:\n  An optional LlmResponse. If an LlmResponse is returned, it will be used\n  instead of propagating the error. Returning `None` allows the original\n  error to be raised."
    - signature: 'def before_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Optional[dict]:'
      docstring: "Callback executed before a tool is called.\n\nThis callback is useful for logging tool usage, input validation, or\nmodifying the arguments before they are passed to the tool.\n\nArgs:\n  tool: The tool instance that is about to be executed.\n  tool_args: The dictionary of arguments to be used for invoking the tool.\n  tool_context: The context specific to the tool execution.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will stop the tool\n  execution and return this response immediately. Returning `None` uses the\n  original, unmodified arguments."
    - signature: 'def after_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, result: dict) -> typing.Optional[dict]:'
      docstring: "Callback executed after a tool has been called.\n\nThis callback allows for inspecting, logging, or modifying the result\nreturned by a tool.\n\nArgs:\n  tool: The tool instance that has just been executed.\n  tool_args: The original arguments that were passed to the tool.\n  tool_context: The context specific to the tool execution.\n  result: The dictionary returned by the tool invocation.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will **replace**\n  the original result from the tool. This allows for post-processing or\n  altering tool outputs. Returning `None` uses the original, unmodified\n  result."
    - signature: 'def on_tool_error_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, error: Exception) -> typing.Optional[dict]:'
      docstring: "Callback executed when a tool call encounters an error.\n\nThis callback provides an opportunity to handle tool errors gracefully,\npotentially providing alternative responses or recovery mechanisms.\n\nArgs:\n  tool: The tool instance that encountered an error.\n  tool_args: The arguments that were passed to the tool.\n  tool_context: The context specific to the tool execution.\n  error: The exception that was raised during tool execution.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will be used as\n  the tool response instead of propagating the error. Returning `None`\n  allows the original error to be raised."
  omitted_inherited_members_from:
  - ABC
- rank: 1205
  id: google.adk.plugins.global_instruction_plugin.GlobalInstructionPlugin.__init__
  name: __init__
  file_path: src/google/adk/plugins/global_instruction_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initialize the GlobalInstructionPlugin.\n\nArgs:\n  global_instruction: The instruction to apply globally. Can be a string or\n    an InstructionProvider function that takes ReadonlyContext and returns a\n    string (sync or async).\n  name: The name of the plugin (defaults to \"global_instruction\")."
  signature: 'def __init__(self, global_instruction: typing.Union[str, google.adk.agents.llm_agent.InstructionProvider], name: str) -> None:'
- rank: 1206
  id: google.adk.plugins.global_instruction_plugin.GlobalInstructionPlugin.before_model_callback
  name: before_model_callback
  file_path: src/google/adk/plugins/global_instruction_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Apply global instructions to the LLM request.\n\nThis callback is executed before each request is sent to the model,\nallowing the plugin to inject global instructions into the request.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_request: The prepared request object to be sent to the model.\n\nReturns:\n  None to allow the LLM request to proceed normally."
  signature: 'def before_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
- rank: 1207
  id: google.adk.plugins.logging_plugin
  name: logging_plugin
  file_path: src/google/adk/plugins/logging_plugin.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1208
  id: google.adk.plugins.logging_plugin.LoggingPlugin
  name: LoggingPlugin
  file_path: src/google/adk/plugins/logging_plugin.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "A plugin that logs important information at each callback point.\n\nThis plugin helps print all critical events in the console. It is not a\nreplacement of existing logging in ADK. It rather helps terminal based\ndebugging by showing all logs in the console, and serves as a simple demo for\neveryone to leverage when developing new plugins.\n\nThis plugin helps users track the invocation status by logging:\n- User messages and invocation context\n- Agent execution flow\n- LLM requests and responses\n- Tool calls with arguments and results\n- Events and final responses\n- Errors during model and tool execution\n\nExample:\n    >>> logging_plugin = LoggingPlugin()\n    >>> runner = Runner(\n    ...     agents=[my_agent],\n    ...     # ...\n    ...     plugins=[logging_plugin],\n    ... )\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, name: str):'
  methods:
  - signature: 'def on_user_message_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, user_message: google.genai.types.Content) -> typing.Optional[google.genai.types.Content]:'
    docstring: Log user message and invocation start.
  - signature: 'def before_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.Optional[google.genai.types.Content]:'
    docstring: Log invocation start.
  - signature: 'def on_event_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, event: google.adk.events.event.Event) -> typing.Optional[google.adk.events.event.Event]:'
    docstring: Log events yielded from the runner.
  - signature: 'def after_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.Optional[None]:'
    docstring: Log invocation completion.
  - signature: 'def before_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
    docstring: Log agent execution start.
  - signature: 'def after_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
    docstring: Log agent execution completion.
  - signature: 'def before_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
    docstring: Log LLM request before sending to model.
  - signature: 'def after_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_response: google.adk.models.llm_response.LlmResponse) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
    docstring: Log LLM response after receiving from model.
  - signature: 'def before_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Optional[dict]:'
    docstring: Log tool execution start.
  - signature: 'def after_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, result: dict) -> typing.Optional[dict]:'
    docstring: Log tool execution completion.
  - signature: 'def on_model_error_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest, error: Exception) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
    docstring: Log LLM error.
  - signature: 'def on_tool_error_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, error: Exception) -> typing.Optional[dict]:'
    docstring: Log tool error.
  inherited_methods:
    BasePlugin:
    - signature: 'def on_user_message_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, user_message: google.genai.types.Content) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed when a user message is received before an invocation starts.\n\nThis callback helps logging and modifying the user message before the\nrunner starts the invocation.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n  user_message: The message content input by user.\n\nReturns:\n  An optional `types.Content` to be returned to the ADK. Returning a\n  value to replace the user message. Returning `None` to proceed\n  normally."
    - signature: 'def before_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed before the ADK runner runs.\n\nThis is the first callback to be called in the lifecycle, ideal for global\nsetup or initialization tasks.\n\nArgs:\n  invocation_context: The context for the entire invocation, containing\n    session information, the root agent, etc.\n\nReturns:\n  An optional `Event` to be returned to the ADK. Returning a value to\n  halt execution of the runner and ends the runner with that event. Return\n  `None` to proceed normally."
    - signature: 'def on_event_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, event: google.adk.events.event.Event) -> typing.Optional[google.adk.events.event.Event]:'
      docstring: "Callback executed after an event is yielded from runner.\n\nThis is the ideal place to make modification to the event before the event\nis handled by the underlying agent app.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n  event: The event raised by the runner.\n\nReturns:\n  An optional value. A non-`None` return may be used by the framework to\n  modify or replace the response. Returning `None` allows the original\n  response to be used."
    - signature: 'def after_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> None:'
      docstring: "Callback executed after an ADK runner run has completed.\n\nThis is the final callback in the ADK lifecycle, suitable for cleanup, final\nlogging, or reporting tasks.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n\nReturns:\n  None"
    - signature: 'def close(self) -> None:'
      docstring: 'Method executed when the runner is closed.


        This method is used for cleanup tasks such as closing network connections

        or releasing resources.'
    - signature: 'def before_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed before an agent's primary logic is invoked.\n\nThis callback can be used for logging, setup, or to short-circuit the\nagent's execution by returning a value.\n\nArgs:\n  agent: The agent that is about to run.\n  callback_context: The context for the agent invocation.\n\nReturns:\n  An optional `types.Content` object. If a value is returned, it will bypass\n  the agent's callbacks and its execution, and return this value directly.\n  Returning `None` allows the agent to proceed normally."
    - signature: 'def after_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed after an agent's primary logic has completed.\n\nArgs:\n  agent: The agent that has just run.\n  callback_context: The context for the agent invocation.\n\nReturns:\n  An optional `types.Content` object. The content to return to the user.\n  When the content is present, the provided content will be used as agent\n  response and appended to event history as agent response."
    - signature: 'def before_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed before a request is sent to the model.\n\nThis provides an opportunity to inspect, log, or modify the `LlmRequest`\nobject. It can also be used to implement caching by returning a cached\n`LlmResponse`, which would skip the actual model call.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_request: The prepared request object to be sent to the model.\n\nReturns:\n  An optional value. The interpretation of a non-`None` trigger an early\n  exit and returns the response immediately. Returning `None` allows the LLM\n  request to proceed normally."
    - signature: 'def after_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_response: google.adk.models.llm_response.LlmResponse) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed after a response is received from the model.\n\nThis is the ideal place to log model responses, collect metrics on token\nusage, or perform post-processing on the raw `LlmResponse`.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_response: The response object received from the model.\n\nReturns:\n  An optional value. A non-`None` return may be used by the framework to\n  modify or replace the response. Returning `None` allows the original\n  response to be used."
    - signature: 'def on_model_error_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest, error: Exception) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed when a model call encounters an error.\n\nThis callback provides an opportunity to handle model errors gracefully,\npotentially providing alternative responses or recovery mechanisms.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_request: The request that was sent to the model when the error\n    occurred.\n  error: The exception that was raised during model execution.\n\nReturns:\n  An optional LlmResponse. If an LlmResponse is returned, it will be used\n  instead of propagating the error. Returning `None` allows the original\n  error to be raised."
    - signature: 'def before_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Optional[dict]:'
      docstring: "Callback executed before a tool is called.\n\nThis callback is useful for logging tool usage, input validation, or\nmodifying the arguments before they are passed to the tool.\n\nArgs:\n  tool: The tool instance that is about to be executed.\n  tool_args: The dictionary of arguments to be used for invoking the tool.\n  tool_context: The context specific to the tool execution.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will stop the tool\n  execution and return this response immediately. Returning `None` uses the\n  original, unmodified arguments."
    - signature: 'def after_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, result: dict) -> typing.Optional[dict]:'
      docstring: "Callback executed after a tool has been called.\n\nThis callback allows for inspecting, logging, or modifying the result\nreturned by a tool.\n\nArgs:\n  tool: The tool instance that has just been executed.\n  tool_args: The original arguments that were passed to the tool.\n  tool_context: The context specific to the tool execution.\n  result: The dictionary returned by the tool invocation.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will **replace**\n  the original result from the tool. This allows for post-processing or\n  altering tool outputs. Returning `None` uses the original, unmodified\n  result."
    - signature: 'def on_tool_error_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, error: Exception) -> typing.Optional[dict]:'
      docstring: "Callback executed when a tool call encounters an error.\n\nThis callback provides an opportunity to handle tool errors gracefully,\npotentially providing alternative responses or recovery mechanisms.\n\nArgs:\n  tool: The tool instance that encountered an error.\n  tool_args: The arguments that were passed to the tool.\n  tool_context: The context specific to the tool execution.\n  error: The exception that was raised during tool execution.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will be used as\n  the tool response instead of propagating the error. Returning `None`\n  allows the original error to be raised."
  omitted_inherited_members_from:
  - ABC
- rank: 1209
  id: google.adk.plugins.logging_plugin.LoggingPlugin.__init__
  name: __init__
  file_path: src/google/adk/plugins/logging_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initialize the logging plugin.\n\nArgs:\n  name: The name of the plugin instance."
  signature: 'def __init__(self, name: str):'
- rank: 1210
  id: google.adk.plugins.logging_plugin.LoggingPlugin.after_agent_callback
  name: after_agent_callback
  file_path: src/google/adk/plugins/logging_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Log agent execution completion.
  signature: 'def after_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
- rank: 1211
  id: google.adk.plugins.logging_plugin.LoggingPlugin.after_model_callback
  name: after_model_callback
  file_path: src/google/adk/plugins/logging_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Log LLM response after receiving from model.
  signature: 'def after_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_response: google.adk.models.llm_response.LlmResponse) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
- rank: 1212
  id: google.adk.plugins.logging_plugin.LoggingPlugin.after_run_callback
  name: after_run_callback
  file_path: src/google/adk/plugins/logging_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Log invocation completion.
  signature: 'def after_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.Optional[None]:'
- rank: 1213
  id: google.adk.plugins.logging_plugin.LoggingPlugin.after_tool_callback
  name: after_tool_callback
  file_path: src/google/adk/plugins/logging_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Log tool execution completion.
  signature: 'def after_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, result: dict) -> typing.Optional[dict]:'
- rank: 1214
  id: google.adk.plugins.logging_plugin.LoggingPlugin.before_agent_callback
  name: before_agent_callback
  file_path: src/google/adk/plugins/logging_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Log agent execution start.
  signature: 'def before_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
- rank: 1215
  id: google.adk.plugins.logging_plugin.LoggingPlugin.before_model_callback
  name: before_model_callback
  file_path: src/google/adk/plugins/logging_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Log LLM request before sending to model.
  signature: 'def before_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
- rank: 1216
  id: google.adk.plugins.logging_plugin.LoggingPlugin.before_run_callback
  name: before_run_callback
  file_path: src/google/adk/plugins/logging_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Log invocation start.
  signature: 'def before_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.Optional[google.genai.types.Content]:'
- rank: 1217
  id: google.adk.plugins.logging_plugin.LoggingPlugin.before_tool_callback
  name: before_tool_callback
  file_path: src/google/adk/plugins/logging_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Log tool execution start.
  signature: 'def before_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Optional[dict]:'
- rank: 1218
  id: google.adk.plugins.logging_plugin.LoggingPlugin.on_event_callback
  name: on_event_callback
  file_path: src/google/adk/plugins/logging_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Log events yielded from the runner.
  signature: 'def on_event_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, event: google.adk.events.event.Event) -> typing.Optional[google.adk.events.event.Event]:'
- rank: 1219
  id: google.adk.plugins.logging_plugin.LoggingPlugin.on_model_error_callback
  name: on_model_error_callback
  file_path: src/google/adk/plugins/logging_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Log LLM error.
  signature: 'def on_model_error_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest, error: Exception) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
- rank: 1220
  id: google.adk.plugins.logging_plugin.LoggingPlugin.on_tool_error_callback
  name: on_tool_error_callback
  file_path: src/google/adk/plugins/logging_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Log tool error.
  signature: 'def on_tool_error_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, error: Exception) -> typing.Optional[dict]:'
- rank: 1221
  id: google.adk.plugins.logging_plugin.LoggingPlugin.on_user_message_callback
  name: on_user_message_callback
  file_path: src/google/adk/plugins/logging_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Log user message and invocation start.
  signature: 'def on_user_message_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, user_message: google.genai.types.Content) -> typing.Optional[google.genai.types.Content]:'
- rank: 1222
  id: google.adk.plugins.multimodal_tool_results_plugin
  name: multimodal_tool_results_plugin
  file_path: src/google/adk/plugins/multimodal_tool_results_plugin.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'PARTS_RETURNED_BY_TOOLS_ID: str'
- rank: 1223
  id: google.adk.plugins.multimodal_tool_results_plugin.MultimodalToolResultsPlugin
  name: MultimodalToolResultsPlugin
  file_path: src/google/adk/plugins/multimodal_tool_results_plugin.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A plugin that modifies function tool responses to support returning list of parts directly.


    Should be removed in favor of directly supporting FunctionResponsePart when these

    are supported outside of computer use tool.

    For context see: https://github.com/google/adk-python/issues/3064#issuecomment-3463067459


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, name: str):'
  methods:
  - signature: 'def after_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, result: dict) -> typing.Optional[dict]:'
    docstring: 'Saves parts returned by the tool in ToolContext.


      Later these are passed to LLM''s context as-is.

      No-op if tool doesn''t return list[google.genai.types.Part] or google.genai.types.Part.'
  - signature: 'def before_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
    docstring: Attach saved list[google.genai.types.Part] returned by the tool to llm_request.
  inherited_methods:
    BasePlugin:
    - signature: 'def on_user_message_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, user_message: google.genai.types.Content) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed when a user message is received before an invocation starts.\n\nThis callback helps logging and modifying the user message before the\nrunner starts the invocation.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n  user_message: The message content input by user.\n\nReturns:\n  An optional `types.Content` to be returned to the ADK. Returning a\n  value to replace the user message. Returning `None` to proceed\n  normally."
    - signature: 'def before_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed before the ADK runner runs.\n\nThis is the first callback to be called in the lifecycle, ideal for global\nsetup or initialization tasks.\n\nArgs:\n  invocation_context: The context for the entire invocation, containing\n    session information, the root agent, etc.\n\nReturns:\n  An optional `Event` to be returned to the ADK. Returning a value to\n  halt execution of the runner and ends the runner with that event. Return\n  `None` to proceed normally."
    - signature: 'def on_event_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, event: google.adk.events.event.Event) -> typing.Optional[google.adk.events.event.Event]:'
      docstring: "Callback executed after an event is yielded from runner.\n\nThis is the ideal place to make modification to the event before the event\nis handled by the underlying agent app.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n  event: The event raised by the runner.\n\nReturns:\n  An optional value. A non-`None` return may be used by the framework to\n  modify or replace the response. Returning `None` allows the original\n  response to be used."
    - signature: 'def after_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> None:'
      docstring: "Callback executed after an ADK runner run has completed.\n\nThis is the final callback in the ADK lifecycle, suitable for cleanup, final\nlogging, or reporting tasks.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n\nReturns:\n  None"
    - signature: 'def close(self) -> None:'
      docstring: 'Method executed when the runner is closed.


        This method is used for cleanup tasks such as closing network connections

        or releasing resources.'
    - signature: 'def before_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed before an agent's primary logic is invoked.\n\nThis callback can be used for logging, setup, or to short-circuit the\nagent's execution by returning a value.\n\nArgs:\n  agent: The agent that is about to run.\n  callback_context: The context for the agent invocation.\n\nReturns:\n  An optional `types.Content` object. If a value is returned, it will bypass\n  the agent's callbacks and its execution, and return this value directly.\n  Returning `None` allows the agent to proceed normally."
    - signature: 'def after_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed after an agent's primary logic has completed.\n\nArgs:\n  agent: The agent that has just run.\n  callback_context: The context for the agent invocation.\n\nReturns:\n  An optional `types.Content` object. The content to return to the user.\n  When the content is present, the provided content will be used as agent\n  response and appended to event history as agent response."
    - signature: 'def before_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed before a request is sent to the model.\n\nThis provides an opportunity to inspect, log, or modify the `LlmRequest`\nobject. It can also be used to implement caching by returning a cached\n`LlmResponse`, which would skip the actual model call.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_request: The prepared request object to be sent to the model.\n\nReturns:\n  An optional value. The interpretation of a non-`None` trigger an early\n  exit and returns the response immediately. Returning `None` allows the LLM\n  request to proceed normally."
    - signature: 'def after_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_response: google.adk.models.llm_response.LlmResponse) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed after a response is received from the model.\n\nThis is the ideal place to log model responses, collect metrics on token\nusage, or perform post-processing on the raw `LlmResponse`.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_response: The response object received from the model.\n\nReturns:\n  An optional value. A non-`None` return may be used by the framework to\n  modify or replace the response. Returning `None` allows the original\n  response to be used."
    - signature: 'def on_model_error_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest, error: Exception) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed when a model call encounters an error.\n\nThis callback provides an opportunity to handle model errors gracefully,\npotentially providing alternative responses or recovery mechanisms.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_request: The request that was sent to the model when the error\n    occurred.\n  error: The exception that was raised during model execution.\n\nReturns:\n  An optional LlmResponse. If an LlmResponse is returned, it will be used\n  instead of propagating the error. Returning `None` allows the original\n  error to be raised."
    - signature: 'def before_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Optional[dict]:'
      docstring: "Callback executed before a tool is called.\n\nThis callback is useful for logging tool usage, input validation, or\nmodifying the arguments before they are passed to the tool.\n\nArgs:\n  tool: The tool instance that is about to be executed.\n  tool_args: The dictionary of arguments to be used for invoking the tool.\n  tool_context: The context specific to the tool execution.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will stop the tool\n  execution and return this response immediately. Returning `None` uses the\n  original, unmodified arguments."
    - signature: 'def after_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, result: dict) -> typing.Optional[dict]:'
      docstring: "Callback executed after a tool has been called.\n\nThis callback allows for inspecting, logging, or modifying the result\nreturned by a tool.\n\nArgs:\n  tool: The tool instance that has just been executed.\n  tool_args: The original arguments that were passed to the tool.\n  tool_context: The context specific to the tool execution.\n  result: The dictionary returned by the tool invocation.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will **replace**\n  the original result from the tool. This allows for post-processing or\n  altering tool outputs. Returning `None` uses the original, unmodified\n  result."
    - signature: 'def on_tool_error_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, error: Exception) -> typing.Optional[dict]:'
      docstring: "Callback executed when a tool call encounters an error.\n\nThis callback provides an opportunity to handle tool errors gracefully,\npotentially providing alternative responses or recovery mechanisms.\n\nArgs:\n  tool: The tool instance that encountered an error.\n  tool_args: The arguments that were passed to the tool.\n  tool_context: The context specific to the tool execution.\n  error: The exception that was raised during tool execution.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will be used as\n  the tool response instead of propagating the error. Returning `None`\n  allows the original error to be raised."
  omitted_inherited_members_from:
  - ABC
- rank: 1224
  id: google.adk.plugins.multimodal_tool_results_plugin.MultimodalToolResultsPlugin.__init__
  name: __init__
  file_path: src/google/adk/plugins/multimodal_tool_results_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initialize the multimodal tool results plugin.\n\nArgs:\n  name: The name of the plugin instance."
  signature: 'def __init__(self, name: str):'
- rank: 1225
  id: google.adk.plugins.multimodal_tool_results_plugin.MultimodalToolResultsPlugin.after_tool_callback
  name: after_tool_callback
  file_path: src/google/adk/plugins/multimodal_tool_results_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Saves parts returned by the tool in ToolContext.


    Later these are passed to LLM''s context as-is.

    No-op if tool doesn''t return list[google.genai.types.Part] or google.genai.types.Part.'
  signature: 'def after_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, result: dict) -> typing.Optional[dict]:'
- rank: 1226
  id: google.adk.plugins.multimodal_tool_results_plugin.MultimodalToolResultsPlugin.before_model_callback
  name: before_model_callback
  file_path: src/google/adk/plugins/multimodal_tool_results_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Attach saved list[google.genai.types.Part] returned by the tool to llm_request.
  signature: 'def before_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
- rank: 1227
  id: google.adk.plugins.plugin_manager
  name: plugin_manager
  file_path: src/google/adk/plugins/plugin_manager.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'PluginCallbackName: Any'
  - signature: 'logger: logging.getLogger'
- rank: 1228
  id: google.adk.plugins.plugin_manager.PluginManager
  name: PluginManager
  file_path: src/google/adk/plugins/plugin_manager.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Manages the registration and execution of plugins.


    The PluginManager is an internal class that orchestrates the invocation of

    plugin callbacks at key points in the SDK''s execution lifecycle. It maintains

    a list of registered plugins and ensures they are called in the order they

    were registered.


    The core execution logic implements an "early exit" strategy: if any plugin

    callback returns a non-`None` value, the execution of subsequent plugins for

    that specific event is halted, and the returned value is propagated up the

    call stack. This allows plugins to short-circuit operations like agent runs,

    tool calls, or model requests.'
  constructor_signature: 'def __init__(self, plugins: typing.Optional[typing.List[google.adk.plugins.base_plugin.BasePlugin]], close_timeout: float):'
  methods:
  - signature: 'def register_plugin(self, plugin: google.adk.plugins.base_plugin.BasePlugin) -> None:'
    docstring: "Registers a new plugin.\n\nArgs:\n  plugin: The plugin instance to register.\n\nRaises:\n  ValueError: If a plugin with the same name is already registered."
  - signature: 'def get_plugin(self, plugin_name: str) -> typing.Optional[google.adk.plugins.base_plugin.BasePlugin]:'
    docstring: "Retrieves a registered plugin by its name.\n\nArgs:\n  plugin_name: The name of the plugin to retrieve.\n\nReturns:\n  The plugin instance if found; otherwise, `None`."
  - signature: 'def run_on_user_message_callback(self, *, user_message: google.genai.types.Content, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.Optional[google.genai.types.Content]:'
    docstring: Runs the `on_user_message_callback` for all plugins.
  - signature: 'def run_before_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.Optional[google.genai.types.Content]:'
    docstring: Runs the `before_run_callback` for all plugins.
  - signature: 'def run_after_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.Optional[None]:'
    docstring: Runs the `after_run_callback` for all plugins.
  - signature: 'def run_on_event_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, event: google.adk.events.event.Event) -> typing.Optional[google.adk.events.event.Event]:'
    docstring: Runs the `on_event_callback` for all plugins.
  - signature: 'def run_before_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
    docstring: Runs the `before_agent_callback` for all plugins.
  - signature: 'def run_after_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
    docstring: Runs the `after_agent_callback` for all plugins.
  - signature: 'def run_before_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Optional[dict]:'
    docstring: Runs the `before_tool_callback` for all plugins.
  - signature: 'def run_after_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, result: dict) -> typing.Optional[dict]:'
    docstring: Runs the `after_tool_callback` for all plugins.
  - signature: 'def run_on_model_error_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest, error: Exception) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
    docstring: Runs the `on_model_error_callback` for all plugins.
  - signature: 'def run_before_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
    docstring: Runs the `before_model_callback` for all plugins.
  - signature: 'def run_after_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_response: google.adk.models.llm_response.LlmResponse) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
    docstring: Runs the `after_model_callback` for all plugins.
  - signature: 'def run_on_tool_error_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, error: Exception) -> typing.Optional[dict]:'
    docstring: Runs the `on_tool_error_callback` for all plugins.
  - signature: 'def close(self) -> None:'
    docstring: "Calls the close method on all registered plugins concurrently.\n\nRaises:\n  RuntimeError: If one or more plugins failed to close, containing\n    details of all failures."
- rank: 1229
  id: google.adk.plugins.plugin_manager.PluginManager.__init__
  name: __init__
  file_path: src/google/adk/plugins/plugin_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the plugin service.\n\nArgs:\n  plugins: An optional list of plugins to register upon initialization.\n  close_timeout: The timeout in seconds for each plugin's close method."
  signature: 'def __init__(self, plugins: typing.Optional[typing.List[google.adk.plugins.base_plugin.BasePlugin]], close_timeout: float):'
- rank: 1230
  id: google.adk.plugins.plugin_manager.PluginManager.close
  name: close
  file_path: src/google/adk/plugins/plugin_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Calls the close method on all registered plugins concurrently.\n\nRaises:\n  RuntimeError: If one or more plugins failed to close, containing\n    details of all failures."
  signature: 'def close(self) -> None:'
- rank: 1231
  id: google.adk.plugins.plugin_manager.PluginManager.get_plugin
  name: get_plugin
  file_path: src/google/adk/plugins/plugin_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Retrieves a registered plugin by its name.\n\nArgs:\n  plugin_name: The name of the plugin to retrieve.\n\nReturns:\n  The plugin instance if found; otherwise, `None`."
  signature: 'def get_plugin(self, plugin_name: str) -> typing.Optional[google.adk.plugins.base_plugin.BasePlugin]:'
- rank: 1232
  id: google.adk.plugins.plugin_manager.PluginManager.register_plugin
  name: register_plugin
  file_path: src/google/adk/plugins/plugin_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Registers a new plugin.\n\nArgs:\n  plugin: The plugin instance to register.\n\nRaises:\n  ValueError: If a plugin with the same name is already registered."
  signature: 'def register_plugin(self, plugin: google.adk.plugins.base_plugin.BasePlugin) -> None:'
- rank: 1233
  id: google.adk.plugins.plugin_manager.PluginManager.run_after_agent_callback
  name: run_after_agent_callback
  file_path: src/google/adk/plugins/plugin_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Runs the `after_agent_callback` for all plugins.
  signature: 'def run_after_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
- rank: 1234
  id: google.adk.plugins.plugin_manager.PluginManager.run_after_model_callback
  name: run_after_model_callback
  file_path: src/google/adk/plugins/plugin_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Runs the `after_model_callback` for all plugins.
  signature: 'def run_after_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_response: google.adk.models.llm_response.LlmResponse) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
- rank: 1235
  id: google.adk.plugins.plugin_manager.PluginManager.run_after_run_callback
  name: run_after_run_callback
  file_path: src/google/adk/plugins/plugin_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Runs the `after_run_callback` for all plugins.
  signature: 'def run_after_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.Optional[None]:'
- rank: 1236
  id: google.adk.plugins.plugin_manager.PluginManager.run_after_tool_callback
  name: run_after_tool_callback
  file_path: src/google/adk/plugins/plugin_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Runs the `after_tool_callback` for all plugins.
  signature: 'def run_after_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, result: dict) -> typing.Optional[dict]:'
- rank: 1237
  id: google.adk.plugins.plugin_manager.PluginManager.run_before_agent_callback
  name: run_before_agent_callback
  file_path: src/google/adk/plugins/plugin_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Runs the `before_agent_callback` for all plugins.
  signature: 'def run_before_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
- rank: 1238
  id: google.adk.plugins.plugin_manager.PluginManager.run_before_model_callback
  name: run_before_model_callback
  file_path: src/google/adk/plugins/plugin_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Runs the `before_model_callback` for all plugins.
  signature: 'def run_before_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
- rank: 1239
  id: google.adk.plugins.plugin_manager.PluginManager.run_before_run_callback
  name: run_before_run_callback
  file_path: src/google/adk/plugins/plugin_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Runs the `before_run_callback` for all plugins.
  signature: 'def run_before_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.Optional[google.genai.types.Content]:'
- rank: 1240
  id: google.adk.plugins.plugin_manager.PluginManager.run_before_tool_callback
  name: run_before_tool_callback
  file_path: src/google/adk/plugins/plugin_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Runs the `before_tool_callback` for all plugins.
  signature: 'def run_before_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Optional[dict]:'
- rank: 1241
  id: google.adk.plugins.plugin_manager.PluginManager.run_on_event_callback
  name: run_on_event_callback
  file_path: src/google/adk/plugins/plugin_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Runs the `on_event_callback` for all plugins.
  signature: 'def run_on_event_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, event: google.adk.events.event.Event) -> typing.Optional[google.adk.events.event.Event]:'
- rank: 1242
  id: google.adk.plugins.plugin_manager.PluginManager.run_on_model_error_callback
  name: run_on_model_error_callback
  file_path: src/google/adk/plugins/plugin_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Runs the `on_model_error_callback` for all plugins.
  signature: 'def run_on_model_error_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest, error: Exception) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
- rank: 1243
  id: google.adk.plugins.plugin_manager.PluginManager.run_on_tool_error_callback
  name: run_on_tool_error_callback
  file_path: src/google/adk/plugins/plugin_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Runs the `on_tool_error_callback` for all plugins.
  signature: 'def run_on_tool_error_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, error: Exception) -> typing.Optional[dict]:'
- rank: 1244
  id: google.adk.plugins.plugin_manager.PluginManager.run_on_user_message_callback
  name: run_on_user_message_callback
  file_path: src/google/adk/plugins/plugin_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Runs the `on_user_message_callback` for all plugins.
  signature: 'def run_on_user_message_callback(self, *, user_message: google.genai.types.Content, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.Optional[google.genai.types.Content]:'
- rank: 1245
  id: google.adk.plugins.reflect_retry_tool_plugin
  name: reflect_retry_tool_plugin
  file_path: src/google/adk/plugins/reflect_retry_tool_plugin.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'REFLECT_AND_RETRY_RESPONSE_TYPE: str'
  - signature: 'GLOBAL_SCOPE_KEY: str'
  - signature: 'PerToolFailuresCounter: Any'
- rank: 1246
  id: google.adk.plugins.reflect_retry_tool_plugin.ReflectAndRetryToolPlugin
  name: ReflectAndRetryToolPlugin
  file_path: src/google/adk/plugins/reflect_retry_tool_plugin.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "Provides self-healing, concurrent-safe error recovery for tool failures.\n\nThis plugin intercepts tool failures, provides structured guidance to the LLM\nfor reflection and correction, and retries the operation up to a configurable\nlimit.\n\n**Key Features:**\n\n- **Concurrency Safe:** Uses locking to safely handle parallel tool\nexecutions\n- **Configurable Scope:** Tracks failures per-invocation (default) or globally\n  using the `TrackingScope` enum.\n- **Extensible Scoping:** The `_get_scope_key` method can be overridden to\n  implement custom tracking logic (e.g., per-user or per-session).\n- **Granular Tracking:** Failure counts are tracked per-tool within the\n  defined scope. A success with one tool resets its counter without affecting\n  others.\n- **Custom Error Extraction:** Supports detecting errors in normal tool\nresponses\nthat\n  don't throw exceptions, by overriding the `extract_error_from_result`\n  method.\n\n**Example:**\n```python\nfrom my_project.plugins\
    \ import ReflectAndRetryToolPlugin, TrackingScope\n\n# Example 1: (MOST COMMON USAGE):\n# Track failures only within the current agent invocation (default).\nerror_handling_plugin = ReflectAndRetryToolPlugin(max_retries=3)\n\n# Example 2:\n# Track failures globally across all turns and users.\nglobal_error_handling_plugin = ReflectAndRetryToolPlugin(max_retries=5,\nscope=TrackingScope.GLOBAL)\n\n# Example 3:\n# Retry on failures but do not throw exceptions.\nerror_handling_plugin =\n  ReflectAndRetryToolPlugin(max_retries=3,\n  throw_exception_if_retry_exceeded=False)\n\n# Example 4:\n# Track failures in successful tool responses that contain errors.\nclass CustomRetryPlugin(ReflectAndRetryToolPlugin):\n  async def extract_error_from_result(self, *, tool, tool_args,tool_context,\n  result):\n    # Detect error based on response content\n    if result.get('status') == 'error':\n        return result\n    return None  # No error detected\nerror_handling_plugin = CustomRetryPlugin(max_retries=5)\n\
    ```\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, name: str, max_retries: int, throw_exception_if_retry_exceeded: bool, tracking_scope: google.adk.plugins.reflect_retry_tool_plugin.TrackingScope):'
  aliases:
  - google.adk.plugins.ReflectAndRetryToolPlugin
  methods:
  - signature: 'def after_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, result: typing.Any) -> typing.Optional[dict[str, typing.Any]]:'
    docstring: "Handles successful tool calls or extracts and processes errors.\n\nArgs:\n  tool: The tool that was called.\n  tool_args: The arguments passed to the tool.\n  tool_context: The context of the tool call.\n  result: The result of the tool call.\n\nReturns:\n  An optional dictionary containing reflection guidance if an error is\n  detected, or None if the tool call was successful or the\n  response is already a reflection message."
  - signature: 'def extract_error_from_result(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, result: typing.Any) -> typing.Optional[dict[str, typing.Any]]:'
    docstring: "Extracts an error from a successful tool result and triggers retry logic.\n\nThis is useful when tool call finishes successfully but the result contains\nan error object like {\"error\": ...} that should be handled by the plugin.\n\nBy overriding this method, you can trigger retry logic on these successful\nresults that contain errors.\n\nArgs:\n  tool: The tool that was called.\n  tool_args: The arguments passed to the tool.\n  tool_context: The context of the tool call.\n  result: The result of the tool call.\n\nReturns:\n  The extracted error if any, or None if no error was detected."
  - signature: 'def on_tool_error_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, error: Exception) -> typing.Optional[dict[str, typing.Any]]:'
    docstring: "Handles tool exceptions by providing reflection guidance.\n\nArgs:\n  tool: The tool that was called.\n  tool_args: The arguments passed to the tool.\n  tool_context: The context of the tool call.\n  error: The exception raised by the tool.\n\nReturns:\n  An optional dictionary containing reflection guidance for the error."
  inherited_methods:
    BasePlugin:
    - signature: 'def on_user_message_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, user_message: google.genai.types.Content) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed when a user message is received before an invocation starts.\n\nThis callback helps logging and modifying the user message before the\nrunner starts the invocation.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n  user_message: The message content input by user.\n\nReturns:\n  An optional `types.Content` to be returned to the ADK. Returning a\n  value to replace the user message. Returning `None` to proceed\n  normally."
    - signature: 'def before_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed before the ADK runner runs.\n\nThis is the first callback to be called in the lifecycle, ideal for global\nsetup or initialization tasks.\n\nArgs:\n  invocation_context: The context for the entire invocation, containing\n    session information, the root agent, etc.\n\nReturns:\n  An optional `Event` to be returned to the ADK. Returning a value to\n  halt execution of the runner and ends the runner with that event. Return\n  `None` to proceed normally."
    - signature: 'def on_event_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, event: google.adk.events.event.Event) -> typing.Optional[google.adk.events.event.Event]:'
      docstring: "Callback executed after an event is yielded from runner.\n\nThis is the ideal place to make modification to the event before the event\nis handled by the underlying agent app.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n  event: The event raised by the runner.\n\nReturns:\n  An optional value. A non-`None` return may be used by the framework to\n  modify or replace the response. Returning `None` allows the original\n  response to be used."
    - signature: 'def after_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> None:'
      docstring: "Callback executed after an ADK runner run has completed.\n\nThis is the final callback in the ADK lifecycle, suitable for cleanup, final\nlogging, or reporting tasks.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n\nReturns:\n  None"
    - signature: 'def close(self) -> None:'
      docstring: 'Method executed when the runner is closed.


        This method is used for cleanup tasks such as closing network connections

        or releasing resources.'
    - signature: 'def before_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed before an agent's primary logic is invoked.\n\nThis callback can be used for logging, setup, or to short-circuit the\nagent's execution by returning a value.\n\nArgs:\n  agent: The agent that is about to run.\n  callback_context: The context for the agent invocation.\n\nReturns:\n  An optional `types.Content` object. If a value is returned, it will bypass\n  the agent's callbacks and its execution, and return this value directly.\n  Returning `None` allows the agent to proceed normally."
    - signature: 'def after_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed after an agent's primary logic has completed.\n\nArgs:\n  agent: The agent that has just run.\n  callback_context: The context for the agent invocation.\n\nReturns:\n  An optional `types.Content` object. The content to return to the user.\n  When the content is present, the provided content will be used as agent\n  response and appended to event history as agent response."
    - signature: 'def before_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed before a request is sent to the model.\n\nThis provides an opportunity to inspect, log, or modify the `LlmRequest`\nobject. It can also be used to implement caching by returning a cached\n`LlmResponse`, which would skip the actual model call.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_request: The prepared request object to be sent to the model.\n\nReturns:\n  An optional value. The interpretation of a non-`None` trigger an early\n  exit and returns the response immediately. Returning `None` allows the LLM\n  request to proceed normally."
    - signature: 'def after_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_response: google.adk.models.llm_response.LlmResponse) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed after a response is received from the model.\n\nThis is the ideal place to log model responses, collect metrics on token\nusage, or perform post-processing on the raw `LlmResponse`.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_response: The response object received from the model.\n\nReturns:\n  An optional value. A non-`None` return may be used by the framework to\n  modify or replace the response. Returning `None` allows the original\n  response to be used."
    - signature: 'def on_model_error_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest, error: Exception) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed when a model call encounters an error.\n\nThis callback provides an opportunity to handle model errors gracefully,\npotentially providing alternative responses or recovery mechanisms.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_request: The request that was sent to the model when the error\n    occurred.\n  error: The exception that was raised during model execution.\n\nReturns:\n  An optional LlmResponse. If an LlmResponse is returned, it will be used\n  instead of propagating the error. Returning `None` allows the original\n  error to be raised."
    - signature: 'def before_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Optional[dict]:'
      docstring: "Callback executed before a tool is called.\n\nThis callback is useful for logging tool usage, input validation, or\nmodifying the arguments before they are passed to the tool.\n\nArgs:\n  tool: The tool instance that is about to be executed.\n  tool_args: The dictionary of arguments to be used for invoking the tool.\n  tool_context: The context specific to the tool execution.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will stop the tool\n  execution and return this response immediately. Returning `None` uses the\n  original, unmodified arguments."
    - signature: 'def after_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, result: dict) -> typing.Optional[dict]:'
      docstring: "Callback executed after a tool has been called.\n\nThis callback allows for inspecting, logging, or modifying the result\nreturned by a tool.\n\nArgs:\n  tool: The tool instance that has just been executed.\n  tool_args: The original arguments that were passed to the tool.\n  tool_context: The context specific to the tool execution.\n  result: The dictionary returned by the tool invocation.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will **replace**\n  the original result from the tool. This allows for post-processing or\n  altering tool outputs. Returning `None` uses the original, unmodified\n  result."
    - signature: 'def on_tool_error_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, error: Exception) -> typing.Optional[dict]:'
      docstring: "Callback executed when a tool call encounters an error.\n\nThis callback provides an opportunity to handle tool errors gracefully,\npotentially providing alternative responses or recovery mechanisms.\n\nArgs:\n  tool: The tool instance that encountered an error.\n  tool_args: The arguments that were passed to the tool.\n  tool_context: The context specific to the tool execution.\n  error: The exception that was raised during tool execution.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will be used as\n  the tool response instead of propagating the error. Returning `None`\n  allows the original error to be raised."
  omitted_inherited_members_from:
  - ABC
- rank: 1247
  id: google.adk.plugins.reflect_retry_tool_plugin.ReflectAndRetryToolPlugin.__init__
  name: __init__
  file_path: src/google/adk/plugins/reflect_retry_tool_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the ReflectAndRetryToolPlugin.\n\nArgs:\n    name: Plugin instance identifier.\n    max_retries: Maximum consecutive failures before giving up (0 = no\n      retries).\n    throw_exception_if_retry_exceeded: If True, raises the final exception\n      when the retry limit is reached. If False, returns guidance instead.\n    tracking_scope: Determines the lifecycle of the error tracking state.\n      Defaults to `TrackingScope.INVOCATION` tracking per-invocation."
  signature: 'def __init__(self, name: str, max_retries: int, throw_exception_if_retry_exceeded: bool, tracking_scope: google.adk.plugins.reflect_retry_tool_plugin.TrackingScope):'
- rank: 1248
  id: google.adk.plugins.reflect_retry_tool_plugin.ReflectAndRetryToolPlugin.after_tool_callback
  name: after_tool_callback
  file_path: src/google/adk/plugins/reflect_retry_tool_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Handles successful tool calls or extracts and processes errors.\n\nArgs:\n  tool: The tool that was called.\n  tool_args: The arguments passed to the tool.\n  tool_context: The context of the tool call.\n  result: The result of the tool call.\n\nReturns:\n  An optional dictionary containing reflection guidance if an error is\n  detected, or None if the tool call was successful or the\n  response is already a reflection message."
  signature: 'def after_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, result: typing.Any) -> typing.Optional[dict[str, typing.Any]]:'
- rank: 1249
  id: google.adk.plugins.reflect_retry_tool_plugin.ReflectAndRetryToolPlugin.extract_error_from_result
  name: extract_error_from_result
  file_path: src/google/adk/plugins/reflect_retry_tool_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Extracts an error from a successful tool result and triggers retry logic.\n\nThis is useful when tool call finishes successfully but the result contains\nan error object like {\"error\": ...} that should be handled by the plugin.\n\nBy overriding this method, you can trigger retry logic on these successful\nresults that contain errors.\n\nArgs:\n  tool: The tool that was called.\n  tool_args: The arguments passed to the tool.\n  tool_context: The context of the tool call.\n  result: The result of the tool call.\n\nReturns:\n  The extracted error if any, or None if no error was detected."
  signature: 'def extract_error_from_result(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, result: typing.Any) -> typing.Optional[dict[str, typing.Any]]:'
- rank: 1250
  id: google.adk.plugins.reflect_retry_tool_plugin.ReflectAndRetryToolPlugin.on_tool_error_callback
  name: on_tool_error_callback
  file_path: src/google/adk/plugins/reflect_retry_tool_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Handles tool exceptions by providing reflection guidance.\n\nArgs:\n  tool: The tool that was called.\n  tool_args: The arguments passed to the tool.\n  tool_context: The context of the tool call.\n  error: The exception raised by the tool.\n\nReturns:\n  An optional dictionary containing reflection guidance for the error."
  signature: 'def on_tool_error_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, error: Exception) -> typing.Optional[dict[str, typing.Any]]:'
- rank: 1251
  id: google.adk.plugins.reflect_retry_tool_plugin.ToolFailureResponse
  name: ToolFailureResponse
  file_path: src/google/adk/plugins/reflect_retry_tool_plugin.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Response containing tool failure details and retry guidance.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, response_type: str = REFLECT_AND_RETRY_RESPONSE_TYPE, error_type: str = '''', error_details: str = '''', retry_count: int = 0, reflection_guidance: str = ''''):'
  properties:
  - signature: 'response_type: str'
  - signature: 'error_type: str'
  - signature: 'error_details: str'
  - signature: 'retry_count: int'
  - signature: 'reflection_guidance: str'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1252
  id: google.adk.plugins.reflect_retry_tool_plugin.TrackingScope
  name: TrackingScope
  file_path: src/google/adk/plugins/reflect_retry_tool_plugin.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Defines the lifecycle scope for tracking tool failure counts.


    [Note: Inherited members from Enum are omitted.]'
  properties:
  - signature: 'INVOCATION: str'
  - signature: 'GLOBAL: str'
  omitted_inherited_members_from:
  - Enum
- rank: 1253
  id: google.adk.plugins.save_files_as_artifacts_plugin
  name: save_files_as_artifacts_plugin
  file_path: src/google/adk/plugins/save_files_as_artifacts_plugin.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '_MODEL_ACCESSIBLE_URI_SCHEMES: Any'
- rank: 1254
  id: google.adk.plugins.save_files_as_artifacts_plugin.SaveFilesAsArtifactsPlugin
  name: SaveFilesAsArtifactsPlugin
  file_path: src/google/adk/plugins/save_files_as_artifacts_plugin.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A plugin that saves files embedded in user messages as artifacts.


    This is useful to allow users to upload files in the chat experience and have

    those files available to the agent within the current session.


    We use Blob.display_name to determine the file name. By default, artifacts are

    session-scoped. For cross-session persistence, prefix the filename with

    "user:".

    Artifacts with the same name will be overwritten. A placeholder with the

    artifact name will be put in place of the embedded file in the user message

    so the model knows where to find the file. You may want to add load_artifacts

    tool to the agent, or load the artifacts in your own tool to use the files.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, name: str):'
  methods:
  - signature: 'def on_user_message_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, user_message: google.genai.types.Content) -> typing.Optional[google.genai.types.Content]:'
    docstring: Process user message and save any attached files as artifacts.
  inherited_methods:
    BasePlugin:
    - signature: 'def on_user_message_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, user_message: google.genai.types.Content) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed when a user message is received before an invocation starts.\n\nThis callback helps logging and modifying the user message before the\nrunner starts the invocation.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n  user_message: The message content input by user.\n\nReturns:\n  An optional `types.Content` to be returned to the ADK. Returning a\n  value to replace the user message. Returning `None` to proceed\n  normally."
    - signature: 'def before_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed before the ADK runner runs.\n\nThis is the first callback to be called in the lifecycle, ideal for global\nsetup or initialization tasks.\n\nArgs:\n  invocation_context: The context for the entire invocation, containing\n    session information, the root agent, etc.\n\nReturns:\n  An optional `Event` to be returned to the ADK. Returning a value to\n  halt execution of the runner and ends the runner with that event. Return\n  `None` to proceed normally."
    - signature: 'def on_event_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, event: google.adk.events.event.Event) -> typing.Optional[google.adk.events.event.Event]:'
      docstring: "Callback executed after an event is yielded from runner.\n\nThis is the ideal place to make modification to the event before the event\nis handled by the underlying agent app.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n  event: The event raised by the runner.\n\nReturns:\n  An optional value. A non-`None` return may be used by the framework to\n  modify or replace the response. Returning `None` allows the original\n  response to be used."
    - signature: 'def after_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> None:'
      docstring: "Callback executed after an ADK runner run has completed.\n\nThis is the final callback in the ADK lifecycle, suitable for cleanup, final\nlogging, or reporting tasks.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n\nReturns:\n  None"
    - signature: 'def close(self) -> None:'
      docstring: 'Method executed when the runner is closed.


        This method is used for cleanup tasks such as closing network connections

        or releasing resources.'
    - signature: 'def before_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed before an agent's primary logic is invoked.\n\nThis callback can be used for logging, setup, or to short-circuit the\nagent's execution by returning a value.\n\nArgs:\n  agent: The agent that is about to run.\n  callback_context: The context for the agent invocation.\n\nReturns:\n  An optional `types.Content` object. If a value is returned, it will bypass\n  the agent's callbacks and its execution, and return this value directly.\n  Returning `None` allows the agent to proceed normally."
    - signature: 'def after_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed after an agent's primary logic has completed.\n\nArgs:\n  agent: The agent that has just run.\n  callback_context: The context for the agent invocation.\n\nReturns:\n  An optional `types.Content` object. The content to return to the user.\n  When the content is present, the provided content will be used as agent\n  response and appended to event history as agent response."
    - signature: 'def before_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed before a request is sent to the model.\n\nThis provides an opportunity to inspect, log, or modify the `LlmRequest`\nobject. It can also be used to implement caching by returning a cached\n`LlmResponse`, which would skip the actual model call.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_request: The prepared request object to be sent to the model.\n\nReturns:\n  An optional value. The interpretation of a non-`None` trigger an early\n  exit and returns the response immediately. Returning `None` allows the LLM\n  request to proceed normally."
    - signature: 'def after_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_response: google.adk.models.llm_response.LlmResponse) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed after a response is received from the model.\n\nThis is the ideal place to log model responses, collect metrics on token\nusage, or perform post-processing on the raw `LlmResponse`.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_response: The response object received from the model.\n\nReturns:\n  An optional value. A non-`None` return may be used by the framework to\n  modify or replace the response. Returning `None` allows the original\n  response to be used."
    - signature: 'def on_model_error_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest, error: Exception) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed when a model call encounters an error.\n\nThis callback provides an opportunity to handle model errors gracefully,\npotentially providing alternative responses or recovery mechanisms.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_request: The request that was sent to the model when the error\n    occurred.\n  error: The exception that was raised during model execution.\n\nReturns:\n  An optional LlmResponse. If an LlmResponse is returned, it will be used\n  instead of propagating the error. Returning `None` allows the original\n  error to be raised."
    - signature: 'def before_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Optional[dict]:'
      docstring: "Callback executed before a tool is called.\n\nThis callback is useful for logging tool usage, input validation, or\nmodifying the arguments before they are passed to the tool.\n\nArgs:\n  tool: The tool instance that is about to be executed.\n  tool_args: The dictionary of arguments to be used for invoking the tool.\n  tool_context: The context specific to the tool execution.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will stop the tool\n  execution and return this response immediately. Returning `None` uses the\n  original, unmodified arguments."
    - signature: 'def after_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, result: dict) -> typing.Optional[dict]:'
      docstring: "Callback executed after a tool has been called.\n\nThis callback allows for inspecting, logging, or modifying the result\nreturned by a tool.\n\nArgs:\n  tool: The tool instance that has just been executed.\n  tool_args: The original arguments that were passed to the tool.\n  tool_context: The context specific to the tool execution.\n  result: The dictionary returned by the tool invocation.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will **replace**\n  the original result from the tool. This allows for post-processing or\n  altering tool outputs. Returning `None` uses the original, unmodified\n  result."
    - signature: 'def on_tool_error_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, error: Exception) -> typing.Optional[dict]:'
      docstring: "Callback executed when a tool call encounters an error.\n\nThis callback provides an opportunity to handle tool errors gracefully,\npotentially providing alternative responses or recovery mechanisms.\n\nArgs:\n  tool: The tool instance that encountered an error.\n  tool_args: The arguments that were passed to the tool.\n  tool_context: The context specific to the tool execution.\n  error: The exception that was raised during tool execution.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will be used as\n  the tool response instead of propagating the error. Returning `None`\n  allows the original error to be raised."
  omitted_inherited_members_from:
  - ABC
- rank: 1255
  id: google.adk.plugins.save_files_as_artifacts_plugin.SaveFilesAsArtifactsPlugin.__init__
  name: __init__
  file_path: src/google/adk/plugins/save_files_as_artifacts_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initialize the save files as artifacts plugin.\n\nArgs:\n  name: The name of the plugin instance."
  signature: 'def __init__(self, name: str):'
- rank: 1256
  id: google.adk.plugins.save_files_as_artifacts_plugin.SaveFilesAsArtifactsPlugin.on_user_message_callback
  name: on_user_message_callback
  file_path: src/google/adk/plugins/save_files_as_artifacts_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Process user message and save any attached files as artifacts.
  signature: 'def on_user_message_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, user_message: google.genai.types.Content) -> typing.Optional[google.genai.types.Content]:'
- rank: 1257
  id: google.adk.runners
  name: runners
  file_path: src/google/adk/runners.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 1258
  id: google.adk.runners.InMemoryRunner.__init__
  name: __init__
  file_path: src/google/adk/runners.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the InMemoryRunner.\n\nArgs:\n    agent: The root agent to run.\n    app_name: The application name of the runner. Defaults to\n      'InMemoryRunner'.\n    plugins: Optional list of plugins for the runner.\n    app: Optional App instance.\n    plugin_close_timeout: The timeout in seconds for plugin close methods."
  signature: 'def __init__(self, agent: typing.Optional[google.adk.agents.base_agent.BaseAgent], *, app_name: typing.Optional[str]=None, plugins: typing.Optional[list[google.adk.plugins.base_plugin.BasePlugin]]=None, app: typing.Optional[google.adk.apps.app.App]=None, plugin_close_timeout: float=5.0):'
- rank: 1259
  id: google.adk.runners.Runner.__init__
  name: __init__
  file_path: src/google/adk/runners.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the Runner.\n\nDevelopers should provide either an `app` instance or both `app_name` and\n`agent`. When `app` is provided, `app_name` can optionally override the\napp's name (useful for deployment scenarios like Agent Engine where the\nresource name differs from the app's identifier). However, `agent` should\nnot be provided when `app` is provided. Providing `app` is the recommended\nway to create a runner.\n\nArgs:\n    app: An optional `App` instance. If provided, `agent` should not be\n      specified. `app_name` can optionally override `app.name`.\n    app_name: The application name of the runner. Required if `app` is not\n      provided. If `app` is provided, this can optionally override `app.name`\n      (e.g., for deployment scenarios where a resource name differs from the\n      app identifier).\n    agent: The root agent to run. Required if `app` is not provided. Should\n      not be provided when `app` is provided.\n    plugins: Deprecated. A list of plugins\
    \ for the runner. Please use the\n      `app` argument to provide plugins instead.\n    artifact_service: The artifact service for the runner.\n    session_service: The session service for the runner.\n    memory_service: The memory service for the runner.\n    credential_service: The credential service for the runner.\n    plugin_close_timeout: The timeout in seconds for plugin close methods.\n    auto_create_session: Whether to automatically create a session when\n      not found. Defaults to False. If False, a missing session raises\n      ValueError with a helpful message.\n\nRaises:\n    ValueError: If `app` is provided along with `agent` or `plugins`, or if\n      `app` is not provided but either `app_name` or `agent` is missing."
  signature: 'def __init__(self, *, app: typing.Optional[google.adk.apps.app.App]=None, app_name: typing.Optional[str]=None, agent: typing.Optional[google.adk.agents.base_agent.BaseAgent]=None, plugins: typing.Optional[typing.List[google.adk.plugins.base_plugin.BasePlugin]]=None, artifact_service: typing.Optional[google.adk.artifacts.base_artifact_service.BaseArtifactService]=None, session_service: google.adk.sessions.base_session_service.BaseSessionService, memory_service: typing.Optional[google.adk.memory.base_memory_service.BaseMemoryService]=None, credential_service: typing.Optional[google.adk.auth.credential_service.base_credential_service.BaseCredentialService]=None, plugin_close_timeout: float=5.0, auto_create_session: bool=False):'
- rank: 1260
  id: google.adk.runners.Runner.close
  name: close
  file_path: src/google/adk/runners.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Closes the runner.
  signature: 'def close(self):'
- rank: 1261
  id: google.adk.runners.Runner.rewind_async
  name: rewind_async
  file_path: src/google/adk/runners.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Rewinds the session to before the specified invocation.
  signature: 'def rewind_async(self, *, user_id: str, session_id: str, rewind_before_invocation_id: str) -> None:'
- rank: 1262
  id: google.adk.runners.Runner.run
  name: run
  file_path: src/google/adk/runners.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Runs the agent.\n\nNOTE:\n  This sync interface is only for local testing and convenience purpose.\n  Consider using `run_async` for production usage.\n\nIf event compaction is enabled in the App configuration, it will be\nperformed after all agent events for the current invocation have been\nyielded. The generator will only finish iterating after event\ncompaction is complete.\n\nArgs:\n  user_id: The user ID of the session.\n  session_id: The session ID of the session.\n  new_message: A new message to append to the session.\n  run_config: The run config for the agent.\n\nYields:\n  The events generated by the agent."
  signature: 'def run(self, *, user_id: str, session_id: str, new_message: google.genai.types.Content, run_config: typing.Optional[google.adk.agents.run_config.RunConfig]=None) -> typing.Generator[google.adk.events.event.Event, None, None]:'
- rank: 1263
  id: google.adk.runners.Runner.run_async
  name: run_async
  file_path: src/google/adk/runners.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Main entry method to run the agent in this runner.\n\nIf event compaction is enabled in the App configuration, it will be\nperformed after all agent events for the current invocation have been\nyielded. The async generator will only finish iterating after event\ncompaction is complete. However, this does not block new `run_async`\ncalls for subsequent user queries, which can be started concurrently.\n\nArgs:\n  user_id: The user ID of the session.\n  session_id: The session ID of the session.\n  invocation_id: The invocation ID of the session, set this to resume an\n    interrupted invocation.\n  new_message: A new message to append to the session.\n  state_delta: Optional state changes to apply to the session.\n  run_config: The run config for the agent.\n\nYields:\n  The events generated by the agent.\n\nRaises:\n  ValueError: If the session is not found; If both invocation_id and\n    new_message are None."
  signature: 'def run_async(self, *, user_id: str, session_id: str, invocation_id: typing.Optional[str]=None, new_message: typing.Optional[google.genai.types.Content]=None, state_delta: typing.Optional[dict[str, typing.Any]]=None, run_config: typing.Optional[google.adk.agents.run_config.RunConfig]=None) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
- rank: 1264
  id: google.adk.runners.Runner.run_debug
  name: run_debug
  file_path: src/google/adk/runners.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Debug helper for quick agent experimentation and testing.\n\nThis convenience method is designed for developers getting started with ADK\nwho want to quickly test agents without dealing with session management,\ncontent formatting, or event streaming. It automatically handles common\nboilerplate while hiding complexity.\n\nIMPORTANT: This is for debugging and experimentation only. For production\nuse, please use the standard run_async() method which provides full control\nover session management, event streaming, and error handling.\n\nArgs:\n    user_messages: Message(s) to send to the agent. Can be: - Single string:\n      \"What is 2+2?\" - List of strings: [\"Hello!\", \"What's my name?\"]\n    user_id: User identifier. Defaults to \"debug_user_id\".\n    session_id: Session identifier for conversation persistence. Defaults to\n      \"debug_session_id\". Reuse the same ID to continue a conversation.\n    run_config: Optional configuration for the agent execution.\n   \
    \ quiet: If True, suppresses console output. Defaults to False (output\n      shown).\n    verbose: If True, shows detailed tool calls and responses. Defaults to\n      False for cleaner output showing only final agent responses.\n\nReturns:\n    list[Event]: All events from all messages.\n\nRaises:\n    ValueError: If session creation/retrieval fails.\n\nExamples:\n    Quick debugging:\n    >>> runner = InMemoryRunner(agent=my_agent)\n    >>> await runner.run_debug(\"What is 2+2?\")\n\n    Multiple queries in conversation:\n    >>> await runner.run_debug([\"Hello!\", \"What's my name?\"])\n\n    Continue a debug session:\n    >>> await runner.run_debug(\"What did we discuss?\")  # Continues default\n    session\n\n    Separate debug sessions:\n    >>> await runner.run_debug(\"Hi\", user_id=\"alice\", session_id=\"debug1\")\n    >>> await runner.run_debug(\"Hi\", user_id=\"bob\", session_id=\"debug2\")\n\n    Capture events for inspection:\n    >>> events = await runner.run_debug(\"\
    Analyze this\")\n    >>> for event in events:\n    ...     inspect_event(event)\n\nNote:\n    For production applications requiring:\n    - Custom session/memory services (Spanner, Cloud SQL, etc.)\n    - Fine-grained event processing and streaming\n    - Error recovery and resumability\n    - Performance optimization\n    Please use run_async() with proper configuration."
  signature: 'def run_debug(self, user_messages: str | list[str], *, user_id: str=''debug_user_id'', session_id: str=''debug_session_id'', run_config: RunConfig | None=None, quiet: bool=False, verbose: bool=False) -> list[google.adk.events.event.Event]:'
- rank: 1265
  id: google.adk.runners.Runner.run_live
  name: run_live
  file_path: src/google/adk/runners.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Runs the agent in live mode (experimental feature).\n\nThe `run_live` method yields a stream of `Event` objects, but not all\nyielded events are saved to the session. Here's a breakdown:\n\n**Events Yielded to Callers:**\n*   **Live Model Audio Events with Inline Data:** Events containing raw\n    audio `Blob` data(`inline_data`).\n*   **Live Model Audio Events with File Data:** Both input and ouput audio\n    data are aggregated into an audio file saved into artifacts. The\n    reference to the file is saved in the event as `file_data`.\n*   **Usage Metadata:** Events containing token usage.\n*   **Transcription Events:** Both partial and non-partial transcription\n    events are yielded.\n*   **Function Call and Response Events:** Always saved.\n*   **Other Control Events:** Most control events are saved.\n\n**Events Saved to the Session:**\n*   **Live Model Audio Events with File Data:** Both input and ouput audio\n    data are aggregated into an audio file saved into artifacts.\
    \ The\n    reference to the file is saved as event in the `file_data` to session\n    if RunConfig.save_live_model_audio_to_session is True.\n*   **Usage Metadata Events:** Saved to the session.\n*   **Non-Partial Transcription Events:** Non-partial transcription events\n    are saved.\n*   **Function Call and Response Events:** Always saved.\n*   **Other Control Events:** Most control events are saved.\n\n**Events Not Saved to the Session:**\n*   **Live Model Audio Events with Inline Data:** Events containing raw\n    audio `Blob` data are **not** saved to the session.\n\nArgs:\n    user_id: The user ID for the session. Required if `session` is None.\n    session_id: The session ID for the session. Required if `session` is\n      None.\n    live_request_queue: The queue for live requests.\n    run_config: The run config for the agent.\n    session: The session to use. This parameter is deprecated, please use\n      `user_id` and `session_id` instead.\n\nYields:\n    AsyncGenerator[Event,\
    \ None]: An asynchronous generator that yields\n    `Event`\n    objects as they are produced by the agent during its live execution.\n\n.. warning::\n    This feature is **experimental** and its API or behavior may change\n    in future releases.\n\n.. NOTE::\n    Either `session` or both `user_id` and `session_id` must be provided."
  signature: 'def run_live(self, *, user_id: typing.Optional[str]=None, session_id: typing.Optional[str]=None, live_request_queue: google.adk.agents.live_request_queue.LiveRequestQueue, run_config: typing.Optional[google.adk.agents.run_config.RunConfig]=None, session: typing.Optional[google.adk.sessions.session.Session]=None) -> typing.AsyncGenerator[google.adk.events.event.Event, None]:'
- rank: 1266
  id: google.adk.sessions
  name: sessions
  file_path: src/google/adk/sessions/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: '__all__: Any'
- rank: 1267
  id: google.adk.sessions.base_session_service
  name: base_session_service
  file_path: src/google/adk/sessions/base_session_service.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1268
  id: google.adk.sessions.base_session_service.BaseSessionService
  name: BaseSessionService
  file_path: src/google/adk/sessions/base_session_service.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Base class for session services.


    The service provides a set of methods for managing sessions and events.


    [Note: Inherited members from abc.ABC are omitted.]'
  methods:
  - signature: 'def create_session(self, *, app_name: str, user_id: str, state: typing.Optional[dict[str, typing.Any]]=None, session_id: typing.Optional[str]=None) -> google.adk.sessions.session.Session:'
    docstring: "Creates a new session.\n\nArgs:\n  app_name: the name of the app.\n  user_id: the id of the user.\n  state: the initial state of the session.\n  session_id: the client-provided id of the session. If not provided, a\n    generated ID will be used.\n\nReturns:\n  session: The newly created session instance."
  - signature: 'def get_session(self, *, app_name: str, user_id: str, session_id: str, config: typing.Optional[google.adk.sessions.base_session_service.GetSessionConfig]=None) -> typing.Optional[google.adk.sessions.session.Session]:'
    docstring: Gets a session.
  - signature: 'def list_sessions(self, *, app_name: str, user_id: typing.Optional[str]=None) -> google.adk.sessions.base_session_service.ListSessionsResponse:'
    docstring: "Lists all the sessions for a user.\n\nArgs:\n  app_name: The name of the app.\n  user_id: The ID of the user. If not provided, lists all sessions for all\n    users.\n\nReturns:\n  A ListSessionsResponse containing the sessions."
  - signature: 'def delete_session(self, *, app_name: str, user_id: str, session_id: str) -> None:'
    docstring: Deletes a session.
  - signature: 'def append_event(self, session: google.adk.sessions.session.Session, event: google.adk.events.event.Event) -> google.adk.events.event.Event:'
    docstring: Appends an event to a session object.
  omitted_inherited_members_from:
  - abc.ABC
- rank: 1269
  id: google.adk.sessions.base_session_service.BaseSessionService.append_event
  name: append_event
  file_path: src/google/adk/sessions/base_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Appends an event to a session object.
  signature: 'def append_event(self, session: google.adk.sessions.session.Session, event: google.adk.events.event.Event) -> google.adk.events.event.Event:'
- rank: 1270
  id: google.adk.sessions.base_session_service.BaseSessionService.create_session
  name: create_session
  file_path: src/google/adk/sessions/base_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Creates a new session.\n\nArgs:\n  app_name: the name of the app.\n  user_id: the id of the user.\n  state: the initial state of the session.\n  session_id: the client-provided id of the session. If not provided, a\n    generated ID will be used.\n\nReturns:\n  session: The newly created session instance."
  signature: 'def create_session(self, *, app_name: str, user_id: str, state: typing.Optional[dict[str, typing.Any]]=None, session_id: typing.Optional[str]=None) -> google.adk.sessions.session.Session:'
- rank: 1271
  id: google.adk.sessions.base_session_service.BaseSessionService.delete_session
  name: delete_session
  file_path: src/google/adk/sessions/base_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Deletes a session.
  signature: 'def delete_session(self, *, app_name: str, user_id: str, session_id: str) -> None:'
- rank: 1272
  id: google.adk.sessions.base_session_service.BaseSessionService.get_session
  name: get_session
  file_path: src/google/adk/sessions/base_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Gets a session.
  signature: 'def get_session(self, *, app_name: str, user_id: str, session_id: str, config: typing.Optional[google.adk.sessions.base_session_service.GetSessionConfig]=None) -> typing.Optional[google.adk.sessions.session.Session]:'
- rank: 1273
  id: google.adk.sessions.base_session_service.BaseSessionService.list_sessions
  name: list_sessions
  file_path: src/google/adk/sessions/base_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Lists all the sessions for a user.\n\nArgs:\n  app_name: The name of the app.\n  user_id: The ID of the user. If not provided, lists all sessions for all\n    users.\n\nReturns:\n  A ListSessionsResponse containing the sessions."
  signature: 'def list_sessions(self, *, app_name: str, user_id: typing.Optional[str]=None) -> google.adk.sessions.base_session_service.ListSessionsResponse:'
- rank: 1274
  id: google.adk.sessions.base_session_service.GetSessionConfig
  name: GetSessionConfig
  file_path: src/google/adk/sessions/base_session_service.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'The configuration of getting a session.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, num_recent_events: typing.Optional[int] = None, after_timestamp: typing.Optional[float] = None):'
  properties:
  - signature: 'num_recent_events: typing.Optional[int]'
  - signature: 'after_timestamp: typing.Optional[float]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1275
  id: google.adk.sessions.base_session_service.ListSessionsResponse
  name: ListSessionsResponse
  file_path: src/google/adk/sessions/base_session_service.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'The response of listing sessions.


    The events and states are not set within each Session object.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, sessions: list[google.adk.sessions.session.Session] = list()):'
  properties:
  - signature: 'sessions: list[google.adk.sessions.session.Session]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1276
  id: google.adk.sessions.database_session_service
  name: database_session_service
  file_path: src/google/adk/sessions/database_session_service.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 1277
  id: google.adk.sessions.database_session_service.DatabaseSessionService
  name: DatabaseSessionService
  file_path: src/google/adk/sessions/database_session_service.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A session service that uses a database for storage.


    [Note: Inherited members from abc.ABC are omitted.]'
  constructor_signature: 'def __init__(self, db_url: str):'
  methods:
  - signature: 'def create_session(self, *, app_name: str, user_id: str, state: typing.Optional[dict[str, typing.Any]]=None, session_id: typing.Optional[str]=None) -> google.adk.sessions.session.Session:'
  - signature: 'def get_session(self, *, app_name: str, user_id: str, session_id: str, config: typing.Optional[google.adk.sessions.base_session_service.GetSessionConfig]=None) -> typing.Optional[google.adk.sessions.session.Session]:'
  - signature: 'def list_sessions(self, *, app_name: str, user_id: typing.Optional[str]=None) -> google.adk.sessions.base_session_service.ListSessionsResponse:'
  - signature: 'def delete_session(self, app_name: str, user_id: str, session_id: str) -> None:'
  - signature: 'def append_event(self, session: google.adk.sessions.session.Session, event: google.adk.events.event.Event) -> google.adk.events.event.Event:'
  - signature: 'def close(self) -> None:'
    docstring: Disposes the SQLAlchemy engine and closes pooled connections.
  inherited_methods:
    BaseSessionService:
    - signature: 'def create_session(self, *, app_name: str, user_id: str, state: typing.Optional[dict[str, typing.Any]]=None, session_id: typing.Optional[str]=None) -> google.adk.sessions.session.Session:'
      docstring: "Creates a new session.\n\nArgs:\n  app_name: the name of the app.\n  user_id: the id of the user.\n  state: the initial state of the session.\n  session_id: the client-provided id of the session. If not provided, a\n    generated ID will be used.\n\nReturns:\n  session: The newly created session instance."
    - signature: 'def get_session(self, *, app_name: str, user_id: str, session_id: str, config: typing.Optional[google.adk.sessions.base_session_service.GetSessionConfig]=None) -> typing.Optional[google.adk.sessions.session.Session]:'
      docstring: Gets a session.
    - signature: 'def list_sessions(self, *, app_name: str, user_id: typing.Optional[str]=None) -> google.adk.sessions.base_session_service.ListSessionsResponse:'
      docstring: "Lists all the sessions for a user.\n\nArgs:\n  app_name: The name of the app.\n  user_id: The ID of the user. If not provided, lists all sessions for all\n    users.\n\nReturns:\n  A ListSessionsResponse containing the sessions."
    - signature: 'def delete_session(self, *, app_name: str, user_id: str, session_id: str) -> None:'
      docstring: Deletes a session.
    - signature: 'def append_event(self, session: google.adk.sessions.session.Session, event: google.adk.events.event.Event) -> google.adk.events.event.Event:'
      docstring: Appends an event to a session object.
  omitted_inherited_members_from:
  - abc.ABC
- rank: 1278
  id: google.adk.sessions.database_session_service.DatabaseSessionService.__init__
  name: __init__
  file_path: src/google/adk/sessions/database_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Initializes the database session service with a database URL.
  signature: 'def __init__(self, db_url: str):'
- rank: 1279
  id: google.adk.sessions.database_session_service.DatabaseSessionService.append_event
  name: append_event
  file_path: src/google/adk/sessions/database_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def append_event(self, session: google.adk.sessions.session.Session, event: google.adk.events.event.Event) -> google.adk.events.event.Event:'
- rank: 1280
  id: google.adk.sessions.database_session_service.DatabaseSessionService.create_session
  name: create_session
  file_path: src/google/adk/sessions/database_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def create_session(self, *, app_name: str, user_id: str, state: typing.Optional[dict[str, typing.Any]]=None, session_id: typing.Optional[str]=None) -> google.adk.sessions.session.Session:'
- rank: 1281
  id: google.adk.sessions.database_session_service.DatabaseSessionService.delete_session
  name: delete_session
  file_path: src/google/adk/sessions/database_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def delete_session(self, app_name: str, user_id: str, session_id: str) -> None:'
- rank: 1282
  id: google.adk.sessions.database_session_service.DatabaseSessionService.get_session
  name: get_session
  file_path: src/google/adk/sessions/database_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_session(self, *, app_name: str, user_id: str, session_id: str, config: typing.Optional[google.adk.sessions.base_session_service.GetSessionConfig]=None) -> typing.Optional[google.adk.sessions.session.Session]:'
- rank: 1283
  id: google.adk.sessions.database_session_service.DatabaseSessionService.list_sessions
  name: list_sessions
  file_path: src/google/adk/sessions/database_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def list_sessions(self, *, app_name: str, user_id: typing.Optional[str]=None) -> google.adk.sessions.base_session_service.ListSessionsResponse:'
- rank: 1284
  id: google.adk.sessions.in_memory_session_service
  name: in_memory_session_service
  file_path: src/google/adk/sessions/in_memory_session_service.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 1285
  id: google.adk.sessions.in_memory_session_service.InMemorySessionService.__init__
  name: __init__
  file_path: src/google/adk/sessions/in_memory_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self):'
- rank: 1286
  id: google.adk.sessions.in_memory_session_service.InMemorySessionService.append_event
  name: append_event
  file_path: src/google/adk/sessions/in_memory_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def append_event(self, session: google.adk.sessions.session.Session, event: google.adk.events.event.Event) -> google.adk.events.event.Event:'
- rank: 1287
  id: google.adk.sessions.in_memory_session_service.InMemorySessionService.create_session
  name: create_session
  file_path: src/google/adk/sessions/in_memory_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def create_session(self, *, app_name: str, user_id: str, state: typing.Optional[dict[str, typing.Any]]=None, session_id: typing.Optional[str]=None) -> google.adk.sessions.session.Session:'
- rank: 1288
  id: google.adk.sessions.in_memory_session_service.InMemorySessionService.create_session_sync
  name: create_session_sync
  file_path: src/google/adk/sessions/in_memory_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def create_session_sync(self, *, app_name: str, user_id: str, state: typing.Optional[dict[str, typing.Any]]=None, session_id: typing.Optional[str]=None) -> google.adk.sessions.session.Session:'
- rank: 1289
  id: google.adk.sessions.in_memory_session_service.InMemorySessionService.delete_session
  name: delete_session
  file_path: src/google/adk/sessions/in_memory_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def delete_session(self, *, app_name: str, user_id: str, session_id: str) -> None:'
- rank: 1290
  id: google.adk.sessions.in_memory_session_service.InMemorySessionService.delete_session_sync
  name: delete_session_sync
  file_path: src/google/adk/sessions/in_memory_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def delete_session_sync(self, *, app_name: str, user_id: str, session_id: str) -> None:'
- rank: 1291
  id: google.adk.sessions.in_memory_session_service.InMemorySessionService.get_session
  name: get_session
  file_path: src/google/adk/sessions/in_memory_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_session(self, *, app_name: str, user_id: str, session_id: str, config: typing.Optional[google.adk.sessions.base_session_service.GetSessionConfig]=None) -> typing.Optional[google.adk.sessions.session.Session]:'
- rank: 1292
  id: google.adk.sessions.in_memory_session_service.InMemorySessionService.get_session_sync
  name: get_session_sync
  file_path: src/google/adk/sessions/in_memory_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_session_sync(self, *, app_name: str, user_id: str, session_id: str, config: typing.Optional[google.adk.sessions.base_session_service.GetSessionConfig]=None) -> typing.Optional[google.adk.sessions.session.Session]:'
- rank: 1293
  id: google.adk.sessions.in_memory_session_service.InMemorySessionService.list_sessions
  name: list_sessions
  file_path: src/google/adk/sessions/in_memory_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def list_sessions(self, *, app_name: str, user_id: typing.Optional[str]=None) -> google.adk.sessions.base_session_service.ListSessionsResponse:'
- rank: 1294
  id: google.adk.sessions.in_memory_session_service.InMemorySessionService.list_sessions_sync
  name: list_sessions_sync
  file_path: src/google/adk/sessions/in_memory_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def list_sessions_sync(self, *, app_name: str, user_id: typing.Optional[str]=None) -> google.adk.sessions.base_session_service.ListSessionsResponse:'
- rank: 1295
  id: google.adk.sessions.migration.migrate_from_sqlalchemy_pickle
  name: migrate_from_sqlalchemy_pickle
  file_path: src/google/adk/sessions/migration/migrate_from_sqlalchemy_pickle.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Migration script from SQLAlchemy DB with Pickle Events to JSON schema.
  methods:
  - signature: 'def migrate(source_db_url: str, dest_db_url: str):'
    docstring: Migrates data from old pickle schema to new JSON schema.
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: 'parser: argparse.ArgumentParser'
  - signature: 'args: parser.parse_args'
- rank: 1296
  id: google.adk.sessions.migration.migrate_from_sqlalchemy_pickle.migrate
  name: migrate
  file_path: src/google/adk/sessions/migration/migrate_from_sqlalchemy_pickle.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Migrates data from old pickle schema to new JSON schema.
  signature: 'def migrate(source_db_url: str, dest_db_url: str):'
- rank: 1297
  id: google.adk.sessions.migration.migrate_from_sqlalchemy_sqlite
  name: migrate_from_sqlalchemy_sqlite
  file_path: src/google/adk/sessions/migration/migrate_from_sqlalchemy_sqlite.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Migration script from SQLAlchemy SQLite to the new SQLite JSON schema.
  methods:
  - signature: 'def migrate(source_db_url: str, dest_db_path: str):'
    docstring: Migrates data from a SQLAlchemy-based SQLite DB to the new schema.
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: 'parser: argparse.ArgumentParser'
  - signature: 'args: parser.parse_args'
  - signature: 'source_url: Any'
- rank: 1298
  id: google.adk.sessions.migration.migrate_from_sqlalchemy_sqlite.migrate
  name: migrate
  file_path: src/google/adk/sessions/migration/migrate_from_sqlalchemy_sqlite.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Migrates data from a SQLAlchemy-based SQLite DB to the new schema.
  signature: 'def migrate(source_db_url: str, dest_db_path: str):'
- rank: 1299
  id: google.adk.sessions.migration.migration_runner
  name: migration_runner
  file_path: src/google/adk/sessions/migration/migration_runner.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Migration runner to upgrade schemas to the latest version.
  methods:
  - signature: 'def upgrade(source_db_url: str, dest_db_url: str):'
    docstring: "Migrates a database from its current version to the latest version.\n\nIf the source database schema is older than the latest version, this\nfunction applies migration scripts sequentially until the schema reaches the\nLATEST_VERSION.\n\nIf multiple migration steps are required, intermediate results are stored in\ntemporary SQLite database files. This means a multistep migration\nbetween other database types (e.g. PostgreSQL to PostgreSQL) will use\nSQLite for intermediate steps.\n\nIn-place migration (source_db_url == dest_db_url) is not supported,\nas migrations always read from a source and write to a destination.\n\nArgs:\n  source_db_url: The SQLAlchemy URL of the database to migrate from.\n  dest_db_url: The SQLAlchemy URL of the database to migrate to. This must be\n    different from source_db_url.\n\nRaises:\n  RuntimeError: If source_db_url and dest_db_url are the same, or if no\n    migration path is found."
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: 'MIGRATIONS: Any'
  - signature: 'LATEST_VERSION: Any'
- rank: 1300
  id: google.adk.sessions.migration.migration_runner.upgrade
  name: upgrade
  file_path: src/google/adk/sessions/migration/migration_runner.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Migrates a database from its current version to the latest version.\n\nIf the source database schema is older than the latest version, this\nfunction applies migration scripts sequentially until the schema reaches the\nLATEST_VERSION.\n\nIf multiple migration steps are required, intermediate results are stored in\ntemporary SQLite database files. This means a multistep migration\nbetween other database types (e.g. PostgreSQL to PostgreSQL) will use\nSQLite for intermediate steps.\n\nIn-place migration (source_db_url == dest_db_url) is not supported,\nas migrations always read from a source and write to a destination.\n\nArgs:\n  source_db_url: The SQLAlchemy URL of the database to migrate from.\n  dest_db_url: The SQLAlchemy URL of the database to migrate to. This must be\n    different from source_db_url.\n\nRaises:\n  RuntimeError: If source_db_url and dest_db_url are the same, or if no\n    migration path is found."
  signature: 'def upgrade(source_db_url: str, dest_db_url: str):'
- rank: 1301
  id: google.adk.sessions.schemas.shared
  name: shared
  file_path: src/google/adk/sessions/schemas/shared.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'DEFAULT_MAX_KEY_LENGTH: int'
  - signature: 'DEFAULT_MAX_VARCHAR_LENGTH: int'
- rank: 1302
  id: google.adk.sessions.schemas.shared.DynamicJSON
  name: DynamicJSON
  file_path: src/google/adk/sessions/schemas/shared.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A JSON-like type that uses JSONB on PostgreSQL and TEXT with JSON serialization for other databases.


    [Note: Inherited members from TypeDecorator are omitted.]'
  methods:
  - signature: 'def load_dialect_impl(self, dialect: sqlalchemy.Dialect):'
  - signature: 'def process_bind_param(self, value, dialect: sqlalchemy.Dialect):'
  - signature: 'def process_result_value(self, value, dialect: sqlalchemy.Dialect):'
  properties:
  - signature: 'impl: Any'
  omitted_inherited_members_from:
  - TypeDecorator
- rank: 1303
  id: google.adk.sessions.schemas.shared.DynamicJSON.load_dialect_impl
  name: load_dialect_impl
  file_path: src/google/adk/sessions/schemas/shared.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def load_dialect_impl(self, dialect: sqlalchemy.Dialect):'
- rank: 1304
  id: google.adk.sessions.schemas.shared.DynamicJSON.process_bind_param
  name: process_bind_param
  file_path: src/google/adk/sessions/schemas/shared.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def process_bind_param(self, value, dialect: sqlalchemy.Dialect):'
- rank: 1305
  id: google.adk.sessions.schemas.shared.DynamicJSON.process_result_value
  name: process_result_value
  file_path: src/google/adk/sessions/schemas/shared.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def process_result_value(self, value, dialect: sqlalchemy.Dialect):'
- rank: 1306
  id: google.adk.sessions.schemas.shared.PreciseTimestamp
  name: PreciseTimestamp
  file_path: src/google/adk/sessions/schemas/shared.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Represents a timestamp precise to the microsecond.


    [Note: Inherited members from TypeDecorator are omitted.]'
  methods:
  - signature: 'def load_dialect_impl(self, dialect):'
  properties:
  - signature: 'impl: Any'
  - signature: 'cache_ok: bool'
  omitted_inherited_members_from:
  - TypeDecorator
- rank: 1307
  id: google.adk.sessions.schemas.shared.PreciseTimestamp.load_dialect_impl
  name: load_dialect_impl
  file_path: src/google/adk/sessions/schemas/shared.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def load_dialect_impl(self, dialect):'
- rank: 1308
  id: google.adk.sessions.schemas.v0
  name: v0
  file_path: src/google/adk/sessions/schemas/v0.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: 'V0 database schema for ADK versions from 1.19.0 to 1.21.0.


    This module defines SQLAlchemy models for storing session and event data

    in a relational database with the EventActions object using pickle

    serialization. To migrate from the schemas in earlier ADK versions to this

    v0 schema, see

    https://github.com/google/adk-python/blob/main/docs/upgrading_from_1_22_0.md.


    The latest schema is defined in `v1.py`. That module uses JSON serialization

    for the EventActions data as well as other fields in the `events` table. See

    https://github.com/google/adk-python/discussions/3605 for more details.'
- rank: 1309
  id: google.adk.sessions.schemas.v0.Base
  name: Base
  file_path: src/google/adk/sessions/schemas/v0.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Base class for v0 database tables.


    [Note: Inherited members from DeclarativeBase are omitted.]'
  omitted_inherited_members_from:
  - DeclarativeBase
- rank: 1310
  id: google.adk.sessions.schemas.v0.DynamicPickleType
  name: DynamicPickleType
  file_path: src/google/adk/sessions/schemas/v0.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Represents a type that can be pickled.


    [Note: Inherited members from TypeDecorator are omitted.]'
  methods:
  - signature: 'def load_dialect_impl(self, dialect):'
  - signature: 'def process_bind_param(self, value, dialect):'
    docstring: Ensures the pickled value is a bytes object before passing it to the database dialect.
  - signature: 'def process_result_value(self, value, dialect):'
    docstring: Ensures the raw bytes from the database are unpickled back into a Python object.
  properties:
  - signature: 'impl: Any'
  omitted_inherited_members_from:
  - TypeDecorator
- rank: 1311
  id: google.adk.sessions.schemas.v0.DynamicPickleType.load_dialect_impl
  name: load_dialect_impl
  file_path: src/google/adk/sessions/schemas/v0.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def load_dialect_impl(self, dialect):'
- rank: 1312
  id: google.adk.sessions.schemas.v0.DynamicPickleType.process_bind_param
  name: process_bind_param
  file_path: src/google/adk/sessions/schemas/v0.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Ensures the pickled value is a bytes object before passing it to the database dialect.
  signature: 'def process_bind_param(self, value, dialect):'
- rank: 1313
  id: google.adk.sessions.schemas.v0.DynamicPickleType.process_result_value
  name: process_result_value
  file_path: src/google/adk/sessions/schemas/v0.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Ensures the raw bytes from the database are unpickled back into a Python object.
  signature: 'def process_result_value(self, value, dialect):'
- rank: 1314
  id: google.adk.sessions.schemas.v0.StorageAppState
  name: StorageAppState
  file_path: src/google/adk/sessions/schemas/v0.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Represents an app state stored in the database.


    [Note: Inherited members from DeclarativeBase are omitted.]'
  properties:
  - signature: 'app_name: sqlalchemy.orm.Mapped[str]'
  - signature: 'state: sqlalchemy.orm.Mapped[sqlalchemy.ext.mutable.MutableDict[str, typing.Any]]'
  - signature: 'update_time: sqlalchemy.orm.Mapped[datetime.datetime]'
  omitted_inherited_members_from:
  - DeclarativeBase
- rank: 1315
  id: google.adk.sessions.schemas.v0.StorageEvent
  name: StorageEvent
  file_path: src/google/adk/sessions/schemas/v0.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Represents an event stored in the database.


    [Note: Inherited members from DeclarativeBase are omitted.]'
  methods:
  - signature: 'def long_running_tool_ids(self, value: set[str]):'
  - signature: 'def long_running_tool_ids(self, value: set[str]):'
  - signature: 'def from_event(cls, session: google.adk.sessions.session.Session, event: google.adk.events.event.Event) -> google.adk.sessions.schemas.v0.StorageEvent:'
  - signature: 'def to_event(self) -> google.adk.events.event.Event:'
  properties:
  - signature: 'id: sqlalchemy.orm.Mapped[str]'
  - signature: 'app_name: sqlalchemy.orm.Mapped[str]'
  - signature: 'user_id: sqlalchemy.orm.Mapped[str]'
  - signature: 'session_id: sqlalchemy.orm.Mapped[str]'
  - signature: 'invocation_id: sqlalchemy.orm.Mapped[str]'
  - signature: 'author: sqlalchemy.orm.Mapped[str]'
  - signature: 'actions: sqlalchemy.orm.Mapped[sqlalchemy.ext.mutable.MutableDict[str, typing.Any]]'
  - signature: 'long_running_tool_ids_json: sqlalchemy.orm.Mapped[typing.Optional[str]]'
  - signature: 'branch: sqlalchemy.orm.Mapped[str]'
  - signature: 'timestamp: sqlalchemy.orm.Mapped[google.adk.sessions.schemas.shared.PreciseTimestamp]'
  - signature: 'content: sqlalchemy.orm.Mapped[dict[str, typing.Any]]'
  - signature: 'grounding_metadata: sqlalchemy.orm.Mapped[dict[str, typing.Any]]'
  - signature: 'custom_metadata: sqlalchemy.orm.Mapped[dict[str, typing.Any]]'
  - signature: 'usage_metadata: sqlalchemy.orm.Mapped[dict[str, typing.Any]]'
  - signature: 'citation_metadata: sqlalchemy.orm.Mapped[dict[str, typing.Any]]'
  - signature: 'partial: sqlalchemy.orm.Mapped[bool]'
  - signature: 'turn_complete: sqlalchemy.orm.Mapped[bool]'
  - signature: 'error_code: sqlalchemy.orm.Mapped[str]'
  - signature: 'error_message: sqlalchemy.orm.Mapped[str]'
  - signature: 'interrupted: sqlalchemy.orm.Mapped[bool]'
  - signature: 'input_transcription: sqlalchemy.orm.Mapped[dict[str, typing.Any]]'
  - signature: 'output_transcription: sqlalchemy.orm.Mapped[dict[str, typing.Any]]'
  - signature: 'storage_session: sqlalchemy.orm.Mapped[google.adk.sessions.schemas.v0.StorageSession]'
  omitted_inherited_members_from:
  - DeclarativeBase
- rank: 1316
  id: google.adk.sessions.schemas.v0.StorageEvent.from_event
  name: from_event
  file_path: src/google/adk/sessions/schemas/v0.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def from_event(cls, session: google.adk.sessions.session.Session, event: google.adk.events.event.Event) -> google.adk.sessions.schemas.v0.StorageEvent:'
- rank: 1317
  id: google.adk.sessions.schemas.v0.StorageEvent.long_running_tool_ids
  name: long_running_tool_ids
  file_path: src/google/adk/sessions/schemas/v0.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def long_running_tool_ids(self, value: set[str]):'
- rank: 1318
  id: google.adk.sessions.schemas.v0.StorageEvent.long_running_tool_ids
  name: long_running_tool_ids
  file_path: src/google/adk/sessions/schemas/v0.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def long_running_tool_ids(self, value: set[str]):'
- rank: 1319
  id: google.adk.sessions.schemas.v0.StorageEvent.to_event
  name: to_event
  file_path: src/google/adk/sessions/schemas/v0.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def to_event(self) -> google.adk.events.event.Event:'
- rank: 1320
  id: google.adk.sessions.schemas.v0.StorageSession
  name: StorageSession
  file_path: src/google/adk/sessions/schemas/v0.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Represents a session stored in the database.


    [Note: Inherited members from DeclarativeBase are omitted.]'
  methods:
  - signature: 'def update_timestamp_tz(self) -> float:'
    docstring: 'Returns the update timestamp as a POSIX timestamp.


      This is a compatibility alias for callers that used the pre-`main` API.'
  - signature: 'def get_update_timestamp(self, is_sqlite: bool) -> float:'
    docstring: Returns the time zone aware update timestamp.
  - signature: 'def to_session(self, state: dict[str, Any] | None, events: list[Event] | None, is_sqlite: bool) -> google.adk.sessions.session.Session:'
    docstring: Converts the storage session to a session object.
  properties:
  - signature: 'app_name: sqlalchemy.orm.Mapped[str]'
  - signature: 'user_id: sqlalchemy.orm.Mapped[str]'
  - signature: 'id: sqlalchemy.orm.Mapped[str]'
  - signature: 'state: sqlalchemy.orm.Mapped[sqlalchemy.ext.mutable.MutableDict[str, typing.Any]]'
  - signature: 'create_time: sqlalchemy.orm.Mapped[datetime.datetime]'
  - signature: 'update_time: sqlalchemy.orm.Mapped[datetime.datetime]'
  - signature: 'storage_events: sqlalchemy.orm.Mapped[list[google.adk.sessions.schemas.v0.StorageEvent]]'
  omitted_inherited_members_from:
  - DeclarativeBase
- rank: 1321
  id: google.adk.sessions.schemas.v0.StorageSession.get_update_timestamp
  name: get_update_timestamp
  file_path: src/google/adk/sessions/schemas/v0.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns the time zone aware update timestamp.
  signature: 'def get_update_timestamp(self, is_sqlite: bool) -> float:'
- rank: 1322
  id: google.adk.sessions.schemas.v0.StorageSession.to_session
  name: to_session
  file_path: src/google/adk/sessions/schemas/v0.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Converts the storage session to a session object.
  signature: 'def to_session(self, state: dict[str, Any] | None, events: list[Event] | None, is_sqlite: bool) -> google.adk.sessions.session.Session:'
- rank: 1323
  id: google.adk.sessions.schemas.v0.StorageSession.update_timestamp_tz
  name: update_timestamp_tz
  file_path: src/google/adk/sessions/schemas/v0.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Returns the update timestamp as a POSIX timestamp.


    This is a compatibility alias for callers that used the pre-`main` API.'
  signature: 'def update_timestamp_tz(self) -> float:'
- rank: 1324
  id: google.adk.sessions.schemas.v0.StorageUserState
  name: StorageUserState
  file_path: src/google/adk/sessions/schemas/v0.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Represents a user state stored in the database.


    [Note: Inherited members from DeclarativeBase are omitted.]'
  properties:
  - signature: 'app_name: sqlalchemy.orm.Mapped[str]'
  - signature: 'user_id: sqlalchemy.orm.Mapped[str]'
  - signature: 'state: sqlalchemy.orm.Mapped[sqlalchemy.ext.mutable.MutableDict[str, typing.Any]]'
  - signature: 'update_time: sqlalchemy.orm.Mapped[datetime.datetime]'
  omitted_inherited_members_from:
  - DeclarativeBase
- rank: 1325
  id: google.adk.sessions.schemas.v1
  name: v1
  file_path: src/google/adk/sessions/schemas/v1.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: 'The v1 database schema for the DatabaseSessionService.


    This module defines SQLAlchemy models for storing session and event data

    in a relational database with the "events" table using JSON

    serialization for Event data.


    See https://github.com/google/adk-python/discussions/3605 for more details.'
- rank: 1326
  id: google.adk.sessions.schemas.v1.Base
  name: Base
  file_path: src/google/adk/sessions/schemas/v1.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Base class for v1 database tables.


    [Note: Inherited members from DeclarativeBase are omitted.]'
  omitted_inherited_members_from:
  - DeclarativeBase
- rank: 1327
  id: google.adk.sessions.schemas.v1.StorageAppState
  name: StorageAppState
  file_path: src/google/adk/sessions/schemas/v1.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Represents an app state stored in the database.


    [Note: Inherited members from DeclarativeBase are omitted.]'
  properties:
  - signature: 'app_name: sqlalchemy.orm.Mapped[str]'
  - signature: 'state: sqlalchemy.orm.Mapped[sqlalchemy.ext.mutable.MutableDict[str, typing.Any]]'
  - signature: 'update_time: sqlalchemy.orm.Mapped[datetime.datetime]'
  omitted_inherited_members_from:
  - DeclarativeBase
- rank: 1328
  id: google.adk.sessions.schemas.v1.StorageEvent
  name: StorageEvent
  file_path: src/google/adk/sessions/schemas/v1.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Represents an event stored in the database.


    [Note: Inherited members from DeclarativeBase are omitted.]'
  methods:
  - signature: 'def from_event(cls, session: google.adk.sessions.session.Session, event: google.adk.events.event.Event) -> google.adk.sessions.schemas.v1.StorageEvent:'
    docstring: Creates a StorageEvent from an Event.
  - signature: 'def to_event(self) -> google.adk.events.event.Event:'
    docstring: Converts the StorageEvent to an Event.
  properties:
  - signature: 'id: sqlalchemy.orm.Mapped[str]'
  - signature: 'app_name: sqlalchemy.orm.Mapped[str]'
  - signature: 'user_id: sqlalchemy.orm.Mapped[str]'
  - signature: 'session_id: sqlalchemy.orm.Mapped[str]'
  - signature: 'invocation_id: sqlalchemy.orm.Mapped[str]'
  - signature: 'timestamp: sqlalchemy.orm.Mapped[google.adk.sessions.schemas.shared.PreciseTimestamp]'
  - signature: 'event_data: sqlalchemy.orm.Mapped[dict[str, typing.Any]]'
  - signature: 'storage_session: sqlalchemy.orm.Mapped[google.adk.sessions.schemas.v1.StorageSession]'
  omitted_inherited_members_from:
  - DeclarativeBase
- rank: 1329
  id: google.adk.sessions.schemas.v1.StorageEvent.from_event
  name: from_event
  file_path: src/google/adk/sessions/schemas/v1.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Creates a StorageEvent from an Event.
  signature: 'def from_event(cls, session: google.adk.sessions.session.Session, event: google.adk.events.event.Event) -> google.adk.sessions.schemas.v1.StorageEvent:'
- rank: 1330
  id: google.adk.sessions.schemas.v1.StorageEvent.to_event
  name: to_event
  file_path: src/google/adk/sessions/schemas/v1.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Converts the StorageEvent to an Event.
  signature: 'def to_event(self) -> google.adk.events.event.Event:'
- rank: 1331
  id: google.adk.sessions.schemas.v1.StorageMetadata
  name: StorageMetadata
  file_path: src/google/adk/sessions/schemas/v1.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Represents ADK internal metadata stored in the database.


    This table is used to store internal information like the schema version.

    The DatabaseSessionService will populate and utilize this table to manage

    database compatibility and migrations.


    [Note: Inherited members from DeclarativeBase are omitted.]'
  properties:
  - signature: 'key: sqlalchemy.orm.Mapped[str]'
  - signature: 'value: sqlalchemy.orm.Mapped[str]'
  omitted_inherited_members_from:
  - DeclarativeBase
- rank: 1332
  id: google.adk.sessions.schemas.v1.StorageSession
  name: StorageSession
  file_path: src/google/adk/sessions/schemas/v1.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Represents a session stored in the database.


    [Note: Inherited members from DeclarativeBase are omitted.]'
  methods:
  - signature: 'def update_timestamp_tz(self) -> float:'
    docstring: 'Returns the update timestamp as a POSIX timestamp.


      This is a compatibility alias for callers that used the pre-`main` API.'
  - signature: 'def get_update_timestamp(self, is_sqlite: bool) -> float:'
    docstring: Returns the time zone aware update timestamp.
  - signature: 'def to_session(self, state: dict[str, Any] | None, events: list[Event] | None, is_sqlite: bool) -> google.adk.sessions.session.Session:'
    docstring: Converts the storage session to a session object.
  properties:
  - signature: 'app_name: sqlalchemy.orm.Mapped[str]'
  - signature: 'user_id: sqlalchemy.orm.Mapped[str]'
  - signature: 'id: sqlalchemy.orm.Mapped[str]'
  - signature: 'state: sqlalchemy.orm.Mapped[sqlalchemy.ext.mutable.MutableDict[str, typing.Any]]'
  - signature: 'create_time: sqlalchemy.orm.Mapped[datetime.datetime]'
  - signature: 'update_time: sqlalchemy.orm.Mapped[datetime.datetime]'
  - signature: 'storage_events: sqlalchemy.orm.Mapped[list[google.adk.sessions.schemas.v1.StorageEvent]]'
  omitted_inherited_members_from:
  - DeclarativeBase
- rank: 1333
  id: google.adk.sessions.schemas.v1.StorageSession.get_update_timestamp
  name: get_update_timestamp
  file_path: src/google/adk/sessions/schemas/v1.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns the time zone aware update timestamp.
  signature: 'def get_update_timestamp(self, is_sqlite: bool) -> float:'
- rank: 1334
  id: google.adk.sessions.schemas.v1.StorageSession.to_session
  name: to_session
  file_path: src/google/adk/sessions/schemas/v1.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Converts the storage session to a session object.
  signature: 'def to_session(self, state: dict[str, Any] | None, events: list[Event] | None, is_sqlite: bool) -> google.adk.sessions.session.Session:'
- rank: 1335
  id: google.adk.sessions.schemas.v1.StorageSession.update_timestamp_tz
  name: update_timestamp_tz
  file_path: src/google/adk/sessions/schemas/v1.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Returns the update timestamp as a POSIX timestamp.


    This is a compatibility alias for callers that used the pre-`main` API.'
  signature: 'def update_timestamp_tz(self) -> float:'
- rank: 1336
  id: google.adk.sessions.schemas.v1.StorageUserState
  name: StorageUserState
  file_path: src/google/adk/sessions/schemas/v1.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Represents a user state stored in the database.


    [Note: Inherited members from DeclarativeBase are omitted.]'
  properties:
  - signature: 'app_name: sqlalchemy.orm.Mapped[str]'
  - signature: 'user_id: sqlalchemy.orm.Mapped[str]'
  - signature: 'state: sqlalchemy.orm.Mapped[sqlalchemy.ext.mutable.MutableDict[str, typing.Any]]'
  - signature: 'update_time: sqlalchemy.orm.Mapped[datetime.datetime]'
  omitted_inherited_members_from:
  - DeclarativeBase
- rank: 1337
  id: google.adk.sessions.session
  name: session
  file_path: src/google/adk/sessions/session.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1338
  id: google.adk.sessions.session.Session
  name: Session
  file_path: src/google/adk/sessions/session.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Represents a series of interactions between a user and agents.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, id: str, app_name: str, user_id: str, state: dict[str, typing.Any] = dict(), events: list[google.adk.events.event.Event] = list()):'
  aliases:
  - google.adk.sessions.Session
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
    docstring: The pydantic model config.
  - signature: 'id: str'
    docstring: The unique identifier of the session.
  - signature: 'app_name: str'
    docstring: The name of the app.
  - signature: 'user_id: str'
    docstring: The id of the user.
  - signature: 'state: dict[str, typing.Any]'
    docstring: The state of the session.
  - signature: 'events: list[google.adk.events.event.Event]'
    docstring: 'The events of the session, e.g. user input, model response, function

      call/response, etc.'
  - signature: 'last_update_time: float'
    docstring: The last update time of the session.
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1339
  id: google.adk.sessions.sqlite_session_service
  name: sqlite_session_service
  file_path: src/google/adk/sessions/sqlite_session_service.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: 'PRAGMA_FOREIGN_KEYS: str'
  - signature: 'APP_STATES_TABLE_SCHEMA: str'
  - signature: 'USER_STATES_TABLE_SCHEMA: str'
  - signature: 'SESSIONS_TABLE_SCHEMA: str'
  - signature: 'EVENTS_TABLE_SCHEMA: str'
  - signature: "CREATE_SCHEMA_SQL: \n.join"
- rank: 1340
  id: google.adk.sessions.sqlite_session_service.SqliteSessionService
  name: SqliteSessionService
  file_path: src/google/adk/sessions/sqlite_session_service.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A session service that uses an SQLite database for storage via aiosqlite.


    Event data is stored as JSON to allow for schema flexibility as event

    fields evolve.


    [Note: Inherited members from abc.ABC are omitted.]'
  constructor_signature: 'def __init__(self, db_path: str):'
  methods:
  - signature: 'def create_session(self, *, app_name: str, user_id: str, state: typing.Optional[dict[str, typing.Any]]=None, session_id: typing.Optional[str]=None) -> google.adk.sessions.session.Session:'
  - signature: 'def get_session(self, *, app_name: str, user_id: str, session_id: str, config: typing.Optional[google.adk.sessions.base_session_service.GetSessionConfig]=None) -> typing.Optional[google.adk.sessions.session.Session]:'
  - signature: 'def list_sessions(self, *, app_name: str, user_id: typing.Optional[str]=None) -> google.adk.sessions.base_session_service.ListSessionsResponse:'
  - signature: 'def delete_session(self, *, app_name: str, user_id: str, session_id: str) -> None:'
  - signature: 'def append_event(self, session: google.adk.sessions.session.Session, event: google.adk.events.event.Event) -> google.adk.events.event.Event:'
  inherited_methods:
    BaseSessionService:
    - signature: 'def create_session(self, *, app_name: str, user_id: str, state: typing.Optional[dict[str, typing.Any]]=None, session_id: typing.Optional[str]=None) -> google.adk.sessions.session.Session:'
      docstring: "Creates a new session.\n\nArgs:\n  app_name: the name of the app.\n  user_id: the id of the user.\n  state: the initial state of the session.\n  session_id: the client-provided id of the session. If not provided, a\n    generated ID will be used.\n\nReturns:\n  session: The newly created session instance."
    - signature: 'def get_session(self, *, app_name: str, user_id: str, session_id: str, config: typing.Optional[google.adk.sessions.base_session_service.GetSessionConfig]=None) -> typing.Optional[google.adk.sessions.session.Session]:'
      docstring: Gets a session.
    - signature: 'def list_sessions(self, *, app_name: str, user_id: typing.Optional[str]=None) -> google.adk.sessions.base_session_service.ListSessionsResponse:'
      docstring: "Lists all the sessions for a user.\n\nArgs:\n  app_name: The name of the app.\n  user_id: The ID of the user. If not provided, lists all sessions for all\n    users.\n\nReturns:\n  A ListSessionsResponse containing the sessions."
    - signature: 'def delete_session(self, *, app_name: str, user_id: str, session_id: str) -> None:'
      docstring: Deletes a session.
    - signature: 'def append_event(self, session: google.adk.sessions.session.Session, event: google.adk.events.event.Event) -> google.adk.events.event.Event:'
      docstring: Appends an event to a session object.
  omitted_inherited_members_from:
  - abc.ABC
- rank: 1341
  id: google.adk.sessions.sqlite_session_service.SqliteSessionService.__init__
  name: __init__
  file_path: src/google/adk/sessions/sqlite_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Initializes the SQLite session service with a database path.
  signature: 'def __init__(self, db_path: str):'
- rank: 1342
  id: google.adk.sessions.sqlite_session_service.SqliteSessionService.append_event
  name: append_event
  file_path: src/google/adk/sessions/sqlite_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def append_event(self, session: google.adk.sessions.session.Session, event: google.adk.events.event.Event) -> google.adk.events.event.Event:'
- rank: 1343
  id: google.adk.sessions.sqlite_session_service.SqliteSessionService.create_session
  name: create_session
  file_path: src/google/adk/sessions/sqlite_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def create_session(self, *, app_name: str, user_id: str, state: typing.Optional[dict[str, typing.Any]]=None, session_id: typing.Optional[str]=None) -> google.adk.sessions.session.Session:'
- rank: 1344
  id: google.adk.sessions.sqlite_session_service.SqliteSessionService.delete_session
  name: delete_session
  file_path: src/google/adk/sessions/sqlite_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def delete_session(self, *, app_name: str, user_id: str, session_id: str) -> None:'
- rank: 1345
  id: google.adk.sessions.sqlite_session_service.SqliteSessionService.get_session
  name: get_session
  file_path: src/google/adk/sessions/sqlite_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_session(self, *, app_name: str, user_id: str, session_id: str, config: typing.Optional[google.adk.sessions.base_session_service.GetSessionConfig]=None) -> typing.Optional[google.adk.sessions.session.Session]:'
- rank: 1346
  id: google.adk.sessions.sqlite_session_service.SqliteSessionService.list_sessions
  name: list_sessions
  file_path: src/google/adk/sessions/sqlite_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def list_sessions(self, *, app_name: str, user_id: typing.Optional[str]=None) -> google.adk.sessions.base_session_service.ListSessionsResponse:'
- rank: 1347
  id: google.adk.sessions.state
  name: state
  file_path: src/google/adk/sessions/state.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1348
  id: google.adk.sessions.state.State
  name: State
  file_path: src/google/adk/sessions/state.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: A state dict that maintains the current value and the pending-commit delta.
  constructor_signature: 'def __init__(self, value: dict[str, typing.Any], delta: dict[str, typing.Any]):'
  methods:
  - signature: 'def setdefault(self, key: str, default: typing.Any) -> typing.Any:'
    docstring: Gets the value of a key, or sets it to a default if the key doesn't exist.
  - signature: 'def has_delta(self) -> bool:'
    docstring: Whether the state has pending delta.
  - signature: 'def get(self, key: str, default: typing.Any) -> typing.Any:'
    docstring: Returns the value of the state dict for the given key.
  - signature: 'def update(self, delta: dict[str, typing.Any]):'
    docstring: Updates the state dict with the given delta.
  - signature: 'def to_dict(self) -> dict[str, typing.Any]:'
    docstring: Returns the state dict.
  properties:
  - signature: 'APP_PREFIX: str'
  - signature: 'USER_PREFIX: str'
  - signature: 'TEMP_PREFIX: str'
- rank: 1349
  id: google.adk.sessions.state.State.__init__
  name: __init__
  file_path: src/google/adk/sessions/state.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Args:

    value: The current value of the state dict.

    delta: The delta change to the current value that hasn''t been committed.'
  signature: 'def __init__(self, value: dict[str, typing.Any], delta: dict[str, typing.Any]):'
- rank: 1350
  id: google.adk.sessions.state.State.get
  name: get
  file_path: src/google/adk/sessions/state.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns the value of the state dict for the given key.
  signature: 'def get(self, key: str, default: typing.Any) -> typing.Any:'
- rank: 1351
  id: google.adk.sessions.state.State.setdefault
  name: setdefault
  file_path: src/google/adk/sessions/state.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Gets the value of a key, or sets it to a default if the key doesn't exist.
  signature: 'def setdefault(self, key: str, default: typing.Any) -> typing.Any:'
- rank: 1352
  id: google.adk.sessions.state.State.to_dict
  name: to_dict
  file_path: src/google/adk/sessions/state.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns the state dict.
  signature: 'def to_dict(self) -> dict[str, typing.Any]:'
- rank: 1353
  id: google.adk.sessions.state.State.update
  name: update
  file_path: src/google/adk/sessions/state.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Updates the state dict with the given delta.
  signature: 'def update(self, delta: dict[str, typing.Any]):'
- rank: 1354
  id: google.adk.sessions.vertex_ai_session_service
  name: vertex_ai_session_service
  file_path: src/google/adk/sessions/vertex_ai_session_service.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 1355
  id: google.adk.sessions.vertex_ai_session_service.VertexAiSessionService.__init__
  name: __init__
  file_path: src/google/adk/sessions/vertex_ai_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the VertexAiSessionService.\n\nArgs:\n  project: The project id of the project to use.\n  location: The location of the project to use.\n  agent_engine_id: The resource ID of the agent engine to use.\n  express_mode_api_key: The API key to use for Express Mode. If not\n    provided, the API key from the GOOGLE_API_KEY environment variable will\n    be used. It will only be used if GOOGLE_GENAI_USE_VERTEXAI is true.\n    Do not use Google AI Studio API key for this field. For more details,\n    visit\n    https://cloud.google.com/vertex-ai/generative-ai/docs/start/express-mode/overview"
  signature: 'def __init__(self, project: typing.Optional[str], location: typing.Optional[str], agent_engine_id: typing.Optional[str], *, express_mode_api_key: typing.Optional[str]=None):'
- rank: 1356
  id: google.adk.sessions.vertex_ai_session_service.VertexAiSessionService.append_event
  name: append_event
  file_path: src/google/adk/sessions/vertex_ai_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def append_event(self, session: google.adk.sessions.session.Session, event: google.adk.events.event.Event) -> google.adk.events.event.Event:'
- rank: 1357
  id: google.adk.sessions.vertex_ai_session_service.VertexAiSessionService.create_session
  name: create_session
  file_path: src/google/adk/sessions/vertex_ai_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Creates a new session.\n\nArgs:\n  app_name: The name of the application.\n  user_id: The ID of the user.\n  state: The initial state of the session.\n  session_id: The ID of the session.\n  **kwargs: Additional arguments to pass to the session creation. E.g. set\n    expire_time='2025-10-01T00:00:00Z' to set the session expiration time.\n    See https://cloud.google.com/vertex-ai/generative-ai/docs/reference/rest/v1beta1/projects.locations.reasoningEngines.sessions\n    for more details.\nReturns:\n  The created session."
  signature: 'def create_session(self, *, app_name: str, user_id: str, state: typing.Optional[dict[str, typing.Any]]=None, session_id: typing.Optional[str]=None) -> google.adk.sessions.session.Session:'
- rank: 1358
  id: google.adk.sessions.vertex_ai_session_service.VertexAiSessionService.delete_session
  name: delete_session
  file_path: src/google/adk/sessions/vertex_ai_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def delete_session(self, *, app_name: str, user_id: str, session_id: str) -> None:'
- rank: 1359
  id: google.adk.sessions.vertex_ai_session_service.VertexAiSessionService.get_session
  name: get_session
  file_path: src/google/adk/sessions/vertex_ai_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_session(self, *, app_name: str, user_id: str, session_id: str, config: typing.Optional[google.adk.sessions.base_session_service.GetSessionConfig]=None) -> typing.Optional[google.adk.sessions.session.Session]:'
- rank: 1360
  id: google.adk.sessions.vertex_ai_session_service.VertexAiSessionService.list_sessions
  name: list_sessions
  file_path: src/google/adk/sessions/vertex_ai_session_service.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def list_sessions(self, *, app_name: str, user_id: typing.Optional[str]=None) -> google.adk.sessions.base_session_service.ListSessionsResponse:'
- rank: 1361
  id: google.adk.telemetry
  name: telemetry
  file_path: src/google/adk/telemetry/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: '__all__: Any'
- rank: 1362
  id: google.adk.telemetry.google_cloud
  name: google_cloud
  file_path: src/google/adk/telemetry/google_cloud.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def get_gcp_exporters(enable_cloud_tracing: bool, enable_cloud_metrics: bool, enable_cloud_logging: bool, google_auth: typing.Optional[tuple[google.auth.credentials.Credentials, str]]) -> google.adk.telemetry.setup.OTelHooks:'
    docstring: "Returns GCP OTel exporters to be used in the app.\n\nArgs:\n  enable_tracing: whether to enable tracing to Cloud Trace.\n  enable_metrics: whether to enable reporting metrics to Cloud Monitoring.\n  enable_logging: whether to enable sending logs to Cloud Logging.\n  google_auth: optional custom credentials and project_id. google.auth.default() used when this is omitted."
  - signature: 'def get_gcp_resource(project_id: typing.Optional[str]) -> opentelemetry.sdk.resources.Resource:'
    docstring: "Returns OTEL with attributes specified in the following order (attributes specified later, overwrite those specified earlier):\n1. Populates gcp.project_id attribute from the project_id argument if present.\n2. OTELResourceDetector populates resource labels from environment variables like OTEL_SERVICE_NAME and OTEL_RESOURCE_ATTRIBUTES.\n3. GCP detector adds attributes corresponding to a correct monitored resource if ADK runs on one of supported platforms (e.g. GCE, GKE, CloudRun).\n\nArgs:\n  project_id: project id to fill out as `gcp.project_id` on the OTEL resource.\n  This may be overwritten by OTELResourceDetector, if `gcp.project_id` is present in `OTEL_RESOURCE_ATTRIBUTES` env var."
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: '_GCP_LOG_NAME_ENV_VARIABLE_NAME: str'
  - signature: '_DEFAULT_LOG_NAME: str'
- rank: 1363
  id: google.adk.telemetry.google_cloud.get_gcp_exporters
  name: get_gcp_exporters
  file_path: src/google/adk/telemetry/google_cloud.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Returns GCP OTel exporters to be used in the app.\n\nArgs:\n  enable_tracing: whether to enable tracing to Cloud Trace.\n  enable_metrics: whether to enable reporting metrics to Cloud Monitoring.\n  enable_logging: whether to enable sending logs to Cloud Logging.\n  google_auth: optional custom credentials and project_id. google.auth.default() used when this is omitted."
  signature: 'def get_gcp_exporters(enable_cloud_tracing: bool, enable_cloud_metrics: bool, enable_cloud_logging: bool, google_auth: typing.Optional[tuple[google.auth.credentials.Credentials, str]]) -> google.adk.telemetry.setup.OTelHooks:'
- rank: 1364
  id: google.adk.telemetry.google_cloud.get_gcp_resource
  name: get_gcp_resource
  file_path: src/google/adk/telemetry/google_cloud.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Returns OTEL with attributes specified in the following order (attributes specified later, overwrite those specified earlier):\n1. Populates gcp.project_id attribute from the project_id argument if present.\n2. OTELResourceDetector populates resource labels from environment variables like OTEL_SERVICE_NAME and OTEL_RESOURCE_ATTRIBUTES.\n3. GCP detector adds attributes corresponding to a correct monitored resource if ADK runs on one of supported platforms (e.g. GCE, GKE, CloudRun).\n\nArgs:\n  project_id: project id to fill out as `gcp.project_id` on the OTEL resource.\n  This may be overwritten by OTELResourceDetector, if `gcp.project_id` is present in `OTEL_RESOURCE_ATTRIBUTES` env var."
  signature: 'def get_gcp_resource(project_id: typing.Optional[str]) -> opentelemetry.sdk.resources.Resource:'
- rank: 1365
  id: google.adk.telemetry.setup
  name: setup
  file_path: src/google/adk/telemetry/setup.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def maybe_set_otel_providers(otel_hooks_to_setup: list[google.adk.telemetry.setup.OTelHooks], otel_resource: typing.Optional[opentelemetry.sdk.resources.Resource]):'
    docstring: "Sets up OTel providers if hooks for a given telemetry type were\npassed.\n\nAdditionally adds generic OTLP exporters based on following env variables:\nOTEL_EXPORTER_OTLP_ENDPOINT\nOTEL_EXPORTER_OTLP_TRACES_ENDPOINT\nOTEL_EXPORTER_OTLP_METRICS_ENDPOINT\nOTEL_EXPORTER_OTLP_LOGS_ENDPOINT\nSee https://opentelemetry.io/docs/languages/sdk-configuration/otlp-exporter/\nfor how they are used.\n\nIf a provider for a specific telemetry type was already globally set -\nthis function will not override it or register more exporters.\n\nArgs:\n  otel_hooks_to_setup: per-telemetry-type processors and readers to be added\n  to OTel providers. If no hooks for a specific telemetry type are passed -\n  provider will not be set.\n  otel_resource: OTel resource to use in providers.\n  If empty - default OTel resource detection will be used."
- rank: 1366
  id: google.adk.telemetry.setup.OTelHooks
  name: OTelHooks
  file_path: src/google/adk/telemetry/setup.py
  type: CLASS
  group: Orphan
  usage_score: 0
  constructor_signature: 'def __init__(self, *, span_processors: list[opentelemetry.sdk.trace.SpanProcessor] = list(), metric_readers: list[opentelemetry.sdk.metrics.export.MetricReader] = list(), log_record_processors: list[opentelemetry.sdk._logs.LogRecordProcessor] = list()):'
  properties:
  - signature: 'span_processors: list[opentelemetry.sdk.trace.SpanProcessor]'
  - signature: 'metric_readers: list[opentelemetry.sdk.metrics.export.MetricReader]'
  - signature: 'log_record_processors: list[opentelemetry.sdk._logs.LogRecordProcessor]'
- rank: 1367
  id: google.adk.telemetry.setup.maybe_set_otel_providers
  name: maybe_set_otel_providers
  file_path: src/google/adk/telemetry/setup.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Sets up OTel providers if hooks for a given telemetry type were\npassed.\n\nAdditionally adds generic OTLP exporters based on following env variables:\nOTEL_EXPORTER_OTLP_ENDPOINT\nOTEL_EXPORTER_OTLP_TRACES_ENDPOINT\nOTEL_EXPORTER_OTLP_METRICS_ENDPOINT\nOTEL_EXPORTER_OTLP_LOGS_ENDPOINT\nSee https://opentelemetry.io/docs/languages/sdk-configuration/otlp-exporter/\nfor how they are used.\n\nIf a provider for a specific telemetry type was already globally set -\nthis function will not override it or register more exporters.\n\nArgs:\n  otel_hooks_to_setup: per-telemetry-type processors and readers to be added\n  to OTel providers. If no hooks for a specific telemetry type are passed -\n  provider will not be set.\n  otel_resource: OTel resource to use in providers.\n  If empty - default OTel resource detection will be used."
  signature: 'def maybe_set_otel_providers(otel_hooks_to_setup: list[google.adk.telemetry.setup.OTelHooks], otel_resource: typing.Optional[opentelemetry.sdk.resources.Resource]):'
- rank: 1368
  id: google.adk.telemetry.tracing
  name: tracing
  file_path: src/google/adk/telemetry/tracing.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def trace_agent_invocation(span: opentelemetry.trace.Span, agent: google.adk.agents.base_agent.BaseAgent, ctx: google.adk.agents.invocation_context.InvocationContext) -> None:'
    docstring: "Sets span attributes immediately available on agent invocation according to OTEL semconv version 1.37.\n\nArgs:\n  span: Span on which attributes are set.\n  agent: Agent from which attributes are gathered.\n  ctx: InvocationContext from which attributes are gathered.\n\nInference related fields are not set, due to their planned removal from invoke_agent span:\nhttps://github.com/open-telemetry/semantic-conventions/issues/2632\n\n`gen_ai.agent.id` is not set because currently it's unclear what attributes this field should have, specifically:\n- In which scope should it be unique (globally, given project, given agentic flow, given deployment).\n- Should it be unchanging between deployments, and how this should this be achieved.\n\n`gen_ai.data_source.id` is not set because it's not available.\nClosest type which could contain this information is types.GroundingMetadata, which does not have an ID.\n\n`server.*` attributes are not set pending confirmation from aabmass."
  - signature: 'def trace_tool_call(tool: google.adk.tools.base_tool.BaseTool, args: dict[str, typing.Any], function_response_event: Event | None):'
    docstring: "Traces tool call.\n\nArgs:\n  tool: The tool that was called.\n  args: The arguments to the tool call.\n  function_response_event: The event with the function response details."
  - signature: 'def trace_merged_tool_calls(response_event_id: str, function_response_event: google.adk.events.event.Event):'
    docstring: "Traces merged tool call events.\n\nCalling this function is not needed for telemetry purposes. This is provided\nfor preventing /debug/trace requests (typically sent by web UI).\n\nArgs:\n  response_event_id: The ID of the response event.\n  function_response_event: The merged response event."
  - signature: 'def trace_call_llm(invocation_context: google.adk.agents.invocation_context.InvocationContext, event_id: str, llm_request: google.adk.models.llm_request.LlmRequest, llm_response: google.adk.models.llm_response.LlmResponse, span: Span | None):'
    docstring: "Traces a call to the LLM.\n\nThis function records details about the LLM request and response as\nattributes on the current OpenTelemetry span.\n\nArgs:\n  invocation_context: The invocation context for the current agent run.\n  event_id: The ID of the event.\n  llm_request: The LLM request object.\n  llm_response: The LLM response object."
  - signature: 'def trace_send_data(invocation_context: google.adk.agents.invocation_context.InvocationContext, event_id: str, data: list[google.genai.types.Content]):'
    docstring: "Traces the sending of data to the agent.\n\nThis function records details about the data sent to the agent as\nattributes on the current OpenTelemetry span.\n\nArgs:\n  invocation_context: The invocation context for the current agent run.\n  event_id: The ID of the event.\n  data: A list of content objects."
  - signature: 'def use_generate_content_span(llm_request: google.adk.models.llm_request.LlmRequest, invocation_context: google.adk.agents.invocation_context.InvocationContext, model_response_event: google.adk.events.event.Event) -> collections.abc.Iterator[Span | None]:'
    docstring: 'Context manager encompassing `generate_content {model.name}` span.


      When an external library for inference instrumentation is installed (e.g. opentelemetry-instrumentation-google-genai),

      span creation is delegated to said library.'
  - signature: 'def trace_generate_content_result(span: Span | None, llm_response: google.adk.models.llm_response.LlmResponse):'
    docstring: Trace result of the inference in generate_content span.
  properties:
  - signature: 'ADK_CAPTURE_MESSAGE_CONTENT_IN_SPANS: str'
  - signature: 'OTEL_INSTRUMENTATION_GENAI_CAPTURE_MESSAGE_CONTENT: str'
  - signature: 'USER_CONTENT_ELIDED: str'
  - signature: 'tracer: opentelemetry.trace.get_tracer'
  - signature: 'otel_logger: opentelemetry._logs.get_logger'
  - signature: 'logger: logging.getLogger'
- rank: 1369
  id: google.adk.telemetry.tracing.trace_agent_invocation
  name: trace_agent_invocation
  file_path: src/google/adk/telemetry/tracing.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Sets span attributes immediately available on agent invocation according to OTEL semconv version 1.37.\n\nArgs:\n  span: Span on which attributes are set.\n  agent: Agent from which attributes are gathered.\n  ctx: InvocationContext from which attributes are gathered.\n\nInference related fields are not set, due to their planned removal from invoke_agent span:\nhttps://github.com/open-telemetry/semantic-conventions/issues/2632\n\n`gen_ai.agent.id` is not set because currently it's unclear what attributes this field should have, specifically:\n- In which scope should it be unique (globally, given project, given agentic flow, given deployment).\n- Should it be unchanging between deployments, and how this should this be achieved.\n\n`gen_ai.data_source.id` is not set because it's not available.\nClosest type which could contain this information is types.GroundingMetadata, which does not have an ID.\n\n`server.*` attributes are not set pending confirmation from aabmass."
  signature: 'def trace_agent_invocation(span: opentelemetry.trace.Span, agent: google.adk.agents.base_agent.BaseAgent, ctx: google.adk.agents.invocation_context.InvocationContext) -> None:'
- rank: 1370
  id: google.adk.telemetry.tracing.trace_call_llm
  name: trace_call_llm
  file_path: src/google/adk/telemetry/tracing.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Traces a call to the LLM.\n\nThis function records details about the LLM request and response as\nattributes on the current OpenTelemetry span.\n\nArgs:\n  invocation_context: The invocation context for the current agent run.\n  event_id: The ID of the event.\n  llm_request: The LLM request object.\n  llm_response: The LLM response object."
  signature: 'def trace_call_llm(invocation_context: google.adk.agents.invocation_context.InvocationContext, event_id: str, llm_request: google.adk.models.llm_request.LlmRequest, llm_response: google.adk.models.llm_response.LlmResponse, span: Span | None):'
  aliases:
  - google.adk.telemetry.trace_call_llm
- rank: 1371
  id: google.adk.telemetry.tracing.trace_generate_content_result
  name: trace_generate_content_result
  file_path: src/google/adk/telemetry/tracing.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Trace result of the inference in generate_content span.
  signature: 'def trace_generate_content_result(span: Span | None, llm_response: google.adk.models.llm_response.LlmResponse):'
- rank: 1372
  id: google.adk.telemetry.tracing.trace_merged_tool_calls
  name: trace_merged_tool_calls
  file_path: src/google/adk/telemetry/tracing.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Traces merged tool call events.\n\nCalling this function is not needed for telemetry purposes. This is provided\nfor preventing /debug/trace requests (typically sent by web UI).\n\nArgs:\n  response_event_id: The ID of the response event.\n  function_response_event: The merged response event."
  signature: 'def trace_merged_tool_calls(response_event_id: str, function_response_event: google.adk.events.event.Event):'
  aliases:
  - google.adk.telemetry.trace_merged_tool_calls
- rank: 1373
  id: google.adk.telemetry.tracing.trace_send_data
  name: trace_send_data
  file_path: src/google/adk/telemetry/tracing.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Traces the sending of data to the agent.\n\nThis function records details about the data sent to the agent as\nattributes on the current OpenTelemetry span.\n\nArgs:\n  invocation_context: The invocation context for the current agent run.\n  event_id: The ID of the event.\n  data: A list of content objects."
  signature: 'def trace_send_data(invocation_context: google.adk.agents.invocation_context.InvocationContext, event_id: str, data: list[google.genai.types.Content]):'
  aliases:
  - google.adk.telemetry.trace_send_data
- rank: 1374
  id: google.adk.telemetry.tracing.trace_tool_call
  name: trace_tool_call
  file_path: src/google/adk/telemetry/tracing.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Traces tool call.\n\nArgs:\n  tool: The tool that was called.\n  args: The arguments to the tool call.\n  function_response_event: The event with the function response details."
  signature: 'def trace_tool_call(tool: google.adk.tools.base_tool.BaseTool, args: dict[str, typing.Any], function_response_event: Event | None):'
  aliases:
  - google.adk.telemetry.trace_tool_call
- rank: 1375
  id: google.adk.telemetry.tracing.use_generate_content_span
  name: use_generate_content_span
  file_path: src/google/adk/telemetry/tracing.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Context manager encompassing `generate_content {model.name}` span.


    When an external library for inference instrumentation is installed (e.g. opentelemetry-instrumentation-google-genai),

    span creation is delegated to said library.'
  signature: 'def use_generate_content_span(llm_request: google.adk.models.llm_request.LlmRequest, invocation_context: google.adk.agents.invocation_context.InvocationContext, model_response_event: google.adk.events.event.Event) -> collections.abc.Iterator[Span | None]:'
- rank: 1376
  id: google.adk.tools
  name: tools
  file_path: src/google/adk/tools/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: '_LAZY_MAPPING: Any'
  - signature: '__all__: list'
- rank: 1377
  id: google.adk.tools.agent_simulator
  name: agent_simulator
  file_path: src/google/adk/tools/agent_simulator/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: '__all__: Any'
- rank: 1378
  id: google.adk.tools.agent_simulator.agent_simulator_config
  name: agent_simulator_config
  file_path: src/google/adk/tools/agent_simulator/agent_simulator_config.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1379
  id: google.adk.tools.agent_simulator.agent_simulator_config.AgentSimulatorConfig
  name: AgentSimulatorConfig
  file_path: src/google/adk/tools/agent_simulator/agent_simulator_config.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Configuration for AgentSimulator.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, tool_simulation_configs: typing.List[google.adk.tools.agent_simulator.agent_simulator_config.ToolSimulationConfig] = list(), simulation_model: str = ''gemini-2.5-flash'', simulation_model_configuration: google.genai.types.GenerateContentConfig = Factory(lambda: genai_types.GenerateContentConfig(thinking_config=genai_types.ThinkingConfig(include_thoughts=True, thinking_budget=10240))), tracing_path: typing.Optional[str] = None):'
  methods:
  - signature: 'def check_tool_simulation_configs(cls, v: typing.List[google.adk.tools.agent_simulator.agent_simulator_config.ToolSimulationConfig]):'
    docstring: Checks that tool_simulation_configs is not empty.
  properties:
  - signature: 'tool_simulation_configs: typing.List[google.adk.tools.agent_simulator.agent_simulator_config.ToolSimulationConfig]'
    docstring: A list of tool simulation configurations.
  - signature: 'simulation_model: str'
    docstring: The model to use for internal simulator LLM calls (tool analysis, mock responses).
  - signature: 'simulation_model_configuration: google.genai.types.GenerateContentConfig'
    docstring: The configuration for the internal simulator LLM calls.
  - signature: 'tracing_path: typing.Optional[str]'
    docstring: 'The path to the tracing file to be used for mocking. Only used if the

      mock_strategy_type is MOCK_STRATEGY_TRACING.'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1380
  id: google.adk.tools.agent_simulator.agent_simulator_config.AgentSimulatorConfig.check_tool_simulation_configs
  name: check_tool_simulation_configs
  file_path: src/google/adk/tools/agent_simulator/agent_simulator_config.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Checks that tool_simulation_configs is not empty.
  signature: 'def check_tool_simulation_configs(cls, v: typing.List[google.adk.tools.agent_simulator.agent_simulator_config.ToolSimulationConfig]):'
- rank: 1381
  id: google.adk.tools.agent_simulator.agent_simulator_config.InjectedError
  name: InjectedError
  file_path: src/google/adk/tools/agent_simulator/agent_simulator_config.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'An error to be injected into a tool call.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, injected_http_error_code: int, error_message: str):'
  properties:
  - signature: 'injected_http_error_code: int'
    docstring: 'Inject http error code to the tool call. Will present as "error_code"

      in the tool response dict.'
  - signature: 'error_message: str'
    docstring: 'Inject error message to the tool call. Will present as

      "error_message" in the tool response dict.'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1382
  id: google.adk.tools.agent_simulator.agent_simulator_config.InjectionConfig
  name: InjectionConfig
  file_path: src/google/adk/tools/agent_simulator/agent_simulator_config.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Injection configuration for a tool.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, injection_probability: float = 1.0, match_args: typing.Optional[typing.Dict[str, typing.Any]] = None, injected_latency_seconds: float = 0.0, random_seed: typing.Optional[int] = None, injected_error: typing.Optional[google.adk.tools.agent_simulator.agent_simulator_config.InjectedError] = None, injected_response: typing.Optional[typing.Dict[str, typing.Any]] = None):'
  methods:
  - signature: 'def check_injected_error_or_response(self) -> Self:'
    docstring: Checks that either injected_error or injected_response is set.
  properties:
  - signature: 'injection_probability: float'
    docstring: Probability of injecting the injected_value.
  - signature: 'match_args: typing.Optional[typing.Dict[str, typing.Any]]'
    docstring: 'Only apply injection if the request matches the match_args.

      If match_args is not provided, the injection will be applied to all

      requests.'
  - signature: 'injected_latency_seconds: float'
    docstring: "Inject latency to the tool call. Please note it may not be accurate if                                                                                                                                                                                             \u2502\nthe interceptor is applied as after tool callback."
  - signature: 'random_seed: typing.Optional[int]'
    docstring: The random seed to use for this injection.
  - signature: 'injected_error: typing.Optional[google.adk.tools.agent_simulator.agent_simulator_config.InjectedError]'
    docstring: The injected error.
  - signature: 'injected_response: typing.Optional[typing.Dict[str, typing.Any]]'
    docstring: The injected response.
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1383
  id: google.adk.tools.agent_simulator.agent_simulator_config.InjectionConfig.check_injected_error_or_response
  name: check_injected_error_or_response
  file_path: src/google/adk/tools/agent_simulator/agent_simulator_config.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Checks that either injected_error or injected_response is set.
  signature: 'def check_injected_error_or_response(self) -> Self:'
- rank: 1384
  id: google.adk.tools.agent_simulator.agent_simulator_config.MockStrategy
  name: MockStrategy
  file_path: src/google/adk/tools/agent_simulator/agent_simulator_config.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Mock strategy for a tool.


    [Note: Inherited members from enum.Enum are omitted.]'
  properties:
  - signature: 'MOCK_STRATEGY_UNSPECIFIED: int'
  - signature: 'MOCK_STRATEGY_TOOL_SPEC: int'
    docstring: Use tool specifications to mock the tool response.
  - signature: 'MOCK_STRATEGY_TRACING: int'
    docstring: 'Use provided tracing and tool specifications to mock the tool

      response based on llm response. Need to provide tracing path in

      command.'
  omitted_inherited_members_from:
  - enum.Enum
- rank: 1385
  id: google.adk.tools.agent_simulator.agent_simulator_config.ToolSimulationConfig
  name: ToolSimulationConfig
  file_path: src/google/adk/tools/agent_simulator/agent_simulator_config.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Simulation configuration for a single tool.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, tool_name: str, injection_configs: typing.List[google.adk.tools.agent_simulator.agent_simulator_config.InjectionConfig] = list(), mock_strategy_type: google.adk.tools.agent_simulator.agent_simulator_config.MockStrategy = MockStrategy.MOCK_STRATEGY_UNSPECIFIED):'
  methods:
  - signature: 'def check_mock_strategy_type(self) -> Self:'
    docstring: Checks that mock_strategy_type is not UNSPECIFIED if no injections.
  properties:
  - signature: 'tool_name: str'
    docstring: Name of the tool to be simulated.
  - signature: 'injection_configs: typing.List[google.adk.tools.agent_simulator.agent_simulator_config.InjectionConfig]'
    docstring: 'Injection configuration for the tool. If provided, the tool will be

      injected with the injected_value with the injection_probability first,

      the mock_strategy will be applied if no injection config is hit.'
  - signature: 'mock_strategy_type: google.adk.tools.agent_simulator.agent_simulator_config.MockStrategy'
    docstring: The mock strategy to use.
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1386
  id: google.adk.tools.agent_simulator.agent_simulator_config.ToolSimulationConfig.check_mock_strategy_type
  name: check_mock_strategy_type
  file_path: src/google/adk/tools/agent_simulator/agent_simulator_config.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Checks that mock_strategy_type is not UNSPECIFIED if no injections.
  signature: 'def check_mock_strategy_type(self) -> Self:'
- rank: 1387
  id: google.adk.tools.agent_simulator.agent_simulator_engine
  name: agent_simulator_engine
  file_path: src/google/adk/tools/agent_simulator/agent_simulator_engine.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'agent_simulator_logger: logging.getLogger'
- rank: 1388
  id: google.adk.tools.agent_simulator.agent_simulator_engine.AgentSimulatorEngine
  name: AgentSimulatorEngine
  file_path: src/google/adk/tools/agent_simulator/agent_simulator_engine.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Core engine to handle the simulation logic.
  constructor_signature: 'def __init__(self, config: google.adk.tools.agent_simulator.agent_simulator_config.AgentSimulatorConfig):'
  methods:
  - signature: 'def simulate(self, tool: google.adk.tools.base_tool.BaseTool, args: typing.Dict[str, typing.Any], tool_context: typing.Any) -> typing.Optional[typing.Dict[str, typing.Any]]:'
    docstring: Simulates a tool call.
- rank: 1389
  id: google.adk.tools.agent_simulator.agent_simulator_engine.AgentSimulatorEngine.__init__
  name: __init__
  file_path: src/google/adk/tools/agent_simulator/agent_simulator_engine.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, config: google.adk.tools.agent_simulator.agent_simulator_config.AgentSimulatorConfig):'
- rank: 1390
  id: google.adk.tools.agent_simulator.agent_simulator_engine.AgentSimulatorEngine.simulate
  name: simulate
  file_path: src/google/adk/tools/agent_simulator/agent_simulator_engine.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Simulates a tool call.
  signature: 'def simulate(self, tool: google.adk.tools.base_tool.BaseTool, args: typing.Dict[str, typing.Any], tool_context: typing.Any) -> typing.Optional[typing.Dict[str, typing.Any]]:'
- rank: 1391
  id: google.adk.tools.agent_simulator.agent_simulator_factory
  name: agent_simulator_factory
  file_path: src/google/adk/tools/agent_simulator/agent_simulator_factory.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1392
  id: google.adk.tools.agent_simulator.agent_simulator_factory.AgentSimulatorFactory
  name: AgentSimulatorFactory
  file_path: src/google/adk/tools/agent_simulator/agent_simulator_factory.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Factory for creating AgentSimulator instances.
  methods:
  - signature: 'def create_callback(config: google.adk.tools.agent_simulator.agent_simulator_config.AgentSimulatorConfig) -> typing.Callable[[BaseTool, Dict[str, Any], Any], typing.Awaitable[typing.Optional[typing.Dict[str, typing.Any]]]]:'
    docstring: "Creates a callback function for AgentSimulator.\n\nArgs:\n  config: The configuration for the AgentSimulator.\n\nReturns:\n  A callable that can be used as a before_tool_callback or after_tool_callback."
  - signature: 'def create_plugin(config: google.adk.tools.agent_simulator.agent_simulator_config.AgentSimulatorConfig) -> google.adk.tools.agent_simulator.agent_simulator_plugin.AgentSimulatorPlugin:'
    docstring: "Creates an ADK Plugin for AgentSimulator.\n\nArgs:\n  config: The configuration for the AgentSimulator.\n\nReturns:\n  An instance of AgentSimulatorPlugin that can be used as an ADK plugin."
- rank: 1393
  id: google.adk.tools.agent_simulator.agent_simulator_factory.AgentSimulatorFactory.create_callback
  name: create_callback
  file_path: src/google/adk/tools/agent_simulator/agent_simulator_factory.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Creates a callback function for AgentSimulator.\n\nArgs:\n  config: The configuration for the AgentSimulator.\n\nReturns:\n  A callable that can be used as a before_tool_callback or after_tool_callback."
  signature: 'def create_callback(config: google.adk.tools.agent_simulator.agent_simulator_config.AgentSimulatorConfig) -> typing.Callable[[BaseTool, Dict[str, Any], Any], typing.Awaitable[typing.Optional[typing.Dict[str, typing.Any]]]]:'
- rank: 1394
  id: google.adk.tools.agent_simulator.agent_simulator_factory.AgentSimulatorFactory.create_plugin
  name: create_plugin
  file_path: src/google/adk/tools/agent_simulator/agent_simulator_factory.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Creates an ADK Plugin for AgentSimulator.\n\nArgs:\n  config: The configuration for the AgentSimulator.\n\nReturns:\n  An instance of AgentSimulatorPlugin that can be used as an ADK plugin."
  signature: 'def create_plugin(config: google.adk.tools.agent_simulator.agent_simulator_config.AgentSimulatorConfig) -> google.adk.tools.agent_simulator.agent_simulator_plugin.AgentSimulatorPlugin:'
- rank: 1395
  id: google.adk.tools.agent_simulator.agent_simulator_plugin
  name: agent_simulator_plugin
  file_path: src/google/adk/tools/agent_simulator/agent_simulator_plugin.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1396
  id: google.adk.tools.agent_simulator.agent_simulator_plugin.AgentSimulatorPlugin
  name: AgentSimulatorPlugin
  file_path: src/google/adk/tools/agent_simulator/agent_simulator_plugin.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'ADK Plugin for AgentSimulator.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, simulator_engine: google.adk.tools.agent_simulator.agent_simulator_engine.AgentSimulatorEngine):'
  methods:
  - signature: 'def before_tool_callback(self, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Optional[typing.Dict[str, typing.Any]]:'
    docstring: Invokes the AgentSimulatorEngine before a tool call.
  properties:
  - signature: 'name: str'
  inherited_methods:
    BasePlugin:
    - signature: 'def on_user_message_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, user_message: google.genai.types.Content) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed when a user message is received before an invocation starts.\n\nThis callback helps logging and modifying the user message before the\nrunner starts the invocation.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n  user_message: The message content input by user.\n\nReturns:\n  An optional `types.Content` to be returned to the ADK. Returning a\n  value to replace the user message. Returning `None` to proceed\n  normally."
    - signature: 'def before_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed before the ADK runner runs.\n\nThis is the first callback to be called in the lifecycle, ideal for global\nsetup or initialization tasks.\n\nArgs:\n  invocation_context: The context for the entire invocation, containing\n    session information, the root agent, etc.\n\nReturns:\n  An optional `Event` to be returned to the ADK. Returning a value to\n  halt execution of the runner and ends the runner with that event. Return\n  `None` to proceed normally."
    - signature: 'def on_event_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext, event: google.adk.events.event.Event) -> typing.Optional[google.adk.events.event.Event]:'
      docstring: "Callback executed after an event is yielded from runner.\n\nThis is the ideal place to make modification to the event before the event\nis handled by the underlying agent app.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n  event: The event raised by the runner.\n\nReturns:\n  An optional value. A non-`None` return may be used by the framework to\n  modify or replace the response. Returning `None` allows the original\n  response to be used."
    - signature: 'def after_run_callback(self, *, invocation_context: google.adk.agents.invocation_context.InvocationContext) -> None:'
      docstring: "Callback executed after an ADK runner run has completed.\n\nThis is the final callback in the ADK lifecycle, suitable for cleanup, final\nlogging, or reporting tasks.\n\nArgs:\n  invocation_context: The context for the entire invocation.\n\nReturns:\n  None"
    - signature: 'def close(self) -> None:'
      docstring: 'Method executed when the runner is closed.


        This method is used for cleanup tasks such as closing network connections

        or releasing resources.'
    - signature: 'def before_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed before an agent's primary logic is invoked.\n\nThis callback can be used for logging, setup, or to short-circuit the\nagent's execution by returning a value.\n\nArgs:\n  agent: The agent that is about to run.\n  callback_context: The context for the agent invocation.\n\nReturns:\n  An optional `types.Content` object. If a value is returned, it will bypass\n  the agent's callbacks and its execution, and return this value directly.\n  Returning `None` allows the agent to proceed normally."
    - signature: 'def after_agent_callback(self, *, agent: google.adk.agents.base_agent.BaseAgent, callback_context: google.adk.agents.callback_context.CallbackContext) -> typing.Optional[google.genai.types.Content]:'
      docstring: "Callback executed after an agent's primary logic has completed.\n\nArgs:\n  agent: The agent that has just run.\n  callback_context: The context for the agent invocation.\n\nReturns:\n  An optional `types.Content` object. The content to return to the user.\n  When the content is present, the provided content will be used as agent\n  response and appended to event history as agent response."
    - signature: 'def before_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed before a request is sent to the model.\n\nThis provides an opportunity to inspect, log, or modify the `LlmRequest`\nobject. It can also be used to implement caching by returning a cached\n`LlmResponse`, which would skip the actual model call.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_request: The prepared request object to be sent to the model.\n\nReturns:\n  An optional value. The interpretation of a non-`None` trigger an early\n  exit and returns the response immediately. Returning `None` allows the LLM\n  request to proceed normally."
    - signature: 'def after_model_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_response: google.adk.models.llm_response.LlmResponse) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed after a response is received from the model.\n\nThis is the ideal place to log model responses, collect metrics on token\nusage, or perform post-processing on the raw `LlmResponse`.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_response: The response object received from the model.\n\nReturns:\n  An optional value. A non-`None` return may be used by the framework to\n  modify or replace the response. Returning `None` allows the original\n  response to be used."
    - signature: 'def on_model_error_callback(self, *, callback_context: google.adk.agents.callback_context.CallbackContext, llm_request: google.adk.models.llm_request.LlmRequest, error: Exception) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
      docstring: "Callback executed when a model call encounters an error.\n\nThis callback provides an opportunity to handle model errors gracefully,\npotentially providing alternative responses or recovery mechanisms.\n\nArgs:\n  callback_context: The context for the current agent call.\n  llm_request: The request that was sent to the model when the error\n    occurred.\n  error: The exception that was raised during model execution.\n\nReturns:\n  An optional LlmResponse. If an LlmResponse is returned, it will be used\n  instead of propagating the error. Returning `None` allows the original\n  error to be raised."
    - signature: 'def before_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Optional[dict]:'
      docstring: "Callback executed before a tool is called.\n\nThis callback is useful for logging tool usage, input validation, or\nmodifying the arguments before they are passed to the tool.\n\nArgs:\n  tool: The tool instance that is about to be executed.\n  tool_args: The dictionary of arguments to be used for invoking the tool.\n  tool_context: The context specific to the tool execution.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will stop the tool\n  execution and return this response immediately. Returning `None` uses the\n  original, unmodified arguments."
    - signature: 'def after_tool_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, result: dict) -> typing.Optional[dict]:'
      docstring: "Callback executed after a tool has been called.\n\nThis callback allows for inspecting, logging, or modifying the result\nreturned by a tool.\n\nArgs:\n  tool: The tool instance that has just been executed.\n  tool_args: The original arguments that were passed to the tool.\n  tool_context: The context specific to the tool execution.\n  result: The dictionary returned by the tool invocation.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will **replace**\n  the original result from the tool. This allows for post-processing or\n  altering tool outputs. Returning `None` uses the original, unmodified\n  result."
    - signature: 'def on_tool_error_callback(self, *, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, error: Exception) -> typing.Optional[dict]:'
      docstring: "Callback executed when a tool call encounters an error.\n\nThis callback provides an opportunity to handle tool errors gracefully,\npotentially providing alternative responses or recovery mechanisms.\n\nArgs:\n  tool: The tool instance that encountered an error.\n  tool_args: The arguments that were passed to the tool.\n  tool_context: The context specific to the tool execution.\n  error: The exception that was raised during tool execution.\n\nReturns:\n  An optional dictionary. If a dictionary is returned, it will be used as\n  the tool response instead of propagating the error. Returning `None`\n  allows the original error to be raised."
  omitted_inherited_members_from:
  - ABC
- rank: 1397
  id: google.adk.tools.agent_simulator.agent_simulator_plugin.AgentSimulatorPlugin.before_tool_callback
  name: before_tool_callback
  file_path: src/google/adk/tools/agent_simulator/agent_simulator_plugin.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Invokes the AgentSimulatorEngine before a tool call.
  signature: 'def before_tool_callback(self, tool: google.adk.tools.base_tool.BaseTool, tool_args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Optional[typing.Dict[str, typing.Any]]:'
- rank: 1398
  id: google.adk.tools.agent_simulator.strategies
  name: strategies
  file_path: src/google/adk/tools/agent_simulator/strategies/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1399
  id: google.adk.tools.agent_simulator.strategies.base
  name: base
  file_path: src/google/adk/tools/agent_simulator/strategies/base.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1400
  id: google.adk.tools.agent_simulator.strategies.base.MockStrategy
  name: MockStrategy
  file_path: src/google/adk/tools/agent_simulator/strategies/base.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Base class for mock strategies.
  methods:
  - signature: 'def mock(self, tool: BaseTool, args: typing.Dict[str, typing.Any], tool_context: typing.Any, tool_connection_map: typing.Optional[google.adk.tools.agent_simulator.tool_connection_map.ToolConnectionMap], state_store: typing.Dict[str, typing.Any]) -> typing.Dict[str, typing.Any]:'
    docstring: Generates a mock response for a tool call.
- rank: 1401
  id: google.adk.tools.agent_simulator.strategies.base.MockStrategy.mock
  name: mock
  file_path: src/google/adk/tools/agent_simulator/strategies/base.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Generates a mock response for a tool call.
  signature: 'def mock(self, tool: BaseTool, args: typing.Dict[str, typing.Any], tool_context: typing.Any, tool_connection_map: typing.Optional[google.adk.tools.agent_simulator.tool_connection_map.ToolConnectionMap], state_store: typing.Dict[str, typing.Any]) -> typing.Dict[str, typing.Any]:'
- rank: 1402
  id: google.adk.tools.agent_simulator.strategies.base.TracingMockStrategy
  name: TracingMockStrategy
  file_path: src/google/adk/tools/agent_simulator/strategies/base.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Mocks a tool response based on tracing and an LLM.
  constructor_signature: 'def __init__(self, llm_name: str, llm_config: genai_types.GenerateContentConfig):'
  methods:
  - signature: 'def mock(self, tool: BaseTool, args: typing.Dict[str, typing.Any], tool_context: typing.Any, tool_connection_map: typing.Optional[google.adk.tools.agent_simulator.tool_connection_map.ToolConnectionMap], state_store: typing.Dict[str, typing.Any]) -> typing.Dict[str, typing.Any]:'
  inherited_methods:
    MockStrategy:
    - signature: 'def mock(self, tool: BaseTool, args: typing.Dict[str, typing.Any], tool_context: typing.Any, tool_connection_map: typing.Optional[google.adk.tools.agent_simulator.tool_connection_map.ToolConnectionMap], state_store: typing.Dict[str, typing.Any]) -> typing.Dict[str, typing.Any]:'
      docstring: Generates a mock response for a tool call.
- rank: 1403
  id: google.adk.tools.agent_simulator.strategies.base.TracingMockStrategy.__init__
  name: __init__
  file_path: src/google/adk/tools/agent_simulator/strategies/base.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, llm_name: str, llm_config: genai_types.GenerateContentConfig):'
- rank: 1404
  id: google.adk.tools.agent_simulator.strategies.base.TracingMockStrategy.mock
  name: mock
  file_path: src/google/adk/tools/agent_simulator/strategies/base.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def mock(self, tool: BaseTool, args: typing.Dict[str, typing.Any], tool_context: typing.Any, tool_connection_map: typing.Optional[google.adk.tools.agent_simulator.tool_connection_map.ToolConnectionMap], state_store: typing.Dict[str, typing.Any]) -> typing.Dict[str, typing.Any]:'
- rank: 1405
  id: google.adk.tools.agent_simulator.strategies.tool_spec_mock_strategy
  name: tool_spec_mock_strategy
  file_path: src/google/adk/tools/agent_simulator/strategies/tool_spec_mock_strategy.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: '_TOOL_SPEC_MOCK_PROMPT_TEMPLATE: str'
- rank: 1406
  id: google.adk.tools.agent_simulator.strategies.tool_spec_mock_strategy.ToolSpecMockStrategy
  name: ToolSpecMockStrategy
  file_path: src/google/adk/tools/agent_simulator/strategies/tool_spec_mock_strategy.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Mocks a tool response based on the tool's specification.
  constructor_signature: 'def __init__(self, llm_name: str, llm_config: google.genai.types.GenerateContentConfig):'
  methods:
  - signature: 'def mock(self, tool: google.adk.tools.base_tool.BaseTool, args: typing.Dict[str, typing.Any], tool_context: typing.Any, tool_connection_map: typing.Optional[google.adk.tools.agent_simulator.tool_connection_map.ToolConnectionMap], state_store: typing.Dict[str, typing.Any]) -> typing.Dict[str, typing.Any]:'
  inherited_methods:
    MockStrategy:
    - signature: 'def mock(self, tool: BaseTool, args: typing.Dict[str, typing.Any], tool_context: typing.Any, tool_connection_map: typing.Optional[google.adk.tools.agent_simulator.tool_connection_map.ToolConnectionMap], state_store: typing.Dict[str, typing.Any]) -> typing.Dict[str, typing.Any]:'
      docstring: Generates a mock response for a tool call.
- rank: 1407
  id: google.adk.tools.agent_simulator.strategies.tool_spec_mock_strategy.ToolSpecMockStrategy.__init__
  name: __init__
  file_path: src/google/adk/tools/agent_simulator/strategies/tool_spec_mock_strategy.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, llm_name: str, llm_config: google.genai.types.GenerateContentConfig):'
- rank: 1408
  id: google.adk.tools.agent_simulator.strategies.tool_spec_mock_strategy.ToolSpecMockStrategy.mock
  name: mock
  file_path: src/google/adk/tools/agent_simulator/strategies/tool_spec_mock_strategy.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def mock(self, tool: google.adk.tools.base_tool.BaseTool, args: typing.Dict[str, typing.Any], tool_context: typing.Any, tool_connection_map: typing.Optional[google.adk.tools.agent_simulator.tool_connection_map.ToolConnectionMap], state_store: typing.Dict[str, typing.Any]) -> typing.Dict[str, typing.Any]:'
- rank: 1409
  id: google.adk.tools.agent_simulator.tool_connection_analyzer
  name: tool_connection_analyzer
  file_path: src/google/adk/tools/agent_simulator/tool_connection_analyzer.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: '_TOOL_CONNECTION_ANALYSIS_PROMPT_TEMPLATE: str'
- rank: 1410
  id: google.adk.tools.agent_simulator.tool_connection_analyzer.ToolConnectionAnalyzer
  name: ToolConnectionAnalyzer
  file_path: src/google/adk/tools/agent_simulator/tool_connection_analyzer.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Uses an LLM to analyze stateful connections between tools. For example,

    get_ticket will consume a ticket_id created by create_ticket, the analyzer

    will create a list of such connections.'
  constructor_signature: 'def __init__(self, llm_name: str, llm_config: google.genai.types.GenerateContentConfig):'
  methods:
  - signature: 'def analyze(self, tools: typing.List[google.adk.tools.base_tool.BaseTool]) -> google.adk.tools.agent_simulator.tool_connection_map.ToolConnectionMap:'
    docstring: Analyzes a list of tools and returns a map of their connections.
- rank: 1411
  id: google.adk.tools.agent_simulator.tool_connection_analyzer.ToolConnectionAnalyzer.__init__
  name: __init__
  file_path: src/google/adk/tools/agent_simulator/tool_connection_analyzer.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, llm_name: str, llm_config: google.genai.types.GenerateContentConfig):'
- rank: 1412
  id: google.adk.tools.agent_simulator.tool_connection_analyzer.ToolConnectionAnalyzer.analyze
  name: analyze
  file_path: src/google/adk/tools/agent_simulator/tool_connection_analyzer.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Analyzes a list of tools and returns a map of their connections.
  signature: 'def analyze(self, tools: typing.List[google.adk.tools.base_tool.BaseTool]) -> google.adk.tools.agent_simulator.tool_connection_map.ToolConnectionMap:'
- rank: 1413
  id: google.adk.tools.agent_simulator.tool_connection_map
  name: tool_connection_map
  file_path: src/google/adk/tools/agent_simulator/tool_connection_map.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1414
  id: google.adk.tools.agent_simulator.tool_connection_map.StatefulParameter
  name: StatefulParameter
  file_path: src/google/adk/tools/agent_simulator/tool_connection_map.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Represents a stateful parameter and its connections.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, parameter_name: str, creating_tools: typing.List[str], consuming_tools: typing.List[str]):'
  properties:
  - signature: 'parameter_name: str'
    docstring: The name of the shared parameter (e.g., "ticket_id").
  - signature: 'creating_tools: typing.List[str]'
    docstring: A list of tools that generate this parameter.
  - signature: 'consuming_tools: typing.List[str]'
    docstring: A list of tools that use this parameter as input.
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1415
  id: google.adk.tools.agent_simulator.tool_connection_map.ToolConnectionMap
  name: ToolConnectionMap
  file_path: src/google/adk/tools/agent_simulator/tool_connection_map.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Represents the map of tool connections.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, stateful_parameters: typing.List[google.adk.tools.agent_simulator.tool_connection_map.StatefulParameter]):'
  properties:
  - signature: 'stateful_parameters: typing.List[google.adk.tools.agent_simulator.tool_connection_map.StatefulParameter]'
    docstring: A list of stateful parameters and their connections.
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1416
  id: google.adk.tools.agent_tool
  name: agent_tool
  file_path: src/google/adk/tools/agent_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1417
  id: google.adk.tools.agent_tool.AgentTool.__init__
  name: __init__
  file_path: src/google/adk/tools/agent_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, agent: google.adk.agents.base_agent.BaseAgent, skip_summarization: bool, *, include_plugins: bool=True):'
- rank: 1418
  id: google.adk.tools.agent_tool.AgentTool.from_config
  name: from_config
  file_path: src/google/adk/tools/agent_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def from_config(cls, config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.agent_tool.AgentTool:'
- rank: 1419
  id: google.adk.tools.agent_tool.AgentTool.run_async
  name: run_async
  file_path: src/google/adk/tools/agent_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
- rank: 1420
  id: google.adk.tools.agent_tool.AgentToolConfig
  name: AgentToolConfig
  file_path: src/google/adk/tools/agent_tool.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'The config for the AgentTool.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, agent: google.adk.agents.common_configs.AgentRefConfig, skip_summarization: bool = False, include_plugins: bool = True):'
  properties:
  - signature: 'agent: google.adk.agents.common_configs.AgentRefConfig'
    docstring: The reference to the agent instance.
  - signature: 'skip_summarization: bool'
    docstring: Whether to skip summarization of the agent output.
  - signature: 'include_plugins: bool'
    docstring: Whether to include plugins from parent runner context.
  inherited_properties:
    BaseToolConfig:
    - signature: 'model_config: pydantic.ConfigDict'
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1421
  id: google.adk.tools.api_registry
  name: api_registry
  file_path: src/google/adk/tools/api_registry.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'API_REGISTRY_URL: str'
- rank: 1422
  id: google.adk.tools.api_registry.ApiRegistry
  name: ApiRegistry
  file_path: src/google/adk/tools/api_registry.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Registry that provides McpToolsets for MCP servers registered in API Registry.
  constructor_signature: 'def __init__(self, api_registry_project_id: str, location: str, header_provider: Callable[[ReadonlyContext], dict[str, str]] | None):'
  methods:
  - signature: 'def get_toolset(self, mcp_server_name: str, tool_filter: ToolPredicate | list[str] | None, tool_name_prefix: str | None) -> google.adk.tools.mcp_tool.mcp_toolset.McpToolset:'
    docstring: "Return the MCP Toolset based on the params.\n\nArgs:\n  mcp_server_name: Filter to select the MCP server name to get tools from.\n  tool_filter: Optional filter to select specific tools. Can be a list of\n    tool names or a ToolPredicate function.\n  tool_name_prefix: Optional prefix to prepend to the names of the tools\n    returned by the toolset.\n\nReturns:\n  McpToolset: A toolset for the MCP server specified."
- rank: 1423
  id: google.adk.tools.api_registry.ApiRegistry.__init__
  name: __init__
  file_path: src/google/adk/tools/api_registry.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initialize the API Registry.\n\nArgs:\n  api_registry_project_id: The project ID for the Google Cloud API Registry.\n  location: The location of the API Registry resources.\n  header_provider: Optional function to provide additional headers for MCP\n    server calls."
  signature: 'def __init__(self, api_registry_project_id: str, location: str, header_provider: Callable[[ReadonlyContext], dict[str, str]] | None):'
- rank: 1424
  id: google.adk.tools.api_registry.ApiRegistry.get_toolset
  name: get_toolset
  file_path: src/google/adk/tools/api_registry.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Return the MCP Toolset based on the params.\n\nArgs:\n  mcp_server_name: Filter to select the MCP server name to get tools from.\n  tool_filter: Optional filter to select specific tools. Can be a list of\n    tool names or a ToolPredicate function.\n  tool_name_prefix: Optional prefix to prepend to the names of the tools\n    returned by the toolset.\n\nReturns:\n  McpToolset: A toolset for the MCP server specified."
  signature: 'def get_toolset(self, mcp_server_name: str, tool_filter: ToolPredicate | list[str] | None, tool_name_prefix: str | None) -> google.adk.tools.mcp_tool.mcp_toolset.McpToolset:'
- rank: 1425
  id: google.adk.tools.apihub_tool
  name: apihub_tool
  file_path: src/google/adk/tools/apihub_tool/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: '__all__: Any'
- rank: 1426
  id: google.adk.tools.apihub_tool.apihub_toolset
  name: apihub_toolset
  file_path: src/google/adk/tools/apihub_tool/apihub_toolset.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1427
  id: google.adk.tools.apihub_tool.apihub_toolset.APIHubToolset.__init__
  name: __init__
  file_path: src/google/adk/tools/apihub_tool/apihub_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the APIHubTool with the given parameters.\n\nExamples::\n\n  apihub_toolset = APIHubToolset(\n      apihub_resource_name=\"projects/test-project/locations/us-central1/apis/test-api\",\n      service_account_json=\"...\",\n  )\n\n  # Get all available tools\n  agent = LlmAgent(tools=[apihub_toolset])\n\n  apihub_toolset = APIHubToolset(\n      apihub_resource_name=\"projects/test-project/locations/us-central1/apis/test-api\",\n      service_account_json=\"...\",\n      tool_filter = ['my_tool']\n  )\n  # Get a specific tool\n  agent = LlmAgent(tools=[\n      ...,\n      apihub_toolset,\n  ])\n\n**apihub_resource_name** is the resource name from API Hub. It must include\nAPI name, and can optionally include API version and spec name.\n\n- If apihub_resource_name includes a spec resource name, the content of that\n  spec will be used for generating the tools.\n- If apihub_resource_name includes only an api or a version name, the\n  first spec of the first version of\
    \ that API will be used.\n\nExample:\n\n* projects/xxx/locations/us-central1/apis/apiname/...\n* https://console.cloud.google.com/apigee/api-hub/apis/apiname?project=xxx\n\nArgs:\n    apihub_resource_name: The resource name of the API in API Hub.\n      Example: ``projects/test-project/locations/us-central1/apis/test-api``.\n    access_token: Google Access token. Generate with gcloud cli\n      ``gcloud auth print-access-token``. Used for fetching API Specs from API Hub.\n    service_account_json: The service account config as a json string.\n      Required if not using default service credential. It is used for\n      creating the API Hub client and fetching the API Specs from API Hub.\n    apihub_client: Optional custom API Hub client.\n    name: Name of the toolset. Optional.\n    description: Description of the toolset. Optional.\n    auth_scheme: Auth scheme that applies to all the tool in the toolset.\n    auth_credential: Auth credential that applies to all the tool in the\n \
    \     toolset.\n    lazy_load_spec: If True, the spec will be loaded lazily when needed.\n      Otherwise, the spec will be loaded immediately and the tools will be\n      generated during initialization.\n    tool_filter: The filter used to filter the tools in the toolset. It can\n      be either a tool predicate or a list of tool names of the tools to\n      expose."
  signature: 'def __init__(self, *, apihub_resource_name: str, access_token: typing.Optional[str]=None, service_account_json: typing.Optional[str]=None, name: str='''', description: str='''', lazy_load_spec=False, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme]=None, auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]=None, apihub_client: typing.Optional[google.adk.tools.apihub_tool.clients.apihub_client.APIHubClient]=None, tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]]=None):'
- rank: 1428
  id: google.adk.tools.apihub_tool.apihub_toolset.APIHubToolset.get_auth_config
  name: get_auth_config
  file_path: src/google/adk/tools/apihub_tool/apihub_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Returns the auth config for this toolset.


    ADK will populate exchanged_auth_credential on this config before calling

    get_tools(). The toolset can then access the ready-to-use credential via

    self._auth_config.exchanged_auth_credential.'
  signature: 'def get_auth_config(self) -> typing.Optional[google.adk.auth.auth_tool.AuthConfig]:'
- rank: 1429
  id: google.adk.tools.apihub_tool.apihub_toolset.APIHubToolset.get_tools
  name: get_tools
  file_path: src/google/adk/tools/apihub_tool/apihub_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Retrieves all available tools.\n\nReturns:\n    A list of all available RestApiTool objects."
  signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> typing.List[google.adk.tools.openapi_tool.openapi_spec_parser.rest_api_tool.RestApiTool]:'
- rank: 1430
  id: google.adk.tools.apihub_tool.clients
  name: clients
  file_path: src/google/adk/tools/apihub_tool/clients/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1431
  id: google.adk.tools.apihub_tool.clients.apihub_client
  name: apihub_client
  file_path: src/google/adk/tools/apihub_tool/clients/apihub_client.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1432
  id: google.adk.tools.apihub_tool.clients.apihub_client.APIHubClient
  name: APIHubClient
  file_path: src/google/adk/tools/apihub_tool/clients/apihub_client.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Client for interacting with the API Hub service.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, *, access_token: typing.Optional[str]=None, service_account_json: typing.Optional[str]=None):'
  methods:
  - signature: 'def get_spec_content(self, path: str) -> str:'
    docstring: "From a given path, get the first spec available in the API Hub.\n\n- If path includes /apis/apiname, get the first spec of that API\n- If path includes /apis/apiname/versions/versionname, get the first spec\n  of that API Version\n- If path includes /apis/apiname/versions/versionname/specs/specname, return\n  that spec\n\nPath can be resource name (projects/xxx/locations/us-central1/apis/apiname),\nand URL from the UI\n(https://console.cloud.google.com/apigee/api-hub/apis/apiname?project=xxx)\n\nArgs:\n    path: The path to the API, API Version, or API Spec.\n\nReturns:\n    The content of the first spec available in the API Hub."
  - signature: 'def list_apis(self, project: str, location: str) -> typing.List[typing.Dict[str, typing.Any]]:'
    docstring: "Lists all APIs in the specified project and location.\n\nArgs:\n    project: The Google Cloud project name.\n    location: The location of the API Hub resources (e.g., 'us-central1').\n\nReturns:\n    A list of API dictionaries, or an empty list if an error occurs."
  - signature: 'def get_api(self, api_resource_name: str) -> typing.Dict[str, typing.Any]:'
    docstring: "Get API detail by API name.\n\nArgs:\n    api_resource_name: Resource name of this API, like\n      projects/xxx/locations/us-central1/apis/apiname\n\nReturns:\n    An API and details in a dict."
  - signature: 'def get_api_version(self, api_version_name: str) -> typing.Dict[str, typing.Any]:'
    docstring: "Gets details of a specific API version.\n\nArgs:\n    api_version_name: The resource name of the API version.\n\nReturns:\n    The API version details as a dictionary, or an empty dictionary if an\n    error occurs."
  inherited_methods:
    BaseAPIHubClient:
    - signature: 'def get_spec_content(self, resource_name: str) -> str:'
      docstring: From a given resource name, get the spec in the API Hub.
  omitted_inherited_members_from:
  - ABC
- rank: 1433
  id: google.adk.tools.apihub_tool.clients.apihub_client.APIHubClient.__init__
  name: __init__
  file_path: src/google/adk/tools/apihub_tool/clients/apihub_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the APIHubClient.\n\nYou must set either access_token or service_account_json. This\ncredential is used for sending request to API Hub API.\n\nArgs:\n    access_token: Google Access token. Generate with gcloud cli `gcloud auth\n      print-access-token`. Useful for local testing.\n    service_account_json: The service account configuration as a dictionary.\n      Required if not using default service credential."
  signature: 'def __init__(self, *, access_token: typing.Optional[str]=None, service_account_json: typing.Optional[str]=None):'
- rank: 1434
  id: google.adk.tools.apihub_tool.clients.apihub_client.APIHubClient.get_api
  name: get_api
  file_path: src/google/adk/tools/apihub_tool/clients/apihub_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Get API detail by API name.\n\nArgs:\n    api_resource_name: Resource name of this API, like\n      projects/xxx/locations/us-central1/apis/apiname\n\nReturns:\n    An API and details in a dict."
  signature: 'def get_api(self, api_resource_name: str) -> typing.Dict[str, typing.Any]:'
- rank: 1435
  id: google.adk.tools.apihub_tool.clients.apihub_client.APIHubClient.get_api_version
  name: get_api_version
  file_path: src/google/adk/tools/apihub_tool/clients/apihub_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Gets details of a specific API version.\n\nArgs:\n    api_version_name: The resource name of the API version.\n\nReturns:\n    The API version details as a dictionary, or an empty dictionary if an\n    error occurs."
  signature: 'def get_api_version(self, api_version_name: str) -> typing.Dict[str, typing.Any]:'
- rank: 1436
  id: google.adk.tools.apihub_tool.clients.apihub_client.APIHubClient.get_spec_content
  name: get_spec_content
  file_path: src/google/adk/tools/apihub_tool/clients/apihub_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "From a given path, get the first spec available in the API Hub.\n\n- If path includes /apis/apiname, get the first spec of that API\n- If path includes /apis/apiname/versions/versionname, get the first spec\n  of that API Version\n- If path includes /apis/apiname/versions/versionname/specs/specname, return\n  that spec\n\nPath can be resource name (projects/xxx/locations/us-central1/apis/apiname),\nand URL from the UI\n(https://console.cloud.google.com/apigee/api-hub/apis/apiname?project=xxx)\n\nArgs:\n    path: The path to the API, API Version, or API Spec.\n\nReturns:\n    The content of the first spec available in the API Hub."
  signature: 'def get_spec_content(self, path: str) -> str:'
- rank: 1437
  id: google.adk.tools.apihub_tool.clients.apihub_client.APIHubClient.list_apis
  name: list_apis
  file_path: src/google/adk/tools/apihub_tool/clients/apihub_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Lists all APIs in the specified project and location.\n\nArgs:\n    project: The Google Cloud project name.\n    location: The location of the API Hub resources (e.g., 'us-central1').\n\nReturns:\n    A list of API dictionaries, or an empty list if an error occurs."
  signature: 'def list_apis(self, project: str, location: str) -> typing.List[typing.Dict[str, typing.Any]]:'
- rank: 1438
  id: google.adk.tools.apihub_tool.clients.apihub_client.BaseAPIHubClient
  name: BaseAPIHubClient
  file_path: src/google/adk/tools/apihub_tool/clients/apihub_client.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Base class for API Hub clients.


    [Note: Inherited members from ABC are omitted.]'
  methods:
  - signature: 'def get_spec_content(self, resource_name: str) -> str:'
    docstring: From a given resource name, get the spec in the API Hub.
  omitted_inherited_members_from:
  - ABC
- rank: 1439
  id: google.adk.tools.apihub_tool.clients.secret_client
  name: secret_client
  file_path: src/google/adk/tools/apihub_tool/clients/secret_client.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1440
  id: google.adk.tools.apihub_tool.clients.secret_client.SecretManagerClient
  name: SecretManagerClient
  file_path: src/google/adk/tools/apihub_tool/clients/secret_client.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "A client for interacting with Google Cloud Secret Manager.\n\nThis class provides a simplified interface for retrieving secrets from\nSecret Manager, handling authentication using either a service account\nJSON keyfile (passed as a string) or a preexisting authorization token.\n\nAttributes:\n    _credentials:  Google Cloud credentials object (ServiceAccountCredentials\n      or Credentials).\n    _client: Secret Manager client instance."
  constructor_signature: 'def __init__(self, service_account_json: typing.Optional[str], auth_token: typing.Optional[str]):'
  methods:
  - signature: 'def get_secret(self, resource_name: str) -> str:'
    docstring: "Retrieves a secret from Google Cloud Secret Manager.\n\nArgs:\n    resource_name: The full resource name of the secret, in the format\n      \"projects/*/secrets/*/versions/*\".  Usually you want the \"latest\"\n      version, e.g.,\n      \"projects/my-project/secrets/my-secret/versions/latest\".\n\nReturns:\n    The secret payload as a string.\n\nRaises:\n    google.api_core.exceptions.GoogleAPIError: If the Secret Manager API\n        returns an error (e.g., secret not found, permission denied).\n    Exception: For other unexpected errors."
- rank: 1441
  id: google.adk.tools.apihub_tool.clients.secret_client.SecretManagerClient.__init__
  name: __init__
  file_path: src/google/adk/tools/apihub_tool/clients/secret_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the SecretManagerClient.\n\nArgs:\n    service_account_json:  The content of a service account JSON keyfile (as\n      a string), not the file path.  Must be valid JSON.\n    auth_token: An existing Google Cloud authorization token.\n\nRaises:\n    ValueError: If neither `service_account_json` nor `auth_token` is\n    provided,\n        or if both are provided.  Also raised if the service_account_json\n        is not valid JSON.\n    google.auth.exceptions.GoogleAuthError: If authentication fails."
  signature: 'def __init__(self, service_account_json: typing.Optional[str], auth_token: typing.Optional[str]):'
- rank: 1442
  id: google.adk.tools.apihub_tool.clients.secret_client.SecretManagerClient.get_secret
  name: get_secret
  file_path: src/google/adk/tools/apihub_tool/clients/secret_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Retrieves a secret from Google Cloud Secret Manager.\n\nArgs:\n    resource_name: The full resource name of the secret, in the format\n      \"projects/*/secrets/*/versions/*\".  Usually you want the \"latest\"\n      version, e.g.,\n      \"projects/my-project/secrets/my-secret/versions/latest\".\n\nReturns:\n    The secret payload as a string.\n\nRaises:\n    google.api_core.exceptions.GoogleAPIError: If the Secret Manager API\n        returns an error (e.g., secret not found, permission denied).\n    Exception: For other unexpected errors."
  signature: 'def get_secret(self, resource_name: str) -> str:'
- rank: 1443
  id: google.adk.tools.application_integration_tool
  name: application_integration_tool
  file_path: src/google/adk/tools/application_integration_tool/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: '__all__: Any'
- rank: 1444
  id: google.adk.tools.application_integration_tool.application_integration_toolset
  name: application_integration_toolset
  file_path: src/google/adk/tools/application_integration_tool/application_integration_toolset.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 1445
  id: google.adk.tools.application_integration_tool.application_integration_toolset.ApplicationIntegrationToolset.__init__
  name: __init__
  file_path: src/google/adk/tools/application_integration_tool/application_integration_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Args:\n\nArgs:\n    project: The GCP project ID.\n    location: The GCP location.\n    connection_template_override: Overrides `ExecuteConnection` default\n      integration name.\n    integration: The integration name.\n    triggers: The list of trigger names in the integration.\n    connection: The connection name.\n    entity_operations: The entity operations supported by the connection.\n    actions: The actions supported by the connection.\n    tool_name_prefix: The name prefix of the generated tools.\n    tool_instructions: The instructions for the tool.\n    service_account_json: The service account configuration as a dictionary.\n      Required if not using default service credential. Used for fetching\n      the Application Integration or Integration Connector resource.\n    tool_filter: The filter used to filter the tools in the toolset. It can\n      be either a tool predicate or a list of tool names of the tools to\n      expose.\n\nRaises:\n    ValueError: If none\
    \ of the following conditions are met:\n      - ``integration`` is provided.\n      - ``connection`` is provided and at least one of ``entity_operations``\n        or ``actions`` is provided.\n    Exception: If there is an error during the initialization of the\n      integration or connection client."
  signature: 'def __init__(self, project: str, location: str, connection_template_override: typing.Optional[str], integration: typing.Optional[str], triggers: typing.Optional[typing.List[str]], connection: typing.Optional[str], entity_operations: typing.Optional[str], actions: typing.Optional[list[str]], tool_name_prefix: typing.Optional[str], tool_instructions: typing.Optional[str], service_account_json: typing.Optional[str], auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme], auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential], tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]]):'
- rank: 1446
  id: google.adk.tools.application_integration_tool.application_integration_toolset.ApplicationIntegrationToolset.get_auth_config
  name: get_auth_config
  file_path: src/google/adk/tools/application_integration_tool/application_integration_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Returns the auth config for this toolset.


    ADK will populate exchanged_auth_credential on this config before calling

    get_tools(). The toolset can then access the ready-to-use credential via

    self._auth_config.exchanged_auth_credential.'
  signature: 'def get_auth_config(self) -> typing.Optional[google.adk.auth.auth_tool.AuthConfig]:'
- rank: 1447
  id: google.adk.tools.application_integration_tool.application_integration_toolset.ApplicationIntegrationToolset.get_tools
  name: get_tools
  file_path: src/google/adk/tools/application_integration_tool/application_integration_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> typing.List[google.adk.tools.openapi_tool.openapi_spec_parser.rest_api_tool.RestApiTool]:'
- rank: 1448
  id: google.adk.tools.application_integration_tool.clients.connections_client
  name: connections_client
  file_path: src/google/adk/tools/application_integration_tool/clients/connections_client.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1449
  id: google.adk.tools.application_integration_tool.clients.connections_client.ConnectionsClient
  name: ConnectionsClient
  file_path: src/google/adk/tools/application_integration_tool/clients/connections_client.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Utility class for interacting with Google Cloud Connectors API.
  constructor_signature: 'def __init__(self, project: str, location: str, connection: str, service_account_json: typing.Optional[str]):'
  methods:
  - signature: 'def get_connection_details(self) -> typing.Dict[str, typing.Any]:'
    docstring: "Retrieves service details (service name and host) for a given connection.\n\nAlso returns if auth override is enabled for the connection.\n\nReturns:\n    tuple: A tuple containing (service_name, host).\n\nRaises:\n    PermissionError: If there are credential issues.\n    ValueError: If there's a request error.\n    Exception: For any other unexpected errors."
  - signature: 'def get_entity_schema_and_operations(self, entity: str) -> typing.Tuple[typing.Dict[str, typing.Any], typing.List[str]]:'
    docstring: "Retrieves the JSON schema for a given entity in a connection.\n\nArgs:\n    entity (str): The entity name.\n\nReturns:\n    tuple: A tuple containing (schema, operations).\n\nRaises:\n    PermissionError: If there are credential issues.\n    ValueError: If there's a request or processing error.\n    Exception: For any other unexpected errors."
  - signature: 'def get_action_schema(self, action: str) -> typing.Dict[str, typing.Any]:'
    docstring: "Retrieves the input and output JSON schema for a given action in a connection.\n\nArgs:\n    action (str): The action name.\n\nReturns:\n    tuple: A tuple containing (input_schema, output_schema).\n\nRaises:\n    PermissionError: If there are credential issues.\n    ValueError: If there's a request or processing error.\n    Exception: For any other unexpected errors."
  - signature: 'def get_connector_base_spec() -> typing.Dict[str, typing.Any]:'
  - signature: 'def get_action_operation(action: str, operation: str, action_display_name: str, tool_name: str, tool_instructions: str) -> typing.Dict[str, typing.Any]:'
  - signature: 'def list_operation(entity: str, schema_as_string: str, tool_name: str, tool_instructions: str) -> typing.Dict[str, typing.Any]:'
  - signature: 'def get_operation(entity: str, schema_as_string: str, tool_name: str, tool_instructions: str) -> typing.Dict[str, typing.Any]:'
  - signature: 'def create_operation(entity: str, tool_name: str, tool_instructions: str) -> typing.Dict[str, typing.Any]:'
  - signature: 'def update_operation(entity: str, tool_name: str, tool_instructions: str) -> typing.Dict[str, typing.Any]:'
  - signature: 'def delete_operation(entity: str, tool_name: str, tool_instructions: str) -> typing.Dict[str, typing.Any]:'
  - signature: 'def create_operation_request(entity: str) -> typing.Dict[str, typing.Any]:'
  - signature: 'def update_operation_request(entity: str) -> typing.Dict[str, typing.Any]:'
  - signature: 'def get_operation_request() -> typing.Dict[str, typing.Any]:'
  - signature: 'def delete_operation_request() -> typing.Dict[str, typing.Any]:'
  - signature: 'def list_operation_request() -> typing.Dict[str, typing.Any]:'
  - signature: 'def action_request(action: str) -> typing.Dict[str, typing.Any]:'
  - signature: 'def action_response(action: str) -> typing.Dict[str, typing.Any]:'
  - signature: 'def execute_custom_query_request() -> typing.Dict[str, typing.Any]:'
  - signature: 'def connector_payload(self, json_schema: typing.Dict[str, typing.Any]) -> typing.Dict[str, typing.Any]:'
- rank: 1450
  id: google.adk.tools.application_integration_tool.clients.connections_client.ConnectionsClient.__init__
  name: __init__
  file_path: src/google/adk/tools/application_integration_tool/clients/connections_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the ConnectionsClient.\n\nArgs:\n  project: The Google Cloud project ID.\n  location: The Google Cloud location (e.g., us-central1).\n  connection: The connection name.\n  service_account_json: The service account configuration as a dictionary.\n    Required if not using default service credential. Used for fetching\n    connection details."
  signature: 'def __init__(self, project: str, location: str, connection: str, service_account_json: typing.Optional[str]):'
- rank: 1451
  id: google.adk.tools.application_integration_tool.clients.connections_client.ConnectionsClient.action_request
  name: action_request
  file_path: src/google/adk/tools/application_integration_tool/clients/connections_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def action_request(action: str) -> typing.Dict[str, typing.Any]:'
- rank: 1452
  id: google.adk.tools.application_integration_tool.clients.connections_client.ConnectionsClient.action_response
  name: action_response
  file_path: src/google/adk/tools/application_integration_tool/clients/connections_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def action_response(action: str) -> typing.Dict[str, typing.Any]:'
- rank: 1453
  id: google.adk.tools.application_integration_tool.clients.connections_client.ConnectionsClient.create_operation
  name: create_operation
  file_path: src/google/adk/tools/application_integration_tool/clients/connections_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def create_operation(entity: str, tool_name: str, tool_instructions: str) -> typing.Dict[str, typing.Any]:'
- rank: 1454
  id: google.adk.tools.application_integration_tool.clients.connections_client.ConnectionsClient.create_operation_request
  name: create_operation_request
  file_path: src/google/adk/tools/application_integration_tool/clients/connections_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def create_operation_request(entity: str) -> typing.Dict[str, typing.Any]:'
- rank: 1455
  id: google.adk.tools.application_integration_tool.clients.connections_client.ConnectionsClient.delete_operation
  name: delete_operation
  file_path: src/google/adk/tools/application_integration_tool/clients/connections_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def delete_operation(entity: str, tool_name: str, tool_instructions: str) -> typing.Dict[str, typing.Any]:'
- rank: 1456
  id: google.adk.tools.application_integration_tool.clients.connections_client.ConnectionsClient.delete_operation_request
  name: delete_operation_request
  file_path: src/google/adk/tools/application_integration_tool/clients/connections_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def delete_operation_request() -> typing.Dict[str, typing.Any]:'
- rank: 1457
  id: google.adk.tools.application_integration_tool.clients.connections_client.ConnectionsClient.execute_custom_query_request
  name: execute_custom_query_request
  file_path: src/google/adk/tools/application_integration_tool/clients/connections_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def execute_custom_query_request() -> typing.Dict[str, typing.Any]:'
- rank: 1458
  id: google.adk.tools.application_integration_tool.clients.connections_client.ConnectionsClient.get_action_operation
  name: get_action_operation
  file_path: src/google/adk/tools/application_integration_tool/clients/connections_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_action_operation(action: str, operation: str, action_display_name: str, tool_name: str, tool_instructions: str) -> typing.Dict[str, typing.Any]:'
- rank: 1459
  id: google.adk.tools.application_integration_tool.clients.connections_client.ConnectionsClient.get_action_schema
  name: get_action_schema
  file_path: src/google/adk/tools/application_integration_tool/clients/connections_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Retrieves the input and output JSON schema for a given action in a connection.\n\nArgs:\n    action (str): The action name.\n\nReturns:\n    tuple: A tuple containing (input_schema, output_schema).\n\nRaises:\n    PermissionError: If there are credential issues.\n    ValueError: If there's a request or processing error.\n    Exception: For any other unexpected errors."
  signature: 'def get_action_schema(self, action: str) -> typing.Dict[str, typing.Any]:'
- rank: 1460
  id: google.adk.tools.application_integration_tool.clients.connections_client.ConnectionsClient.get_connection_details
  name: get_connection_details
  file_path: src/google/adk/tools/application_integration_tool/clients/connections_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Retrieves service details (service name and host) for a given connection.\n\nAlso returns if auth override is enabled for the connection.\n\nReturns:\n    tuple: A tuple containing (service_name, host).\n\nRaises:\n    PermissionError: If there are credential issues.\n    ValueError: If there's a request error.\n    Exception: For any other unexpected errors."
  signature: 'def get_connection_details(self) -> typing.Dict[str, typing.Any]:'
- rank: 1461
  id: google.adk.tools.application_integration_tool.clients.connections_client.ConnectionsClient.get_connector_base_spec
  name: get_connector_base_spec
  file_path: src/google/adk/tools/application_integration_tool/clients/connections_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_connector_base_spec() -> typing.Dict[str, typing.Any]:'
- rank: 1462
  id: google.adk.tools.application_integration_tool.clients.connections_client.ConnectionsClient.get_entity_schema_and_operations
  name: get_entity_schema_and_operations
  file_path: src/google/adk/tools/application_integration_tool/clients/connections_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Retrieves the JSON schema for a given entity in a connection.\n\nArgs:\n    entity (str): The entity name.\n\nReturns:\n    tuple: A tuple containing (schema, operations).\n\nRaises:\n    PermissionError: If there are credential issues.\n    ValueError: If there's a request or processing error.\n    Exception: For any other unexpected errors."
  signature: 'def get_entity_schema_and_operations(self, entity: str) -> typing.Tuple[typing.Dict[str, typing.Any], typing.List[str]]:'
- rank: 1463
  id: google.adk.tools.application_integration_tool.clients.connections_client.ConnectionsClient.get_operation
  name: get_operation
  file_path: src/google/adk/tools/application_integration_tool/clients/connections_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_operation(entity: str, schema_as_string: str, tool_name: str, tool_instructions: str) -> typing.Dict[str, typing.Any]:'
- rank: 1464
  id: google.adk.tools.application_integration_tool.clients.connections_client.ConnectionsClient.get_operation_request
  name: get_operation_request
  file_path: src/google/adk/tools/application_integration_tool/clients/connections_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_operation_request() -> typing.Dict[str, typing.Any]:'
- rank: 1465
  id: google.adk.tools.application_integration_tool.clients.connections_client.ConnectionsClient.list_operation
  name: list_operation
  file_path: src/google/adk/tools/application_integration_tool/clients/connections_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def list_operation(entity: str, schema_as_string: str, tool_name: str, tool_instructions: str) -> typing.Dict[str, typing.Any]:'
- rank: 1466
  id: google.adk.tools.application_integration_tool.clients.connections_client.ConnectionsClient.list_operation_request
  name: list_operation_request
  file_path: src/google/adk/tools/application_integration_tool/clients/connections_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def list_operation_request() -> typing.Dict[str, typing.Any]:'
- rank: 1467
  id: google.adk.tools.application_integration_tool.clients.connections_client.ConnectionsClient.update_operation
  name: update_operation
  file_path: src/google/adk/tools/application_integration_tool/clients/connections_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def update_operation(entity: str, tool_name: str, tool_instructions: str) -> typing.Dict[str, typing.Any]:'
- rank: 1468
  id: google.adk.tools.application_integration_tool.clients.connections_client.ConnectionsClient.update_operation_request
  name: update_operation_request
  file_path: src/google/adk/tools/application_integration_tool/clients/connections_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def update_operation_request(entity: str) -> typing.Dict[str, typing.Any]:'
- rank: 1469
  id: google.adk.tools.application_integration_tool.clients.integration_client
  name: integration_client
  file_path: src/google/adk/tools/application_integration_tool/clients/integration_client.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1470
  id: google.adk.tools.application_integration_tool.clients.integration_client.IntegrationClient
  name: IntegrationClient
  file_path: src/google/adk/tools/application_integration_tool/clients/integration_client.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A client for interacting with Google Cloud Application Integration.


    This class provides methods for retrieving OpenAPI spec for an integration or

    a connection.'
  constructor_signature: 'def __init__(self, project: str, location: str, connection_template_override: typing.Optional[str], integration: typing.Optional[str], triggers: typing.Optional[typing.List[str]], connection: typing.Optional[str], entity_operations: typing.Optional[dict[str, list[str]]], actions: typing.Optional[list[str]], service_account_json: typing.Optional[str]):'
  methods:
  - signature: 'def get_openapi_spec_for_integration(self):'
    docstring: "Gets the OpenAPI spec for the integration.\n\nReturns:\n    dict: The OpenAPI spec as a dictionary.\nRaises:\n    PermissionError: If there are credential issues.\n    ValueError: If there's a request error or processing error.\n    Exception: For any other unexpected errors."
  - signature: 'def get_openapi_spec_for_connection(self, tool_name, tool_instructions):'
    docstring: "Gets the OpenAPI spec for the connection.\n\nReturns:\n    dict: The OpenAPI spec as a dictionary.\nRaises:\n    ValueError: If there's an error retrieving the OpenAPI spec.\n    PermissionError: If there are credential issues.\n    Exception: For any other unexpected errors."
- rank: 1471
  id: google.adk.tools.application_integration_tool.clients.integration_client.IntegrationClient.__init__
  name: __init__
  file_path: src/google/adk/tools/application_integration_tool/clients/integration_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the ApplicationIntegrationClient.\n\nArgs:\n    project: The Google Cloud project ID.\n    location: The Google Cloud location (e.g., us-central1).\n    connection_template_override: Overrides `ExecuteConnection` default\n      integration name.\n    integration: The integration name.\n    triggers: The list of trigger IDs for the integration.\n    connection: The connection name.\n    entity_operations: A dictionary mapping entity names to a list of\n      operations (e.g., LIST, CREATE, UPDATE, DELETE, GET).\n    actions: List of actions.\n    service_account_json: The service account configuration as a dictionary.\n      Required if not using default service credential. Used for fetching\n      connection details."
  signature: 'def __init__(self, project: str, location: str, connection_template_override: typing.Optional[str], integration: typing.Optional[str], triggers: typing.Optional[typing.List[str]], connection: typing.Optional[str], entity_operations: typing.Optional[dict[str, list[str]]], actions: typing.Optional[list[str]], service_account_json: typing.Optional[str]):'
- rank: 1472
  id: google.adk.tools.application_integration_tool.clients.integration_client.IntegrationClient.get_openapi_spec_for_connection
  name: get_openapi_spec_for_connection
  file_path: src/google/adk/tools/application_integration_tool/clients/integration_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Gets the OpenAPI spec for the connection.\n\nReturns:\n    dict: The OpenAPI spec as a dictionary.\nRaises:\n    ValueError: If there's an error retrieving the OpenAPI spec.\n    PermissionError: If there are credential issues.\n    Exception: For any other unexpected errors."
  signature: 'def get_openapi_spec_for_connection(self, tool_name, tool_instructions):'
- rank: 1473
  id: google.adk.tools.application_integration_tool.clients.integration_client.IntegrationClient.get_openapi_spec_for_integration
  name: get_openapi_spec_for_integration
  file_path: src/google/adk/tools/application_integration_tool/clients/integration_client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Gets the OpenAPI spec for the integration.\n\nReturns:\n    dict: The OpenAPI spec as a dictionary.\nRaises:\n    PermissionError: If there are credential issues.\n    ValueError: If there's a request error or processing error.\n    Exception: For any other unexpected errors."
  signature: 'def get_openapi_spec_for_integration(self):'
- rank: 1474
  id: google.adk.tools.application_integration_tool.integration_connector_tool
  name: integration_connector_tool
  file_path: src/google/adk/tools/application_integration_tool/integration_connector_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 1475
  id: google.adk.tools.application_integration_tool.integration_connector_tool.IntegrationConnectorTool
  name: IntegrationConnectorTool
  file_path: src/google/adk/tools/application_integration_tool/integration_connector_tool.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "A tool that wraps a RestApiTool to interact with a specific Application Integration endpoint.\n\nThis tool adds Application Integration specific context like connection\ndetails, entity, operation, and action to the underlying REST API call\nhandled by RestApiTool. It prepares the arguments and then delegates the\nactual API call execution to the contained RestApiTool instance.\n\n* Generates request params and body\n* Attaches auth credentials to API call.\n\nExample::\n\n  # Each API operation in the spec will be turned into its own tool\n  # Name of the tool is the operationId of that operation, in snake case\n  operations = OperationGenerator().parse(openapi_spec_dict)\n  tool = [RestApiTool.from_parsed_operation(o) for o in operations]\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, name: str, description: str, connection_name: str, connection_host: str, connection_service_name: str, entity: str, operation: str, action: str, rest_api_tool: google.adk.tools.openapi_tool.openapi_spec_parser.rest_api_tool.RestApiTool, auth_scheme: typing.Optional[typing.Union[google.adk.auth.auth_schemes.AuthScheme, str]], auth_credential: typing.Optional[typing.Union[google.adk.auth.auth_credential.AuthCredential, str]]):'
  methods:
  - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: typing.Optional[google.adk.tools.tool_context.ToolContext]) -> typing.Dict[str, typing.Any]:'
  properties:
  - signature: 'EXCLUDE_FIELDS: Any'
  - signature: 'OPTIONAL_FIELDS: Any'
  inherited_methods:
    BaseTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
      docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
      docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  inherited_properties:
    BaseTool:
    - signature: 'name: str'
      docstring: The name of the tool.
    - signature: 'description: str'
      docstring: The description of the tool.
    - signature: 'is_long_running: bool'
      docstring: 'Whether the tool is a long running operation, which typically returns a

        resource id first and finishes the operation later.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the BaseTool.


        An optional key-value pair for storing and retrieving tool-specific metadata,

        such as tool manifests, etc.


        NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 1476
  id: google.adk.tools.application_integration_tool.integration_connector_tool.IntegrationConnectorTool.__init__
  name: __init__
  file_path: src/google/adk/tools/application_integration_tool/integration_connector_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the ApplicationIntegrationTool.\n\nArgs:\n    name: The name of the tool, typically derived from the API operation.\n      Should be unique and adhere to Gemini function naming conventions\n      (e.g., less than 64 characters).\n    description: A description of what the tool does, usually based on the\n      API operation's summary or description.\n    connection_name: The name of the Integration Connector connection.\n    connection_host: The hostname or IP address for the connection.\n    connection_service_name: The specific service name within the host.\n    entity: The Integration Connector entity being targeted.\n    operation: The specific operation being performed on the entity.\n    action: The action associated with the operation (e.g., 'execute').\n    rest_api_tool: An initialized RestApiTool instance that handles the\n      underlying REST API communication based on an OpenAPI specification\n      operation. This tool will be called by ApplicationIntegrationTool\
    \ with\n      added connection and context arguments. tool =\n      [RestApiTool.from_parsed_operation(o) for o in operations]"
  signature: 'def __init__(self, name: str, description: str, connection_name: str, connection_host: str, connection_service_name: str, entity: str, operation: str, action: str, rest_api_tool: google.adk.tools.openapi_tool.openapi_spec_parser.rest_api_tool.RestApiTool, auth_scheme: typing.Optional[typing.Union[google.adk.auth.auth_schemes.AuthScheme, str]], auth_credential: typing.Optional[typing.Union[google.adk.auth.auth_credential.AuthCredential, str]]):'
- rank: 1477
  id: google.adk.tools.application_integration_tool.integration_connector_tool.IntegrationConnectorTool.run_async
  name: run_async
  file_path: src/google/adk/tools/application_integration_tool/integration_connector_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: typing.Optional[google.adk.tools.tool_context.ToolContext]) -> typing.Dict[str, typing.Any]:'
- rank: 1478
  id: google.adk.tools.authenticated_function_tool
  name: authenticated_function_tool
  file_path: src/google/adk/tools/authenticated_function_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 1479
  id: google.adk.tools.authenticated_function_tool.AuthenticatedFunctionTool.__init__
  name: __init__
  file_path: src/google/adk/tools/authenticated_function_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the AuthenticatedFunctionTool.\n\nArgs:\n    func: The function to be called.\n    auth_config: The authentication configuration.\n    response_for_auth_required: The response to return when the tool is\n      requesting auth credential from the client. There could be two case,\n      the tool doesn't configure any credentials\n      (auth_config.raw_auth_credential is missing) or the credentials\n      configured is not enough to authenticate the tool (e.g. an OAuth\n      client id and client secret are configured) and needs client input\n      (e.g. client need to involve the end user in an oauth flow and get\n      back the oauth response.)"
  signature: 'def __init__(self, *, func: typing.Callable[Ellipsis, typing.Any], auth_config: google.adk.auth.auth_tool.AuthConfig=None, response_for_auth_required: typing.Optional[typing.Union[dict[str, typing.Any], str]]=None):'
- rank: 1480
  id: google.adk.tools.authenticated_function_tool.AuthenticatedFunctionTool._run_async_impl
  name: _run_async_impl
  file_path: src/google/adk/tools/authenticated_function_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def _run_async_impl(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, credential: google.adk.auth.auth_credential.AuthCredential) -> typing.Any:'
- rank: 1481
  id: google.adk.tools.authenticated_function_tool.AuthenticatedFunctionTool.run_async
  name: run_async
  file_path: src/google/adk/tools/authenticated_function_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
- rank: 1482
  id: google.adk.tools.base_authenticated_tool
  name: base_authenticated_tool
  file_path: src/google/adk/tools/base_authenticated_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 1483
  id: google.adk.tools.base_authenticated_tool.BaseAuthenticatedTool
  name: BaseAuthenticatedTool
  file_path: src/google/adk/tools/base_authenticated_tool.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A base tool class that handles authentication before the actual tool logic

    gets called. Functions can accept a special `credential` argument which is the

    credential ready for use.(Experimental)


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, *, name, description, auth_config: google.adk.auth.auth_tool.AuthConfig=None, response_for_auth_required: typing.Optional[typing.Union[dict[str, typing.Any], str]]=None):'
  methods:
  - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
  - signature: 'def _run_async_impl(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, credential: google.adk.auth.auth_credential.AuthCredential) -> typing.Any:'
  inherited_methods:
    BaseTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
      docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
      docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  inherited_properties:
    BaseTool:
    - signature: 'name: str'
      docstring: The name of the tool.
    - signature: 'description: str'
      docstring: The description of the tool.
    - signature: 'is_long_running: bool'
      docstring: 'Whether the tool is a long running operation, which typically returns a

        resource id first and finishes the operation later.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the BaseTool.


        An optional key-value pair for storing and retrieving tool-specific metadata,

        such as tool manifests, etc.


        NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 1484
  id: google.adk.tools.base_authenticated_tool.BaseAuthenticatedTool.__init__
  name: __init__
  file_path: src/google/adk/tools/base_authenticated_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Args:\nname: The name of the tool.\ndescription: The description of the tool.\nauth_config: The auth configuration of the tool.\nresponse_for_auth_required: The response to return when the tool is\n    requesting auth credential from the client. There could be two case,\n    the tool doesn't configure any credentials\n    (auth_config.raw_auth_credential is missing) or the credentials\n    configured is not enough to authenticate the tool (e.g. an OAuth\n    client id and client secret are configured) and needs client input\n    (e.g. client need to involve the end user in an oauth flow and get\n    back the oauth response.)"
  signature: 'def __init__(self, *, name, description, auth_config: google.adk.auth.auth_tool.AuthConfig=None, response_for_auth_required: typing.Optional[typing.Union[dict[str, typing.Any], str]]=None):'
- rank: 1485
  id: google.adk.tools.base_authenticated_tool.BaseAuthenticatedTool._run_async_impl
  name: _run_async_impl
  file_path: src/google/adk/tools/base_authenticated_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def _run_async_impl(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, credential: google.adk.auth.auth_credential.AuthCredential) -> typing.Any:'
- rank: 1486
  id: google.adk.tools.base_authenticated_tool.BaseAuthenticatedTool.run_async
  name: run_async
  file_path: src/google/adk/tools/base_authenticated_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
- rank: 1487
  id: google.adk.tools.base_tool
  name: base_tool
  file_path: src/google/adk/tools/base_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: 'SelfTool: typing.TypeVar'
- rank: 1488
  id: google.adk.tools.base_tool.BaseTool
  name: BaseTool
  file_path: src/google/adk/tools/base_tool.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'The base class for all tools.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, *, name, description, is_long_running: bool=False, custom_metadata: typing.Optional[dict[str, typing.Any]]=None):'
  methods:
  - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
    docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
  - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
    docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
  - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
    docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  properties:
  - signature: 'name: str'
    docstring: The name of the tool.
  - signature: 'description: str'
    docstring: The description of the tool.
  - signature: 'is_long_running: bool'
    docstring: 'Whether the tool is a long running operation, which typically returns a

      resource id first and finishes the operation later.'
  - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
    docstring: 'The custom metadata of the BaseTool.


      An optional key-value pair for storing and retrieving tool-specific metadata,

      such as tool manifests, etc.


      NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 1489
  id: google.adk.tools.base_tool.BaseTool.__init__
  name: __init__
  file_path: src/google/adk/tools/base_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, *, name, description, is_long_running: bool=False, custom_metadata: typing.Optional[dict[str, typing.Any]]=None):'
- rank: 1490
  id: google.adk.tools.base_tool.BaseTool.from_config
  name: from_config
  file_path: src/google/adk/tools/base_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
- rank: 1491
  id: google.adk.tools.base_tool.BaseTool.process_llm_request
  name: process_llm_request
  file_path: src/google/adk/tools/base_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
  signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
- rank: 1492
  id: google.adk.tools.base_tool.BaseTool.run_async
  name: run_async
  file_path: src/google/adk/tools/base_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
  signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
- rank: 1493
  id: google.adk.tools.base_toolset
  name: base_toolset
  file_path: src/google/adk/tools/base_toolset.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'SelfToolset: typing.TypeVar'
- rank: 1494
  id: google.adk.tools.base_toolset.BaseToolset
  name: BaseToolset
  file_path: src/google/adk/tools/base_toolset.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Base class for toolset.


    A toolset is a collection of tools that can be used by an agent.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, *, tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]]=None, tool_name_prefix: typing.Optional[str]=None):'
  methods:
  - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
    docstring: "Return all tools in the toolset based on the provided context.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools available under the specified context."
  - signature: 'def get_tools_with_prefix(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
    docstring: "Return all tools with optional prefix applied to tool names.\n\nThis method calls get_tools() and applies prefixing if tool_name_prefix is provided.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools with prefixed names if tool_name_prefix is provided."
  - signature: 'def close(self) -> None:'
    docstring: "Performs cleanup and releases resources held by the toolset.\n\nNOTE:\n  This method is invoked, for example, at the end of an agent server's\n  lifecycle or when the toolset is no longer needed. Implementations\n  should ensure that any open connections, files, or other managed\n  resources are properly released to prevent leaks."
  - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_toolset.SelfToolset], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_toolset.SelfToolset:'
    docstring: "Creates a toolset instance from a config.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The toolset instance."
  - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
    docstring: "Processes the outgoing LLM request for this toolset. This method will be\ncalled before each tool processes the llm request.\n\nUse cases:\n- Instead of let each tool process the llm request, we can let the toolset\n  process the llm request. e.g. ComputerUseToolset can add computer use\n  tool to the llm request.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
  - signature: 'def get_auth_config(self) -> typing.Optional[google.adk.auth.auth_tool.AuthConfig]:'
    docstring: "Returns the auth config for this toolset. ADK will make sure the\n'exchanged_auth_credential' field in the config is populated with\nready-to-use credential (e.g. oauth token for OAuth flow) before calling\nget_tools method or execute any tools returned by this toolset. Thus toolset\ncan use this credential either for tool listing or tool calling. If tool\ncalling needs a different credential from ADK client, call\ntool_context.request_credential in the tool.\n\nToolsets that support authentication should override this method to return\nan AuthConfig constructed from their auth_scheme, auth_credential, and\noptional credential_key parameters.\n\nReturns:\n  AuthConfig if the toolset has authentication configured, None otherwise."
  omitted_inherited_members_from:
  - ABC
- rank: 1495
  id: google.adk.tools.base_toolset.BaseToolset.__init__
  name: __init__
  file_path: src/google/adk/tools/base_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initialize the toolset.\n\nArgs:\n  tool_filter: Filter to apply to tools.\n  tool_name_prefix: The prefix to prepend to the names of the tools returned by the toolset."
  signature: 'def __init__(self, *, tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]]=None, tool_name_prefix: typing.Optional[str]=None):'
- rank: 1496
  id: google.adk.tools.base_toolset.BaseToolset.close
  name: close
  file_path: src/google/adk/tools/base_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Performs cleanup and releases resources held by the toolset.\n\nNOTE:\n  This method is invoked, for example, at the end of an agent server's\n  lifecycle or when the toolset is no longer needed. Implementations\n  should ensure that any open connections, files, or other managed\n  resources are properly released to prevent leaks."
  signature: 'def close(self) -> None:'
- rank: 1497
  id: google.adk.tools.base_toolset.BaseToolset.from_config
  name: from_config
  file_path: src/google/adk/tools/base_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Creates a toolset instance from a config.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The toolset instance."
  signature: 'def from_config(cls: typing.Type[google.adk.tools.base_toolset.SelfToolset], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_toolset.SelfToolset:'
- rank: 1498
  id: google.adk.tools.base_toolset.BaseToolset.get_auth_config
  name: get_auth_config
  file_path: src/google/adk/tools/base_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Returns the auth config for this toolset. ADK will make sure the\n'exchanged_auth_credential' field in the config is populated with\nready-to-use credential (e.g. oauth token for OAuth flow) before calling\nget_tools method or execute any tools returned by this toolset. Thus toolset\ncan use this credential either for tool listing or tool calling. If tool\ncalling needs a different credential from ADK client, call\ntool_context.request_credential in the tool.\n\nToolsets that support authentication should override this method to return\nan AuthConfig constructed from their auth_scheme, auth_credential, and\noptional credential_key parameters.\n\nReturns:\n  AuthConfig if the toolset has authentication configured, None otherwise."
  signature: 'def get_auth_config(self) -> typing.Optional[google.adk.auth.auth_tool.AuthConfig]:'
- rank: 1499
  id: google.adk.tools.base_toolset.BaseToolset.get_tools
  name: get_tools
  file_path: src/google/adk/tools/base_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Return all tools in the toolset based on the provided context.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools available under the specified context."
  signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
- rank: 1500
  id: google.adk.tools.base_toolset.BaseToolset.get_tools_with_prefix
  name: get_tools_with_prefix
  file_path: src/google/adk/tools/base_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Return all tools with optional prefix applied to tool names.\n\nThis method calls get_tools() and applies prefixing if tool_name_prefix is provided.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools with prefixed names if tool_name_prefix is provided."
  signature: 'def get_tools_with_prefix(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
- rank: 1501
  id: google.adk.tools.base_toolset.BaseToolset.process_llm_request
  name: process_llm_request
  file_path: src/google/adk/tools/base_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Processes the outgoing LLM request for this toolset. This method will be\ncalled before each tool processes the llm request.\n\nUse cases:\n- Instead of let each tool process the llm request, we can let the toolset\n  process the llm request. e.g. ComputerUseToolset can add computer use\n  tool to the llm request.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
  signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
- rank: 1502
  id: google.adk.tools.base_toolset.ToolPredicate
  name: ToolPredicate
  file_path: src/google/adk/tools/base_toolset.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Base class for a predicate that defines the interface to decide whether a


    tool should be exposed to LLM. Toolset implementer could consider whether to

    accept such instance in the toolset''s constructor and apply the predicate in

    get_tools method.


    [Note: Inherited members from Protocol are omitted.]'
  omitted_inherited_members_from:
  - Protocol
- rank: 1503
  id: google.adk.tools.bigquery
  name: bigquery
  file_path: src/google/adk/tools/bigquery/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: "BigQuery Tools (Experimental).\n\nBigQuery Tools under this module are hand crafted and customized while the tools\nunder google.adk.tools.google_api_tool are auto generated based on API\ndefinition. The rationales to have customized tool are:\n\n1. BigQuery APIs have functions overlaps and LLM can't tell what tool to use\n2. BigQuery APIs have a lot of parameters with some rarely used, which are not\n   LLM-friendly\n3. We want to provide more high-level tools like forecasting, RAG, segmentation,\n   etc.\n4. We want to provide extra access guardrails in those tools. For example,\n   execute_sql can't arbitrarily mutate existing data."
  properties:
  - signature: '__all__: Any'
- rank: 1504
  id: google.adk.tools.bigquery.bigquery_credentials
  name: bigquery_credentials
  file_path: src/google/adk/tools/bigquery/bigquery_credentials.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'BIGQUERY_TOKEN_CACHE_KEY: str'
  - signature: 'BIGQUERY_DEFAULT_SCOPE: Any'
- rank: 1505
  id: google.adk.tools.bigquery.bigquery_toolset
  name: bigquery_toolset
  file_path: src/google/adk/tools/bigquery/bigquery_toolset.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1506
  id: google.adk.tools.bigquery.bigquery_toolset.BigQueryToolset.__init__
  name: __init__
  file_path: src/google/adk/tools/bigquery/bigquery_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, *, tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]]=None, credentials_config: typing.Optional[google.adk.tools.bigquery.bigquery_credentials.BigQueryCredentialsConfig]=None, bigquery_tool_config: typing.Optional[google.adk.tools.bigquery.config.BigQueryToolConfig]=None):'
- rank: 1507
  id: google.adk.tools.bigquery.bigquery_toolset.BigQueryToolset.get_tools
  name: get_tools
  file_path: src/google/adk/tools/bigquery/bigquery_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Get tools from the toolset.
  signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> typing.List[google.adk.tools.base_tool.BaseTool]:'
- rank: 1508
  id: google.adk.tools.bigquery.client
  name: client
  file_path: src/google/adk/tools/bigquery/client.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def get_bigquery_client(*, project: typing.Optional[str], credentials: google.auth.credentials.Credentials, location: typing.Optional[str]=None, user_agent: typing.Optional[typing.Union[str, typing.List[str]]]=None) -> google.cloud.bigquery.Client:'
    docstring: "Get a BigQuery client.\n\nArgs:\n  project: The GCP project ID.\n  credentials: The credentials to use for the request.\n  location: The location of the BigQuery client.\n  user_agent: The user agent to use for the request.\n\nReturns:\n  A BigQuery client."
  properties:
  - signature: 'USER_AGENT: Any'
- rank: 1509
  id: google.adk.tools.bigquery.config
  name: config
  file_path: src/google/adk/tools/bigquery/config.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1510
  id: google.adk.tools.bigquery.config.BigQueryToolConfig.validate_application_name
  name: validate_application_name
  file_path: src/google/adk/tools/bigquery/config.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Validate the application name.
  signature: 'def validate_application_name(cls, v):'
- rank: 1511
  id: google.adk.tools.bigquery.config.BigQueryToolConfig.validate_job_labels
  name: validate_job_labels
  file_path: src/google/adk/tools/bigquery/config.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Validate that job_labels keys are not empty.
  signature: 'def validate_job_labels(cls, v):'
- rank: 1512
  id: google.adk.tools.bigquery.config.BigQueryToolConfig.validate_maximum_bytes_billed
  name: validate_maximum_bytes_billed
  file_path: src/google/adk/tools/bigquery/config.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Validate the maximum bytes billed.
  signature: 'def validate_maximum_bytes_billed(cls, v):'
- rank: 1513
  id: google.adk.tools.bigquery.config.WriteMode
  name: WriteMode
  file_path: src/google/adk/tools/bigquery/config.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Write mode indicating what levels of write operations are allowed in BigQuery.


    [Note: Inherited members from Enum are omitted.]'
  properties:
  - signature: 'BLOCKED: str'
    docstring: 'No write operations are allowed.


      This mode implies that only read (i.e. SELECT query) operations are allowed.'
  - signature: 'PROTECTED: str'
    docstring: 'Only protected write operations are allowed in a BigQuery session.


      In this mode write operations in the anonymous dataset of a BigQuery session

      are allowed. For example, a temporary table can be created, manipulated and

      deleted in the anonymous dataset during Agent interaction, while protecting

      permanent tables from being modified or deleted. To learn more about BigQuery

      sessions, see https://cloud.google.com/bigquery/docs/sessions-intro.'
  - signature: 'ALLOWED: str'
    docstring: All write operations are allowed.
  omitted_inherited_members_from:
  - Enum
- rank: 1514
  id: google.adk.tools.bigquery.data_insights_tool
  name: data_insights_tool
  file_path: src/google/adk/tools/bigquery/data_insights_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def ask_data_insights(project_id: str, user_query_with_context: str, table_references: typing.List[typing.Dict[str, str]], credentials: google.auth.credentials.Credentials, settings: google.adk.tools.bigquery.config.BigQueryToolConfig) -> typing.Dict[str, typing.Any]:'
    docstring: "Answers questions about structured data in BigQuery tables using natural language.\n\nThis function takes a user's question (which can include conversational\nhistory for context) and references to specific BigQuery tables, and sends\nthem to a stateless conversational API.\n\nThe API uses a GenAI agent to understand the question, generate and execute\nSQL queries and Python code, and formulate an answer. This function returns a\ndetailed, sequential log of this entire process, which includes any generated\nSQL or Python code, the data retrieved, and the final text answer. The final\nanswer is always in plain text, as the underlying API is instructed not to\ngenerate any charts, graphs, images, or other visualizations.\n\nUse this tool to perform data analysis, get insights, or answer complex\nquestions about the contents of specific BigQuery tables.\n\nArgs:\n    project_id (str): The project that the inquiry is performed in.\n    user_query_with_context (str): The user's\
      \ original request, enriched with\n      relevant context from the conversation history. The user's core intent\n      should be preserved, but context should be added to resolve ambiguities\n      in follow-up questions.\n    table_references (List[Dict[str, str]]): A list of dictionaries, each\n      specifying a BigQuery table to be used as context for the question.\n    credentials (Credentials): The credentials to use for the request.\n    settings (BigQueryToolConfig): The settings for the tool.\n\nReturns:\n    A dictionary with two keys:\n    - 'status': A string indicating the final status (e.g., \"SUCCESS\").\n    - 'response': A list of dictionaries, where each dictionary\n      represents a step in the API's execution process (e.g., SQL\n      generation, data retrieval, final answer).\n\nExample:\n    A query joining multiple tables, showing the full return structure.\n    The original question: \"Which customer from New York spent the most last\n    month?\"\n\n    >>>\
      \ ask_data_insights(\n    ...     project_id=\"some-project-id\",\n    ...     user_query_with_context=(\n    ...         \"Which customer from New York spent the most last month?\"\n    ...         \"Context: The 'customers' table joins with the 'orders' table\"\n    ...         \" on the 'customer_id' column.\"\n    ...         \"\"\n    ...     ),\n    ...     table_references=[\n    ...         {\n    ...             \"projectId\": \"my-gcp-project\",\n    ...             \"datasetId\": \"sales_data\",\n    ...             \"tableId\": \"customers\"\n    ...         },\n    ...         {\n    ...             \"projectId\": \"my-gcp-project\",\n    ...             \"datasetId\": \"sales_data\",\n    ...             \"tableId\": \"orders\"\n    ...         }\n    ...     ]\n    ... )\n    {\n      \"status\": \"SUCCESS\",\n      \"response\": [\n        {\n          \"SQL Generated\": \"SELECT t1.customer_name, SUM(t2.order_total) ... \"\n        },\n        {\n          \"Data Retrieved\"\
      : {\n            \"headers\": [\"customer_name\", \"total_spent\"],\n            \"rows\": [[\"Jane Doe\", 1234.56]],\n            \"summary\": \"Showing all 1 rows.\"\n          }\n        },\n        {\n          \"Answer\": \"The customer who spent the most was Jane Doe.\"\n        }\n      ]\n    }"
- rank: 1515
  id: google.adk.tools.bigquery.data_insights_tool.ask_data_insights
  name: ask_data_insights
  file_path: src/google/adk/tools/bigquery/data_insights_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Answers questions about structured data in BigQuery tables using natural language.\n\nThis function takes a user's question (which can include conversational\nhistory for context) and references to specific BigQuery tables, and sends\nthem to a stateless conversational API.\n\nThe API uses a GenAI agent to understand the question, generate and execute\nSQL queries and Python code, and formulate an answer. This function returns a\ndetailed, sequential log of this entire process, which includes any generated\nSQL or Python code, the data retrieved, and the final text answer. The final\nanswer is always in plain text, as the underlying API is instructed not to\ngenerate any charts, graphs, images, or other visualizations.\n\nUse this tool to perform data analysis, get insights, or answer complex\nquestions about the contents of specific BigQuery tables.\n\nArgs:\n    project_id (str): The project that the inquiry is performed in.\n    user_query_with_context (str): The user's\
    \ original request, enriched with\n      relevant context from the conversation history. The user's core intent\n      should be preserved, but context should be added to resolve ambiguities\n      in follow-up questions.\n    table_references (List[Dict[str, str]]): A list of dictionaries, each\n      specifying a BigQuery table to be used as context for the question.\n    credentials (Credentials): The credentials to use for the request.\n    settings (BigQueryToolConfig): The settings for the tool.\n\nReturns:\n    A dictionary with two keys:\n    - 'status': A string indicating the final status (e.g., \"SUCCESS\").\n    - 'response': A list of dictionaries, where each dictionary\n      represents a step in the API's execution process (e.g., SQL\n      generation, data retrieval, final answer).\n\nExample:\n    A query joining multiple tables, showing the full return structure.\n    The original question: \"Which customer from New York spent the most last\n    month?\"\n\n    >>>\
    \ ask_data_insights(\n    ...     project_id=\"some-project-id\",\n    ...     user_query_with_context=(\n    ...         \"Which customer from New York spent the most last month?\"\n    ...         \"Context: The 'customers' table joins with the 'orders' table\"\n    ...         \" on the 'customer_id' column.\"\n    ...         \"\"\n    ...     ),\n    ...     table_references=[\n    ...         {\n    ...             \"projectId\": \"my-gcp-project\",\n    ...             \"datasetId\": \"sales_data\",\n    ...             \"tableId\": \"customers\"\n    ...         },\n    ...         {\n    ...             \"projectId\": \"my-gcp-project\",\n    ...             \"datasetId\": \"sales_data\",\n    ...             \"tableId\": \"orders\"\n    ...         }\n    ...     ]\n    ... )\n    {\n      \"status\": \"SUCCESS\",\n      \"response\": [\n        {\n          \"SQL Generated\": \"SELECT t1.customer_name, SUM(t2.order_total) ... \"\n        },\n        {\n          \"Data Retrieved\"\
    : {\n            \"headers\": [\"customer_name\", \"total_spent\"],\n            \"rows\": [[\"Jane Doe\", 1234.56]],\n            \"summary\": \"Showing all 1 rows.\"\n          }\n        },\n        {\n          \"Answer\": \"The customer who spent the most was Jane Doe.\"\n        }\n      ]\n    }"
  signature: 'def ask_data_insights(project_id: str, user_query_with_context: str, table_references: typing.List[typing.Dict[str, str]], credentials: google.auth.credentials.Credentials, settings: google.adk.tools.bigquery.config.BigQueryToolConfig) -> typing.Dict[str, typing.Any]:'
- rank: 1516
  id: google.adk.tools.bigquery.metadata_tool
  name: metadata_tool
  file_path: src/google/adk/tools/bigquery/metadata_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def list_dataset_ids(project_id: str, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.bigquery.config.BigQueryToolConfig) -> list[str]:'
    docstring: "List BigQuery dataset ids in a Google Cloud project.\n\nArgs:\n    project_id (str): The Google Cloud project id.\n    credentials (Credentials): The credentials to use for the request.\n\nReturns:\n    list[str]: List of the BigQuery dataset ids present in the project.\n\nExamples:\n    >>> list_dataset_ids(\"bigquery-public-data\")\n    ['america_health_rankings',\n     'american_community_survey',\n     'aml_ai_input_dataset',\n     'austin_311',\n     'austin_bikeshare',\n     'austin_crime',\n     'austin_incidents',\n     'austin_waste',\n     'baseball',\n     'bbc_news']"
  - signature: 'def get_dataset_info(project_id: str, dataset_id: str, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.bigquery.config.BigQueryToolConfig) -> dict:'
    docstring: "Get metadata information about a BigQuery dataset.\n\nArgs:\n    project_id (str): The Google Cloud project id containing the dataset.\n    dataset_id (str): The BigQuery dataset id.\n    credentials (Credentials): The credentials to use for the request.\n\nReturns:\n    dict: Dictionary representing the properties of the dataset.\n\nExamples:\n    >>> get_dataset_info(\"bigquery-public-data\", \"cdc_places\")\n    {\n      \"kind\": \"bigquery#dataset\",\n      \"etag\": \"fz9BaiXKgbGi53EpI2rJug==\",\n      \"id\": \"bigquery-public-data:cdc_places\",\n      \"selfLink\": \"https://content-bigquery.googleapis.com/bigquery/v2/projects/bigquery-public-data/datasets/cdc_places\",\n      \"datasetReference\": {\n        \"datasetId\": \"cdc_places\",\n        \"projectId\": \"bigquery-public-data\"\n      },\n      \"description\": \"Local Data for Better Health, County Data\",\n      \"access\": [\n        {\n          \"role\": \"WRITER\",\n          \"specialGroup\": \"projectWriters\"\
      \n        },\n        {\n          \"role\": \"OWNER\",\n          \"specialGroup\": \"projectOwners\"\n        },\n        {\n          \"role\": \"OWNER\",\n          \"userByEmail\": \"some-redacted-email@bigquery-public-data.iam.gserviceaccount.com\"\n        },\n        {\n          \"role\": \"READER\",\n          \"specialGroup\": \"projectReaders\"\n        }\n      ],\n      \"creationTime\": \"1640891845643\",\n      \"lastModifiedTime\": \"1640891845643\",\n      \"location\": \"US\",\n      \"type\": \"DEFAULT\",\n      \"maxTimeTravelHours\": \"168\"\n    }"
  - signature: 'def list_table_ids(project_id: str, dataset_id: str, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.bigquery.config.BigQueryToolConfig) -> list[str]:'
    docstring: "List table ids in a BigQuery dataset.\n\nArgs:\n    project_id (str): The Google Cloud project id containing the dataset.\n    dataset_id (str): The BigQuery dataset id.\n    credentials (Credentials): The credentials to use for the request.\n\nReturns:\n    list[str]: List of the tables ids present in the dataset.\n\nExamples:\n    >>> list_table_ids(\"bigquery-public-data\", \"cdc_places\")\n    ['chronic_disease_indicators',\n     'local_data_for_better_health_county_data']"
  - signature: 'def get_table_info(project_id: str, dataset_id: str, table_id: str, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.bigquery.config.BigQueryToolConfig) -> dict:'
    docstring: "Get metadata information about a BigQuery table.\n\nArgs:\n    project_id (str): The Google Cloud project id containing the dataset.\n    dataset_id (str): The BigQuery dataset id containing the table.\n    table_id (str): The BigQuery table id.\n    credentials (Credentials): The credentials to use for the request.\n\nReturns:\n    dict: Dictionary representing the properties of the table.\n\nExamples:\n    >>> get_table_info(\"bigquery-public-data\", \"cdc_places\", \"local_data_for_better_health_county_data\")\n    {\n      \"kind\": \"bigquery#table\",\n      \"etag\": \"wx23aDqmgc39oUSiNuYTAA==\",\n      \"id\": \"bigquery-public-data:cdc_places.local_data_for_better_health_county_data\",\n      \"selfLink\": \"https://content-bigquery.googleapis.com/bigquery/v2/projects/bigquery-public-data/datasets/cdc_places/tables/local_data_for_better_health_county_data\",\n      \"tableReference\": {\n        \"projectId\": \"bigquery-public-data\",\n        \"datasetId\": \"cdc_places\"\
      ,\n        \"tableId\": \"local_data_for_better_health_county_data\"\n      },\n      \"description\": \"Local Data for Better Health, County Data\",\n      \"schema\": {\n        \"fields\": [\n          {\n            \"name\": \"year\",\n            \"type\": \"INTEGER\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"stateabbr\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"statedesc\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"locationname\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"datasource\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"category\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n\
      \          },\n          {\n            \"name\": \"measure\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"data_value_unit\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"data_value_type\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"data_value\",\n            \"type\": \"FLOAT\",\n            \"mode\": \"NULLABLE\"\n          }\n        ]\n      },\n      \"numBytes\": \"234849\",\n      \"numLongTermBytes\": \"0\",\n      \"numRows\": \"1000\",\n      \"creationTime\": \"1640891846119\",\n      \"lastModifiedTime\": \"1749427268137\",\n      \"type\": \"TABLE\",\n      \"location\": \"US\",\n      \"numTimeTravelPhysicalBytes\": \"285737\",\n      \"numTotalLogicalBytes\": \"234849\",\n      \"numActiveLogicalBytes\": \"234849\",\n      \"numLongTermLogicalBytes\"\
      : \"0\",\n      \"numTotalPhysicalBytes\": \"326557\",\n      \"numActivePhysicalBytes\": \"326557\",\n      \"numLongTermPhysicalBytes\": \"0\",\n      \"numCurrentPhysicalBytes\": \"40820\"\n    }"
  - signature: 'def get_job_info(project_id: str, job_id: str, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.bigquery.config.BigQueryToolConfig) -> dict:'
    docstring: "Get metadata information about a BigQuery job. Including slot usage,\n   job configuration, job statistics, job status, original query etc.\n\nArgs:\n    project_id (str): The Google Cloud project id containing the job.\n    job_id (str): The BigQuery job id.\n    credentials (Credentials): The credentials to use for the request.\n    settings (BigQueryToolConfig): The BigQuery tool settings.\n\nReturns:\n    dict: Dictionary representing the properties of the job.\n\nExamples:\n    >>> user may give job id in format of: project_id:region.job_id\n    like bigquery-public-data:US.bquxjob_12345678_1234567890\n    >>> get_job_info(\"bigquery-public-data\", \"bquxjob_12345678_1234567890\")\n    {\n      \"get_job_info_response\": {\n        \"configuration\": {\n          \"jobType\": \"QUERY\",\n          \"query\": {\n            \"destinationTable\": {\n              \"datasetId\": \"_fd6de55d5d5c13fcfb0449cbf933bb695b2c3085\",\n              \"projectId\": \"projectid\",\n\
      \              \"tableId\": \"anonfbbe65d6_9782_469b_9f56_1392560314b2\"\n            },\n            \"priority\": \"INTERACTIVE\",\n            \"query\": \"SELECT * FROM `projectid.dataset_id.table_id` WHERE TIMESTAMP_TRUNC(_PARTITIONTIME, DAY) = TIMESTAMP(\"2025-10-29\") LIMIT 1000\",\n            \"useLegacySql\": false,\n            \"writeDisposition\": \"WRITE_TRUNCATE\"\n          }\n        },\n        \"etag\": \"EdeYv9sdcO7tD9HsffvcuQ==\",\n        \"id\": \"projectid:US.job-id\",\n        \"jobCreationReason\": {\n          \"code\": \"REQUESTED\"\n        },\n        \"jobReference\": {\n          \"jobId\": \"job-id\",\n          \"location\": \"US\",\n          \"projectId\": \"projectid\"\n        },\n        \"kind\": \"bigquery#job\",\n        \"principal_subject\": \"user:abc@google.com\",\n        \"selfLink\": \"https://bigquery.googleapis.com/bigquery/v2/projects/projectid/jobs/job-id?location=US\",\n        \"statistics\": {\n          \"creationTime\": 1761760370152,\n\
      \          \"endTime\": 1761760371250,\n          \"finalExecutionDurationMs\": \"489\",\n          \"query\": {\n            \"billingTier\": 1,\n            \"cacheHit\": false,\n            \"estimatedBytesProcessed\": \"5597805\",\n            \"metadataCacheStatistics\": {\n              \"tableMetadataCacheUsage\": [\n                {\n                  \"explanation\": \"Table does not have CMETA.\",\n                  \"tableReference\": {\n                    \"datasetId\": \"datasetId\",\n                    \"projectId\": \"projectid\",\n                    \"tableId\": \"tableId\"\n                  },\n                  \"unusedReason\": \"OTHER_REASON\"\n                }\n              ]\n            },\n            \"queryPlan\": [\n              {\n                \"completedParallelInputs\": \"3\",\n                \"computeMode\": \"BIGQUERY\",\n                \"computeMsAvg\": \"13\",\n                \"computeMsMax\": \"15\",\n                \"computeRatioAvg\"\
      : 0.054852320675105488,\n                \"computeRatioMax\": 0.063291139240506333,\n                \"endMs\": \"1761760370422\",\n                \"id\": \"0\",\n                \"name\": \"S00: Input\",\n                \"parallelInputs\": \"8\",\n                \"readMsAvg\": \"18\",\n                \"readMsMax\": \"21\",\n                \"readRatioAvg\": 0.0759493670886076,\n                \"readRatioMax\": 0.088607594936708861,\n                \"recordsRead\": \"1690\",\n                \"recordsWritten\": \"1690\",\n                \"shuffleOutputBytes\": \"1031149\",\n                \"shuffleOutputBytesSpilled\": \"0\",\n                \"slotMs\": \"157\",\n                \"startMs\": \"1761760370388\",\n                \"status\": \"COMPLETE\",\n                \"steps\": [\n                  {\n                    \"kind\": \"READ\",\n                    \"substeps\": [\n                      \"$2:extendedFields.$is_not_null, $3:extendedFields.traceId, $4:span.$is_not_null,\
      \ $5:span.spanKind, $6:span.endTime, $7:span.startTime, $8:span.parentSpanId, $9:span.spanId, $10:span.name, $11:span.childSpanCount.$is_not_null, $12:span.childSpanCount.value, $13:span.sameProcessAsParentSpan.$is_not_null, $14:span.sameProcessAsParentSpan.value, $15:span.status.$is_not_null, $16:span.status.message, $17:span.status.code\",\n                      \"FROM projectid.dataset_id.table_id\",\n                      \"WHERE equal(timestamp_trunc($1, 3), 1761696000.000000000)\"\n                    ]\n                  },\n                  {\n                    \"kind\": \"LIMIT\",\n                    \"substeps\": [\n                      \"1000\"\n                    ]\n                  },\n                  {\n                    \"kind\": \"WRITE\",\n                    \"substeps\": [\n                      \"$2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17\",\n                      \"TO __stage00_output\"\n                    ]\n           \
      \       }\n                ],\n                \"waitMsAvg\": \"1\",\n                \"waitMsMax\": \"1\",\n                \"waitRatioAvg\": 0.0042194092827004216,\n                \"waitRatioMax\": 0.0042194092827004216,\n                \"writeMsAvg\": \"2\",\n                \"writeMsMax\": \"2\",\n                \"writeRatioAvg\": 0.0084388185654008432,\n                \"writeRatioMax\": 0.0084388185654008432\n              },\n              {\n                \"completedParallelInputs\": \"1\",\n                \"computeMode\": \"BIGQUERY\",\n                \"computeMsAvg\": \"22\",\n                \"computeMsMax\": \"22\",\n                \"computeRatioAvg\": 0.092827004219409287,\n                \"computeRatioMax\": 0.092827004219409287,\n                \"endMs\": \"1761760370428\",\n                \"id\": \"1\",\n                \"inputStages\": [\n                  \"0\"\n                ],\n                \"name\": \"S01: Compute+\",\n                \"parallelInputs\"\
      : \"1\",\n                \"readMsAvg\": \"0\",\n                \"readMsMax\": \"0\",\n                \"readRatioAvg\": 0,\n                \"readRatioMax\": 0,\n                \"recordsRead\": \"1001\",\n                \"recordsWritten\": \"1000\",\n                \"shuffleOutputBytes\": \"800157\",\n                \"shuffleOutputBytesSpilled\": \"0\",\n                \"slotMs\": \"29\",\n                \"startMs\": \"1761760370398\",\n                \"status\": \"COMPLETE\",\n                \"steps\": [\n                  {\n                    \"kind\": \"READ\",\n                    \"substeps\": [\n                      \"$2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17\",\n                      \"FROM __stage00_output\"\n                    ]\n                  },\n                  {\n                    \"kind\": \"COMPUTE\",\n                    \"substeps\": [\n                      \"$130 := MAKE_STRUCT($3, $2)\",\n                      \"\
      $131 := MAKE_STRUCT($10, $9, $8, MAKE_STRUCT($29, $28, $27), $7, $6, MAKE_STRUCT(...), MAKE_STRUCT(...), MAKE_STRUCT(...), ...)\"\n                    ]\n                  },\n                  {\n                    \"kind\": \"LIMIT\",\n                    \"substeps\": [\n                      \"1000\"\n                    ]\n                  },\n                  {\n                    \"kind\": \"WRITE\",\n                    \"substeps\": [\n                      \"$130, $131\",\n                      \"TO __stage01_output\"\n                    ]\n                  }\n                ],\n                \"waitMsAvg\": \"7\",\n                \"waitMsMax\": \"7\",\n                \"waitRatioAvg\": 0.029535864978902954,\n                \"waitRatioMax\": 0.029535864978902954,\n                \"writeMsAvg\": \"4\",\n                \"writeMsMax\": \"4\",\n                \"writeRatioAvg\": 0.016877637130801686,\n                \"writeRatioMax\": 0.016877637130801686\n     \
      \         },\n              {\n                \"completedParallelInputs\": \"1\",\n                \"computeMode\": \"BIGQUERY\",\n                \"computeMsAvg\": \"33\",\n                \"computeMsMax\": \"33\",\n                \"computeRatioAvg\": 0.13924050632911392,\n                \"computeRatioMax\": 0.13924050632911392,\n                \"endMs\": \"1761760370745\",\n                \"id\": \"2\",\n                \"inputStages\": [\n                  \"1\"\n                ],\n                \"name\": \"S02: Output\",\n                \"parallelInputs\": \"1\",\n                \"readMsAvg\": \"0\",\n                \"readMsMax\": \"0\",\n                \"readRatioAvg\": 0,\n                \"readRatioMax\": 0,\n                \"recordsRead\": \"1000\",\n                \"recordsWritten\": \"1000\",\n                \"shuffleOutputBytes\": \"459829\",\n                \"shuffleOutputBytesSpilled\": \"0\",\n                \"slotMs\": \"106\",\n                \"startMs\"\
      : \"1761760370667\",\n                \"status\": \"COMPLETE\",\n                \"steps\": [\n                  {\n                    \"kind\": \"READ\",\n                    \"substeps\": [\n                      \"$130, $131\",\n                      \"FROM __stage01_output\"\n                    ]\n                  },\n                  {\n                    \"kind\": \"WRITE\",\n                    \"substeps\": [\n                      \"$130, $131\",\n                      \"TO __stage02_output\"\n                    ]\n                  }\n                ],\n                \"waitMsAvg\": \"237\",\n                \"waitMsMax\": \"237\",\n                \"waitRatioAvg\": 1,\n                \"waitRatioMax\": 1,\n                \"writeMsAvg\": \"55\",\n                \"writeMsMax\": \"55\",\n                \"writeRatioAvg\": 0.2320675105485232,\n                \"writeRatioMax\": 0.2320675105485232\n              }\n            ],\n            \"referencedTables\": [\n\
      \              {\n                \"datasetId\": \"dataset_id\",\n                \"projectId\": \"projectid\",\n                \"tableId\": \"table_id\"\n              }\n            ],\n            \"statementType\": \"SELECT\",\n            \"timeline\": [\n              {\n                \"completedUnits\": \"5\",\n                \"elapsedMs\": \"492\",\n                \"estimatedRunnableUnits\": \"0\",\n                \"pendingUnits\": \"5\",\n                \"totalSlotMs\": \"293\"\n              }\n            ],\n            \"totalBytesBilled\": \"10485760\",\n            \"totalBytesProcessed\": \"5597805\",\n            \"totalPartitionsProcessed\": \"2\",\n            \"totalSlotMs\": \"293\",\n            \"transferredBytes\": \"0\"\n          },\n          \"startTime\": 1761760370268,\n          \"totalBytesProcessed\": \"5597805\",\n          \"totalSlotMs\": \"293\"\n        },\n        \"status\": {\n          \"state\": \"DONE\"\n        },\n        \"user_email\"\
      : \"abc@google.com\"\n      }\n    }"
- rank: 1517
  id: google.adk.tools.bigquery.metadata_tool.get_dataset_info
  name: get_dataset_info
  file_path: src/google/adk/tools/bigquery/metadata_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Get metadata information about a BigQuery dataset.\n\nArgs:\n    project_id (str): The Google Cloud project id containing the dataset.\n    dataset_id (str): The BigQuery dataset id.\n    credentials (Credentials): The credentials to use for the request.\n\nReturns:\n    dict: Dictionary representing the properties of the dataset.\n\nExamples:\n    >>> get_dataset_info(\"bigquery-public-data\", \"cdc_places\")\n    {\n      \"kind\": \"bigquery#dataset\",\n      \"etag\": \"fz9BaiXKgbGi53EpI2rJug==\",\n      \"id\": \"bigquery-public-data:cdc_places\",\n      \"selfLink\": \"https://content-bigquery.googleapis.com/bigquery/v2/projects/bigquery-public-data/datasets/cdc_places\",\n      \"datasetReference\": {\n        \"datasetId\": \"cdc_places\",\n        \"projectId\": \"bigquery-public-data\"\n      },\n      \"description\": \"Local Data for Better Health, County Data\",\n      \"access\": [\n        {\n          \"role\": \"WRITER\",\n          \"specialGroup\": \"projectWriters\"\
    \n        },\n        {\n          \"role\": \"OWNER\",\n          \"specialGroup\": \"projectOwners\"\n        },\n        {\n          \"role\": \"OWNER\",\n          \"userByEmail\": \"some-redacted-email@bigquery-public-data.iam.gserviceaccount.com\"\n        },\n        {\n          \"role\": \"READER\",\n          \"specialGroup\": \"projectReaders\"\n        }\n      ],\n      \"creationTime\": \"1640891845643\",\n      \"lastModifiedTime\": \"1640891845643\",\n      \"location\": \"US\",\n      \"type\": \"DEFAULT\",\n      \"maxTimeTravelHours\": \"168\"\n    }"
  signature: 'def get_dataset_info(project_id: str, dataset_id: str, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.bigquery.config.BigQueryToolConfig) -> dict:'
- rank: 1518
  id: google.adk.tools.bigquery.metadata_tool.get_job_info
  name: get_job_info
  file_path: src/google/adk/tools/bigquery/metadata_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Get metadata information about a BigQuery job. Including slot usage,\n   job configuration, job statistics, job status, original query etc.\n\nArgs:\n    project_id (str): The Google Cloud project id containing the job.\n    job_id (str): The BigQuery job id.\n    credentials (Credentials): The credentials to use for the request.\n    settings (BigQueryToolConfig): The BigQuery tool settings.\n\nReturns:\n    dict: Dictionary representing the properties of the job.\n\nExamples:\n    >>> user may give job id in format of: project_id:region.job_id\n    like bigquery-public-data:US.bquxjob_12345678_1234567890\n    >>> get_job_info(\"bigquery-public-data\", \"bquxjob_12345678_1234567890\")\n    {\n      \"get_job_info_response\": {\n        \"configuration\": {\n          \"jobType\": \"QUERY\",\n          \"query\": {\n            \"destinationTable\": {\n              \"datasetId\": \"_fd6de55d5d5c13fcfb0449cbf933bb695b2c3085\",\n              \"projectId\": \"projectid\",\n\
    \              \"tableId\": \"anonfbbe65d6_9782_469b_9f56_1392560314b2\"\n            },\n            \"priority\": \"INTERACTIVE\",\n            \"query\": \"SELECT * FROM `projectid.dataset_id.table_id` WHERE TIMESTAMP_TRUNC(_PARTITIONTIME, DAY) = TIMESTAMP(\"2025-10-29\") LIMIT 1000\",\n            \"useLegacySql\": false,\n            \"writeDisposition\": \"WRITE_TRUNCATE\"\n          }\n        },\n        \"etag\": \"EdeYv9sdcO7tD9HsffvcuQ==\",\n        \"id\": \"projectid:US.job-id\",\n        \"jobCreationReason\": {\n          \"code\": \"REQUESTED\"\n        },\n        \"jobReference\": {\n          \"jobId\": \"job-id\",\n          \"location\": \"US\",\n          \"projectId\": \"projectid\"\n        },\n        \"kind\": \"bigquery#job\",\n        \"principal_subject\": \"user:abc@google.com\",\n        \"selfLink\": \"https://bigquery.googleapis.com/bigquery/v2/projects/projectid/jobs/job-id?location=US\",\n        \"statistics\": {\n          \"creationTime\": 1761760370152,\n\
    \          \"endTime\": 1761760371250,\n          \"finalExecutionDurationMs\": \"489\",\n          \"query\": {\n            \"billingTier\": 1,\n            \"cacheHit\": false,\n            \"estimatedBytesProcessed\": \"5597805\",\n            \"metadataCacheStatistics\": {\n              \"tableMetadataCacheUsage\": [\n                {\n                  \"explanation\": \"Table does not have CMETA.\",\n                  \"tableReference\": {\n                    \"datasetId\": \"datasetId\",\n                    \"projectId\": \"projectid\",\n                    \"tableId\": \"tableId\"\n                  },\n                  \"unusedReason\": \"OTHER_REASON\"\n                }\n              ]\n            },\n            \"queryPlan\": [\n              {\n                \"completedParallelInputs\": \"3\",\n                \"computeMode\": \"BIGQUERY\",\n                \"computeMsAvg\": \"13\",\n                \"computeMsMax\": \"15\",\n                \"computeRatioAvg\"\
    : 0.054852320675105488,\n                \"computeRatioMax\": 0.063291139240506333,\n                \"endMs\": \"1761760370422\",\n                \"id\": \"0\",\n                \"name\": \"S00: Input\",\n                \"parallelInputs\": \"8\",\n                \"readMsAvg\": \"18\",\n                \"readMsMax\": \"21\",\n                \"readRatioAvg\": 0.0759493670886076,\n                \"readRatioMax\": 0.088607594936708861,\n                \"recordsRead\": \"1690\",\n                \"recordsWritten\": \"1690\",\n                \"shuffleOutputBytes\": \"1031149\",\n                \"shuffleOutputBytesSpilled\": \"0\",\n                \"slotMs\": \"157\",\n                \"startMs\": \"1761760370388\",\n                \"status\": \"COMPLETE\",\n                \"steps\": [\n                  {\n                    \"kind\": \"READ\",\n                    \"substeps\": [\n                      \"$2:extendedFields.$is_not_null, $3:extendedFields.traceId, $4:span.$is_not_null,\
    \ $5:span.spanKind, $6:span.endTime, $7:span.startTime, $8:span.parentSpanId, $9:span.spanId, $10:span.name, $11:span.childSpanCount.$is_not_null, $12:span.childSpanCount.value, $13:span.sameProcessAsParentSpan.$is_not_null, $14:span.sameProcessAsParentSpan.value, $15:span.status.$is_not_null, $16:span.status.message, $17:span.status.code\",\n                      \"FROM projectid.dataset_id.table_id\",\n                      \"WHERE equal(timestamp_trunc($1, 3), 1761696000.000000000)\"\n                    ]\n                  },\n                  {\n                    \"kind\": \"LIMIT\",\n                    \"substeps\": [\n                      \"1000\"\n                    ]\n                  },\n                  {\n                    \"kind\": \"WRITE\",\n                    \"substeps\": [\n                      \"$2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17\",\n                      \"TO __stage00_output\"\n                    ]\n             \
    \     }\n                ],\n                \"waitMsAvg\": \"1\",\n                \"waitMsMax\": \"1\",\n                \"waitRatioAvg\": 0.0042194092827004216,\n                \"waitRatioMax\": 0.0042194092827004216,\n                \"writeMsAvg\": \"2\",\n                \"writeMsMax\": \"2\",\n                \"writeRatioAvg\": 0.0084388185654008432,\n                \"writeRatioMax\": 0.0084388185654008432\n              },\n              {\n                \"completedParallelInputs\": \"1\",\n                \"computeMode\": \"BIGQUERY\",\n                \"computeMsAvg\": \"22\",\n                \"computeMsMax\": \"22\",\n                \"computeRatioAvg\": 0.092827004219409287,\n                \"computeRatioMax\": 0.092827004219409287,\n                \"endMs\": \"1761760370428\",\n                \"id\": \"1\",\n                \"inputStages\": [\n                  \"0\"\n                ],\n                \"name\": \"S01: Compute+\",\n                \"parallelInputs\"\
    : \"1\",\n                \"readMsAvg\": \"0\",\n                \"readMsMax\": \"0\",\n                \"readRatioAvg\": 0,\n                \"readRatioMax\": 0,\n                \"recordsRead\": \"1001\",\n                \"recordsWritten\": \"1000\",\n                \"shuffleOutputBytes\": \"800157\",\n                \"shuffleOutputBytesSpilled\": \"0\",\n                \"slotMs\": \"29\",\n                \"startMs\": \"1761760370398\",\n                \"status\": \"COMPLETE\",\n                \"steps\": [\n                  {\n                    \"kind\": \"READ\",\n                    \"substeps\": [\n                      \"$2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17\",\n                      \"FROM __stage00_output\"\n                    ]\n                  },\n                  {\n                    \"kind\": \"COMPUTE\",\n                    \"substeps\": [\n                      \"$130 := MAKE_STRUCT($3, $2)\",\n                      \"$131\
    \ := MAKE_STRUCT($10, $9, $8, MAKE_STRUCT($29, $28, $27), $7, $6, MAKE_STRUCT(...), MAKE_STRUCT(...), MAKE_STRUCT(...), ...)\"\n                    ]\n                  },\n                  {\n                    \"kind\": \"LIMIT\",\n                    \"substeps\": [\n                      \"1000\"\n                    ]\n                  },\n                  {\n                    \"kind\": \"WRITE\",\n                    \"substeps\": [\n                      \"$130, $131\",\n                      \"TO __stage01_output\"\n                    ]\n                  }\n                ],\n                \"waitMsAvg\": \"7\",\n                \"waitMsMax\": \"7\",\n                \"waitRatioAvg\": 0.029535864978902954,\n                \"waitRatioMax\": 0.029535864978902954,\n                \"writeMsAvg\": \"4\",\n                \"writeMsMax\": \"4\",\n                \"writeRatioAvg\": 0.016877637130801686,\n                \"writeRatioMax\": 0.016877637130801686\n          \
    \    },\n              {\n                \"completedParallelInputs\": \"1\",\n                \"computeMode\": \"BIGQUERY\",\n                \"computeMsAvg\": \"33\",\n                \"computeMsMax\": \"33\",\n                \"computeRatioAvg\": 0.13924050632911392,\n                \"computeRatioMax\": 0.13924050632911392,\n                \"endMs\": \"1761760370745\",\n                \"id\": \"2\",\n                \"inputStages\": [\n                  \"1\"\n                ],\n                \"name\": \"S02: Output\",\n                \"parallelInputs\": \"1\",\n                \"readMsAvg\": \"0\",\n                \"readMsMax\": \"0\",\n                \"readRatioAvg\": 0,\n                \"readRatioMax\": 0,\n                \"recordsRead\": \"1000\",\n                \"recordsWritten\": \"1000\",\n                \"shuffleOutputBytes\": \"459829\",\n                \"shuffleOutputBytesSpilled\": \"0\",\n                \"slotMs\": \"106\",\n                \"startMs\"\
    : \"1761760370667\",\n                \"status\": \"COMPLETE\",\n                \"steps\": [\n                  {\n                    \"kind\": \"READ\",\n                    \"substeps\": [\n                      \"$130, $131\",\n                      \"FROM __stage01_output\"\n                    ]\n                  },\n                  {\n                    \"kind\": \"WRITE\",\n                    \"substeps\": [\n                      \"$130, $131\",\n                      \"TO __stage02_output\"\n                    ]\n                  }\n                ],\n                \"waitMsAvg\": \"237\",\n                \"waitMsMax\": \"237\",\n                \"waitRatioAvg\": 1,\n                \"waitRatioMax\": 1,\n                \"writeMsAvg\": \"55\",\n                \"writeMsMax\": \"55\",\n                \"writeRatioAvg\": 0.2320675105485232,\n                \"writeRatioMax\": 0.2320675105485232\n              }\n            ],\n            \"referencedTables\": [\n\
    \              {\n                \"datasetId\": \"dataset_id\",\n                \"projectId\": \"projectid\",\n                \"tableId\": \"table_id\"\n              }\n            ],\n            \"statementType\": \"SELECT\",\n            \"timeline\": [\n              {\n                \"completedUnits\": \"5\",\n                \"elapsedMs\": \"492\",\n                \"estimatedRunnableUnits\": \"0\",\n                \"pendingUnits\": \"5\",\n                \"totalSlotMs\": \"293\"\n              }\n            ],\n            \"totalBytesBilled\": \"10485760\",\n            \"totalBytesProcessed\": \"5597805\",\n            \"totalPartitionsProcessed\": \"2\",\n            \"totalSlotMs\": \"293\",\n            \"transferredBytes\": \"0\"\n          },\n          \"startTime\": 1761760370268,\n          \"totalBytesProcessed\": \"5597805\",\n          \"totalSlotMs\": \"293\"\n        },\n        \"status\": {\n          \"state\": \"DONE\"\n        },\n        \"user_email\"\
    : \"abc@google.com\"\n      }\n    }"
  signature: 'def get_job_info(project_id: str, job_id: str, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.bigquery.config.BigQueryToolConfig) -> dict:'
- rank: 1519
  id: google.adk.tools.bigquery.metadata_tool.get_table_info
  name: get_table_info
  file_path: src/google/adk/tools/bigquery/metadata_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Get metadata information about a BigQuery table.\n\nArgs:\n    project_id (str): The Google Cloud project id containing the dataset.\n    dataset_id (str): The BigQuery dataset id containing the table.\n    table_id (str): The BigQuery table id.\n    credentials (Credentials): The credentials to use for the request.\n\nReturns:\n    dict: Dictionary representing the properties of the table.\n\nExamples:\n    >>> get_table_info(\"bigquery-public-data\", \"cdc_places\", \"local_data_for_better_health_county_data\")\n    {\n      \"kind\": \"bigquery#table\",\n      \"etag\": \"wx23aDqmgc39oUSiNuYTAA==\",\n      \"id\": \"bigquery-public-data:cdc_places.local_data_for_better_health_county_data\",\n      \"selfLink\": \"https://content-bigquery.googleapis.com/bigquery/v2/projects/bigquery-public-data/datasets/cdc_places/tables/local_data_for_better_health_county_data\",\n      \"tableReference\": {\n        \"projectId\": \"bigquery-public-data\",\n        \"datasetId\": \"cdc_places\"\
    ,\n        \"tableId\": \"local_data_for_better_health_county_data\"\n      },\n      \"description\": \"Local Data for Better Health, County Data\",\n      \"schema\": {\n        \"fields\": [\n          {\n            \"name\": \"year\",\n            \"type\": \"INTEGER\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"stateabbr\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"statedesc\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"locationname\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"datasource\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"category\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n \
    \         },\n          {\n            \"name\": \"measure\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"data_value_unit\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"data_value_type\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"data_value\",\n            \"type\": \"FLOAT\",\n            \"mode\": \"NULLABLE\"\n          }\n        ]\n      },\n      \"numBytes\": \"234849\",\n      \"numLongTermBytes\": \"0\",\n      \"numRows\": \"1000\",\n      \"creationTime\": \"1640891846119\",\n      \"lastModifiedTime\": \"1749427268137\",\n      \"type\": \"TABLE\",\n      \"location\": \"US\",\n      \"numTimeTravelPhysicalBytes\": \"285737\",\n      \"numTotalLogicalBytes\": \"234849\",\n      \"numActiveLogicalBytes\": \"234849\",\n      \"numLongTermLogicalBytes\"\
    : \"0\",\n      \"numTotalPhysicalBytes\": \"326557\",\n      \"numActivePhysicalBytes\": \"326557\",\n      \"numLongTermPhysicalBytes\": \"0\",\n      \"numCurrentPhysicalBytes\": \"40820\"\n    }"
  signature: 'def get_table_info(project_id: str, dataset_id: str, table_id: str, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.bigquery.config.BigQueryToolConfig) -> dict:'
- rank: 1520
  id: google.adk.tools.bigquery.metadata_tool.list_dataset_ids
  name: list_dataset_ids
  file_path: src/google/adk/tools/bigquery/metadata_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "List BigQuery dataset ids in a Google Cloud project.\n\nArgs:\n    project_id (str): The Google Cloud project id.\n    credentials (Credentials): The credentials to use for the request.\n\nReturns:\n    list[str]: List of the BigQuery dataset ids present in the project.\n\nExamples:\n    >>> list_dataset_ids(\"bigquery-public-data\")\n    ['america_health_rankings',\n     'american_community_survey',\n     'aml_ai_input_dataset',\n     'austin_311',\n     'austin_bikeshare',\n     'austin_crime',\n     'austin_incidents',\n     'austin_waste',\n     'baseball',\n     'bbc_news']"
  signature: 'def list_dataset_ids(project_id: str, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.bigquery.config.BigQueryToolConfig) -> list[str]:'
- rank: 1521
  id: google.adk.tools.bigquery.metadata_tool.list_table_ids
  name: list_table_ids
  file_path: src/google/adk/tools/bigquery/metadata_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "List table ids in a BigQuery dataset.\n\nArgs:\n    project_id (str): The Google Cloud project id containing the dataset.\n    dataset_id (str): The BigQuery dataset id.\n    credentials (Credentials): The credentials to use for the request.\n\nReturns:\n    list[str]: List of the tables ids present in the dataset.\n\nExamples:\n    >>> list_table_ids(\"bigquery-public-data\", \"cdc_places\")\n    ['chronic_disease_indicators',\n     'local_data_for_better_health_county_data']"
  signature: 'def list_table_ids(project_id: str, dataset_id: str, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.bigquery.config.BigQueryToolConfig) -> list[str]:'
- rank: 1522
  id: google.adk.tools.bigquery.query_tool
  name: query_tool
  file_path: src/google/adk/tools/bigquery/query_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def execute_sql(project_id: str, query: str, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.bigquery.config.BigQueryToolConfig, tool_context: google.adk.tools.tool_context.ToolContext, dry_run: bool) -> dict:'
    docstring: "Run a BigQuery or BigQuery ML SQL query in the project and return the result.\n\nArgs:\n    project_id (str): The GCP project id in which the query should be\n      executed.\n    query (str): The BigQuery SQL query to be executed.\n    credentials (Credentials): The credentials to use for the request.\n    settings (BigQueryToolConfig): The settings for the tool.\n    tool_context (ToolContext): The context for the tool.\n    dry_run (bool, default False): If True, the query will not be executed.\n      Instead, the query will be validated and information about the query\n      will be returned. Defaults to False.\n\nReturns:\n    dict: If `dry_run` is False, dictionary representing the result of the\n          query. If the result contains the key \"result_is_likely_truncated\"\n          with value True, it means that there may be additional rows matching\n          the query not returned in the result.\n          If `dry_run` is True, dictionary with \"dry_run_info\"\
      \ field\n          containing query information returned by BigQuery.\n\nExamples:\n    Fetch data or insights from a table:\n\n        >>> execute_sql(\"my_project\",\n        ... \"SELECT island, COUNT(*) AS population \"\n        ... \"FROM `bigquery-public-data`.`ml_datasets`.`penguins` GROUP BY island\")\n        {\n          \"status\": \"SUCCESS\",\n          \"rows\": [\n              {\n                  \"island\": \"Dream\",\n                  \"population\": 124\n              },\n              {\n                  \"island\": \"Biscoe\",\n                  \"population\": 168\n              },\n              {\n                  \"island\": \"Torgersen\",\n                  \"population\": 52\n              }\n          ]\n        }\n\n    Validate a query and estimate costs without executing it:\n\n        >>> execute_sql(\n        ...     \"my_project\",\n        ...     \"SELECT island FROM \"\n        ...     \"`bigquery-public-data`.`ml_datasets`.`penguins`\",\n \
      \       ...     dry_run=True\n        ... )\n        {\n          \"status\": \"SUCCESS\",\n          \"dry_run_info\": {\n            \"configuration\": {\n              \"dryRun\": True,\n              \"jobType\": \"QUERY\",\n              \"query\": {\n                \"destinationTable\": {\n                  \"datasetId\": \"_...\",\n                  \"projectId\": \"my_project\",\n                  \"tableId\": \"anon...\"\n                },\n                \"priority\": \"INTERACTIVE\",\n                \"query\": \"SELECT island FROM `bigquery-public-data`.`ml_datasets`.`penguins`\",\n                \"useLegacySql\": False,\n                \"writeDisposition\": \"WRITE_TRUNCATE\"\n              }\n            },\n            \"jobReference\": {\n              \"location\": \"US\",\n              \"projectId\": \"my_project\"\n            }\n          }\n        }"
  - signature: 'def get_execute_sql(settings: google.adk.tools.bigquery.config.BigQueryToolConfig) -> typing.Callable[Ellipsis, dict]:'
    docstring: "Get the execute_sql tool customized as per the given tool settings.\n\nArgs:\n    settings: BigQuery tool settings indicating the behavior of the\n      execute_sql tool.\n\nReturns:\n    callable[..., dict]: A version of the execute_sql tool respecting the tool\n    settings."
  - signature: 'def forecast(project_id: str, history_data: str, timestamp_col: str, data_col: str, horizon: int, id_cols: typing.Optional[list[str]], *, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.bigquery.config.BigQueryToolConfig, tool_context: google.adk.tools.tool_context.ToolContext) -> dict:'
    docstring: "Run a BigQuery AI time series forecast using AI.FORECAST.\n\nArgs:\n    project_id (str): The GCP project id in which the query should be\n      executed.\n    history_data (str): The table id of the BigQuery table containing the\n      history time series data or a query statement that select the history\n      data.\n    timestamp_col (str): The name of the column containing the timestamp for\n      each data point.\n    data_col (str): The name of the column containing the numerical values to\n      be forecasted.\n    horizon (int, optional): The number of time steps to forecast into the\n      future. Defaults to 10.\n    id_cols (list, optional): The column names of the id columns to indicate\n      each time series when there are multiple time series in the table. All\n      elements must be strings. Defaults to None.\n    credentials (Credentials): The credentials to use for the request.\n    settings (BigQueryToolConfig): The settings for the tool.\n    tool_context\
      \ (ToolContext): The context for the tool.\n\nReturns:\n    dict: Dictionary representing the result of the forecast. The result\n          contains the forecasted values along with prediction intervals.\n\nExamples:\n    Forecast daily sales for the next 7 days based on historical data from\n    a BigQuery table:\n\n        >>> forecast(\n        ...     project_id=\"my-gcp-project\",\n        ...     history_data=\"my-dataset.my-sales-table\",\n        ...     timestamp_col=\"sale_date\",\n        ...     data_col=\"daily_sales\",\n        ...     horizon=7\n        ... )\n        {\n          \"status\": \"SUCCESS\",\n          \"rows\": [\n            {\n              \"forecast_timestamp\": \"2025-01-08T00:00:00\",\n              \"forecast_value\": 12345.67,\n              \"confidence_level\": 0.95,\n              \"prediction_interval_lower_bound\": 11000.0,\n              \"prediction_interval_upper_bound\": 13691.34,\n              \"ai_forecast_status\": \"\"\n         \
      \   },\n            ...\n          ]\n        }\n\n    Forecast multiple time series using a SQL query as input:\n\n        >>> history_query = (\n        ...     \"SELECT unique_id, timestamp, value \"\n        ...     \"FROM `my-project.my-dataset.my-timeseries-table` \"\n        ...     \"WHERE timestamp > '1980-01-01'\"\n        ... )\n        >>> forecast(\n        ...     project_id=\"my-gcp-project\",\n        ...     history_data=history_query,\n        ...     timestamp_col=\"timestamp\",\n        ...     data_col=\"value\",\n        ...     id_cols=[\"unique_id\"],\n        ...     horizon=14\n        ... )\n        {\n          \"status\": \"SUCCESS\",\n          \"rows\": [\n            {\n              \"unique_id\": \"T1\",\n              \"forecast_timestamp\": \"1980-08-28T00:00:00\",\n              \"forecast_value\": 1253218.75,\n              \"confidence_level\": 0.95,\n              \"prediction_interval_lower_bound\": 274252.51,\n              \"prediction_interval_upper_bound\"\
      : 2232184.99,\n              \"ai_forecast_status\": \"\"\n            },\n            ...\n          ]\n        }\n\n    Error Scenarios:\n        When an element in `id_cols` is not a string:\n\n        >>> forecast(\n        ...     project_id=\"my-gcp-project\",\n        ...     history_data=\"my-dataset.my-sales-table\",\n        ...     timestamp_col=\"sale_date\",\n        ...     data_col=\"daily_sales\",\n        ...     id_cols=[\"store_id\", 123]\n        ... )\n        {\n          \"status\": \"ERROR\",\n          \"error_details\": \"All elements in id_cols must be strings.\"\n        }\n\n        When `history_data` refers to a table that does not exist:\n\n        >>> forecast(\n        ...     project_id=\"my-gcp-project\",\n        ...     history_data=\"my-dataset.nonexistent-table\",\n        ...     timestamp_col=\"sale_date\",\n        ...     data_col=\"daily_sales\"\n        ... )\n        {\n          \"status\": \"ERROR\",\n          \"error_details\": \"\
      Not found: Table\n          my-gcp-project:my-dataset.nonexistent-table was not found in\n          location US\"\n        }"
  - signature: 'def analyze_contribution(project_id: str, input_data: str, contribution_metric: str, dimension_id_cols: list[str], is_test_col: str, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.bigquery.config.BigQueryToolConfig, tool_context: google.adk.tools.tool_context.ToolContext, top_k_insights: int, pruning_method: str) -> dict:'
    docstring: "Run a BigQuery ML contribution analysis using ML.CREATE_MODEL and ML.GET_INSIGHTS.\n\nArgs:\n    project_id (str): The GCP project id in which the query should be\n      executed.\n    input_data (str): The data that contain the test and control data to\n      analyze. Can be a fully qualified BigQuery table ID or a SQL query.\n    dimension_id_cols (list[str]): The column names of the dimension columns.\n    contribution_metric (str): The name of the column that contains the metric\n      to analyze. Provides the expression to use to calculate the metric you\n      are analyzing. To calculate a summable metric, the expression must be in\n      the form SUM(metric_column_name), where metric_column_name is a numeric\n      data type.  To calculate a summable ratio metric, the expression must be\n      in the form\n      SUM(numerator_metric_column_name)/SUM(denominator_metric_column_name),\n      where numerator_metric_column_name and denominator_metric_column_name\n     \
      \ are numeric data types.  To calculate a summable by category metric, the\n      expression must be in the form\n      SUM(metric_sum_column_name)/COUNT(DISTINCT categorical_column_name). The\n      summed column must be a numeric data type. The categorical column must\n      have type BOOL, DATE, DATETIME, TIME, TIMESTAMP, STRING, or INT64.\n    is_test_col (str): The name of the column to use to determine whether a\n      given row is test data or control data. The column must have a BOOL data\n      type.\n    credentials: The credentials to use for the request.\n    settings: The settings for the tool.\n    tool_context: The context for the tool.\n    top_k_insights (int, optional): The number of top insights to return,\n      ranked by apriori support. Defaults to 30.\n    pruning_method (str, optional): The method to use for pruning redundant\n      insights. Can be 'NO_PRUNING' or 'PRUNE_REDUNDANT_INSIGHTS'. Defaults to\n      \"PRUNE_REDUNDANT_INSIGHTS\".\n\nReturns:\n   \
      \ dict: Dictionary representing the result of the contribution analysis.\n\nExamples:\n    Analyze the contribution of different dimensions to the total sales:\n\n        >>> analyze_contribution(\n        ...     project_id=\"my-gcp-project\",\n        ...     input_data=\"my-dataset.my-sales-table\",\n        ...     dimension_id_cols=[\"store_id\", \"product_category\"],\n        ...     contribution_metric=\"SUM(total_sales)\",\n        ...     is_test_col=\"is_test\"\n        ... )\n        The return is:\n        {\n          \"status\": \"SUCCESS\",\n          \"rows\": [\n            {\n              \"store_id\": \"S1\",\n              \"product_category\": \"Electronics\",\n              \"contributors\": [\"S1\", \"Electronics\"],\n              \"metric_test\": 120,\n              \"metric_control\": 100,\n              \"difference\": 20,\n              \"relative_difference\": 0.2,\n              \"unexpected_difference\": 5,\n              \"relative_unexpected_difference\"\
      : 0.043,\n              \"apriori_support\": 0.15\n            },\n            ...\n          ]\n        }\n\n    Analyze the contribution of different dimensions to the total sales using\n    a SQL query as input:\n\n        >>> analyze_contribution(\n        ...     project_id=\"my-gcp-project\",\n        ...     input_data=\"SELECT store_id, product_category, total_sales, \"\n        ...     \"is_test FROM `my-project.my-dataset.my-sales-table` \"\n        ...     \"WHERE transaction_date > '2025-01-01'\"\n        ...     dimension_id_cols=[\"store_id\", \"product_category\"],\n        ...     contribution_metric=\"SUM(total_sales)\",\n        ...     is_test_col=\"is_test\"\n        ... )\n        The return is:\n        {\n          \"status\": \"SUCCESS\",\n          \"rows\": [\n            {\n              \"store_id\": \"S2\",\n              \"product_category\": \"Groceries\",\n              \"contributors\": [\"S2\", \"Groceries\"],\n              \"metric_test\": 250,\n\
      \              \"metric_control\": 200,\n              \"difference\": 50,\n              \"relative_difference\": 0.25,\n              \"unexpected_difference\": 10,\n              \"relative_unexpected_difference\": 0.041,\n              \"apriori_support\": 0.22\n            },\n            ...\n          ]\n        }"
  - signature: 'def detect_anomalies(project_id: str, history_data: str, times_series_timestamp_col: str, times_series_data_col: str, horizon: typing.Optional[int], target_data: typing.Optional[str], times_series_id_cols: typing.Optional[list[str]], anomaly_prob_threshold: typing.Optional[float], *, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.bigquery.config.BigQueryToolConfig, tool_context: google.adk.tools.tool_context.ToolContext) -> dict:'
    docstring: "Run a BigQuery time series ARIMA_PLUS model training and anomaly detection using CREATE MODEL and ML.DETECT_ANOMALIES clauses.\n\nArgs:\n    project_id (str): The GCP project id in which the query should be\n      executed.\n    history_data (str): The table id of the BigQuery table containing the\n      history time series data or a query statement that select the history\n      data.\n    times_series_timestamp_col (str): The name of the column containing the\n      timestamp for each data point.\n    times_series_data_col (str): The name of the column containing the\n      numerical values to be forecasted and anomaly detected.\n    horizon (int, optional): The number of time steps to forecast into the\n      future. Defaults to 1000.\n    target_data (str, optional): The table id of the BigQuery table containing\n      the target time series data or a query statement that select the target\n      data.\n    times_series_id_cols (list, optional): The column names of the\
      \ id columns\n      to indicate each time series when there are multiple time series in the\n      table. All elements must be strings. Defaults to None.\n    anomaly_prob_threshold (float, optional): The probability threshold to\n      determine if a data point is an anomaly. Defaults to 0.95.\n    credentials (Credentials): The credentials to use for the request.\n    settings (BigQueryToolConfig): The settings for the tool.\n    tool_context (ToolContext): The context for the tool.\n\nReturns:\n    dict: Dictionary representing the result of the anomaly detection. The\n          result contains the boolean value if the data point is anomaly or\n          not, lower bound, upper bound and anomaly probability for each data\n          point and also the probability of whether the data point is anomaly\n          or not.\n\nExamples:\n    Detect Anomalies daily sales based on historical data from a BigQuery\n    table:\n\n        >>> detect_anomalies(\n        ...     project_id=\"\
      my-gcp-project\",\n        ...     history_data=\"my-dataset.my-sales-table\",\n        ...     times_series_timestamp_col=\"sale_date\",\n        ...     times_series_data_col=\"daily_sales\"\n        ... )\n        {\n          \"status\": \"SUCCESS\",\n          \"rows\": [\n            {\n              \"ts_timestamp\": \"2021-01-01 00:00:01 UTC\",\n              \"ts_data\": 125.3,\n              \"is_anomaly\": TRUE,\n              \"lower_bound\": 129.5,\n              \"upper_bound\": 133.6 ,\n              \"anomaly_probability\": 0.93\n            },\n            ...\n          ]\n        }\n\n    Detect Anomalies on multiple time series using a SQL query as input:\n\n        >>> history_query = (\n        ...     \"SELECT unique_id, timestamp, value \"\n        ...     \"FROM `my-project.my-dataset.my-timeseries-table` \"\n        ...     \"WHERE timestamp > '1980-01-01'\"\n        ... )\n        >>> detect_anomalies(\n        ...     project_id=\"my-gcp-project\",\n   \
      \     ...     history_data=history_query,\n        ...     times_series_timestamp_col=\"timestamp\",\n        ...     times_series_data_col=\"value\",\n        ...     times_series_id_cols=[\"unique_id\"]\n        ... )\n        {\n          \"status\": \"SUCCESS\",\n          \"rows\": [\n            {\n              \"unique_id\": \"T1\",\n              \"ts_timestamp\": \"2021-01-01 00:00:01 UTC\",\n              \"ts_data\": 125.3,\n              \"is_anomaly\": TRUE,\n              \"lower_bound\": 129.5,\n              \"upper_bound\": 133.6 ,\n              \"anomaly_probability\": 0.93\n            },\n            ...\n          ]\n        }\n\n    Error Scenarios:\n        When an element in `times_series_id_cols` is not a string:\n\n        >>> detect_anomalies(\n        ...     project_id=\"my-gcp-project\",\n        ...     history_data=\"my-dataset.my-sales-table\",\n        ...     times_series_timestamp_col=\"sale_date\",\n        ...     times_series_data_col=\"daily_sales\"\
      ,\n        ...     times_series_id_cols=[\"store_id\", 123]\n        ... )\n        {\n          \"status\": \"ERROR\",\n          \"error_details\": \"All elements in times_series_id_cols must be\n          strings.\"\n        }\n\n        When `history_data` refers to a table that does not exist:\n\n        >>> detect_anomalies(\n        ...     project_id=\"my-gcp-project\",\n        ...     history_data=\"my-dataset.nonexistent-table\",\n        ...     times_series_timestamp_col=\"sale_date\",\n        ...     times_series_data_col=\"daily_sales\"\n        ... )\n        {\n          \"status\": \"ERROR\",\n          \"error_details\": \"Not found: Table\n          my-gcp-project:my-dataset.nonexistent-table was not found in\n          location US\"\n        }"
  properties:
  - signature: 'BIGQUERY_SESSION_INFO_KEY: str'
- rank: 1523
  id: google.adk.tools.bigquery.query_tool.analyze_contribution
  name: analyze_contribution
  file_path: src/google/adk/tools/bigquery/query_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Run a BigQuery ML contribution analysis using ML.CREATE_MODEL and ML.GET_INSIGHTS.\n\nArgs:\n    project_id (str): The GCP project id in which the query should be\n      executed.\n    input_data (str): The data that contain the test and control data to\n      analyze. Can be a fully qualified BigQuery table ID or a SQL query.\n    dimension_id_cols (list[str]): The column names of the dimension columns.\n    contribution_metric (str): The name of the column that contains the metric\n      to analyze. Provides the expression to use to calculate the metric you\n      are analyzing. To calculate a summable metric, the expression must be in\n      the form SUM(metric_column_name), where metric_column_name is a numeric\n      data type.  To calculate a summable ratio metric, the expression must be\n      in the form\n      SUM(numerator_metric_column_name)/SUM(denominator_metric_column_name),\n      where numerator_metric_column_name and denominator_metric_column_name\n      are\
    \ numeric data types.  To calculate a summable by category metric, the\n      expression must be in the form\n      SUM(metric_sum_column_name)/COUNT(DISTINCT categorical_column_name). The\n      summed column must be a numeric data type. The categorical column must\n      have type BOOL, DATE, DATETIME, TIME, TIMESTAMP, STRING, or INT64.\n    is_test_col (str): The name of the column to use to determine whether a\n      given row is test data or control data. The column must have a BOOL data\n      type.\n    credentials: The credentials to use for the request.\n    settings: The settings for the tool.\n    tool_context: The context for the tool.\n    top_k_insights (int, optional): The number of top insights to return,\n      ranked by apriori support. Defaults to 30.\n    pruning_method (str, optional): The method to use for pruning redundant\n      insights. Can be 'NO_PRUNING' or 'PRUNE_REDUNDANT_INSIGHTS'. Defaults to\n      \"PRUNE_REDUNDANT_INSIGHTS\".\n\nReturns:\n    dict:\
    \ Dictionary representing the result of the contribution analysis.\n\nExamples:\n    Analyze the contribution of different dimensions to the total sales:\n\n        >>> analyze_contribution(\n        ...     project_id=\"my-gcp-project\",\n        ...     input_data=\"my-dataset.my-sales-table\",\n        ...     dimension_id_cols=[\"store_id\", \"product_category\"],\n        ...     contribution_metric=\"SUM(total_sales)\",\n        ...     is_test_col=\"is_test\"\n        ... )\n        The return is:\n        {\n          \"status\": \"SUCCESS\",\n          \"rows\": [\n            {\n              \"store_id\": \"S1\",\n              \"product_category\": \"Electronics\",\n              \"contributors\": [\"S1\", \"Electronics\"],\n              \"metric_test\": 120,\n              \"metric_control\": 100,\n              \"difference\": 20,\n              \"relative_difference\": 0.2,\n              \"unexpected_difference\": 5,\n              \"relative_unexpected_difference\"\
    : 0.043,\n              \"apriori_support\": 0.15\n            },\n            ...\n          ]\n        }\n\n    Analyze the contribution of different dimensions to the total sales using\n    a SQL query as input:\n\n        >>> analyze_contribution(\n        ...     project_id=\"my-gcp-project\",\n        ...     input_data=\"SELECT store_id, product_category, total_sales, \"\n        ...     \"is_test FROM `my-project.my-dataset.my-sales-table` \"\n        ...     \"WHERE transaction_date > '2025-01-01'\"\n        ...     dimension_id_cols=[\"store_id\", \"product_category\"],\n        ...     contribution_metric=\"SUM(total_sales)\",\n        ...     is_test_col=\"is_test\"\n        ... )\n        The return is:\n        {\n          \"status\": \"SUCCESS\",\n          \"rows\": [\n            {\n              \"store_id\": \"S2\",\n              \"product_category\": \"Groceries\",\n              \"contributors\": [\"S2\", \"Groceries\"],\n              \"metric_test\": 250,\n \
    \             \"metric_control\": 200,\n              \"difference\": 50,\n              \"relative_difference\": 0.25,\n              \"unexpected_difference\": 10,\n              \"relative_unexpected_difference\": 0.041,\n              \"apriori_support\": 0.22\n            },\n            ...\n          ]\n        }"
  signature: 'def analyze_contribution(project_id: str, input_data: str, contribution_metric: str, dimension_id_cols: list[str], is_test_col: str, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.bigquery.config.BigQueryToolConfig, tool_context: google.adk.tools.tool_context.ToolContext, top_k_insights: int, pruning_method: str) -> dict:'
- rank: 1524
  id: google.adk.tools.bigquery.query_tool.detect_anomalies
  name: detect_anomalies
  file_path: src/google/adk/tools/bigquery/query_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Run a BigQuery time series ARIMA_PLUS model training and anomaly detection using CREATE MODEL and ML.DETECT_ANOMALIES clauses.\n\nArgs:\n    project_id (str): The GCP project id in which the query should be\n      executed.\n    history_data (str): The table id of the BigQuery table containing the\n      history time series data or a query statement that select the history\n      data.\n    times_series_timestamp_col (str): The name of the column containing the\n      timestamp for each data point.\n    times_series_data_col (str): The name of the column containing the\n      numerical values to be forecasted and anomaly detected.\n    horizon (int, optional): The number of time steps to forecast into the\n      future. Defaults to 1000.\n    target_data (str, optional): The table id of the BigQuery table containing\n      the target time series data or a query statement that select the target\n      data.\n    times_series_id_cols (list, optional): The column names of the\
    \ id columns\n      to indicate each time series when there are multiple time series in the\n      table. All elements must be strings. Defaults to None.\n    anomaly_prob_threshold (float, optional): The probability threshold to\n      determine if a data point is an anomaly. Defaults to 0.95.\n    credentials (Credentials): The credentials to use for the request.\n    settings (BigQueryToolConfig): The settings for the tool.\n    tool_context (ToolContext): The context for the tool.\n\nReturns:\n    dict: Dictionary representing the result of the anomaly detection. The\n          result contains the boolean value if the data point is anomaly or\n          not, lower bound, upper bound and anomaly probability for each data\n          point and also the probability of whether the data point is anomaly\n          or not.\n\nExamples:\n    Detect Anomalies daily sales based on historical data from a BigQuery\n    table:\n\n        >>> detect_anomalies(\n        ...     project_id=\"my-gcp-project\"\
    ,\n        ...     history_data=\"my-dataset.my-sales-table\",\n        ...     times_series_timestamp_col=\"sale_date\",\n        ...     times_series_data_col=\"daily_sales\"\n        ... )\n        {\n          \"status\": \"SUCCESS\",\n          \"rows\": [\n            {\n              \"ts_timestamp\": \"2021-01-01 00:00:01 UTC\",\n              \"ts_data\": 125.3,\n              \"is_anomaly\": TRUE,\n              \"lower_bound\": 129.5,\n              \"upper_bound\": 133.6 ,\n              \"anomaly_probability\": 0.93\n            },\n            ...\n          ]\n        }\n\n    Detect Anomalies on multiple time series using a SQL query as input:\n\n        >>> history_query = (\n        ...     \"SELECT unique_id, timestamp, value \"\n        ...     \"FROM `my-project.my-dataset.my-timeseries-table` \"\n        ...     \"WHERE timestamp > '1980-01-01'\"\n        ... )\n        >>> detect_anomalies(\n        ...     project_id=\"my-gcp-project\",\n        ...     history_data=history_query,\n\
    \        ...     times_series_timestamp_col=\"timestamp\",\n        ...     times_series_data_col=\"value\",\n        ...     times_series_id_cols=[\"unique_id\"]\n        ... )\n        {\n          \"status\": \"SUCCESS\",\n          \"rows\": [\n            {\n              \"unique_id\": \"T1\",\n              \"ts_timestamp\": \"2021-01-01 00:00:01 UTC\",\n              \"ts_data\": 125.3,\n              \"is_anomaly\": TRUE,\n              \"lower_bound\": 129.5,\n              \"upper_bound\": 133.6 ,\n              \"anomaly_probability\": 0.93\n            },\n            ...\n          ]\n        }\n\n    Error Scenarios:\n        When an element in `times_series_id_cols` is not a string:\n\n        >>> detect_anomalies(\n        ...     project_id=\"my-gcp-project\",\n        ...     history_data=\"my-dataset.my-sales-table\",\n        ...     times_series_timestamp_col=\"sale_date\",\n        ...     times_series_data_col=\"daily_sales\",\n        ...     times_series_id_cols=[\"\
    store_id\", 123]\n        ... )\n        {\n          \"status\": \"ERROR\",\n          \"error_details\": \"All elements in times_series_id_cols must be\n          strings.\"\n        }\n\n        When `history_data` refers to a table that does not exist:\n\n        >>> detect_anomalies(\n        ...     project_id=\"my-gcp-project\",\n        ...     history_data=\"my-dataset.nonexistent-table\",\n        ...     times_series_timestamp_col=\"sale_date\",\n        ...     times_series_data_col=\"daily_sales\"\n        ... )\n        {\n          \"status\": \"ERROR\",\n          \"error_details\": \"Not found: Table\n          my-gcp-project:my-dataset.nonexistent-table was not found in\n          location US\"\n        }"
  signature: 'def detect_anomalies(project_id: str, history_data: str, times_series_timestamp_col: str, times_series_data_col: str, horizon: typing.Optional[int], target_data: typing.Optional[str], times_series_id_cols: typing.Optional[list[str]], anomaly_prob_threshold: typing.Optional[float], *, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.bigquery.config.BigQueryToolConfig, tool_context: google.adk.tools.tool_context.ToolContext) -> dict:'
- rank: 1525
  id: google.adk.tools.bigquery.query_tool.execute_sql
  name: execute_sql
  file_path: src/google/adk/tools/bigquery/query_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Run a BigQuery or BigQuery ML SQL query in the project and return the result.\n\nArgs:\n    project_id (str): The GCP project id in which the query should be\n      executed.\n    query (str): The BigQuery SQL query to be executed.\n    credentials (Credentials): The credentials to use for the request.\n    settings (BigQueryToolConfig): The settings for the tool.\n    tool_context (ToolContext): The context for the tool.\n    dry_run (bool, default False): If True, the query will not be executed.\n      Instead, the query will be validated and information about the query\n      will be returned. Defaults to False.\n\nReturns:\n    dict: If `dry_run` is False, dictionary representing the result of the\n          query. If the result contains the key \"result_is_likely_truncated\"\n          with value True, it means that there may be additional rows matching\n          the query not returned in the result.\n          If `dry_run` is True, dictionary with \"dry_run_info\" field\n\
    \          containing query information returned by BigQuery.\n\nExamples:\n    Fetch data or insights from a table:\n\n        >>> execute_sql(\"my_project\",\n        ... \"SELECT island, COUNT(*) AS population \"\n        ... \"FROM `bigquery-public-data`.`ml_datasets`.`penguins` GROUP BY island\")\n        {\n          \"status\": \"SUCCESS\",\n          \"rows\": [\n              {\n                  \"island\": \"Dream\",\n                  \"population\": 124\n              },\n              {\n                  \"island\": \"Biscoe\",\n                  \"population\": 168\n              },\n              {\n                  \"island\": \"Torgersen\",\n                  \"population\": 52\n              }\n          ]\n        }\n\n    Validate a query and estimate costs without executing it:\n\n        >>> execute_sql(\n        ...     \"my_project\",\n        ...     \"SELECT island FROM \"\n        ...     \"`bigquery-public-data`.`ml_datasets`.`penguins`\",\n        ...\
    \     dry_run=True\n        ... )\n        {\n          \"status\": \"SUCCESS\",\n          \"dry_run_info\": {\n            \"configuration\": {\n              \"dryRun\": True,\n              \"jobType\": \"QUERY\",\n              \"query\": {\n                \"destinationTable\": {\n                  \"datasetId\": \"_...\",\n                  \"projectId\": \"my_project\",\n                  \"tableId\": \"anon...\"\n                },\n                \"priority\": \"INTERACTIVE\",\n                \"query\": \"SELECT island FROM `bigquery-public-data`.`ml_datasets`.`penguins`\",\n                \"useLegacySql\": False,\n                \"writeDisposition\": \"WRITE_TRUNCATE\"\n              }\n            },\n            \"jobReference\": {\n              \"location\": \"US\",\n              \"projectId\": \"my_project\"\n            }\n          }\n        }"
  signature: 'def execute_sql(project_id: str, query: str, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.bigquery.config.BigQueryToolConfig, tool_context: google.adk.tools.tool_context.ToolContext, dry_run: bool) -> dict:'
- rank: 1526
  id: google.adk.tools.bigquery.query_tool.forecast
  name: forecast
  file_path: src/google/adk/tools/bigquery/query_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Run a BigQuery AI time series forecast using AI.FORECAST.\n\nArgs:\n    project_id (str): The GCP project id in which the query should be\n      executed.\n    history_data (str): The table id of the BigQuery table containing the\n      history time series data or a query statement that select the history\n      data.\n    timestamp_col (str): The name of the column containing the timestamp for\n      each data point.\n    data_col (str): The name of the column containing the numerical values to\n      be forecasted.\n    horizon (int, optional): The number of time steps to forecast into the\n      future. Defaults to 10.\n    id_cols (list, optional): The column names of the id columns to indicate\n      each time series when there are multiple time series in the table. All\n      elements must be strings. Defaults to None.\n    credentials (Credentials): The credentials to use for the request.\n    settings (BigQueryToolConfig): The settings for the tool.\n    tool_context\
    \ (ToolContext): The context for the tool.\n\nReturns:\n    dict: Dictionary representing the result of the forecast. The result\n          contains the forecasted values along with prediction intervals.\n\nExamples:\n    Forecast daily sales for the next 7 days based on historical data from\n    a BigQuery table:\n\n        >>> forecast(\n        ...     project_id=\"my-gcp-project\",\n        ...     history_data=\"my-dataset.my-sales-table\",\n        ...     timestamp_col=\"sale_date\",\n        ...     data_col=\"daily_sales\",\n        ...     horizon=7\n        ... )\n        {\n          \"status\": \"SUCCESS\",\n          \"rows\": [\n            {\n              \"forecast_timestamp\": \"2025-01-08T00:00:00\",\n              \"forecast_value\": 12345.67,\n              \"confidence_level\": 0.95,\n              \"prediction_interval_lower_bound\": 11000.0,\n              \"prediction_interval_upper_bound\": 13691.34,\n              \"ai_forecast_status\": \"\"\n           \
    \ },\n            ...\n          ]\n        }\n\n    Forecast multiple time series using a SQL query as input:\n\n        >>> history_query = (\n        ...     \"SELECT unique_id, timestamp, value \"\n        ...     \"FROM `my-project.my-dataset.my-timeseries-table` \"\n        ...     \"WHERE timestamp > '1980-01-01'\"\n        ... )\n        >>> forecast(\n        ...     project_id=\"my-gcp-project\",\n        ...     history_data=history_query,\n        ...     timestamp_col=\"timestamp\",\n        ...     data_col=\"value\",\n        ...     id_cols=[\"unique_id\"],\n        ...     horizon=14\n        ... )\n        {\n          \"status\": \"SUCCESS\",\n          \"rows\": [\n            {\n              \"unique_id\": \"T1\",\n              \"forecast_timestamp\": \"1980-08-28T00:00:00\",\n              \"forecast_value\": 1253218.75,\n              \"confidence_level\": 0.95,\n              \"prediction_interval_lower_bound\": 274252.51,\n              \"prediction_interval_upper_bound\"\
    : 2232184.99,\n              \"ai_forecast_status\": \"\"\n            },\n            ...\n          ]\n        }\n\n    Error Scenarios:\n        When an element in `id_cols` is not a string:\n\n        >>> forecast(\n        ...     project_id=\"my-gcp-project\",\n        ...     history_data=\"my-dataset.my-sales-table\",\n        ...     timestamp_col=\"sale_date\",\n        ...     data_col=\"daily_sales\",\n        ...     id_cols=[\"store_id\", 123]\n        ... )\n        {\n          \"status\": \"ERROR\",\n          \"error_details\": \"All elements in id_cols must be strings.\"\n        }\n\n        When `history_data` refers to a table that does not exist:\n\n        >>> forecast(\n        ...     project_id=\"my-gcp-project\",\n        ...     history_data=\"my-dataset.nonexistent-table\",\n        ...     timestamp_col=\"sale_date\",\n        ...     data_col=\"daily_sales\"\n        ... )\n        {\n          \"status\": \"ERROR\",\n          \"error_details\": \"Not\
    \ found: Table\n          my-gcp-project:my-dataset.nonexistent-table was not found in\n          location US\"\n        }"
  signature: 'def forecast(project_id: str, history_data: str, timestamp_col: str, data_col: str, horizon: int, id_cols: typing.Optional[list[str]], *, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.bigquery.config.BigQueryToolConfig, tool_context: google.adk.tools.tool_context.ToolContext) -> dict:'
- rank: 1527
  id: google.adk.tools.bigquery.query_tool.get_execute_sql
  name: get_execute_sql
  file_path: src/google/adk/tools/bigquery/query_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Get the execute_sql tool customized as per the given tool settings.\n\nArgs:\n    settings: BigQuery tool settings indicating the behavior of the\n      execute_sql tool.\n\nReturns:\n    callable[..., dict]: A version of the execute_sql tool respecting the tool\n    settings."
  signature: 'def get_execute_sql(settings: google.adk.tools.bigquery.config.BigQueryToolConfig) -> typing.Callable[Ellipsis, dict]:'
- rank: 1528
  id: google.adk.tools.bigtable
  name: bigtable
  file_path: src/google/adk/tools/bigtable/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: 'Bigtable Tools (Experimental).


    Bigtable tools under this module are hand crafted and customized while the tools

    under google.adk.tools.google_api_tool are auto generated based on API

    definition. The rationales to have customized tool are:


    1. A dedicated Bigtable toolset to provide an easier, integrated way to interact

    with Bigtable for building AI Agent applications quickly.

    2. We want to provide extra access guardrails and controls in those tools.

    3. Use Bigtable Toolset for more customization and control to interact with

    Bigtable tables.'
  properties:
  - signature: '__all__: Any'
- rank: 1529
  id: google.adk.tools.bigtable.bigtable_credentials
  name: bigtable_credentials
  file_path: src/google/adk/tools/bigtable/bigtable_credentials.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'BIGTABLE_TOKEN_CACHE_KEY: str'
  - signature: 'BIGTABLE_DEFAULT_SCOPE: Any'
- rank: 1530
  id: google.adk.tools.bigtable.bigtable_toolset
  name: bigtable_toolset
  file_path: src/google/adk/tools/bigtable/bigtable_toolset.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'DEFAULT_BIGTABLE_TOOL_NAME_PREFIX: str'
- rank: 1531
  id: google.adk.tools.bigtable.bigtable_toolset.BigtableToolset
  name: BigtableToolset
  file_path: src/google/adk/tools/bigtable/bigtable_toolset.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "Bigtable Toolset contains tools for interacting with Bigtable data and metadata.\n\nThe tool names are:\n  - bigtable_list_instances\n  - bigtable_get_instance_info\n  - bigtable_list_tables\n  - bigtable_get_table_info\n  - bigtable_execute_sql\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, *, tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]]=None, credentials_config: typing.Optional[google.adk.tools.bigtable.bigtable_credentials.BigtableCredentialsConfig]=None, bigtable_tool_settings: typing.Optional[google.adk.tools.bigtable.settings.BigtableToolSettings]=None):'
  methods:
  - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> typing.List[google.adk.tools.base_tool.BaseTool]:'
    docstring: Get tools from the toolset.
  inherited_methods:
    BaseToolset:
    - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools in the toolset based on the provided context.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools available under the specified context."
    - signature: 'def get_tools_with_prefix(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools with optional prefix applied to tool names.\n\nThis method calls get_tools() and applies prefixing if tool_name_prefix is provided.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools with prefixed names if tool_name_prefix is provided."
    - signature: 'def close(self) -> None:'
      docstring: "Performs cleanup and releases resources held by the toolset.\n\nNOTE:\n  This method is invoked, for example, at the end of an agent server's\n  lifecycle or when the toolset is no longer needed. Implementations\n  should ensure that any open connections, files, or other managed\n  resources are properly released to prevent leaks."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_toolset.SelfToolset], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_toolset.SelfToolset:'
      docstring: "Creates a toolset instance from a config.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The toolset instance."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this toolset. This method will be\ncalled before each tool processes the llm request.\n\nUse cases:\n- Instead of let each tool process the llm request, we can let the toolset\n  process the llm request. e.g. ComputerUseToolset can add computer use\n  tool to the llm request.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def get_auth_config(self) -> typing.Optional[google.adk.auth.auth_tool.AuthConfig]:'
      docstring: "Returns the auth config for this toolset. ADK will make sure the\n'exchanged_auth_credential' field in the config is populated with\nready-to-use credential (e.g. oauth token for OAuth flow) before calling\nget_tools method or execute any tools returned by this toolset. Thus toolset\ncan use this credential either for tool listing or tool calling. If tool\ncalling needs a different credential from ADK client, call\ntool_context.request_credential in the tool.\n\nToolsets that support authentication should override this method to return\nan AuthConfig constructed from their auth_scheme, auth_credential, and\noptional credential_key parameters.\n\nReturns:\n  AuthConfig if the toolset has authentication configured, None otherwise."
  omitted_inherited_members_from:
  - ABC
- rank: 1532
  id: google.adk.tools.bigtable.bigtable_toolset.BigtableToolset.__init__
  name: __init__
  file_path: src/google/adk/tools/bigtable/bigtable_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, *, tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]]=None, credentials_config: typing.Optional[google.adk.tools.bigtable.bigtable_credentials.BigtableCredentialsConfig]=None, bigtable_tool_settings: typing.Optional[google.adk.tools.bigtable.settings.BigtableToolSettings]=None):'
- rank: 1533
  id: google.adk.tools.bigtable.bigtable_toolset.BigtableToolset.get_tools
  name: get_tools
  file_path: src/google/adk/tools/bigtable/bigtable_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Get tools from the toolset.
  signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> typing.List[google.adk.tools.base_tool.BaseTool]:'
- rank: 1534
  id: google.adk.tools.bigtable.client
  name: client
  file_path: src/google/adk/tools/bigtable/client.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def get_bigtable_data_client(*, project: str, credentials: google.auth.credentials.Credentials) -> google.cloud.bigtable.BigtableDataClient:'
    docstring: Get a Bigtable client.
  - signature: 'def get_bigtable_admin_client(*, project: str, credentials: google.auth.credentials.Credentials) -> google.cloud.bigtable.Client:'
    docstring: Get a Bigtable client.
  properties:
  - signature: 'USER_AGENT: Any'
- rank: 1535
  id: google.adk.tools.bigtable.client.get_bigtable_admin_client
  name: get_bigtable_admin_client
  file_path: src/google/adk/tools/bigtable/client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Get a Bigtable client.
  signature: 'def get_bigtable_admin_client(*, project: str, credentials: google.auth.credentials.Credentials) -> google.cloud.bigtable.Client:'
- rank: 1536
  id: google.adk.tools.bigtable.client.get_bigtable_data_client
  name: get_bigtable_data_client
  file_path: src/google/adk/tools/bigtable/client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Get a Bigtable client.
  signature: 'def get_bigtable_data_client(*, project: str, credentials: google.auth.credentials.Credentials) -> google.cloud.bigtable.BigtableDataClient:'
- rank: 1537
  id: google.adk.tools.bigtable.metadata_tool
  name: metadata_tool
  file_path: src/google/adk/tools/bigtable/metadata_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def list_instances(project_id: str, credentials: google.auth.credentials.Credentials) -> dict:'
    docstring: "List Bigtable instance ids in a Google Cloud project.\n\nArgs:\n    project_id (str): The Google Cloud project id.\n    credentials (Credentials): The credentials to use for the request.\n\nReturns:\n    dict: Dictionary with a list of the Bigtable instance ids present in the project."
  - signature: 'def get_instance_info(project_id: str, instance_id: str, credentials: google.auth.credentials.Credentials) -> dict:'
    docstring: "Get metadata information about a Bigtable instance.\n\nArgs:\n    project_id (str): The Google Cloud project id containing the instance.\n    instance_id (str): The Bigtable instance id.\n    credentials (Credentials): The credentials to use for the request.\n\nReturns:\n    dict: Dictionary representing the properties of the instance."
  - signature: 'def list_tables(project_id: str, instance_id: str, credentials: google.auth.credentials.Credentials) -> dict:'
    docstring: "List table ids in a Bigtable instance.\n\nArgs:\n    project_id (str): The Google Cloud project id containing the instance.\n    instance_id (str): The Bigtable instance id.\n    credentials (Credentials): The credentials to use for the request.\n\nReturns:\n    dict: Dictionary with a list of the tables ids present in the instance."
  - signature: 'def get_table_info(project_id: str, instance_id: str, table_id: str, credentials: google.auth.credentials.Credentials) -> dict:'
    docstring: "Get metadata information about a Bigtable table.\n\nArgs:\n    project_id (str): The Google Cloud project id containing the instance.\n    instance_id (str): The Bigtable instance id containing the table.\n    table_id (str): The Bigtable table id.\n    credentials (Credentials): The credentials to use for the request.\n\nReturns:\n    dict: Dictionary representing the properties of the table."
- rank: 1538
  id: google.adk.tools.bigtable.metadata_tool.get_instance_info
  name: get_instance_info
  file_path: src/google/adk/tools/bigtable/metadata_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Get metadata information about a Bigtable instance.\n\nArgs:\n    project_id (str): The Google Cloud project id containing the instance.\n    instance_id (str): The Bigtable instance id.\n    credentials (Credentials): The credentials to use for the request.\n\nReturns:\n    dict: Dictionary representing the properties of the instance."
  signature: 'def get_instance_info(project_id: str, instance_id: str, credentials: google.auth.credentials.Credentials) -> dict:'
- rank: 1539
  id: google.adk.tools.bigtable.metadata_tool.get_table_info
  name: get_table_info
  file_path: src/google/adk/tools/bigtable/metadata_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Get metadata information about a Bigtable table.\n\nArgs:\n    project_id (str): The Google Cloud project id containing the instance.\n    instance_id (str): The Bigtable instance id containing the table.\n    table_id (str): The Bigtable table id.\n    credentials (Credentials): The credentials to use for the request.\n\nReturns:\n    dict: Dictionary representing the properties of the table."
  signature: 'def get_table_info(project_id: str, instance_id: str, table_id: str, credentials: google.auth.credentials.Credentials) -> dict:'
- rank: 1540
  id: google.adk.tools.bigtable.metadata_tool.list_instances
  name: list_instances
  file_path: src/google/adk/tools/bigtable/metadata_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "List Bigtable instance ids in a Google Cloud project.\n\nArgs:\n    project_id (str): The Google Cloud project id.\n    credentials (Credentials): The credentials to use for the request.\n\nReturns:\n    dict: Dictionary with a list of the Bigtable instance ids present in the project."
  signature: 'def list_instances(project_id: str, credentials: google.auth.credentials.Credentials) -> dict:'
- rank: 1541
  id: google.adk.tools.bigtable.metadata_tool.list_tables
  name: list_tables
  file_path: src/google/adk/tools/bigtable/metadata_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "List table ids in a Bigtable instance.\n\nArgs:\n    project_id (str): The Google Cloud project id containing the instance.\n    instance_id (str): The Bigtable instance id.\n    credentials (Credentials): The credentials to use for the request.\n\nReturns:\n    dict: Dictionary with a list of the tables ids present in the instance."
  signature: 'def list_tables(project_id: str, instance_id: str, credentials: google.auth.credentials.Credentials) -> dict:'
- rank: 1542
  id: google.adk.tools.bigtable.query_tool
  name: query_tool
  file_path: src/google/adk/tools/bigtable/query_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def execute_sql(project_id: str, instance_id: str, query: str, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.bigtable.settings.BigtableToolSettings, tool_context: google.adk.tools.tool_context.ToolContext) -> dict:'
    docstring: "Execute a GoogleSQL query from a Bigtable table.\n\nArgs:\n    project_id (str): The GCP project id in which the query should be\n      executed.\n    instance_id (str): The instance id of the Bigtable database.\n    query (str): The Bigtable SQL query to be executed.\n    credentials (Credentials): The credentials to use for the request.\n    settings (BigtableToolSettings): The configuration for the tool.\n    tool_context (ToolContext): The context for the tool.\nReturns:\n    dict: Dictionary containing the status and the rows read.\n          If the result contains the key \"result_is_likely_truncated\" with\n          value True, it means that there may be additional rows matching the\n          query not returned in the result.\n\nExamples:\n    Fetch data or insights from a table:\n\n        >>> execute_sql(\"my_project\", \"my_instance\",\n        ... \"SELECT * from mytable\", credentials, config, tool_context)\n        {\n          \"status\": \"SUCCESS\",\n  \
      \        \"rows\": [\n              {\n                  \"user_id\": 1,\n                  \"user_name\": \"Alice\"\n              }\n          ]\n        }"
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: 'DEFAULT_MAX_EXECUTED_QUERY_RESULT_ROWS: int'
- rank: 1543
  id: google.adk.tools.bigtable.query_tool.execute_sql
  name: execute_sql
  file_path: src/google/adk/tools/bigtable/query_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Execute a GoogleSQL query from a Bigtable table.\n\nArgs:\n    project_id (str): The GCP project id in which the query should be\n      executed.\n    instance_id (str): The instance id of the Bigtable database.\n    query (str): The Bigtable SQL query to be executed.\n    credentials (Credentials): The credentials to use for the request.\n    settings (BigtableToolSettings): The configuration for the tool.\n    tool_context (ToolContext): The context for the tool.\nReturns:\n    dict: Dictionary containing the status and the rows read.\n          If the result contains the key \"result_is_likely_truncated\" with\n          value True, it means that there may be additional rows matching the\n          query not returned in the result.\n\nExamples:\n    Fetch data or insights from a table:\n\n        >>> execute_sql(\"my_project\", \"my_instance\",\n        ... \"SELECT * from mytable\", credentials, config, tool_context)\n        {\n          \"status\": \"SUCCESS\",\n    \
    \      \"rows\": [\n              {\n                  \"user_id\": 1,\n                  \"user_name\": \"Alice\"\n              }\n          ]\n        }"
  signature: 'def execute_sql(project_id: str, instance_id: str, query: str, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.bigtable.settings.BigtableToolSettings, tool_context: google.adk.tools.tool_context.ToolContext) -> dict:'
- rank: 1544
  id: google.adk.tools.bigtable.settings
  name: settings
  file_path: src/google/adk/tools/bigtable/settings.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1545
  id: google.adk.tools.bigtable.settings.BigtableToolSettings
  name: BigtableToolSettings
  file_path: src/google/adk/tools/bigtable/settings.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Settings for Bigtable tools.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, max_query_result_rows: int = 50):'
  properties:
  - signature: 'max_query_result_rows: int'
    docstring: Maximum number of rows to return from a query result.
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1546
  id: google.adk.tools.computer_use
  name: computer_use
  file_path: src/google/adk/tools/computer_use/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1547
  id: google.adk.tools.computer_use.base_computer
  name: base_computer
  file_path: src/google/adk/tools/computer_use/base_computer.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1548
  id: google.adk.tools.computer_use.base_computer.BaseComputer
  name: BaseComputer
  file_path: src/google/adk/tools/computer_use/base_computer.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'async defines an interface for computer environments.


    This abstract base class async defines the standard interface for controlling

    computer environments, including web browsers and other interactive systems.


    [Note: Inherited members from abc.ABC are omitted.]'
  methods:
  - signature: 'def screen_size(self) -> tuple[int, int]:'
    docstring: "Returns the screen size of the environment.\n\nReturns:\n  A tuple of (width, height) in pixels."
  - signature: 'def open_web_browser(self) -> google.adk.tools.computer_use.base_computer.ComputerState:'
    docstring: "Opens the web browser.\n\nReturns:\n  The current state after opening the browser."
  - signature: 'def click_at(self, x: int, y: int) -> google.adk.tools.computer_use.base_computer.ComputerState:'
    docstring: "Clicks at a specific x, y coordinate on the webpage.\n\nThe 'x' and 'y' values are absolute values, scaled to the height and width of the screen.\n\nArgs:\n  x: The x-coordinate to click at.\n  y: The y-coordinate to click at.\n\nReturns:\n  The current state after clicking."
  - signature: 'def hover_at(self, x: int, y: int) -> google.adk.tools.computer_use.base_computer.ComputerState:'
    docstring: "Hovers at a specific x, y coordinate on the webpage.\n\nMay be used to explore sub-menus that appear on hover.\nThe 'x' and 'y' values are absolute values, scaled to the height and width of the screen.\n\nArgs:\n  x: The x-coordinate to hover at.\n  y: The y-coordinate to hover at.\n\nReturns:\n  The current state after hovering."
  - signature: 'def type_text_at(self, x: int, y: int, text: str, press_enter: bool, clear_before_typing: bool) -> google.adk.tools.computer_use.base_computer.ComputerState:'
    docstring: "Types text at a specific x, y coordinate.\n\nThe system automatically presses ENTER after typing. To disable this, set `press_enter` to False.\nThe system automatically clears any existing content before typing the specified `text`. To disable this, set `clear_before_typing` to False.\nThe 'x' and 'y' values are absolute values, scaled to the height and width of the screen.\n\nArgs:\n  x: The x-coordinate to type at.\n  y: The y-coordinate to type at.\n  text: The text to type.\n  press_enter: Whether to press ENTER after typing.\n  clear_before_typing: Whether to clear existing content before typing.\n\nReturns:\n  The current state after typing."
  - signature: 'def scroll_document(self, direction: typing.Literal[up, down, left, right]) -> google.adk.tools.computer_use.base_computer.ComputerState:'
    docstring: "Scrolls the entire webpage \"up\", \"down\", \"left\" or \"right\" based on direction.\n\nArgs:\n  direction: The direction to scroll.\n\nReturns:\n  The current state after scrolling."
  - signature: 'def scroll_at(self, x: int, y: int, direction: typing.Literal[up, down, left, right], magnitude: int) -> google.adk.tools.computer_use.base_computer.ComputerState:'
    docstring: "Scrolls up, down, right, or left at a x, y coordinate by magnitude.\n\nThe 'x' and 'y' values are absolute values, scaled to the height and width of the screen.\n\nArgs:\n  x: The x-coordinate to scroll at.\n  y: The y-coordinate to scroll at.\n  direction: The direction to scroll.\n  magnitude: The amount to scroll.\n\nReturns:\n  The current state after scrolling."
  - signature: 'def wait(self, seconds: int) -> google.adk.tools.computer_use.base_computer.ComputerState:'
    docstring: "Waits for n seconds to allow unfinished webpage processes to complete.\n\nArgs:\n  seconds: The number of seconds to wait.\n\nReturns:\n  The current state after waiting."
  - signature: 'def go_back(self) -> google.adk.tools.computer_use.base_computer.ComputerState:'
    docstring: "Navigates back to the previous webpage in the browser history.\n\nReturns:\n  The current state after navigating back."
  - signature: 'def go_forward(self) -> google.adk.tools.computer_use.base_computer.ComputerState:'
    docstring: "Navigates forward to the next webpage in the browser history.\n\nReturns:\n  The current state after navigating forward."
  - signature: 'def search(self) -> google.adk.tools.computer_use.base_computer.ComputerState:'
    docstring: "Directly jumps to a search engine home page.\n\nUsed when you need to start with a search. For example, this is used when\nthe current website doesn't have the information needed or because a new\ntask is being started.\n\nReturns:\n  The current state after navigating to search."
  - signature: 'def navigate(self, url: str) -> google.adk.tools.computer_use.base_computer.ComputerState:'
    docstring: "Navigates directly to a specified URL.\n\nArgs:\n  url: The URL to navigate to.\n\nReturns:\n  The current state after navigation."
  - signature: 'def key_combination(self, keys: list[str]) -> google.adk.tools.computer_use.base_computer.ComputerState:'
    docstring: "Presses keyboard keys and combinations, such as \"control+c\" or \"enter\".\n\nArgs:\n  keys: List of keys to press in combination.\n\nReturns:\n  The current state after key press."
  - signature: 'def drag_and_drop(self, x: int, y: int, destination_x: int, destination_y: int) -> google.adk.tools.computer_use.base_computer.ComputerState:'
    docstring: "Drag and drop an element from a x, y coordinate to a destination destination_y, destination_x coordinate.\n\nThe 'x', 'y', 'destination_y' and 'destination_x' values are absolute values, scaled to the height and width of the screen.\n\nArgs:\n  x: The x-coordinate to start dragging from.\n  y: The y-coordinate to start dragging from.\n  destination_x: The x-coordinate to drop at.\n  destination_y: The y-coordinate to drop at.\n\nReturns:\n  The current state after drag and drop."
  - signature: 'def current_state(self) -> google.adk.tools.computer_use.base_computer.ComputerState:'
    docstring: "Returns the current state of the current webpage.\n\nReturns:\n  The current environment state."
  - signature: 'def initialize(self) -> None:'
    docstring: Initialize the computer.
  - signature: 'def close(self) -> None:'
    docstring: Cleanup resource of the computer.
  - signature: 'def environment(self) -> google.adk.tools.computer_use.base_computer.ComputerEnvironment:'
    docstring: Returns the environment of the computer.
  omitted_inherited_members_from:
  - abc.ABC
- rank: 1549
  id: google.adk.tools.computer_use.base_computer.BaseComputer.click_at
  name: click_at
  file_path: src/google/adk/tools/computer_use/base_computer.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Clicks at a specific x, y coordinate on the webpage.\n\nThe 'x' and 'y' values are absolute values, scaled to the height and width of the screen.\n\nArgs:\n  x: The x-coordinate to click at.\n  y: The y-coordinate to click at.\n\nReturns:\n  The current state after clicking."
  signature: 'def click_at(self, x: int, y: int) -> google.adk.tools.computer_use.base_computer.ComputerState:'
- rank: 1550
  id: google.adk.tools.computer_use.base_computer.BaseComputer.current_state
  name: current_state
  file_path: src/google/adk/tools/computer_use/base_computer.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Returns the current state of the current webpage.\n\nReturns:\n  The current environment state."
  signature: 'def current_state(self) -> google.adk.tools.computer_use.base_computer.ComputerState:'
- rank: 1551
  id: google.adk.tools.computer_use.base_computer.BaseComputer.drag_and_drop
  name: drag_and_drop
  file_path: src/google/adk/tools/computer_use/base_computer.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Drag and drop an element from a x, y coordinate to a destination destination_y, destination_x coordinate.\n\nThe 'x', 'y', 'destination_y' and 'destination_x' values are absolute values, scaled to the height and width of the screen.\n\nArgs:\n  x: The x-coordinate to start dragging from.\n  y: The y-coordinate to start dragging from.\n  destination_x: The x-coordinate to drop at.\n  destination_y: The y-coordinate to drop at.\n\nReturns:\n  The current state after drag and drop."
  signature: 'def drag_and_drop(self, x: int, y: int, destination_x: int, destination_y: int) -> google.adk.tools.computer_use.base_computer.ComputerState:'
- rank: 1552
  id: google.adk.tools.computer_use.base_computer.BaseComputer.go_back
  name: go_back
  file_path: src/google/adk/tools/computer_use/base_computer.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Navigates back to the previous webpage in the browser history.\n\nReturns:\n  The current state after navigating back."
  signature: 'def go_back(self) -> google.adk.tools.computer_use.base_computer.ComputerState:'
- rank: 1553
  id: google.adk.tools.computer_use.base_computer.BaseComputer.go_forward
  name: go_forward
  file_path: src/google/adk/tools/computer_use/base_computer.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Navigates forward to the next webpage in the browser history.\n\nReturns:\n  The current state after navigating forward."
  signature: 'def go_forward(self) -> google.adk.tools.computer_use.base_computer.ComputerState:'
- rank: 1554
  id: google.adk.tools.computer_use.base_computer.BaseComputer.hover_at
  name: hover_at
  file_path: src/google/adk/tools/computer_use/base_computer.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Hovers at a specific x, y coordinate on the webpage.\n\nMay be used to explore sub-menus that appear on hover.\nThe 'x' and 'y' values are absolute values, scaled to the height and width of the screen.\n\nArgs:\n  x: The x-coordinate to hover at.\n  y: The y-coordinate to hover at.\n\nReturns:\n  The current state after hovering."
  signature: 'def hover_at(self, x: int, y: int) -> google.adk.tools.computer_use.base_computer.ComputerState:'
- rank: 1555
  id: google.adk.tools.computer_use.base_computer.BaseComputer.key_combination
  name: key_combination
  file_path: src/google/adk/tools/computer_use/base_computer.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Presses keyboard keys and combinations, such as \"control+c\" or \"enter\".\n\nArgs:\n  keys: List of keys to press in combination.\n\nReturns:\n  The current state after key press."
  signature: 'def key_combination(self, keys: list[str]) -> google.adk.tools.computer_use.base_computer.ComputerState:'
- rank: 1556
  id: google.adk.tools.computer_use.base_computer.BaseComputer.navigate
  name: navigate
  file_path: src/google/adk/tools/computer_use/base_computer.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Navigates directly to a specified URL.\n\nArgs:\n  url: The URL to navigate to.\n\nReturns:\n  The current state after navigation."
  signature: 'def navigate(self, url: str) -> google.adk.tools.computer_use.base_computer.ComputerState:'
- rank: 1557
  id: google.adk.tools.computer_use.base_computer.BaseComputer.open_web_browser
  name: open_web_browser
  file_path: src/google/adk/tools/computer_use/base_computer.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Opens the web browser.\n\nReturns:\n  The current state after opening the browser."
  signature: 'def open_web_browser(self) -> google.adk.tools.computer_use.base_computer.ComputerState:'
- rank: 1558
  id: google.adk.tools.computer_use.base_computer.BaseComputer.screen_size
  name: screen_size
  file_path: src/google/adk/tools/computer_use/base_computer.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Returns the screen size of the environment.\n\nReturns:\n  A tuple of (width, height) in pixels."
  signature: 'def screen_size(self) -> tuple[int, int]:'
- rank: 1559
  id: google.adk.tools.computer_use.base_computer.BaseComputer.scroll_at
  name: scroll_at
  file_path: src/google/adk/tools/computer_use/base_computer.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Scrolls up, down, right, or left at a x, y coordinate by magnitude.\n\nThe 'x' and 'y' values are absolute values, scaled to the height and width of the screen.\n\nArgs:\n  x: The x-coordinate to scroll at.\n  y: The y-coordinate to scroll at.\n  direction: The direction to scroll.\n  magnitude: The amount to scroll.\n\nReturns:\n  The current state after scrolling."
  signature: 'def scroll_at(self, x: int, y: int, direction: typing.Literal[up, down, left, right], magnitude: int) -> google.adk.tools.computer_use.base_computer.ComputerState:'
- rank: 1560
  id: google.adk.tools.computer_use.base_computer.BaseComputer.scroll_document
  name: scroll_document
  file_path: src/google/adk/tools/computer_use/base_computer.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Scrolls the entire webpage \"up\", \"down\", \"left\" or \"right\" based on direction.\n\nArgs:\n  direction: The direction to scroll.\n\nReturns:\n  The current state after scrolling."
  signature: 'def scroll_document(self, direction: typing.Literal[up, down, left, right]) -> google.adk.tools.computer_use.base_computer.ComputerState:'
- rank: 1561
  id: google.adk.tools.computer_use.base_computer.BaseComputer.search
  name: search
  file_path: src/google/adk/tools/computer_use/base_computer.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Directly jumps to a search engine home page.\n\nUsed when you need to start with a search. For example, this is used when\nthe current website doesn't have the information needed or because a new\ntask is being started.\n\nReturns:\n  The current state after navigating to search."
  signature: 'def search(self) -> google.adk.tools.computer_use.base_computer.ComputerState:'
- rank: 1562
  id: google.adk.tools.computer_use.base_computer.BaseComputer.type_text_at
  name: type_text_at
  file_path: src/google/adk/tools/computer_use/base_computer.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Types text at a specific x, y coordinate.\n\nThe system automatically presses ENTER after typing. To disable this, set `press_enter` to False.\nThe system automatically clears any existing content before typing the specified `text`. To disable this, set `clear_before_typing` to False.\nThe 'x' and 'y' values are absolute values, scaled to the height and width of the screen.\n\nArgs:\n  x: The x-coordinate to type at.\n  y: The y-coordinate to type at.\n  text: The text to type.\n  press_enter: Whether to press ENTER after typing.\n  clear_before_typing: Whether to clear existing content before typing.\n\nReturns:\n  The current state after typing."
  signature: 'def type_text_at(self, x: int, y: int, text: str, press_enter: bool, clear_before_typing: bool) -> google.adk.tools.computer_use.base_computer.ComputerState:'
- rank: 1563
  id: google.adk.tools.computer_use.base_computer.BaseComputer.wait
  name: wait
  file_path: src/google/adk/tools/computer_use/base_computer.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Waits for n seconds to allow unfinished webpage processes to complete.\n\nArgs:\n  seconds: The number of seconds to wait.\n\nReturns:\n  The current state after waiting."
  signature: 'def wait(self, seconds: int) -> google.adk.tools.computer_use.base_computer.ComputerState:'
- rank: 1564
  id: google.adk.tools.computer_use.base_computer.ComputerEnvironment
  name: ComputerEnvironment
  file_path: src/google/adk/tools/computer_use/base_computer.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Case insensitive enum for computer environments.


    [Note: Inherited members from Enum, str are omitted.]'
  properties:
  - signature: 'ENVIRONMENT_UNSPECIFIED: str'
    docstring: Defaults to browser.
  - signature: 'ENVIRONMENT_BROWSER: str'
    docstring: Operates in a web browser.
  omitted_inherited_members_from:
  - str
  - Enum
- rank: 1565
  id: google.adk.tools.computer_use.base_computer.ComputerState
  name: ComputerState
  file_path: src/google/adk/tools/computer_use/base_computer.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "Represents the current state of the computer environment.\n\nAttributes:\n  screenshot: The screenshot in PNG format as bytes.\n  url: The current URL of the webpage being displayed.\n\n[Note: Inherited members from pydantic.BaseModel are omitted.]"
  constructor_signature: 'def __init__(self, *, screenshot: bytes = None, url: typing.Optional[str] = None):'
  properties:
  - signature: 'screenshot: bytes'
  - signature: 'url: typing.Optional[str]'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1566
  id: google.adk.tools.computer_use.computer_use_tool
  name: computer_use_tool
  file_path: src/google/adk/tools/computer_use/computer_use_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 1567
  id: google.adk.tools.computer_use.computer_use_tool.ComputerUseTool
  name: ComputerUseTool
  file_path: src/google/adk/tools/computer_use/computer_use_tool.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A tool that wraps computer control functions for use with LLMs.


    This tool automatically normalizes coordinates from a virtual coordinate space

    (by default 1000x1000) to the actual screen size. This allows LLMs to work

    with a consistent coordinate system regardless of the actual screen

    dimensions, making their output more predictable and easier to handle.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, *, func: typing.Callable[Ellipsis, typing.Any], screen_size: tuple[int, int], virtual_screen_size: tuple[int, int]=(1000, 1000)):'
  methods:
  - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
    docstring: Run the computer control function with normalized coordinates.
  - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
    docstring: ComputerUseToolset will add this tool to the LLM request and add computer use configuration to the LLM request.
  inherited_methods:
    FunctionTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
    BaseTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
      docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
      docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  inherited_properties:
    BaseTool:
    - signature: 'name: str'
      docstring: The name of the tool.
    - signature: 'description: str'
      docstring: The description of the tool.
    - signature: 'is_long_running: bool'
      docstring: 'Whether the tool is a long running operation, which typically returns a

        resource id first and finishes the operation later.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the BaseTool.


        An optional key-value pair for storing and retrieving tool-specific metadata,

        such as tool manifests, etc.


        NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 1568
  id: google.adk.tools.computer_use.computer_use_tool.ComputerUseTool.__init__
  name: __init__
  file_path: src/google/adk/tools/computer_use/computer_use_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initialize the ComputerUseTool.\n\nArgs:\n  func: The computer control function to wrap.\n  screen_size: The actual screen size as (width, height) in pixels. This\n    represents the real dimensions of the target screen/display.\n  virtual_screen_size: The virtual coordinate space dimensions as (width,\n    height) that the LLM uses to specify coordinates. Coordinates from the\n    LLM are automatically normalized from this virtual space to the actual\n    screen_size. Default is (1000, 1000), meaning the LLM thinks it's\n    working with a 1000x1000 pixel screen regardless of the actual screen\n    dimensions.\n\nRaises:\n  ValueError: If screen_size or virtual_screen_size is not a valid tuple\n    of positive integers."
  signature: 'def __init__(self, *, func: typing.Callable[Ellipsis, typing.Any], screen_size: tuple[int, int], virtual_screen_size: tuple[int, int]=(1000, 1000)):'
- rank: 1569
  id: google.adk.tools.computer_use.computer_use_tool.ComputerUseTool.process_llm_request
  name: process_llm_request
  file_path: src/google/adk/tools/computer_use/computer_use_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: ComputerUseToolset will add this tool to the LLM request and add computer use configuration to the LLM request.
  signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
- rank: 1570
  id: google.adk.tools.computer_use.computer_use_tool.ComputerUseTool.run_async
  name: run_async
  file_path: src/google/adk/tools/computer_use/computer_use_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Run the computer control function with normalized coordinates.
  signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
- rank: 1571
  id: google.adk.tools.computer_use.computer_use_toolset
  name: computer_use_toolset
  file_path: src/google/adk/tools/computer_use/computer_use_toolset.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'EXCLUDED_METHODS: Any'
  - signature: 'logger: logging.getLogger'
- rank: 1572
  id: google.adk.tools.computer_use.computer_use_toolset.ComputerUseToolset
  name: ComputerUseToolset
  file_path: src/google/adk/tools/computer_use/computer_use_toolset.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, *, computer: google.adk.tools.computer_use.base_computer.BaseComputer):'
  methods:
  - signature: 'def adapt_computer_use_tool(method_name: str, adapter_func: typing.Union[typing.Callable[[Callable[..., Any]], typing.Callable[Ellipsis, typing.Any]], typing.Callable[[Callable[..., Any]], typing.Any]], llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
    docstring: "Adapt a computer use tool by replacing it with a modified version.\n\nArgs:\n  method_name: The name of the method (of BaseComputer class) to adapt (e.g.\n    'wait').\n  adapter_func: A function that accepts existing computer use async function\n    and returns a new computer use async function. Can be either sync or\n    async function. The name of the returned function will be used as the\n    new tool name.\n  llm_request: The LLM request containing the tools dictionary."
  - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.computer_use.computer_use_tool.ComputerUseTool]:'
  - signature: 'def close(self) -> None:'
  - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
    docstring: Add its tools to the LLM request and add computer use configuration to the LLM request.
  inherited_methods:
    BaseToolset:
    - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools in the toolset based on the provided context.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools available under the specified context."
    - signature: 'def get_tools_with_prefix(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools with optional prefix applied to tool names.\n\nThis method calls get_tools() and applies prefixing if tool_name_prefix is provided.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools with prefixed names if tool_name_prefix is provided."
    - signature: 'def close(self) -> None:'
      docstring: "Performs cleanup and releases resources held by the toolset.\n\nNOTE:\n  This method is invoked, for example, at the end of an agent server's\n  lifecycle or when the toolset is no longer needed. Implementations\n  should ensure that any open connections, files, or other managed\n  resources are properly released to prevent leaks."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_toolset.SelfToolset], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_toolset.SelfToolset:'
      docstring: "Creates a toolset instance from a config.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The toolset instance."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this toolset. This method will be\ncalled before each tool processes the llm request.\n\nUse cases:\n- Instead of let each tool process the llm request, we can let the toolset\n  process the llm request. e.g. ComputerUseToolset can add computer use\n  tool to the llm request.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def get_auth_config(self) -> typing.Optional[google.adk.auth.auth_tool.AuthConfig]:'
      docstring: "Returns the auth config for this toolset. ADK will make sure the\n'exchanged_auth_credential' field in the config is populated with\nready-to-use credential (e.g. oauth token for OAuth flow) before calling\nget_tools method or execute any tools returned by this toolset. Thus toolset\ncan use this credential either for tool listing or tool calling. If tool\ncalling needs a different credential from ADK client, call\ntool_context.request_credential in the tool.\n\nToolsets that support authentication should override this method to return\nan AuthConfig constructed from their auth_scheme, auth_credential, and\noptional credential_key parameters.\n\nReturns:\n  AuthConfig if the toolset has authentication configured, None otherwise."
  omitted_inherited_members_from:
  - ABC
- rank: 1573
  id: google.adk.tools.computer_use.computer_use_toolset.ComputerUseToolset.__init__
  name: __init__
  file_path: src/google/adk/tools/computer_use/computer_use_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, *, computer: google.adk.tools.computer_use.base_computer.BaseComputer):'
- rank: 1574
  id: google.adk.tools.computer_use.computer_use_toolset.ComputerUseToolset.adapt_computer_use_tool
  name: adapt_computer_use_tool
  file_path: src/google/adk/tools/computer_use/computer_use_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Adapt a computer use tool by replacing it with a modified version.\n\nArgs:\n  method_name: The name of the method (of BaseComputer class) to adapt (e.g.\n    'wait').\n  adapter_func: A function that accepts existing computer use async function\n    and returns a new computer use async function. Can be either sync or\n    async function. The name of the returned function will be used as the\n    new tool name.\n  llm_request: The LLM request containing the tools dictionary."
  signature: 'def adapt_computer_use_tool(method_name: str, adapter_func: typing.Union[typing.Callable[[Callable[..., Any]], typing.Callable[Ellipsis, typing.Any]], typing.Callable[[Callable[..., Any]], typing.Any]], llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
- rank: 1575
  id: google.adk.tools.computer_use.computer_use_toolset.ComputerUseToolset.get_tools
  name: get_tools
  file_path: src/google/adk/tools/computer_use/computer_use_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.computer_use.computer_use_tool.ComputerUseTool]:'
- rank: 1576
  id: google.adk.tools.computer_use.computer_use_toolset.ComputerUseToolset.process_llm_request
  name: process_llm_request
  file_path: src/google/adk/tools/computer_use/computer_use_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Add its tools to the LLM request and add computer use configuration to the LLM request.
  signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
- rank: 1577
  id: google.adk.tools.crewai_tool
  name: crewai_tool
  file_path: src/google/adk/tools/crewai_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1578
  id: google.adk.tools.crewai_tool.CrewaiTool
  name: CrewaiTool
  file_path: src/google/adk/tools/crewai_tool.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Use this class to wrap a CrewAI tool.


    If the original tool name and description are not suitable, you can override

    them in the constructor.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, tool: crewai.tools.BaseTool, *, name: str, description: str):'
  methods:
  - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
    docstring: 'Override run_async to handle CrewAI-specific parameter filtering.


      CrewAI tools use **kwargs pattern, so we need special parameter filtering

      logic that allows all parameters to pass through while removing only

      reserved parameters like ''self'' and ''tool_context''.


      Note: ''tool_context'' is removed from the initial args dictionary to prevent

      duplicates, but is re-added if the function signature explicitly requires it

      as a parameter.'
  - signature: 'def from_config(cls: type[google.adk.tools.crewai_tool.CrewaiTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.crewai_tool.CrewaiTool:'
  properties:
  - signature: 'tool: crewai.tools.BaseTool'
    docstring: The wrapped CrewAI tool.
  inherited_methods:
    FunctionTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
    BaseTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
      docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
      docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  inherited_properties:
    BaseTool:
    - signature: 'name: str'
      docstring: The name of the tool.
    - signature: 'description: str'
      docstring: The description of the tool.
    - signature: 'is_long_running: bool'
      docstring: 'Whether the tool is a long running operation, which typically returns a

        resource id first and finishes the operation later.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the BaseTool.


        An optional key-value pair for storing and retrieving tool-specific metadata,

        such as tool manifests, etc.


        NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 1579
  id: google.adk.tools.crewai_tool.CrewaiTool.__init__
  name: __init__
  file_path: src/google/adk/tools/crewai_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, tool: crewai.tools.BaseTool, *, name: str, description: str):'
- rank: 1580
  id: google.adk.tools.crewai_tool.CrewaiTool.from_config
  name: from_config
  file_path: src/google/adk/tools/crewai_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def from_config(cls: type[google.adk.tools.crewai_tool.CrewaiTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.crewai_tool.CrewaiTool:'
- rank: 1581
  id: google.adk.tools.crewai_tool.CrewaiTool.run_async
  name: run_async
  file_path: src/google/adk/tools/crewai_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Override run_async to handle CrewAI-specific parameter filtering.


    CrewAI tools use **kwargs pattern, so we need special parameter filtering

    logic that allows all parameters to pass through while removing only

    reserved parameters like ''self'' and ''tool_context''.


    Note: ''tool_context'' is removed from the initial args dictionary to prevent

    duplicates, but is re-added if the function signature explicitly requires it

    as a parameter.'
  signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
- rank: 1582
  id: google.adk.tools.crewai_tool.CrewaiToolConfig
  name: CrewaiToolConfig
  file_path: src/google/adk/tools/crewai_tool.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, tool: str, name: str = '''', description: str = ''''):'
  properties:
  - signature: 'tool: str'
    docstring: The fully qualified path of the CrewAI tool instance.
  - signature: 'name: str'
    docstring: The name of the tool.
  - signature: 'description: str'
    docstring: The description of the tool.
  inherited_properties:
    BaseToolConfig:
    - signature: 'model_config: pydantic.ConfigDict'
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1583
  id: google.adk.tools.data_agent
  name: data_agent
  file_path: src/google/adk/tools/data_agent/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Data Agent Tools.
  properties:
  - signature: '__all__: Any'
- rank: 1584
  id: google.adk.tools.data_agent.config
  name: config
  file_path: src/google/adk/tools/data_agent/config.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1585
  id: google.adk.tools.data_agent.config.DataAgentToolConfig
  name: DataAgentToolConfig
  file_path: src/google/adk/tools/data_agent/config.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Configuration for Data Agent tools.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, max_query_result_rows: int = 50):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'max_query_result_rows: int'
    docstring: 'Maximum number of rows to return from a query.


      By default, the query result will be limited to 50 rows.'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1586
  id: google.adk.tools.data_agent.credentials
  name: credentials
  file_path: src/google/adk/tools/data_agent/credentials.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'DATA_AGENT_TOKEN_CACHE_KEY: str'
  - signature: 'DATA_AGENT_DEFAULT_SCOPE: Any'
- rank: 1587
  id: google.adk.tools.data_agent.credentials.DataAgentCredentialsConfig
  name: DataAgentCredentialsConfig
  file_path: src/google/adk/tools/data_agent/credentials.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Data Agent Credentials Configuration for Google API tools.


    [Note: Inherited members from BaseGoogleCredentialsConfig are omitted.]'
  aliases:
  - google.adk.tools.data_agent.DataAgentCredentialsConfig
  omitted_inherited_members_from:
  - BaseGoogleCredentialsConfig
- rank: 1588
  id: google.adk.tools.data_agent.data_agent_tool
  name: data_agent_tool
  file_path: src/google/adk/tools/data_agent/data_agent_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def list_accessible_data_agents(project_id: str, credentials: google.auth.credentials.Credentials) -> dict[str, typing.Any]:'
    docstring: "Lists accessible data agents in a project.\n\nArgs:\n    project_id: The project to list agents in.\n    credentials: The credentials to use for the request.\n\nReturns:\n    A dictionary containing the status and a list of data agents with their\n    detailed information, including name, display_name, description (if\n    available), create_time, update_time, and data_analytics_agent context,\n    or error details if the request fails.\n\nExamples:\n    >>> list_accessible_data_agents(\n    ...     project_id=\"my-gcp-project\",\n    ...     credentials=credentials,\n    ... )\n    {\n      \"status\": \"SUCCESS\",\n      \"response\": [\n        {\n          \"name\": \"projects/my-project/locations/global/dataAgents/agent1\",\n          \"displayName\": \"My Test Agent\",\n          \"createTime\": \"2025-10-01T22:44:22.473927629Z\",\n          \"updateTime\": \"2025-10-01T22:44:23.094541325Z\",\n          \"dataAnalyticsAgent\": {\n            \"publishedContext\": {\n\
      \              \"datasourceReferences\": [{\n                \"bq\": {\n                  \"tableReferences\": [{\n                    \"projectId\": \"my-project\",\n                    \"datasetId\": \"dataset1\",\n                    \"tableId\": \"table1\"\n                  }]\n                }\n              }]\n            }\n          }\n        },\n        {\n          \"name\": \"projects/my-project/locations/global/dataAgents/agent2\",\n          \"displayName\": \"\",\n          \"description\": \"Description for Agent 2.\",\n          \"createTime\": \"2025-06-23T20:23:48.650597312Z\",\n          \"updateTime\": \"2025-06-23T20:23:49.437095391Z\",\n          \"dataAnalyticsAgent\": {\n            \"publishedContext\": {\n              \"datasourceReferences\": [{\n                \"bq\": {\n                  \"tableReferences\": [{\n                    \"projectId\": \"another-project\",\n                    \"datasetId\": \"dataset2\",\n                    \"tableId\"\
      : \"table2\"\n                  }]\n                }\n              }],\n              \"systemInstruction\": \"You are a helpful assistant.\",\n              \"options\": {\"analysis\": {\"python\": {\"enabled\": True}}}\n            }\n          }\n        }\n      ]\n    }"
  - signature: 'def get_data_agent_info(data_agent_name: str, credentials: google.auth.credentials.Credentials) -> dict[str, typing.Any]:'
    docstring: "Gets a data agent by name.\n\nArgs:\n    data_agent_name: The name of the agent to get, in format\n      projects/{project}/locations/{location}/dataAgents/{agent}.\n    credentials: The credentials to use for the request.\n\nReturns:\n    A dictionary containing the status and details of a data agent,\n    including name, display_name, description (if available),\n    create_time, update_time, and data_analytics_agent context,\n    or error details if the request fails.\n\nExamples:\n    >>> get_data_agent_info(\n    ...\n    data_agent_name=\"projects/my-project/locations/global/dataAgents/agent-1\",\n    ...     credentials=credentials,\n    ... )\n    {\n        \"status\": \"SUCCESS\",\n        \"response\": {\n            \"name\": \"projects/my-project/locations/global/dataAgents/agent-1\",\n            \"description\": \"Description for Agent 1.\",\n            \"createTime\": \"2025-06-23T20:23:48.650597312Z\",\n            \"updateTime\": \"2025-06-23T20:23:49.437095391Z\"\
      ,\n            \"dataAnalyticsAgent\": {\n                \"publishedContext\": {\n                    \"systemInstruction\": \"You are a helpful assistant.\",\n                    \"options\": {\"analysis\": {\"python\": {\"enabled\": True}}},\n                    \"datasourceReferences\": {\n                        \"bq\": {\n                            \"tableReferences\": [{\n                                \"projectId\": \"my-gcp-project\",\n                                \"datasetId\": \"dataset1\",\n                                \"tableId\": \"table1\"\n                            }]\n                        }\n                    },\n                }\n            }\n        }\n    }"
  - signature: 'def ask_data_agent(data_agent_name: str, query: str, *, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.data_agent.config.DataAgentToolConfig, tool_context: google.adk.tools.tool_context.ToolContext) -> dict[str, typing.Any]:'
    docstring: "Asks a question to a data agent.\n\nArgs:\n    data_agent_name: The resource name of an existing data agent to ask, in\n      format projects/{project}/locations/{location}/dataAgents/{agent}.\n    query: The question to ask the agent.\n    credentials: The credentials to use for the request.\n    tool_context: The context for the tool.\n\nReturns:\n    A dictionary with two keys:\n    - 'status': A string indicating the final status (e.g., \"SUCCESS\").\n    - 'response': A list of dictionaries, where each dictionary\n      represents a step in the agent's execution process (e.g., SQL\n      generation, data retrieval, final answer). Note that the 'Answer'\n      step contains a text response which may summarize findings or refer\n      to previous steps of agent execution, such as 'Data Retrieved', in\n      which cases, the 'Answer' step does not include the result data.\n\nExamples:\n    A query to a data agent, showing the full return structure.\n    The original question:\
      \ \"Which customer from New York spent the most last\n    month?\"\n\n    >>> ask_data_agent(\n    ...\n    data_agent_name=\"projects/my-project/locations/global/dataAgents/sales-agent\",\n    ...     query=\"Which customer from New York spent the most last month?\",\n    ...     credentials=credentials,\n    ...     tool_context=tool_context,\n    ... )\n    {\n      \"status\": \"SUCCESS\",\n      \"response\": [\n        {\n          \"Question\": \"Which customer from New York spent the most last\n          month?\"\n        },\n        {\n          \"Schema Resolved\": [\n            {\n              \"source_name\": \"my-gcp-project.sales_data.customers\",\n              \"schema\": {\n                \"headers\": [\"Column\", \"Type\", \"Description\", \"Mode\"],\n                \"rows\": [\n                  [\"customer_id\", \"INT64\", \"Customer ID\", \"REQUIRED\"],\n                  [\"customer_name\", \"STRING\", \"Customer Name\", \"NULLABLE\"],\n                ]\n\
      \              }\n            }\n          ]\n        },\n        {\n          \"Retrieval Query\": {\n            \"Query Name\": \"top_spender\",\n            \"Question\": \"Find top spending customer from New York in the last\n            month.\"\n          }\n        },\n        {\n          \"SQL Generated\": \"SELECT t1.customer_name, SUM(t2.order_total) ... \"\n        },\n        {\n          \"Data Retrieved\": {\n            \"headers\": [\"customer_name\", \"total_spent\"],\n            \"rows\": [[\"Jane Doe\", 1234.56]],\n            \"summary\": \"Showing all 1 rows.\"\n          }\n        },\n        {\n          \"Answer\": \"The customer who spent the most last month was Jane Doe.\"\n        }\n      ]\n    }"
  properties:
  - signature: 'BASE_URL: str'
- rank: 1589
  id: google.adk.tools.data_agent.data_agent_tool.ask_data_agent
  name: ask_data_agent
  file_path: src/google/adk/tools/data_agent/data_agent_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Asks a question to a data agent.\n\nArgs:\n    data_agent_name: The resource name of an existing data agent to ask, in\n      format projects/{project}/locations/{location}/dataAgents/{agent}.\n    query: The question to ask the agent.\n    credentials: The credentials to use for the request.\n    tool_context: The context for the tool.\n\nReturns:\n    A dictionary with two keys:\n    - 'status': A string indicating the final status (e.g., \"SUCCESS\").\n    - 'response': A list of dictionaries, where each dictionary\n      represents a step in the agent's execution process (e.g., SQL\n      generation, data retrieval, final answer). Note that the 'Answer'\n      step contains a text response which may summarize findings or refer\n      to previous steps of agent execution, such as 'Data Retrieved', in\n      which cases, the 'Answer' step does not include the result data.\n\nExamples:\n    A query to a data agent, showing the full return structure.\n    The original question:\
    \ \"Which customer from New York spent the most last\n    month?\"\n\n    >>> ask_data_agent(\n    ...\n    data_agent_name=\"projects/my-project/locations/global/dataAgents/sales-agent\",\n    ...     query=\"Which customer from New York spent the most last month?\",\n    ...     credentials=credentials,\n    ...     tool_context=tool_context,\n    ... )\n    {\n      \"status\": \"SUCCESS\",\n      \"response\": [\n        {\n          \"Question\": \"Which customer from New York spent the most last\n          month?\"\n        },\n        {\n          \"Schema Resolved\": [\n            {\n              \"source_name\": \"my-gcp-project.sales_data.customers\",\n              \"schema\": {\n                \"headers\": [\"Column\", \"Type\", \"Description\", \"Mode\"],\n                \"rows\": [\n                  [\"customer_id\", \"INT64\", \"Customer ID\", \"REQUIRED\"],\n                  [\"customer_name\", \"STRING\", \"Customer Name\", \"NULLABLE\"],\n                ]\n \
    \             }\n            }\n          ]\n        },\n        {\n          \"Retrieval Query\": {\n            \"Query Name\": \"top_spender\",\n            \"Question\": \"Find top spending customer from New York in the last\n            month.\"\n          }\n        },\n        {\n          \"SQL Generated\": \"SELECT t1.customer_name, SUM(t2.order_total) ... \"\n        },\n        {\n          \"Data Retrieved\": {\n            \"headers\": [\"customer_name\", \"total_spent\"],\n            \"rows\": [[\"Jane Doe\", 1234.56]],\n            \"summary\": \"Showing all 1 rows.\"\n          }\n        },\n        {\n          \"Answer\": \"The customer who spent the most last month was Jane Doe.\"\n        }\n      ]\n    }"
  signature: 'def ask_data_agent(data_agent_name: str, query: str, *, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.data_agent.config.DataAgentToolConfig, tool_context: google.adk.tools.tool_context.ToolContext) -> dict[str, typing.Any]:'
- rank: 1590
  id: google.adk.tools.data_agent.data_agent_tool.get_data_agent_info
  name: get_data_agent_info
  file_path: src/google/adk/tools/data_agent/data_agent_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Gets a data agent by name.\n\nArgs:\n    data_agent_name: The name of the agent to get, in format\n      projects/{project}/locations/{location}/dataAgents/{agent}.\n    credentials: The credentials to use for the request.\n\nReturns:\n    A dictionary containing the status and details of a data agent,\n    including name, display_name, description (if available),\n    create_time, update_time, and data_analytics_agent context,\n    or error details if the request fails.\n\nExamples:\n    >>> get_data_agent_info(\n    ...\n    data_agent_name=\"projects/my-project/locations/global/dataAgents/agent-1\",\n    ...     credentials=credentials,\n    ... )\n    {\n        \"status\": \"SUCCESS\",\n        \"response\": {\n            \"name\": \"projects/my-project/locations/global/dataAgents/agent-1\",\n            \"description\": \"Description for Agent 1.\",\n            \"createTime\": \"2025-06-23T20:23:48.650597312Z\",\n            \"updateTime\": \"2025-06-23T20:23:49.437095391Z\"\
    ,\n            \"dataAnalyticsAgent\": {\n                \"publishedContext\": {\n                    \"systemInstruction\": \"You are a helpful assistant.\",\n                    \"options\": {\"analysis\": {\"python\": {\"enabled\": True}}},\n                    \"datasourceReferences\": {\n                        \"bq\": {\n                            \"tableReferences\": [{\n                                \"projectId\": \"my-gcp-project\",\n                                \"datasetId\": \"dataset1\",\n                                \"tableId\": \"table1\"\n                            }]\n                        }\n                    },\n                }\n            }\n        }\n    }"
  signature: 'def get_data_agent_info(data_agent_name: str, credentials: google.auth.credentials.Credentials) -> dict[str, typing.Any]:'
- rank: 1591
  id: google.adk.tools.data_agent.data_agent_tool.list_accessible_data_agents
  name: list_accessible_data_agents
  file_path: src/google/adk/tools/data_agent/data_agent_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Lists accessible data agents in a project.\n\nArgs:\n    project_id: The project to list agents in.\n    credentials: The credentials to use for the request.\n\nReturns:\n    A dictionary containing the status and a list of data agents with their\n    detailed information, including name, display_name, description (if\n    available), create_time, update_time, and data_analytics_agent context,\n    or error details if the request fails.\n\nExamples:\n    >>> list_accessible_data_agents(\n    ...     project_id=\"my-gcp-project\",\n    ...     credentials=credentials,\n    ... )\n    {\n      \"status\": \"SUCCESS\",\n      \"response\": [\n        {\n          \"name\": \"projects/my-project/locations/global/dataAgents/agent1\",\n          \"displayName\": \"My Test Agent\",\n          \"createTime\": \"2025-10-01T22:44:22.473927629Z\",\n          \"updateTime\": \"2025-10-01T22:44:23.094541325Z\",\n          \"dataAnalyticsAgent\": {\n            \"publishedContext\": {\n\
    \              \"datasourceReferences\": [{\n                \"bq\": {\n                  \"tableReferences\": [{\n                    \"projectId\": \"my-project\",\n                    \"datasetId\": \"dataset1\",\n                    \"tableId\": \"table1\"\n                  }]\n                }\n              }]\n            }\n          }\n        },\n        {\n          \"name\": \"projects/my-project/locations/global/dataAgents/agent2\",\n          \"displayName\": \"\",\n          \"description\": \"Description for Agent 2.\",\n          \"createTime\": \"2025-06-23T20:23:48.650597312Z\",\n          \"updateTime\": \"2025-06-23T20:23:49.437095391Z\",\n          \"dataAnalyticsAgent\": {\n            \"publishedContext\": {\n              \"datasourceReferences\": [{\n                \"bq\": {\n                  \"tableReferences\": [{\n                    \"projectId\": \"another-project\",\n                    \"datasetId\": \"dataset2\",\n                    \"tableId\"\
    : \"table2\"\n                  }]\n                }\n              }],\n              \"systemInstruction\": \"You are a helpful assistant.\",\n              \"options\": {\"analysis\": {\"python\": {\"enabled\": True}}}\n            }\n          }\n        }\n      ]\n    }"
  signature: 'def list_accessible_data_agents(project_id: str, credentials: google.auth.credentials.Credentials) -> dict[str, typing.Any]:'
- rank: 1592
  id: google.adk.tools.data_agent.data_agent_toolset
  name: data_agent_toolset
  file_path: src/google/adk/tools/data_agent/data_agent_toolset.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1593
  id: google.adk.tools.data_agent.data_agent_toolset.DataAgentToolset
  name: DataAgentToolset
  file_path: src/google/adk/tools/data_agent/data_agent_toolset.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Data Agent Toolset contains tools for interacting with data agents.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, *, tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]]=None, credentials_config: typing.Optional[google.adk.tools.data_agent.credentials.DataAgentCredentialsConfig]=None, data_agent_tool_config: typing.Optional[google.adk.tools.data_agent.config.DataAgentToolConfig]=None):'
  aliases:
  - google.adk.tools.data_agent.DataAgentToolset
  methods:
  - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> typing.List[google.adk.tools.base_tool.BaseTool]:'
  - signature: 'def close(self):'
  inherited_methods:
    BaseToolset:
    - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools in the toolset based on the provided context.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools available under the specified context."
    - signature: 'def get_tools_with_prefix(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools with optional prefix applied to tool names.\n\nThis method calls get_tools() and applies prefixing if tool_name_prefix is provided.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools with prefixed names if tool_name_prefix is provided."
    - signature: 'def close(self) -> None:'
      docstring: "Performs cleanup and releases resources held by the toolset.\n\nNOTE:\n  This method is invoked, for example, at the end of an agent server's\n  lifecycle or when the toolset is no longer needed. Implementations\n  should ensure that any open connections, files, or other managed\n  resources are properly released to prevent leaks."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_toolset.SelfToolset], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_toolset.SelfToolset:'
      docstring: "Creates a toolset instance from a config.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The toolset instance."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this toolset. This method will be\ncalled before each tool processes the llm request.\n\nUse cases:\n- Instead of let each tool process the llm request, we can let the toolset\n  process the llm request. e.g. ComputerUseToolset can add computer use\n  tool to the llm request.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def get_auth_config(self) -> typing.Optional[google.adk.auth.auth_tool.AuthConfig]:'
      docstring: "Returns the auth config for this toolset. ADK will make sure the\n'exchanged_auth_credential' field in the config is populated with\nready-to-use credential (e.g. oauth token for OAuth flow) before calling\nget_tools method or execute any tools returned by this toolset. Thus toolset\ncan use this credential either for tool listing or tool calling. If tool\ncalling needs a different credential from ADK client, call\ntool_context.request_credential in the tool.\n\nToolsets that support authentication should override this method to return\nan AuthConfig constructed from their auth_scheme, auth_credential, and\noptional credential_key parameters.\n\nReturns:\n  AuthConfig if the toolset has authentication configured, None otherwise."
  omitted_inherited_members_from:
  - ABC
- rank: 1594
  id: google.adk.tools.data_agent.data_agent_toolset.DataAgentToolset.__init__
  name: __init__
  file_path: src/google/adk/tools/data_agent/data_agent_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, *, tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]]=None, credentials_config: typing.Optional[google.adk.tools.data_agent.credentials.DataAgentCredentialsConfig]=None, data_agent_tool_config: typing.Optional[google.adk.tools.data_agent.config.DataAgentToolConfig]=None):'
- rank: 1595
  id: google.adk.tools.data_agent.data_agent_toolset.DataAgentToolset.get_tools
  name: get_tools
  file_path: src/google/adk/tools/data_agent/data_agent_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> typing.List[google.adk.tools.base_tool.BaseTool]:'
- rank: 1596
  id: google.adk.tools.discovery_engine_search_tool
  name: discovery_engine_search_tool
  file_path: src/google/adk/tools/discovery_engine_search_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1597
  id: google.adk.tools.discovery_engine_search_tool.DiscoveryEngineSearchTool
  name: DiscoveryEngineSearchTool
  file_path: src/google/adk/tools/discovery_engine_search_tool.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Tool for searching the discovery engine.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, data_store_id: typing.Optional[str], data_store_specs: typing.Optional[list[google.genai.types.VertexAISearchDataStoreSpec]], search_engine_id: typing.Optional[str], filter: typing.Optional[str], max_results: typing.Optional[int]):'
  methods:
  - signature: 'def discovery_engine_search(self, query: str) -> dict[str, typing.Any]:'
    docstring: "Search through Vertex AI Search's discovery engine search API.\n\nArgs:\n  query: The search query.\n\nReturns:\n  A dictionary containing the status of the request and the list of search\n  results, which contains the title, url and content."
  inherited_methods:
    FunctionTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
    BaseTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
      docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
      docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  inherited_properties:
    BaseTool:
    - signature: 'name: str'
      docstring: The name of the tool.
    - signature: 'description: str'
      docstring: The description of the tool.
    - signature: 'is_long_running: bool'
      docstring: 'Whether the tool is a long running operation, which typically returns a

        resource id first and finishes the operation later.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the BaseTool.


        An optional key-value pair for storing and retrieving tool-specific metadata,

        such as tool manifests, etc.


        NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 1598
  id: google.adk.tools.discovery_engine_search_tool.DiscoveryEngineSearchTool.__init__
  name: __init__
  file_path: src/google/adk/tools/discovery_engine_search_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the DiscoveryEngineSearchTool.\n\nArgs:\n  data_store_id: The Vertex AI search data store resource ID in the format\n    of\n    \"projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}\".\n  data_store_specs: Specifications that define the specific DataStores to be\n    searched. It should only be set if engine is used.\n  search_engine_id: The Vertex AI search engine resource ID in the format of\n    \"projects/{project}/locations/{location}/collections/{collection}/engines/{engine}\".\n  filter: The filter to be applied to the search request. Default is None.\n  max_results: The maximum number of results to return. Default is None."
  signature: 'def __init__(self, data_store_id: typing.Optional[str], data_store_specs: typing.Optional[list[google.genai.types.VertexAISearchDataStoreSpec]], search_engine_id: typing.Optional[str], filter: typing.Optional[str], max_results: typing.Optional[int]):'
- rank: 1599
  id: google.adk.tools.discovery_engine_search_tool.DiscoveryEngineSearchTool.discovery_engine_search
  name: discovery_engine_search
  file_path: src/google/adk/tools/discovery_engine_search_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Search through Vertex AI Search's discovery engine search API.\n\nArgs:\n  query: The search query.\n\nReturns:\n  A dictionary containing the status of the request and the list of search\n  results, which contains the title, url and content."
  signature: 'def discovery_engine_search(self, query: str) -> dict[str, typing.Any]:'
- rank: 1600
  id: google.adk.tools.enterprise_search_tool
  name: enterprise_search_tool
  file_path: src/google/adk/tools/enterprise_search_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'enterprise_web_search_tool: EnterpriseWebSearchTool'
- rank: 1601
  id: google.adk.tools.enterprise_search_tool.EnterpriseWebSearchTool
  name: EnterpriseWebSearchTool
  file_path: src/google/adk/tools/enterprise_search_tool.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A Gemini 2+ built-in tool using web grounding for Enterprise compliance.


    NOTE: This tool is not the same as Vertex AI Search, which is used to be

    called "Enterprise Search".


    See the documentation for more details:

    https://cloud.google.com/vertex-ai/generative-ai/docs/grounding/web-grounding-enterprise.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self):'
  methods:
  - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.LlmRequest) -> None:'
  inherited_methods:
    BaseTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
      docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
      docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  inherited_properties:
    BaseTool:
    - signature: 'name: str'
      docstring: The name of the tool.
    - signature: 'description: str'
      docstring: The description of the tool.
    - signature: 'is_long_running: bool'
      docstring: 'Whether the tool is a long running operation, which typically returns a

        resource id first and finishes the operation later.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the BaseTool.


        An optional key-value pair for storing and retrieving tool-specific metadata,

        such as tool manifests, etc.


        NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 1602
  id: google.adk.tools.enterprise_search_tool.EnterpriseWebSearchTool.__init__
  name: __init__
  file_path: src/google/adk/tools/enterprise_search_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Initializes the Enterprise Web Search tool.
  signature: 'def __init__(self):'
- rank: 1603
  id: google.adk.tools.enterprise_search_tool.EnterpriseWebSearchTool.process_llm_request
  name: process_llm_request
  file_path: src/google/adk/tools/enterprise_search_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.LlmRequest) -> None:'
- rank: 1604
  id: google.adk.tools.example_tool
  name: example_tool
  file_path: src/google/adk/tools/example_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1605
  id: google.adk.tools.example_tool.ExampleTool.__init__
  name: __init__
  file_path: src/google/adk/tools/example_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, examples: typing.Union[list[google.adk.examples.example.Example], google.adk.examples.base_example_provider.BaseExampleProvider]):'
- rank: 1606
  id: google.adk.tools.example_tool.ExampleTool.from_config
  name: from_config
  file_path: src/google/adk/tools/example_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def from_config(cls: type[google.adk.tools.example_tool.ExampleTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.example_tool.ExampleTool:'
- rank: 1607
  id: google.adk.tools.example_tool.ExampleTool.process_llm_request
  name: process_llm_request
  file_path: src/google/adk/tools/example_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
- rank: 1608
  id: google.adk.tools.example_tool.ExampleToolConfig
  name: ExampleToolConfig
  file_path: src/google/adk/tools/example_tool.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, examples: typing.Union[list[google.adk.examples.example.Example], str]):'
  properties:
  - signature: 'examples: typing.Union[list[google.adk.examples.example.Example], str]'
    docstring: 'The examples to add to the LLM request. User can either provide a list of

      examples or a fully-qualified name to a BaseExampleProvider object in code.'
  inherited_properties:
    BaseToolConfig:
    - signature: 'model_config: pydantic.ConfigDict'
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1609
  id: google.adk.tools.exit_loop_tool
  name: exit_loop_tool
  file_path: src/google/adk/tools/exit_loop_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def exit_loop(tool_context: google.adk.tools.tool_context.ToolContext):'
    docstring: 'Exits the loop.


      Call this function only when you are instructed to do so.'
- rank: 1610
  id: google.adk.tools.exit_loop_tool.exit_loop
  name: exit_loop
  file_path: src/google/adk/tools/exit_loop_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Exits the loop.


    Call this function only when you are instructed to do so.'
  signature: 'def exit_loop(tool_context: google.adk.tools.tool_context.ToolContext):'
  aliases:
  - google.adk.tools.exit_loop
- rank: 1611
  id: google.adk.tools.function_tool
  name: function_tool
  file_path: src/google/adk/tools/function_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 1612
  id: google.adk.tools.function_tool.FunctionTool.__init__
  name: __init__
  file_path: src/google/adk/tools/function_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the FunctionTool. Extracts metadata from a callable object.\n\nArgs:\n  func: The function to wrap.\n  require_confirmation: Whether this tool requires confirmation. A boolean or\n    a callable that takes the function's arguments and returns a boolean. If\n    the callable returns True, the tool will require confirmation from the\n    user."
  signature: 'def __init__(self, func: typing.Callable[Ellipsis, typing.Any], *, require_confirmation: typing.Union[bool, typing.Callable[Ellipsis, bool]]=False):'
- rank: 1613
  id: google.adk.tools.function_tool.FunctionTool.run_async
  name: run_async
  file_path: src/google/adk/tools/function_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
- rank: 1614
  id: google.adk.tools.get_user_choice_tool
  name: get_user_choice_tool
  file_path: src/google/adk/tools/get_user_choice_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def get_user_choice(options: list[str], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Optional[str]:'
    docstring: Provides the options to the user and asks them to choose one.
  properties:
  - signature: 'get_user_choice_tool: google.adk.tools.long_running_tool.LongRunningFunctionTool'
- rank: 1615
  id: google.adk.tools.get_user_choice_tool.get_user_choice
  name: get_user_choice
  file_path: src/google/adk/tools/get_user_choice_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Provides the options to the user and asks them to choose one.
  signature: 'def get_user_choice(options: list[str], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Optional[str]:'
- rank: 1616
  id: google.adk.tools.google_api_tool
  name: google_api_tool
  file_path: src/google/adk/tools/google_api_tool/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: 'Auto-generated tools and toolsets for Google APIs.


    These tools and toolsets are auto-generated based on the API specifications

    provided by the Google API Discovery API.'
  properties:
  - signature: '__all__: Any'
- rank: 1617
  id: google.adk.tools.google_api_tool.google_api_tool
  name: google_api_tool
  file_path: src/google/adk/tools/google_api_tool/google_api_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1618
  id: google.adk.tools.google_api_tool.google_api_tool.GoogleApiTool
  name: GoogleApiTool
  file_path: src/google/adk/tools/google_api_tool/google_api_tool.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, rest_api_tool: google.adk.tools.openapi_tool.RestApiTool, client_id: typing.Optional[str], client_secret: typing.Optional[str], service_account: typing.Optional[google.adk.auth.auth_credential.ServiceAccount], *, additional_headers: typing.Optional[typing.Dict[str, str]]=None):'
  methods:
  - signature: 'def run_async(self, *, args: typing.Dict[str, typing.Any], tool_context: typing.Optional[google.adk.tools.tool_context.ToolContext]) -> typing.Dict[str, typing.Any]:'
  - signature: 'def configure_auth(self, client_id: str, client_secret: str):'
  - signature: 'def configure_sa_auth(self, service_account: google.adk.auth.auth_credential.ServiceAccount):'
  inherited_methods:
    BaseTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
      docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
      docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  inherited_properties:
    BaseTool:
    - signature: 'name: str'
      docstring: The name of the tool.
    - signature: 'description: str'
      docstring: The description of the tool.
    - signature: 'is_long_running: bool'
      docstring: 'Whether the tool is a long running operation, which typically returns a

        resource id first and finishes the operation later.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the BaseTool.


        An optional key-value pair for storing and retrieving tool-specific metadata,

        such as tool manifests, etc.


        NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 1619
  id: google.adk.tools.google_api_tool.google_api_tool.GoogleApiTool.__init__
  name: __init__
  file_path: src/google/adk/tools/google_api_tool/google_api_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, rest_api_tool: google.adk.tools.openapi_tool.RestApiTool, client_id: typing.Optional[str], client_secret: typing.Optional[str], service_account: typing.Optional[google.adk.auth.auth_credential.ServiceAccount], *, additional_headers: typing.Optional[typing.Dict[str, str]]=None):'
- rank: 1620
  id: google.adk.tools.google_api_tool.google_api_tool.GoogleApiTool.configure_auth
  name: configure_auth
  file_path: src/google/adk/tools/google_api_tool/google_api_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def configure_auth(self, client_id: str, client_secret: str):'
- rank: 1621
  id: google.adk.tools.google_api_tool.google_api_tool.GoogleApiTool.configure_sa_auth
  name: configure_sa_auth
  file_path: src/google/adk/tools/google_api_tool/google_api_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def configure_sa_auth(self, service_account: google.adk.auth.auth_credential.ServiceAccount):'
- rank: 1622
  id: google.adk.tools.google_api_tool.google_api_tool.GoogleApiTool.run_async
  name: run_async
  file_path: src/google/adk/tools/google_api_tool/google_api_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def run_async(self, *, args: typing.Dict[str, typing.Any], tool_context: typing.Optional[google.adk.tools.tool_context.ToolContext]) -> typing.Dict[str, typing.Any]:'
- rank: 1623
  id: google.adk.tools.google_api_tool.google_api_toolset
  name: google_api_toolset
  file_path: src/google/adk/tools/google_api_tool/google_api_toolset.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1624
  id: google.adk.tools.google_api_tool.google_api_toolset.GoogleApiToolset
  name: GoogleApiToolset
  file_path: src/google/adk/tools/google_api_tool/google_api_toolset.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "Google API Toolset contains tools for interacting with Google APIs.\n\nUsually one toolsets will contain tools only related to one Google API, e.g.\nGoogle Bigquery API toolset will contain tools only related to Google\nBigquery API, like list dataset tool, list table tool etc.\n\nArgs:\n  api_name: The name of the Google API (e.g., \"calendar\", \"gmail\").\n  api_version: The version of the API (e.g., \"v3\", \"v1\").\n  client_id: OAuth2 client ID for authentication.\n  client_secret: OAuth2 client secret for authentication.\n  tool_filter: Optional filter to include only specific tools or use a predicate function.\n  service_account: Optional service account for authentication.\n  tool_name_prefix: Optional prefix to add to all tool names in this toolset.\n  additional_headers: Optional dict of HTTP headers to inject into every request\n    executed by this toolset.\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, api_name: str, api_version: str, client_id: typing.Optional[str], client_secret: typing.Optional[str], tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]], service_account: typing.Optional[google.adk.auth.auth_credential.ServiceAccount], tool_name_prefix: typing.Optional[str], *, additional_headers: typing.Optional[typing.Dict[str, str]]=None):'
  methods:
  - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> typing.List[google.adk.tools.google_api_tool.google_api_tool.GoogleApiTool]:'
    docstring: Get all tools in the toolset.
  - signature: 'def set_tool_filter(self, tool_filter: typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]):'
  - signature: 'def configure_auth(self, client_id: str, client_secret: str):'
  - signature: 'def configure_sa_auth(self, service_account: google.adk.auth.auth_credential.ServiceAccount):'
  - signature: 'def close(self):'
  inherited_methods:
    BaseToolset:
    - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools in the toolset based on the provided context.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools available under the specified context."
    - signature: 'def get_tools_with_prefix(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools with optional prefix applied to tool names.\n\nThis method calls get_tools() and applies prefixing if tool_name_prefix is provided.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools with prefixed names if tool_name_prefix is provided."
    - signature: 'def close(self) -> None:'
      docstring: "Performs cleanup and releases resources held by the toolset.\n\nNOTE:\n  This method is invoked, for example, at the end of an agent server's\n  lifecycle or when the toolset is no longer needed. Implementations\n  should ensure that any open connections, files, or other managed\n  resources are properly released to prevent leaks."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_toolset.SelfToolset], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_toolset.SelfToolset:'
      docstring: "Creates a toolset instance from a config.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The toolset instance."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this toolset. This method will be\ncalled before each tool processes the llm request.\n\nUse cases:\n- Instead of let each tool process the llm request, we can let the toolset\n  process the llm request. e.g. ComputerUseToolset can add computer use\n  tool to the llm request.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def get_auth_config(self) -> typing.Optional[google.adk.auth.auth_tool.AuthConfig]:'
      docstring: "Returns the auth config for this toolset. ADK will make sure the\n'exchanged_auth_credential' field in the config is populated with\nready-to-use credential (e.g. oauth token for OAuth flow) before calling\nget_tools method or execute any tools returned by this toolset. Thus toolset\ncan use this credential either for tool listing or tool calling. If tool\ncalling needs a different credential from ADK client, call\ntool_context.request_credential in the tool.\n\nToolsets that support authentication should override this method to return\nan AuthConfig constructed from their auth_scheme, auth_credential, and\noptional credential_key parameters.\n\nReturns:\n  AuthConfig if the toolset has authentication configured, None otherwise."
  omitted_inherited_members_from:
  - ABC
- rank: 1625
  id: google.adk.tools.google_api_tool.google_api_toolset.GoogleApiToolset.__init__
  name: __init__
  file_path: src/google/adk/tools/google_api_tool/google_api_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, api_name: str, api_version: str, client_id: typing.Optional[str], client_secret: typing.Optional[str], tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]], service_account: typing.Optional[google.adk.auth.auth_credential.ServiceAccount], tool_name_prefix: typing.Optional[str], *, additional_headers: typing.Optional[typing.Dict[str, str]]=None):'
- rank: 1626
  id: google.adk.tools.google_api_tool.google_api_toolset.GoogleApiToolset.get_tools
  name: get_tools
  file_path: src/google/adk/tools/google_api_tool/google_api_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Get all tools in the toolset.
  signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> typing.List[google.adk.tools.google_api_tool.google_api_tool.GoogleApiTool]:'
- rank: 1627
  id: google.adk.tools.google_api_tool.google_api_toolsets
  name: google_api_toolsets
  file_path: src/google/adk/tools/google_api_tool/google_api_toolsets.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 1628
  id: google.adk.tools.google_api_tool.google_api_toolsets.BigQueryToolset
  name: BigQueryToolset
  file_path: src/google/adk/tools/google_api_tool/google_api_toolsets.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "Auto-generated BigQuery toolset based on Google BigQuery API v2 spec exposed by Google API discovery API.\n\nArgs:\n  client_id: OAuth2 client ID for authentication.\n  client_secret: OAuth2 client secret for authentication.\n  tool_filter: Optional filter to include only specific tools or use a predicate function.\n  service_account: Optional service account for authentication.\n  tool_name_prefix: Optional prefix to add to all tool names in this toolset.\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, client_id: typing.Optional[str], client_secret: typing.Optional[str], tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]], service_account: typing.Optional[google.adk.auth.auth_credential.ServiceAccount], tool_name_prefix: typing.Optional[str]):'
  aliases:
  - google.adk.tools.google_api_tool.BigQueryToolset
  inherited_methods:
    GoogleApiToolset:
    - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> typing.List[google.adk.tools.google_api_tool.google_api_tool.GoogleApiTool]:'
      docstring: Get all tools in the toolset.
    - signature: 'def set_tool_filter(self, tool_filter: typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]):'
    - signature: 'def configure_auth(self, client_id: str, client_secret: str):'
    - signature: 'def configure_sa_auth(self, service_account: google.adk.auth.auth_credential.ServiceAccount):'
    - signature: 'def close(self):'
    BaseToolset:
    - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools in the toolset based on the provided context.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools available under the specified context."
    - signature: 'def get_tools_with_prefix(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools with optional prefix applied to tool names.\n\nThis method calls get_tools() and applies prefixing if tool_name_prefix is provided.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools with prefixed names if tool_name_prefix is provided."
    - signature: 'def close(self) -> None:'
      docstring: "Performs cleanup and releases resources held by the toolset.\n\nNOTE:\n  This method is invoked, for example, at the end of an agent server's\n  lifecycle or when the toolset is no longer needed. Implementations\n  should ensure that any open connections, files, or other managed\n  resources are properly released to prevent leaks."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_toolset.SelfToolset], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_toolset.SelfToolset:'
      docstring: "Creates a toolset instance from a config.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The toolset instance."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this toolset. This method will be\ncalled before each tool processes the llm request.\n\nUse cases:\n- Instead of let each tool process the llm request, we can let the toolset\n  process the llm request. e.g. ComputerUseToolset can add computer use\n  tool to the llm request.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def get_auth_config(self) -> typing.Optional[google.adk.auth.auth_tool.AuthConfig]:'
      docstring: "Returns the auth config for this toolset. ADK will make sure the\n'exchanged_auth_credential' field in the config is populated with\nready-to-use credential (e.g. oauth token for OAuth flow) before calling\nget_tools method or execute any tools returned by this toolset. Thus toolset\ncan use this credential either for tool listing or tool calling. If tool\ncalling needs a different credential from ADK client, call\ntool_context.request_credential in the tool.\n\nToolsets that support authentication should override this method to return\nan AuthConfig constructed from their auth_scheme, auth_credential, and\noptional credential_key parameters.\n\nReturns:\n  AuthConfig if the toolset has authentication configured, None otherwise."
  omitted_inherited_members_from:
  - ABC
- rank: 1629
  id: google.adk.tools.google_api_tool.google_api_toolsets.BigQueryToolset.__init__
  name: __init__
  file_path: src/google/adk/tools/google_api_tool/google_api_toolsets.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, client_id: typing.Optional[str], client_secret: typing.Optional[str], tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]], service_account: typing.Optional[google.adk.auth.auth_credential.ServiceAccount], tool_name_prefix: typing.Optional[str]):'
- rank: 1630
  id: google.adk.tools.google_api_tool.google_api_toolsets.CalendarToolset
  name: CalendarToolset
  file_path: src/google/adk/tools/google_api_tool/google_api_toolsets.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "Auto-generated Calendar toolset based on Google Calendar API v3 spec exposed by Google API discovery API.\n\nArgs:\n  client_id: OAuth2 client ID for authentication.\n  client_secret: OAuth2 client secret for authentication.\n  tool_filter: Optional filter to include only specific tools or use a predicate function.\n  service_account: Optional service account for authentication.\n  tool_name_prefix: Optional prefix to add to all tool names in this toolset.\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, client_id: typing.Optional[str], client_secret: typing.Optional[str], tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]], service_account: typing.Optional[google.adk.auth.auth_credential.ServiceAccount], tool_name_prefix: typing.Optional[str]):'
  aliases:
  - google.adk.tools.google_api_tool.CalendarToolset
  inherited_methods:
    GoogleApiToolset:
    - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> typing.List[google.adk.tools.google_api_tool.google_api_tool.GoogleApiTool]:'
      docstring: Get all tools in the toolset.
    - signature: 'def set_tool_filter(self, tool_filter: typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]):'
    - signature: 'def configure_auth(self, client_id: str, client_secret: str):'
    - signature: 'def configure_sa_auth(self, service_account: google.adk.auth.auth_credential.ServiceAccount):'
    - signature: 'def close(self):'
    BaseToolset:
    - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools in the toolset based on the provided context.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools available under the specified context."
    - signature: 'def get_tools_with_prefix(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools with optional prefix applied to tool names.\n\nThis method calls get_tools() and applies prefixing if tool_name_prefix is provided.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools with prefixed names if tool_name_prefix is provided."
    - signature: 'def close(self) -> None:'
      docstring: "Performs cleanup and releases resources held by the toolset.\n\nNOTE:\n  This method is invoked, for example, at the end of an agent server's\n  lifecycle or when the toolset is no longer needed. Implementations\n  should ensure that any open connections, files, or other managed\n  resources are properly released to prevent leaks."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_toolset.SelfToolset], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_toolset.SelfToolset:'
      docstring: "Creates a toolset instance from a config.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The toolset instance."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this toolset. This method will be\ncalled before each tool processes the llm request.\n\nUse cases:\n- Instead of let each tool process the llm request, we can let the toolset\n  process the llm request. e.g. ComputerUseToolset can add computer use\n  tool to the llm request.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def get_auth_config(self) -> typing.Optional[google.adk.auth.auth_tool.AuthConfig]:'
      docstring: "Returns the auth config for this toolset. ADK will make sure the\n'exchanged_auth_credential' field in the config is populated with\nready-to-use credential (e.g. oauth token for OAuth flow) before calling\nget_tools method or execute any tools returned by this toolset. Thus toolset\ncan use this credential either for tool listing or tool calling. If tool\ncalling needs a different credential from ADK client, call\ntool_context.request_credential in the tool.\n\nToolsets that support authentication should override this method to return\nan AuthConfig constructed from their auth_scheme, auth_credential, and\noptional credential_key parameters.\n\nReturns:\n  AuthConfig if the toolset has authentication configured, None otherwise."
  omitted_inherited_members_from:
  - ABC
- rank: 1631
  id: google.adk.tools.google_api_tool.google_api_toolsets.CalendarToolset.__init__
  name: __init__
  file_path: src/google/adk/tools/google_api_tool/google_api_toolsets.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, client_id: typing.Optional[str], client_secret: typing.Optional[str], tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]], service_account: typing.Optional[google.adk.auth.auth_credential.ServiceAccount], tool_name_prefix: typing.Optional[str]):'
- rank: 1632
  id: google.adk.tools.google_api_tool.google_api_toolsets.DocsToolset
  name: DocsToolset
  file_path: src/google/adk/tools/google_api_tool/google_api_toolsets.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "Auto-generated Docs toolset based on Google Docs API v1 spec exposed by Google API discovery API.\n\nArgs:\n  client_id: OAuth2 client ID for authentication.\n  client_secret: OAuth2 client secret for authentication.\n  tool_filter: Optional filter to include only specific tools or use a predicate function.\n  service_account: Optional service account for authentication.\n  tool_name_prefix: Optional prefix to add to all tool names in this toolset.\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, client_id: typing.Optional[str], client_secret: typing.Optional[str], tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]], service_account: typing.Optional[google.adk.auth.auth_credential.ServiceAccount], tool_name_prefix: typing.Optional[str]):'
  aliases:
  - google.adk.tools.google_api_tool.DocsToolset
  inherited_methods:
    GoogleApiToolset:
    - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> typing.List[google.adk.tools.google_api_tool.google_api_tool.GoogleApiTool]:'
      docstring: Get all tools in the toolset.
    - signature: 'def set_tool_filter(self, tool_filter: typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]):'
    - signature: 'def configure_auth(self, client_id: str, client_secret: str):'
    - signature: 'def configure_sa_auth(self, service_account: google.adk.auth.auth_credential.ServiceAccount):'
    - signature: 'def close(self):'
    BaseToolset:
    - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools in the toolset based on the provided context.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools available under the specified context."
    - signature: 'def get_tools_with_prefix(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools with optional prefix applied to tool names.\n\nThis method calls get_tools() and applies prefixing if tool_name_prefix is provided.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools with prefixed names if tool_name_prefix is provided."
    - signature: 'def close(self) -> None:'
      docstring: "Performs cleanup and releases resources held by the toolset.\n\nNOTE:\n  This method is invoked, for example, at the end of an agent server's\n  lifecycle or when the toolset is no longer needed. Implementations\n  should ensure that any open connections, files, or other managed\n  resources are properly released to prevent leaks."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_toolset.SelfToolset], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_toolset.SelfToolset:'
      docstring: "Creates a toolset instance from a config.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The toolset instance."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this toolset. This method will be\ncalled before each tool processes the llm request.\n\nUse cases:\n- Instead of let each tool process the llm request, we can let the toolset\n  process the llm request. e.g. ComputerUseToolset can add computer use\n  tool to the llm request.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def get_auth_config(self) -> typing.Optional[google.adk.auth.auth_tool.AuthConfig]:'
      docstring: "Returns the auth config for this toolset. ADK will make sure the\n'exchanged_auth_credential' field in the config is populated with\nready-to-use credential (e.g. oauth token for OAuth flow) before calling\nget_tools method or execute any tools returned by this toolset. Thus toolset\ncan use this credential either for tool listing or tool calling. If tool\ncalling needs a different credential from ADK client, call\ntool_context.request_credential in the tool.\n\nToolsets that support authentication should override this method to return\nan AuthConfig constructed from their auth_scheme, auth_credential, and\noptional credential_key parameters.\n\nReturns:\n  AuthConfig if the toolset has authentication configured, None otherwise."
  omitted_inherited_members_from:
  - ABC
- rank: 1633
  id: google.adk.tools.google_api_tool.google_api_toolsets.DocsToolset.__init__
  name: __init__
  file_path: src/google/adk/tools/google_api_tool/google_api_toolsets.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, client_id: typing.Optional[str], client_secret: typing.Optional[str], tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]], service_account: typing.Optional[google.adk.auth.auth_credential.ServiceAccount], tool_name_prefix: typing.Optional[str]):'
- rank: 1634
  id: google.adk.tools.google_api_tool.google_api_toolsets.GmailToolset
  name: GmailToolset
  file_path: src/google/adk/tools/google_api_tool/google_api_toolsets.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "Auto-generated Gmail toolset based on Google Gmail API v1 spec exposed by Google API discovery API.\n\nArgs:\n  client_id: OAuth2 client ID for authentication.\n  client_secret: OAuth2 client secret for authentication.\n  tool_filter: Optional filter to include only specific tools or use a predicate function.\n  service_account: Optional service account for authentication.\n  tool_name_prefix: Optional prefix to add to all tool names in this toolset.\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, client_id: typing.Optional[str], client_secret: typing.Optional[str], tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]], service_account: typing.Optional[google.adk.auth.auth_credential.ServiceAccount], tool_name_prefix: typing.Optional[str]):'
  aliases:
  - google.adk.tools.google_api_tool.GmailToolset
  inherited_methods:
    GoogleApiToolset:
    - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> typing.List[google.adk.tools.google_api_tool.google_api_tool.GoogleApiTool]:'
      docstring: Get all tools in the toolset.
    - signature: 'def set_tool_filter(self, tool_filter: typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]):'
    - signature: 'def configure_auth(self, client_id: str, client_secret: str):'
    - signature: 'def configure_sa_auth(self, service_account: google.adk.auth.auth_credential.ServiceAccount):'
    - signature: 'def close(self):'
    BaseToolset:
    - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools in the toolset based on the provided context.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools available under the specified context."
    - signature: 'def get_tools_with_prefix(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools with optional prefix applied to tool names.\n\nThis method calls get_tools() and applies prefixing if tool_name_prefix is provided.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools with prefixed names if tool_name_prefix is provided."
    - signature: 'def close(self) -> None:'
      docstring: "Performs cleanup and releases resources held by the toolset.\n\nNOTE:\n  This method is invoked, for example, at the end of an agent server's\n  lifecycle or when the toolset is no longer needed. Implementations\n  should ensure that any open connections, files, or other managed\n  resources are properly released to prevent leaks."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_toolset.SelfToolset], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_toolset.SelfToolset:'
      docstring: "Creates a toolset instance from a config.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The toolset instance."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this toolset. This method will be\ncalled before each tool processes the llm request.\n\nUse cases:\n- Instead of let each tool process the llm request, we can let the toolset\n  process the llm request. e.g. ComputerUseToolset can add computer use\n  tool to the llm request.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def get_auth_config(self) -> typing.Optional[google.adk.auth.auth_tool.AuthConfig]:'
      docstring: "Returns the auth config for this toolset. ADK will make sure the\n'exchanged_auth_credential' field in the config is populated with\nready-to-use credential (e.g. oauth token for OAuth flow) before calling\nget_tools method or execute any tools returned by this toolset. Thus toolset\ncan use this credential either for tool listing or tool calling. If tool\ncalling needs a different credential from ADK client, call\ntool_context.request_credential in the tool.\n\nToolsets that support authentication should override this method to return\nan AuthConfig constructed from their auth_scheme, auth_credential, and\noptional credential_key parameters.\n\nReturns:\n  AuthConfig if the toolset has authentication configured, None otherwise."
  omitted_inherited_members_from:
  - ABC
- rank: 1635
  id: google.adk.tools.google_api_tool.google_api_toolsets.GmailToolset.__init__
  name: __init__
  file_path: src/google/adk/tools/google_api_tool/google_api_toolsets.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, client_id: typing.Optional[str], client_secret: typing.Optional[str], tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]], service_account: typing.Optional[google.adk.auth.auth_credential.ServiceAccount], tool_name_prefix: typing.Optional[str]):'
- rank: 1636
  id: google.adk.tools.google_api_tool.google_api_toolsets.SheetsToolset
  name: SheetsToolset
  file_path: src/google/adk/tools/google_api_tool/google_api_toolsets.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "Auto-generated Sheets toolset based on Google Sheets API v4 spec exposed by Google API discovery API.\n\nArgs:\n  client_id: OAuth2 client ID for authentication.\n  client_secret: OAuth2 client secret for authentication.\n  tool_filter: Optional filter to include only specific tools or use a predicate function.\n  service_account: Optional service account for authentication.\n  tool_name_prefix: Optional prefix to add to all tool names in this toolset.\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, client_id: typing.Optional[str], client_secret: typing.Optional[str], tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]], service_account: typing.Optional[google.adk.auth.auth_credential.ServiceAccount], tool_name_prefix: typing.Optional[str]):'
  aliases:
  - google.adk.tools.google_api_tool.SheetsToolset
  inherited_methods:
    GoogleApiToolset:
    - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> typing.List[google.adk.tools.google_api_tool.google_api_tool.GoogleApiTool]:'
      docstring: Get all tools in the toolset.
    - signature: 'def set_tool_filter(self, tool_filter: typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]):'
    - signature: 'def configure_auth(self, client_id: str, client_secret: str):'
    - signature: 'def configure_sa_auth(self, service_account: google.adk.auth.auth_credential.ServiceAccount):'
    - signature: 'def close(self):'
    BaseToolset:
    - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools in the toolset based on the provided context.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools available under the specified context."
    - signature: 'def get_tools_with_prefix(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools with optional prefix applied to tool names.\n\nThis method calls get_tools() and applies prefixing if tool_name_prefix is provided.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools with prefixed names if tool_name_prefix is provided."
    - signature: 'def close(self) -> None:'
      docstring: "Performs cleanup and releases resources held by the toolset.\n\nNOTE:\n  This method is invoked, for example, at the end of an agent server's\n  lifecycle or when the toolset is no longer needed. Implementations\n  should ensure that any open connections, files, or other managed\n  resources are properly released to prevent leaks."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_toolset.SelfToolset], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_toolset.SelfToolset:'
      docstring: "Creates a toolset instance from a config.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The toolset instance."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this toolset. This method will be\ncalled before each tool processes the llm request.\n\nUse cases:\n- Instead of let each tool process the llm request, we can let the toolset\n  process the llm request. e.g. ComputerUseToolset can add computer use\n  tool to the llm request.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def get_auth_config(self) -> typing.Optional[google.adk.auth.auth_tool.AuthConfig]:'
      docstring: "Returns the auth config for this toolset. ADK will make sure the\n'exchanged_auth_credential' field in the config is populated with\nready-to-use credential (e.g. oauth token for OAuth flow) before calling\nget_tools method or execute any tools returned by this toolset. Thus toolset\ncan use this credential either for tool listing or tool calling. If tool\ncalling needs a different credential from ADK client, call\ntool_context.request_credential in the tool.\n\nToolsets that support authentication should override this method to return\nan AuthConfig constructed from their auth_scheme, auth_credential, and\noptional credential_key parameters.\n\nReturns:\n  AuthConfig if the toolset has authentication configured, None otherwise."
  omitted_inherited_members_from:
  - ABC
- rank: 1637
  id: google.adk.tools.google_api_tool.google_api_toolsets.SheetsToolset.__init__
  name: __init__
  file_path: src/google/adk/tools/google_api_tool/google_api_toolsets.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, client_id: typing.Optional[str], client_secret: typing.Optional[str], tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]], service_account: typing.Optional[google.adk.auth.auth_credential.ServiceAccount], tool_name_prefix: typing.Optional[str]):'
- rank: 1638
  id: google.adk.tools.google_api_tool.google_api_toolsets.SlidesToolset
  name: SlidesToolset
  file_path: src/google/adk/tools/google_api_tool/google_api_toolsets.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "Auto-generated Slides toolset based on Google Slides API v1 spec exposed by Google API discovery API.\n\nArgs:\n  client_id: OAuth2 client ID for authentication.\n  client_secret: OAuth2 client secret for authentication.\n  tool_filter: Optional filter to include only specific tools or use a predicate function.\n  service_account: Optional service account for authentication.\n  tool_name_prefix: Optional prefix to add to all tool names in this toolset.\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, client_id: typing.Optional[str], client_secret: typing.Optional[str], tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]], service_account: typing.Optional[google.adk.auth.auth_credential.ServiceAccount], tool_name_prefix: typing.Optional[str]):'
  aliases:
  - google.adk.tools.google_api_tool.SlidesToolset
  inherited_methods:
    GoogleApiToolset:
    - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> typing.List[google.adk.tools.google_api_tool.google_api_tool.GoogleApiTool]:'
      docstring: Get all tools in the toolset.
    - signature: 'def set_tool_filter(self, tool_filter: typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]):'
    - signature: 'def configure_auth(self, client_id: str, client_secret: str):'
    - signature: 'def configure_sa_auth(self, service_account: google.adk.auth.auth_credential.ServiceAccount):'
    - signature: 'def close(self):'
    BaseToolset:
    - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools in the toolset based on the provided context.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools available under the specified context."
    - signature: 'def get_tools_with_prefix(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools with optional prefix applied to tool names.\n\nThis method calls get_tools() and applies prefixing if tool_name_prefix is provided.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools with prefixed names if tool_name_prefix is provided."
    - signature: 'def close(self) -> None:'
      docstring: "Performs cleanup and releases resources held by the toolset.\n\nNOTE:\n  This method is invoked, for example, at the end of an agent server's\n  lifecycle or when the toolset is no longer needed. Implementations\n  should ensure that any open connections, files, or other managed\n  resources are properly released to prevent leaks."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_toolset.SelfToolset], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_toolset.SelfToolset:'
      docstring: "Creates a toolset instance from a config.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The toolset instance."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this toolset. This method will be\ncalled before each tool processes the llm request.\n\nUse cases:\n- Instead of let each tool process the llm request, we can let the toolset\n  process the llm request. e.g. ComputerUseToolset can add computer use\n  tool to the llm request.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def get_auth_config(self) -> typing.Optional[google.adk.auth.auth_tool.AuthConfig]:'
      docstring: "Returns the auth config for this toolset. ADK will make sure the\n'exchanged_auth_credential' field in the config is populated with\nready-to-use credential (e.g. oauth token for OAuth flow) before calling\nget_tools method or execute any tools returned by this toolset. Thus toolset\ncan use this credential either for tool listing or tool calling. If tool\ncalling needs a different credential from ADK client, call\ntool_context.request_credential in the tool.\n\nToolsets that support authentication should override this method to return\nan AuthConfig constructed from their auth_scheme, auth_credential, and\noptional credential_key parameters.\n\nReturns:\n  AuthConfig if the toolset has authentication configured, None otherwise."
  omitted_inherited_members_from:
  - ABC
- rank: 1639
  id: google.adk.tools.google_api_tool.google_api_toolsets.SlidesToolset.__init__
  name: __init__
  file_path: src/google/adk/tools/google_api_tool/google_api_toolsets.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, client_id: typing.Optional[str], client_secret: typing.Optional[str], tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]], service_account: typing.Optional[google.adk.auth.auth_credential.ServiceAccount], tool_name_prefix: typing.Optional[str]):'
- rank: 1640
  id: google.adk.tools.google_api_tool.google_api_toolsets.YoutubeToolset
  name: YoutubeToolset
  file_path: src/google/adk/tools/google_api_tool/google_api_toolsets.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "Auto-generated YouTube toolset based on YouTube API v3 spec exposed by Google API discovery API.\n\nArgs:\n  client_id: OAuth2 client ID for authentication.\n  client_secret: OAuth2 client secret for authentication.\n  tool_filter: Optional filter to include only specific tools or use a predicate function.\n  service_account: Optional service account for authentication.\n  tool_name_prefix: Optional prefix to add to all tool names in this toolset.\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, client_id: typing.Optional[str], client_secret: typing.Optional[str], tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]], service_account: typing.Optional[google.adk.auth.auth_credential.ServiceAccount], tool_name_prefix: typing.Optional[str]):'
  aliases:
  - google.adk.tools.google_api_tool.YoutubeToolset
  inherited_methods:
    GoogleApiToolset:
    - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> typing.List[google.adk.tools.google_api_tool.google_api_tool.GoogleApiTool]:'
      docstring: Get all tools in the toolset.
    - signature: 'def set_tool_filter(self, tool_filter: typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]):'
    - signature: 'def configure_auth(self, client_id: str, client_secret: str):'
    - signature: 'def configure_sa_auth(self, service_account: google.adk.auth.auth_credential.ServiceAccount):'
    - signature: 'def close(self):'
    BaseToolset:
    - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools in the toolset based on the provided context.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools available under the specified context."
    - signature: 'def get_tools_with_prefix(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools with optional prefix applied to tool names.\n\nThis method calls get_tools() and applies prefixing if tool_name_prefix is provided.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools with prefixed names if tool_name_prefix is provided."
    - signature: 'def close(self) -> None:'
      docstring: "Performs cleanup and releases resources held by the toolset.\n\nNOTE:\n  This method is invoked, for example, at the end of an agent server's\n  lifecycle or when the toolset is no longer needed. Implementations\n  should ensure that any open connections, files, or other managed\n  resources are properly released to prevent leaks."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_toolset.SelfToolset], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_toolset.SelfToolset:'
      docstring: "Creates a toolset instance from a config.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The toolset instance."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this toolset. This method will be\ncalled before each tool processes the llm request.\n\nUse cases:\n- Instead of let each tool process the llm request, we can let the toolset\n  process the llm request. e.g. ComputerUseToolset can add computer use\n  tool to the llm request.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def get_auth_config(self) -> typing.Optional[google.adk.auth.auth_tool.AuthConfig]:'
      docstring: "Returns the auth config for this toolset. ADK will make sure the\n'exchanged_auth_credential' field in the config is populated with\nready-to-use credential (e.g. oauth token for OAuth flow) before calling\nget_tools method or execute any tools returned by this toolset. Thus toolset\ncan use this credential either for tool listing or tool calling. If tool\ncalling needs a different credential from ADK client, call\ntool_context.request_credential in the tool.\n\nToolsets that support authentication should override this method to return\nan AuthConfig constructed from their auth_scheme, auth_credential, and\noptional credential_key parameters.\n\nReturns:\n  AuthConfig if the toolset has authentication configured, None otherwise."
  omitted_inherited_members_from:
  - ABC
- rank: 1641
  id: google.adk.tools.google_api_tool.google_api_toolsets.YoutubeToolset.__init__
  name: __init__
  file_path: src/google/adk/tools/google_api_tool/google_api_toolsets.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, client_id: typing.Optional[str], client_secret: typing.Optional[str], tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]], service_account: typing.Optional[google.adk.auth.auth_credential.ServiceAccount], tool_name_prefix: typing.Optional[str]):'
- rank: 1642
  id: google.adk.tools.google_api_tool.googleapi_to_openapi_converter
  name: googleapi_to_openapi_converter
  file_path: src/google/adk/tools/google_api_tool/googleapi_to_openapi_converter.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def main():'
    docstring: Command line interface for the converter.
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 1643
  id: google.adk.tools.google_api_tool.googleapi_to_openapi_converter.GoogleApiToOpenApiConverter
  name: GoogleApiToOpenApiConverter
  file_path: src/google/adk/tools/google_api_tool/googleapi_to_openapi_converter.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Converts Google API Discovery documents to OpenAPI v3 format.
  constructor_signature: 'def __init__(self, api_name: str, api_version: str):'
  methods:
  - signature: 'def fetch_google_api_spec(self) -> None:'
    docstring: Fetches the Google API specification using discovery service.
  - signature: 'def convert(self) -> typing.Dict[str, typing.Any]:'
    docstring: "Convert the Google API spec to OpenAPI v3 format.\n\nReturns:\n    Dict containing the converted OpenAPI v3 specification"
  - signature: 'def save_openapi_spec(self, output_path: str) -> None:'
    docstring: "Save the OpenAPI specification to a file.\n\nArgs:\n    output_path: Path where the OpenAPI spec should be saved"
- rank: 1644
  id: google.adk.tools.google_api_tool.googleapi_to_openapi_converter.GoogleApiToOpenApiConverter.__init__
  name: __init__
  file_path: src/google/adk/tools/google_api_tool/googleapi_to_openapi_converter.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initialize the converter with the API name and version.\n\nArgs:\n    api_name: The name of the Google API (e.g., \"calendar\")\n    api_version: The version of the API (e.g., \"v3\")"
  signature: 'def __init__(self, api_name: str, api_version: str):'
- rank: 1645
  id: google.adk.tools.google_api_tool.googleapi_to_openapi_converter.GoogleApiToOpenApiConverter.convert
  name: convert
  file_path: src/google/adk/tools/google_api_tool/googleapi_to_openapi_converter.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Convert the Google API spec to OpenAPI v3 format.\n\nReturns:\n    Dict containing the converted OpenAPI v3 specification"
  signature: 'def convert(self) -> typing.Dict[str, typing.Any]:'
- rank: 1646
  id: google.adk.tools.google_api_tool.googleapi_to_openapi_converter.GoogleApiToOpenApiConverter.fetch_google_api_spec
  name: fetch_google_api_spec
  file_path: src/google/adk/tools/google_api_tool/googleapi_to_openapi_converter.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Fetches the Google API specification using discovery service.
  signature: 'def fetch_google_api_spec(self) -> None:'
- rank: 1647
  id: google.adk.tools.google_api_tool.googleapi_to_openapi_converter.GoogleApiToOpenApiConverter.save_openapi_spec
  name: save_openapi_spec
  file_path: src/google/adk/tools/google_api_tool/googleapi_to_openapi_converter.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Save the OpenAPI specification to a file.\n\nArgs:\n    output_path: Path where the OpenAPI spec should be saved"
  signature: 'def save_openapi_spec(self, output_path: str) -> None:'
- rank: 1648
  id: google.adk.tools.google_api_tool.googleapi_to_openapi_converter.main
  name: main
  file_path: src/google/adk/tools/google_api_tool/googleapi_to_openapi_converter.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Command line interface for the converter.
  signature: 'def main():'
- rank: 1649
  id: google.adk.tools.google_maps_grounding_tool
  name: google_maps_grounding_tool
  file_path: src/google/adk/tools/google_maps_grounding_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'google_maps_grounding: GoogleMapsGroundingTool'
- rank: 1650
  id: google.adk.tools.google_maps_grounding_tool.GoogleMapsGroundingTool
  name: GoogleMapsGroundingTool
  file_path: src/google/adk/tools/google_maps_grounding_tool.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A built-in tool that is automatically invoked by Gemini 2 models to ground query results with Google Maps.


    This tool operates internally within the model and does not require or perform

    local code execution.


    Only available for use with the VertexAI Gemini API (e.g.

    GOOGLE_GENAI_USE_VERTEXAI=TRUE)


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self):'
  methods:
  - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.LlmRequest) -> None:'
  inherited_methods:
    BaseTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
      docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
      docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  inherited_properties:
    BaseTool:
    - signature: 'name: str'
      docstring: The name of the tool.
    - signature: 'description: str'
      docstring: The description of the tool.
    - signature: 'is_long_running: bool'
      docstring: 'Whether the tool is a long running operation, which typically returns a

        resource id first and finishes the operation later.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the BaseTool.


        An optional key-value pair for storing and retrieving tool-specific metadata,

        such as tool manifests, etc.


        NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 1651
  id: google.adk.tools.google_maps_grounding_tool.GoogleMapsGroundingTool.process_llm_request
  name: process_llm_request
  file_path: src/google/adk/tools/google_maps_grounding_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.LlmRequest) -> None:'
- rank: 1652
  id: google.adk.tools.google_search_agent_tool
  name: google_search_agent_tool
  file_path: src/google/adk/tools/google_search_agent_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def create_google_search_agent(model: typing.Union[str, google.adk.models.base_llm.BaseLlm]) -> google.adk.agents.llm_agent.LlmAgent:'
    docstring: Create a sub-agent that only uses google_search tool.
- rank: 1653
  id: google.adk.tools.google_search_agent_tool.GoogleSearchAgentTool
  name: GoogleSearchAgentTool
  file_path: src/google/adk/tools/google_search_agent_tool.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "A tool that wraps a sub-agent that only uses google_search tool.\n\nThis is a workaround to support using google_search tool with other tools.\nTODO(b/448114567): Remove once the workaround is no longer needed.\n\nAttributes:\n  model: The model to use for the sub-agent.\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, agent: google.adk.agents.llm_agent.LlmAgent):'
  methods:
  - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
  inherited_methods:
    AgentTool:
    - signature: 'def populate_name(cls, data: typing.Any) -> typing.Any:'
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
    - signature: 'def from_config(cls, config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.agent_tool.AgentTool:'
    BaseTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
      docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
      docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  inherited_properties:
    BaseTool:
    - signature: 'name: str'
      docstring: The name of the tool.
    - signature: 'description: str'
      docstring: The description of the tool.
    - signature: 'is_long_running: bool'
      docstring: 'Whether the tool is a long running operation, which typically returns a

        resource id first and finishes the operation later.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the BaseTool.


        An optional key-value pair for storing and retrieving tool-specific metadata,

        such as tool manifests, etc.


        NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 1654
  id: google.adk.tools.google_search_agent_tool.GoogleSearchAgentTool.run_async
  name: run_async
  file_path: src/google/adk/tools/google_search_agent_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
- rank: 1655
  id: google.adk.tools.google_search_agent_tool.create_google_search_agent
  name: create_google_search_agent
  file_path: src/google/adk/tools/google_search_agent_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Create a sub-agent that only uses google_search tool.
  signature: 'def create_google_search_agent(model: typing.Union[str, google.adk.models.base_llm.BaseLlm]) -> google.adk.agents.llm_agent.LlmAgent:'
- rank: 1656
  id: google.adk.tools.google_search_tool
  name: google_search_tool
  file_path: src/google/adk/tools/google_search_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'google_search: GoogleSearchTool'
- rank: 1657
  id: google.adk.tools.google_search_tool.GoogleSearchTool.__init__
  name: __init__
  file_path: src/google/adk/tools/google_search_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the Google search tool.\n\nArgs:\n  bypass_multi_tools_limit: Whether to bypass the multi tools limitation,\n    so that the tool can be used with other tools in the same agent.\n  model: Optional model name to use for processing the LLM request. If\n    provided, this model will be used instead of the model from the\n    incoming llm_request."
  signature: 'def __init__(self, *, bypass_multi_tools_limit: bool=False, model: str | None=None):'
- rank: 1658
  id: google.adk.tools.google_search_tool.GoogleSearchTool.process_llm_request
  name: process_llm_request
  file_path: src/google/adk/tools/google_search_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.LlmRequest) -> None:'
- rank: 1659
  id: google.adk.tools.google_tool
  name: google_tool
  file_path: src/google/adk/tools/google_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1660
  id: google.adk.tools.google_tool.GoogleTool
  name: GoogleTool
  file_path: src/google/adk/tools/google_tool.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'GoogleTool class for tools that call Google APIs.


    This class is for developers to handcraft customized Google API tools rather

    than auto generate Google API tools based on API specs.


    This class handles all the OAuth complexity, credential management,

    and common Google API patterns so subclasses can focus on their

    specific functionality.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, func: typing.Callable[Ellipsis, typing.Any], *, credentials_config: typing.Optional[google.adk.tools._google_credentials.BaseGoogleCredentialsConfig]=None, tool_settings: typing.Optional[pydantic.BaseModel]=None):'
  methods:
  - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
    docstring: 'Main entry point for tool execution with credential handling.


      This method handles all the OAuth complexity and then delegates

      to the subclass''s run_async_with_credential method.'
  inherited_methods:
    FunctionTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
    BaseTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
      docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
      docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  inherited_properties:
    BaseTool:
    - signature: 'name: str'
      docstring: The name of the tool.
    - signature: 'description: str'
      docstring: The description of the tool.
    - signature: 'is_long_running: bool'
      docstring: 'Whether the tool is a long running operation, which typically returns a

        resource id first and finishes the operation later.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the BaseTool.


        An optional key-value pair for storing and retrieving tool-specific metadata,

        such as tool manifests, etc.


        NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 1661
  id: google.adk.tools.google_tool.GoogleTool.__init__
  name: __init__
  file_path: src/google/adk/tools/google_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initialize the Google API tool.\n\nArgs:\n    func: callable that implements the tool's logic, can accept one\n      'credential\" parameter\n    credentials_config: credentials config used to call Google API. If None,\n      then we don't handle the auth logic\n    tool_settings: Tool-specific settings. This settings should be provided\n      by each toolset that uses this class to create customized tools."
  signature: 'def __init__(self, func: typing.Callable[Ellipsis, typing.Any], *, credentials_config: typing.Optional[google.adk.tools._google_credentials.BaseGoogleCredentialsConfig]=None, tool_settings: typing.Optional[pydantic.BaseModel]=None):'
- rank: 1662
  id: google.adk.tools.google_tool.GoogleTool.run_async
  name: run_async
  file_path: src/google/adk/tools/google_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Main entry point for tool execution with credential handling.


    This method handles all the OAuth complexity and then delegates

    to the subclass''s run_async_with_credential method.'
  signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
- rank: 1663
  id: google.adk.tools.langchain_tool
  name: langchain_tool
  file_path: src/google/adk/tools/langchain_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1664
  id: google.adk.tools.langchain_tool.LangchainTool.__init__
  name: __init__
  file_path: src/google/adk/tools/langchain_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, tool: typing.Union[langchain_core.tools.BaseTool, object], name: typing.Optional[str], description: typing.Optional[str]):'
- rank: 1665
  id: google.adk.tools.langchain_tool.LangchainTool.from_config
  name: from_config
  file_path: src/google/adk/tools/langchain_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def from_config(cls: type[google.adk.tools.langchain_tool.LangchainTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.langchain_tool.LangchainTool:'
- rank: 1666
  id: google.adk.tools.langchain_tool.LangchainToolConfig
  name: LangchainToolConfig
  file_path: src/google/adk/tools/langchain_tool.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, tool: str, name: str = '''', description: str = ''''):'
  properties:
  - signature: 'tool: str'
    docstring: The fully qualified path of the Langchain tool instance.
  - signature: 'name: str'
    docstring: The name of the tool.
  - signature: 'description: str'
    docstring: The description of the tool.
  inherited_properties:
    BaseToolConfig:
    - signature: 'model_config: pydantic.ConfigDict'
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1667
  id: google.adk.tools.load_artifacts_tool
  name: load_artifacts_tool
  file_path: src/google/adk/tools/load_artifacts_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: '_GEMINI_SUPPORTED_INLINE_MIME_PREFIXES: Any'
  - signature: '_GEMINI_SUPPORTED_INLINE_MIME_TYPES: frozenset'
  - signature: '_TEXT_LIKE_MIME_TYPES: frozenset'
  - signature: 'logger: logging.getLogger'
  - signature: 'load_artifacts_tool: LoadArtifactsTool'
- rank: 1668
  id: google.adk.tools.load_artifacts_tool.LoadArtifactsTool
  name: LoadArtifactsTool
  file_path: src/google/adk/tools/load_artifacts_tool.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A tool that loads the artifacts and adds them to the session.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self):'
  methods:
  - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
  - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
  inherited_methods:
    BaseTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
      docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
      docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  inherited_properties:
    BaseTool:
    - signature: 'name: str'
      docstring: The name of the tool.
    - signature: 'description: str'
      docstring: The description of the tool.
    - signature: 'is_long_running: bool'
      docstring: 'Whether the tool is a long running operation, which typically returns a

        resource id first and finishes the operation later.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the BaseTool.


        An optional key-value pair for storing and retrieving tool-specific metadata,

        such as tool manifests, etc.


        NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 1669
  id: google.adk.tools.load_artifacts_tool.LoadArtifactsTool.__init__
  name: __init__
  file_path: src/google/adk/tools/load_artifacts_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self):'
- rank: 1670
  id: google.adk.tools.load_artifacts_tool.LoadArtifactsTool.process_llm_request
  name: process_llm_request
  file_path: src/google/adk/tools/load_artifacts_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
- rank: 1671
  id: google.adk.tools.load_artifacts_tool.LoadArtifactsTool.run_async
  name: run_async
  file_path: src/google/adk/tools/load_artifacts_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
- rank: 1672
  id: google.adk.tools.load_memory_tool
  name: load_memory_tool
  file_path: src/google/adk/tools/load_memory_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def load_memory(query: str, tool_context: google.adk.tools.tool_context.ToolContext) -> google.adk.tools.load_memory_tool.LoadMemoryResponse:'
    docstring: "Loads the memory for the current user.\n\nArgs:\n  query: The query to load the memory for.\n\nReturns:\n  A list of memory results."
  properties:
  - signature: 'load_memory_tool: LoadMemoryTool'
- rank: 1673
  id: google.adk.tools.load_memory_tool.LoadMemoryResponse
  name: LoadMemoryResponse
  file_path: src/google/adk/tools/load_memory_tool.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, memories: list[google.adk.memory.memory_entry.MemoryEntry] = list()):'
  properties:
  - signature: 'memories: list[google.adk.memory.memory_entry.MemoryEntry]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1674
  id: google.adk.tools.load_memory_tool.LoadMemoryTool
  name: LoadMemoryTool
  file_path: src/google/adk/tools/load_memory_tool.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A tool that loads the memory for the current user.


    NOTE: Currently this tool only uses text part from the memory.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self):'
  methods:
  - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.LlmRequest) -> None:'
  inherited_methods:
    FunctionTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
    BaseTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
      docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
      docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  inherited_properties:
    BaseTool:
    - signature: 'name: str'
      docstring: The name of the tool.
    - signature: 'description: str'
      docstring: The description of the tool.
    - signature: 'is_long_running: bool'
      docstring: 'Whether the tool is a long running operation, which typically returns a

        resource id first and finishes the operation later.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the BaseTool.


        An optional key-value pair for storing and retrieving tool-specific metadata,

        such as tool manifests, etc.


        NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 1675
  id: google.adk.tools.load_memory_tool.LoadMemoryTool.process_llm_request
  name: process_llm_request
  file_path: src/google/adk/tools/load_memory_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.LlmRequest) -> None:'
- rank: 1676
  id: google.adk.tools.load_memory_tool.load_memory
  name: load_memory
  file_path: src/google/adk/tools/load_memory_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Loads the memory for the current user.\n\nArgs:\n  query: The query to load the memory for.\n\nReturns:\n  A list of memory results."
  signature: 'def load_memory(query: str, tool_context: google.adk.tools.tool_context.ToolContext) -> google.adk.tools.load_memory_tool.LoadMemoryResponse:'
- rank: 1677
  id: google.adk.tools.load_web_page
  name: load_web_page
  file_path: src/google/adk/tools/load_web_page.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def load_web_page(url: str) -> str:'
    docstring: "Fetches the content in the url and returns the text in it.\n\nArgs:\n    url (str): The url to browse.\n\nReturns:\n    str: The text content of the url."
- rank: 1678
  id: google.adk.tools.load_web_page.load_web_page
  name: load_web_page
  file_path: src/google/adk/tools/load_web_page.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Fetches the content in the url and returns the text in it.\n\nArgs:\n    url (str): The url to browse.\n\nReturns:\n    str: The text content of the url."
  signature: 'def load_web_page(url: str) -> str:'
- rank: 1679
  id: google.adk.tools.long_running_tool
  name: long_running_tool
  file_path: src/google/adk/tools/long_running_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1680
  id: google.adk.tools.mcp_tool
  name: mcp_tool
  file_path: src/google/adk/tools/mcp_tool/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: '__all__: Any'
  - signature: 'logger: logging.getLogger'
- rank: 1681
  id: google.adk.tools.mcp_tool.conversion_utils
  name: conversion_utils
  file_path: src/google/adk/tools/mcp_tool/conversion_utils.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def adk_to_mcp_tool_type(tool: google.adk.tools.base_tool.BaseTool) -> mcp.types.Tool:'
    docstring: "Convert a Tool in ADK into MCP tool type.\n\nThis function transforms an ADK tool definition into its equivalent\nrepresentation in the MCP (Model Context Protocol) system.\n\nArgs:\n    tool: The ADK tool to convert. It should be an instance of a class derived\n      from `BaseTool`.\n\nReturns:\n    An object of MCP Tool type, representing the converted tool.\n\nExamples:\n    # Assuming 'my_tool' is an instance of a BaseTool derived class\n    mcp_tool = adk_to_mcp_tool_type(my_tool)\n    print(mcp_tool)"
  - signature: 'def gemini_to_json_schema(gemini_schema: google.genai.types.Schema) -> typing.Dict[str, typing.Any]:'
    docstring: "Converts a Gemini Schema object into a JSON Schema dictionary.\n\nArgs:\n    gemini_schema: An instance of the Gemini Schema class.\n\nReturns:\n    A dictionary representing the equivalent JSON Schema.\n\nRaises:\n    TypeError: If the input is not an instance of the expected Schema class.\n    ValueError: If an invalid Gemini Type enum value is encountered."
- rank: 1682
  id: google.adk.tools.mcp_tool.conversion_utils.adk_to_mcp_tool_type
  name: adk_to_mcp_tool_type
  file_path: src/google/adk/tools/mcp_tool/conversion_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Convert a Tool in ADK into MCP tool type.\n\nThis function transforms an ADK tool definition into its equivalent\nrepresentation in the MCP (Model Context Protocol) system.\n\nArgs:\n    tool: The ADK tool to convert. It should be an instance of a class derived\n      from `BaseTool`.\n\nReturns:\n    An object of MCP Tool type, representing the converted tool.\n\nExamples:\n    # Assuming 'my_tool' is an instance of a BaseTool derived class\n    mcp_tool = adk_to_mcp_tool_type(my_tool)\n    print(mcp_tool)"
  signature: 'def adk_to_mcp_tool_type(tool: google.adk.tools.base_tool.BaseTool) -> mcp.types.Tool:'
- rank: 1683
  id: google.adk.tools.mcp_tool.conversion_utils.gemini_to_json_schema
  name: gemini_to_json_schema
  file_path: src/google/adk/tools/mcp_tool/conversion_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Converts a Gemini Schema object into a JSON Schema dictionary.\n\nArgs:\n    gemini_schema: An instance of the Gemini Schema class.\n\nReturns:\n    A dictionary representing the equivalent JSON Schema.\n\nRaises:\n    TypeError: If the input is not an instance of the expected Schema class.\n    ValueError: If an invalid Gemini Type enum value is encountered."
  signature: 'def gemini_to_json_schema(gemini_schema: google.genai.types.Schema) -> typing.Dict[str, typing.Any]:'
- rank: 1684
  id: google.adk.tools.mcp_tool.mcp_session_manager
  name: mcp_session_manager
  file_path: src/google/adk/tools/mcp_tool/mcp_session_manager.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def retry_on_errors(func):'
    docstring: "Decorator to automatically retry action when MCP session errors occur.\n\nWhen MCP session errors occur, the decorator will automatically retry the\naction once. The create_session method will handle creating a new session\nif the old one was disconnected.\n\nCancellation is not retried and must be allowed to propagate. In async\nruntimes, cancellation may surface as `asyncio.CancelledError` or as another\nexception while the task is cancelling.\n\nArgs:\n    func: The function to decorate.\n\nReturns:\n    The decorated function."
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: 'SseServerParams: Any'
  - signature: 'StreamableHTTPServerParams: Any'
- rank: 1685
  id: google.adk.tools.mcp_tool.mcp_session_manager.CheckableMcpHttpClientFactory
  name: CheckableMcpHttpClientFactory
  file_path: src/google/adk/tools/mcp_tool/mcp_session_manager.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from McpHttpClientFactory, Protocol are omitted.]'
  omitted_inherited_members_from:
  - Protocol
  - McpHttpClientFactory
- rank: 1686
  id: google.adk.tools.mcp_tool.mcp_session_manager.MCPSessionManager
  name: MCPSessionManager
  file_path: src/google/adk/tools/mcp_tool/mcp_session_manager.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Manages MCP client sessions.


    This class provides methods for creating and initializing MCP client sessions,

    handling different connection parameters (Stdio and SSE) and supporting

    session pooling based on authentication headers.'
  constructor_signature: 'def __init__(self, connection_params: typing.Union[mcp.StdioServerParameters, google.adk.tools.mcp_tool.mcp_session_manager.StdioConnectionParams, google.adk.tools.mcp_tool.mcp_session_manager.SseConnectionParams, google.adk.tools.mcp_tool.mcp_session_manager.StreamableHTTPConnectionParams], errlog: typing.TextIO):'
  methods:
  - signature: 'def create_session(self, headers: typing.Optional[typing.Dict[str, str]]) -> mcp.ClientSession:'
    docstring: "Creates and initializes an MCP client session.\n\nThis method will check if an existing session for the given headers\nis still connected. If it's disconnected, it will be cleaned up and\na new session will be created.\n\nArgs:\n    headers: Optional headers to include in the session. These will be\n            merged with any existing connection headers. Only applicable\n            for SSE and StreamableHTTP connections.\n\nReturns:\n    ClientSession: The initialized MCP client session."
  - signature: 'def close(self):'
    docstring: Closes all sessions and cleans up resources.
- rank: 1687
  id: google.adk.tools.mcp_tool.mcp_session_manager.MCPSessionManager.__init__
  name: __init__
  file_path: src/google/adk/tools/mcp_tool/mcp_session_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the MCP session manager.\n\nArgs:\n    connection_params: Parameters for the MCP connection (Stdio, SSE or\n      Streamable HTTP). Stdio by default also has a 5s read timeout as other\n      parameters but it's not configurable for now.\n    errlog: (Optional) TextIO stream for error logging. Use only for\n      initializing a local stdio MCP session."
  signature: 'def __init__(self, connection_params: typing.Union[mcp.StdioServerParameters, google.adk.tools.mcp_tool.mcp_session_manager.StdioConnectionParams, google.adk.tools.mcp_tool.mcp_session_manager.SseConnectionParams, google.adk.tools.mcp_tool.mcp_session_manager.StreamableHTTPConnectionParams], errlog: typing.TextIO):'
- rank: 1688
  id: google.adk.tools.mcp_tool.mcp_session_manager.MCPSessionManager.close
  name: close
  file_path: src/google/adk/tools/mcp_tool/mcp_session_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Closes all sessions and cleans up resources.
  signature: 'def close(self):'
- rank: 1689
  id: google.adk.tools.mcp_tool.mcp_session_manager.MCPSessionManager.create_session
  name: create_session
  file_path: src/google/adk/tools/mcp_tool/mcp_session_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Creates and initializes an MCP client session.\n\nThis method will check if an existing session for the given headers\nis still connected. If it's disconnected, it will be cleaned up and\na new session will be created.\n\nArgs:\n    headers: Optional headers to include in the session. These will be\n            merged with any existing connection headers. Only applicable\n            for SSE and StreamableHTTP connections.\n\nReturns:\n    ClientSession: The initialized MCP client session."
  signature: 'def create_session(self, headers: typing.Optional[typing.Dict[str, str]]) -> mcp.ClientSession:'
- rank: 1690
  id: google.adk.tools.mcp_tool.mcp_session_manager.retry_on_errors
  name: retry_on_errors
  file_path: src/google/adk/tools/mcp_tool/mcp_session_manager.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Decorator to automatically retry action when MCP session errors occur.\n\nWhen MCP session errors occur, the decorator will automatically retry the\naction once. The create_session method will handle creating a new session\nif the old one was disconnected.\n\nCancellation is not retried and must be allowed to propagate. In async\nruntimes, cancellation may surface as `asyncio.CancelledError` or as another\nexception while the task is cancelling.\n\nArgs:\n    func: The function to decorate.\n\nReturns:\n    The decorated function."
  signature: 'def retry_on_errors(func):'
- rank: 1691
  id: google.adk.tools.mcp_tool.mcp_tool
  name: mcp_tool
  file_path: src/google/adk/tools/mcp_tool/mcp_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 1692
  id: google.adk.tools.mcp_tool.mcp_tool.MCPTool
  name: MCPTool
  file_path: src/google/adk/tools/mcp_tool/mcp_tool.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Deprecated name, use `McpTool` instead.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self):'
  inherited_methods:
    McpTool:
    - signature: 'def raw_mcp_tool(self) -> mcp.types.Tool:'
      docstring: Returns the raw MCP tool.
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
    - signature: 'def _run_async_impl(self, *, args, tool_context: google.adk.tools.tool_context.ToolContext, credential: google.adk.auth.auth_credential.AuthCredential) -> typing.Dict[str, typing.Any]:'
      docstring: "Runs the tool asynchronously.\n\nArgs:\n    args: The arguments as a dict to pass to the tool.\n    tool_context: The tool context of the current invocation.\n\nReturns:\n    Any: The response from the tool."
    BaseAuthenticatedTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
    - signature: 'def _run_async_impl(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, credential: google.adk.auth.auth_credential.AuthCredential) -> typing.Any:'
    BaseTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
      docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
      docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  inherited_properties:
    BaseTool:
    - signature: 'name: str'
      docstring: The name of the tool.
    - signature: 'description: str'
      docstring: The description of the tool.
    - signature: 'is_long_running: bool'
      docstring: 'Whether the tool is a long running operation, which typically returns a

        resource id first and finishes the operation later.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the BaseTool.


        An optional key-value pair for storing and retrieving tool-specific metadata,

        such as tool manifests, etc.


        NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 1693
  id: google.adk.tools.mcp_tool.mcp_tool.MCPTool.__init__
  name: __init__
  file_path: src/google/adk/tools/mcp_tool/mcp_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self):'
- rank: 1694
  id: google.adk.tools.mcp_tool.mcp_tool.McpTool
  name: McpTool
  file_path: src/google/adk/tools/mcp_tool/mcp_tool.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Turns an MCP Tool into an ADK Tool.


    Internally, the tool initializes from a MCP Tool, and uses the MCP Session to

    call the tool.


    Note: For API key authentication, only header-based API keys are supported.

    Query and cookie-based API keys will result in authentication errors.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, *, mcp_tool: mcp.types.Tool, mcp_session_manager: google.adk.tools.mcp_tool.mcp_session_manager.MCPSessionManager, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme]=None, auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]=None, require_confirmation: typing.Union[bool, typing.Callable[Ellipsis, bool]]=False, header_provider: typing.Optional[typing.Callable[[ReadonlyContext], typing.Dict[str, str]]]=None, progress_callback: typing.Optional[typing.Union[mcp.shared.session.ProgressFnT, google.adk.tools.mcp_tool.mcp_tool.ProgressCallbackFactory]]=None):'
  methods:
  - signature: 'def raw_mcp_tool(self) -> mcp.types.Tool:'
    docstring: Returns the raw MCP tool.
  - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
  - signature: 'def _run_async_impl(self, *, args, tool_context: google.adk.tools.tool_context.ToolContext, credential: google.adk.auth.auth_credential.AuthCredential) -> typing.Dict[str, typing.Any]:'
    docstring: "Runs the tool asynchronously.\n\nArgs:\n    args: The arguments as a dict to pass to the tool.\n    tool_context: The tool context of the current invocation.\n\nReturns:\n    Any: The response from the tool."
  inherited_methods:
    BaseAuthenticatedTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
    - signature: 'def _run_async_impl(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext, credential: google.adk.auth.auth_credential.AuthCredential) -> typing.Any:'
    BaseTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
      docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
      docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  inherited_properties:
    BaseTool:
    - signature: 'name: str'
      docstring: The name of the tool.
    - signature: 'description: str'
      docstring: The description of the tool.
    - signature: 'is_long_running: bool'
      docstring: 'Whether the tool is a long running operation, which typically returns a

        resource id first and finishes the operation later.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the BaseTool.


        An optional key-value pair for storing and retrieving tool-specific metadata,

        such as tool manifests, etc.


        NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 1695
  id: google.adk.tools.mcp_tool.mcp_tool.McpTool.__init__
  name: __init__
  file_path: src/google/adk/tools/mcp_tool/mcp_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes an McpTool.\n\nThis tool wraps an MCP Tool interface and uses a session manager to\ncommunicate with the MCP server.\n\nArgs:\n    mcp_tool: The MCP tool to wrap.\n    mcp_session_manager: The MCP session manager to use for communication.\n    auth_scheme: The authentication scheme to use.\n    auth_credential: The authentication credential to use.\n    require_confirmation: Whether this tool requires confirmation. A boolean\n      or a callable that takes the function's arguments and returns a\n      boolean. If the callable returns True, the tool will require\n      confirmation from the user.\n    header_provider: Optional function to provide dynamic headers.\n    progress_callback: Optional callback to receive progress notifications\n      from MCP server during long-running tool execution. Can be either:\n\n      - A ``ProgressFnT`` callback that receives (progress, total, message).\n        This callback will be used for all invocations.\n\n      - A ``ProgressCallbackFactory``\
    \ that creates per-invocation callbacks.\n        The factory receives (tool_name, callback_context, **kwargs) and\n        returns a ProgressFnT or None. This allows callbacks to access\n        and modify runtime context like session state.\n\nRaises:\n    ValueError: If mcp_tool or mcp_session_manager is None."
  signature: 'def __init__(self, *, mcp_tool: mcp.types.Tool, mcp_session_manager: google.adk.tools.mcp_tool.mcp_session_manager.MCPSessionManager, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme]=None, auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]=None, require_confirmation: typing.Union[bool, typing.Callable[Ellipsis, bool]]=False, header_provider: typing.Optional[typing.Callable[[ReadonlyContext], typing.Dict[str, str]]]=None, progress_callback: typing.Optional[typing.Union[mcp.shared.session.ProgressFnT, google.adk.tools.mcp_tool.mcp_tool.ProgressCallbackFactory]]=None):'
- rank: 1696
  id: google.adk.tools.mcp_tool.mcp_tool.McpTool._run_async_impl
  name: _run_async_impl
  file_path: src/google/adk/tools/mcp_tool/mcp_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Runs the tool asynchronously.\n\nArgs:\n    args: The arguments as a dict to pass to the tool.\n    tool_context: The tool context of the current invocation.\n\nReturns:\n    Any: The response from the tool."
  signature: 'def _run_async_impl(self, *, args, tool_context: google.adk.tools.tool_context.ToolContext, credential: google.adk.auth.auth_credential.AuthCredential) -> typing.Dict[str, typing.Any]:'
- rank: 1697
  id: google.adk.tools.mcp_tool.mcp_tool.McpTool.run_async
  name: run_async
  file_path: src/google/adk/tools/mcp_tool/mcp_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
- rank: 1698
  id: google.adk.tools.mcp_tool.mcp_tool.ProgressCallbackFactory
  name: ProgressCallbackFactory
  file_path: src/google/adk/tools/mcp_tool/mcp_tool.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "Factory protocol for creating per-tool progress callbacks.\n\nThis protocol allows users to create different progress callbacks for\ndifferent tools based on tool name and runtime context. The factory receives\nthe tool name, a CallbackContext for accessing and modifying session state,\nand additional keyword arguments for forward compatibility.\n\nExample usage::\n\n  def my_callback_factory(\n      tool_name: str,\n      *,\n      callback_context: CallbackContext | None = None,\n      **kwargs\n  ) -> ProgressFnT | None:\n    session_id = callback_context.session.id if callback_context else \"N/A\"\n\n    async def callback(progress, total, message):\n      print(f\"[{tool_name}] Session {session_id}: {progress}/{total}\")\n      # Can modify state in the callback\n      if callback_context:\n        callback_context.state['last_progress'] = progress\n\n    return callback\n\n  toolset = McpToolset(\n      connection_params=...,\n      progress_callback=my_callback_factory,\n\
    \  )\n\nNote:\n  The **kwargs parameter is required for forward compatibility. Future\n  versions may pass additional parameters. Implementations should accept\n  **kwargs even if they don't use them.\n\n[Note: Inherited members from Protocol are omitted.]"
  omitted_inherited_members_from:
  - Protocol
- rank: 1699
  id: google.adk.tools.mcp_tool.mcp_toolset
  name: mcp_toolset
  file_path: src/google/adk/tools/mcp_tool/mcp_toolset.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: 'T: typing.TypeVar'
- rank: 1700
  id: google.adk.tools.mcp_tool.mcp_toolset.MCPToolset.__init__
  name: __init__
  file_path: src/google/adk/tools/mcp_tool/mcp_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self):'
- rank: 1701
  id: google.adk.tools.mcp_tool.mcp_toolset.McpToolset.__init__
  name: __init__
  file_path: src/google/adk/tools/mcp_tool/mcp_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the McpToolset.\n\nArgs:\n  connection_params: The connection parameters to the MCP server. Can be:\n    ``StdioConnectionParams`` for using local mcp server (e.g. using ``npx``\n    or ``python3``); or ``SseConnectionParams`` for a local/remote SSE\n    server; or ``StreamableHTTPConnectionParams`` for local/remote\n    Streamable http server. Note, ``StdioServerParameters`` is also\n    supported for using local mcp server (e.g. using ``npx`` or ``python3``\n    ), but it does not support timeout, and we recommend to use\n    ``StdioConnectionParams`` instead when timeout is needed.\n  tool_filter: Optional filter to select specific tools. Can be either: - A\n    list of tool names to include - A ToolPredicate function for custom\n    filtering logic\n  tool_name_prefix: A prefix to be added to the name of each tool in this\n    toolset.\n  errlog: TextIO stream for error logging.\n  auth_scheme: The auth scheme of the tool for tool calling\n  auth_credential:\
    \ The auth credential of the tool for tool calling\n  require_confirmation: Whether tools in this toolset require confirmation.\n    Can be a single boolean or a callable to apply to all tools.\n  header_provider: A callable that takes a ReadonlyContext and returns a\n    dictionary of headers to be used for the MCP session.\n  progress_callback: Optional callback to receive progress notifications\n    from MCP server during long-running tool execution. Can be either:\n\n    - A ``ProgressFnT`` callback that receives (progress, total, message).\n      This callback will be shared by all tools in the toolset.\n\n    - A ``ProgressCallbackFactory`` that creates per-tool callbacks. The\n      factory receives (tool_name, callback_context, **kwargs) and returns\n      a ProgressFnT or None. This allows different tools to have different\n      progress handling logic and access/modify session state via the\n      CallbackContext. The **kwargs parameter allows for future\n      extensibility."
  signature: 'def __init__(self, *, connection_params: typing.Union[mcp.StdioServerParameters, google.adk.tools.mcp_tool.mcp_session_manager.StdioConnectionParams, google.adk.tools.mcp_tool.mcp_session_manager.SseConnectionParams, google.adk.tools.mcp_tool.mcp_session_manager.StreamableHTTPConnectionParams], tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]]=None, tool_name_prefix: typing.Optional[str]=None, errlog: typing.TextIO=sys.stderr, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme]=None, auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]=None, require_confirmation: typing.Union[bool, typing.Callable[Ellipsis, bool]]=False, header_provider: typing.Optional[typing.Callable[[ReadonlyContext], typing.Dict[str, str]]]=None, progress_callback: typing.Optional[typing.Union[mcp.shared.session.ProgressFnT, google.adk.tools.mcp_tool.mcp_tool.ProgressCallbackFactory]]=None):'
- rank: 1702
  id: google.adk.tools.mcp_tool.mcp_toolset.McpToolset.close
  name: close
  file_path: src/google/adk/tools/mcp_tool/mcp_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Performs cleanup and releases resources held by the toolset.


    This method closes the MCP session and cleans up all associated resources.

    It''s designed to be safe to call multiple times and handles cleanup errors

    gracefully to avoid blocking application shutdown.'
  signature: 'def close(self) -> None:'
- rank: 1703
  id: google.adk.tools.mcp_tool.mcp_toolset.McpToolset.from_config
  name: from_config
  file_path: src/google/adk/tools/mcp_tool/mcp_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Creates an McpToolset from a configuration object.
  signature: 'def from_config(cls: type[google.adk.tools.mcp_tool.mcp_toolset.McpToolset], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.mcp_tool.mcp_toolset.McpToolset:'
- rank: 1704
  id: google.adk.tools.mcp_tool.mcp_toolset.McpToolset.get_auth_config
  name: get_auth_config
  file_path: src/google/adk/tools/mcp_tool/mcp_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Returns the auth config for this toolset.


    ADK will populate exchanged_auth_credential on this config before calling

    get_tools(). The toolset can then access the ready-to-use credential via

    self._auth_config.exchanged_auth_credential.'
  signature: 'def get_auth_config(self) -> typing.Optional[google.adk.auth.auth_tool.AuthConfig]:'
- rank: 1705
  id: google.adk.tools.mcp_tool.mcp_toolset.McpToolset.get_resource_info
  name: get_resource_info
  file_path: src/google/adk/tools/mcp_tool/mcp_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns metadata about a specific resource (name, MIME type, etc.).
  signature: 'def get_resource_info(self, name: str, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> dict[str, typing.Any]:'
- rank: 1706
  id: google.adk.tools.mcp_tool.mcp_toolset.McpToolset.get_tools
  name: get_tools
  file_path: src/google/adk/tools/mcp_tool/mcp_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Return all tools in the toolset based on the provided context.\n\nArgs:\n    readonly_context: Context used to filter tools available to the agent.\n      If None, all tools in the toolset are returned.\n\nReturns:\n    List[BaseTool]: A list of tools available under the specified context."
  signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> typing.List[google.adk.tools.base_tool.BaseTool]:'
- rank: 1707
  id: google.adk.tools.mcp_tool.mcp_toolset.McpToolset.list_resources
  name: list_resources
  file_path: src/google/adk/tools/mcp_tool/mcp_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns a list of resource names available on the MCP server.
  signature: 'def list_resources(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[str]:'
- rank: 1708
  id: google.adk.tools.mcp_tool.mcp_toolset.McpToolset.read_resource
  name: read_resource
  file_path: src/google/adk/tools/mcp_tool/mcp_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Fetches and returns a list of contents of the named resource.\n\nArgs:\n  name: The name of the resource to fetch.\n  readonly_context: Context used to provide headers for the MCP session.\n\nReturns:\n  List of contents of the resource."
  signature: 'def read_resource(self, name: str, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> typing.Any:'
- rank: 1709
  id: google.adk.tools.mcp_tool.mcp_toolset.McpToolsetConfig
  name: McpToolsetConfig
  file_path: src/google/adk/tools/mcp_tool/mcp_toolset.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'The config for McpToolset.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, stdio_server_params: typing.Optional[mcp.StdioServerParameters] = None, stdio_connection_params: typing.Optional[google.adk.tools.mcp_tool.mcp_session_manager.StdioConnectionParams] = None, sse_connection_params: typing.Optional[google.adk.tools.mcp_tool.mcp_session_manager.SseConnectionParams] = None, streamable_http_connection_params: typing.Optional[google.adk.tools.mcp_tool.mcp_session_manager.StreamableHTTPConnectionParams] = None, tool_filter: typing.Optional[typing.List[str]] = None, tool_name_prefix: typing.Optional[str] = None, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme] = None, auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential] = None):'
  properties:
  - signature: 'stdio_server_params: typing.Optional[mcp.StdioServerParameters]'
  - signature: 'stdio_connection_params: typing.Optional[google.adk.tools.mcp_tool.mcp_session_manager.StdioConnectionParams]'
  - signature: 'sse_connection_params: typing.Optional[google.adk.tools.mcp_tool.mcp_session_manager.SseConnectionParams]'
  - signature: 'streamable_http_connection_params: typing.Optional[google.adk.tools.mcp_tool.mcp_session_manager.StreamableHTTPConnectionParams]'
  - signature: 'tool_filter: typing.Optional[typing.List[str]]'
  - signature: 'tool_name_prefix: typing.Optional[str]'
  - signature: 'auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme]'
  - signature: 'auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]'
  inherited_properties:
    BaseToolConfig:
    - signature: 'model_config: pydantic.ConfigDict'
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1710
  id: google.adk.tools.mcp_tool.session_context
  name: session_context
  file_path: src/google/adk/tools/mcp_tool/session_context.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 1711
  id: google.adk.tools.mcp_tool.session_context.SessionContext
  name: SessionContext
  file_path: src/google/adk/tools/mcp_tool/session_context.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Represents the context of a single MCP session within a dedicated task.


    AnyIO''s TaskGroup/CancelScope requires that the start and end of a scope

    occur within the same task. Since MCP clients use AnyIO internally, we need

    to ensure that the client''s entire lifecycle (creation, usage, and cleanup)

    happens within a single dedicated task.


    This class spawns a background task that:

    1. Enters the MCP client''s async context and initializes the session

    2. Signals readiness via an asyncio.Event

    3. Waits for a close signal

    4. Cleans up the client within the same task


    This ensures CancelScope constraints are satisfied regardless of which

    task calls start() or close().


    Can be used in two ways:

    1. Direct method calls: start() and close()

    2. As an async context manager: async with lifecycle as session: ...'
  constructor_signature: 'def __init__(self, client: typing.AsyncContextManager, timeout: typing.Optional[float], sse_read_timeout: typing.Optional[float], is_stdio: bool):'
  methods:
  - signature: 'def session(self) -> typing.Optional[mcp.ClientSession]:'
    docstring: Get the managed ClientSession, if available.
  - signature: 'def start(self) -> mcp.ClientSession:'
    docstring: "Start the runner and wait for the session to be ready.\n\nReturns:\n    The initialized ClientSession.\n\nRaises:\n    ConnectionError: If session creation fails."
  - signature: 'def close(self):'
    docstring: Signal the context task to close and wait for cleanup.
- rank: 1712
  id: google.adk.tools.mcp_tool.session_context.SessionContext.__init__
  name: __init__
  file_path: src/google/adk/tools/mcp_tool/session_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Args:\nclient: An MCP client context manager (e.g., from streamablehttp_client,\n    sse_client, or stdio_client).\ntimeout: Timeout in seconds for connection and initialization.\nsse_read_timeout: Timeout in seconds for reading data from the MCP SSE\n    server.\nis_stdio: Whether this is a stdio connection (affects read timeout)."
  signature: 'def __init__(self, client: typing.AsyncContextManager, timeout: typing.Optional[float], sse_read_timeout: typing.Optional[float], is_stdio: bool):'
- rank: 1713
  id: google.adk.tools.mcp_tool.session_context.SessionContext.close
  name: close
  file_path: src/google/adk/tools/mcp_tool/session_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Signal the context task to close and wait for cleanup.
  signature: 'def close(self):'
- rank: 1714
  id: google.adk.tools.mcp_tool.session_context.SessionContext.start
  name: start
  file_path: src/google/adk/tools/mcp_tool/session_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Start the runner and wait for the session to be ready.\n\nReturns:\n    The initialized ClientSession.\n\nRaises:\n    ConnectionError: If session creation fails."
  signature: 'def start(self) -> mcp.ClientSession:'
- rank: 1715
  id: google.adk.tools.openapi_tool
  name: openapi_tool
  file_path: src/google/adk/tools/openapi_tool/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: '__all__: Any'
- rank: 1716
  id: google.adk.tools.openapi_tool.auth
  name: auth
  file_path: src/google/adk/tools/openapi_tool/auth/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: '__all__: Any'
- rank: 1717
  id: google.adk.tools.openapi_tool.auth.auth_helpers
  name: auth_helpers
  file_path: src/google/adk/tools/openapi_tool/auth/auth_helpers.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def token_to_scheme_credential(token_type: typing.Literal[apikey, oauth2Token], location: typing.Optional[typing.Literal[header, query, cookie]], name: typing.Optional[str], credential_value: typing.Optional[str]) -> typing.Tuple[google.adk.auth.auth_schemes.AuthScheme, google.adk.auth.auth_credential.AuthCredential]:'
    docstring: "Creates a AuthScheme and AuthCredential for API key or bearer token.\n\nExamples:\n```\n# API Key in header\nauth_scheme, auth_credential = token_to_scheme_credential(\"apikey\", \"header\",\n\"X-API-Key\", \"your_api_key_value\")\n\n# API Key in query parameter\nauth_scheme, auth_credential = token_to_scheme_credential(\"apikey\", \"query\",\n\"api_key\", \"your_api_key_value\")\n\n# OAuth2 Bearer Token in Authorization header\nauth_scheme, auth_credential = token_to_scheme_credential(\"oauth2Token\",\n\"header\", \"Authorization\", \"your_bearer_token_value\")\n```\n\nArgs:\n    type: 'apikey' or 'oauth2Token'.\n    location: 'header', 'query', or 'cookie' (only 'header' for oauth2Token).\n    name: The name of the header, query parameter, or cookie.\n    credential_value:  The value of the API Key/ Token.\n\nReturns:\n    Tuple: (AuthScheme, AuthCredential)\n\nRaises:\n    ValueError: For invalid type or location."
  - signature: 'def service_account_dict_to_scheme_credential(config: typing.Dict[str, typing.Any], scopes: typing.List[str]) -> typing.Tuple[google.adk.auth.auth_schemes.AuthScheme, google.adk.auth.auth_credential.AuthCredential]:'
    docstring: "Creates AuthScheme and AuthCredential for Google Service Account.\n\nReturns a bearer token scheme, and a service account credential.\n\nArgs:\n    config: A ServiceAccount object containing the Google Service Account\n      configuration.\n    scopes: A list of scopes to be used.\n\nReturns:\n    Tuple: (AuthScheme, AuthCredential)"
  - signature: 'def service_account_scheme_credential(config: google.adk.auth.auth_credential.ServiceAccount) -> typing.Tuple[google.adk.auth.auth_schemes.AuthScheme, google.adk.auth.auth_credential.AuthCredential]:'
    docstring: "Creates AuthScheme and AuthCredential for Google Service Account.\n\nReturns a bearer token scheme, and a service account credential.\n\nArgs:\n    config: A ServiceAccount object containing the Google Service Account\n      configuration.\n\nReturns:\n    Tuple: (AuthScheme, AuthCredential)"
  - signature: 'def openid_dict_to_scheme_credential(config_dict: typing.Dict[str, typing.Any], scopes: typing.List[str], credential_dict: typing.Dict[str, typing.Any]) -> typing.Tuple[google.adk.auth.auth_schemes.OpenIdConnectWithConfig, google.adk.auth.auth_credential.AuthCredential]:'
    docstring: "Constructs OpenID scheme and credential from configuration and credential dictionaries.\n\nArgs:\n    config_dict: Dictionary containing OpenID Connect configuration,  must\n      include at least 'authorization_endpoint' and 'token_endpoint'.\n    scopes: List of scopes to be used.\n    credential_dict: Dictionary containing credential information, must\n      include 'client_id', 'client_secret', and 'scopes'.  May optionally\n      include 'redirect_uri'.\n\nReturns:\n    Tuple: (OpenIdConnectWithConfig, AuthCredential)\n\nRaises:\n    ValueError: If required fields are missing in the input dictionaries."
  - signature: 'def openid_url_to_scheme_credential(openid_url: str, scopes: typing.List[str], credential_dict: typing.Dict[str, typing.Any]) -> typing.Tuple[google.adk.auth.auth_schemes.OpenIdConnectWithConfig, google.adk.auth.auth_credential.AuthCredential]:'
    docstring: "Constructs OpenID scheme and credential from OpenID URL, scopes, and credential dictionary.\n\nFetches OpenID configuration from the provided URL.\n\nArgs:\n    openid_url: The OpenID Connect discovery URL.\n    scopes: List of scopes to be used.\n    credential_dict: Dictionary containing credential information, must\n      include at least \"client_id\" and \"client_secret\", may optionally include\n      \"redirect_uri\" and \"scope\"\n\nReturns:\n    Tuple: (AuthScheme, AuthCredential)\n\nRaises:\n    ValueError: If the OpenID URL is invalid, fetching fails, or required\n      fields are missing.\n    httpx.HTTPStatusError or httpx.RequestError: If there's an error during the\n        HTTP request."
  - signature: 'def credential_to_param(auth_scheme: google.adk.auth.auth_schemes.AuthScheme, auth_credential: google.adk.auth.auth_credential.AuthCredential) -> typing.Tuple[typing.Optional[google.adk.tools.openapi_tool.common.common.ApiParameter], typing.Optional[typing.Dict[str, typing.Any]]]:'
    docstring: "Converts AuthCredential and AuthScheme to a Parameter and a dictionary for additional kwargs.\n\nThis function now supports all credential types returned by the exchangers:\n- API Key\n- HTTP Bearer (for Bearer tokens, OAuth2, Service Account, OpenID Connect)\n- OAuth2 and OpenID Connect (returns None, None, as the token is now a Bearer\ntoken)\n- Service Account (returns None, None, as the token is now a Bearer token)\n\nArgs:\n    auth_scheme: The AuthScheme object.\n    auth_credential: The AuthCredential object.\n\nReturns:\n    Tuple: (ApiParameter, Dict[str, Any])"
  - signature: 'def dict_to_auth_scheme(data: typing.Dict[str, typing.Any]) -> google.adk.auth.auth_schemes.AuthScheme:'
    docstring: "Converts a dictionary to a FastAPI AuthScheme object.\n\nArgs:\n    data: The dictionary representing the security scheme.\n\nReturns:\n    A AuthScheme object (APIKey, HTTPBase, OAuth2, OpenIdConnect, or\n    HTTPBearer).\n\nRaises:\n    ValueError: If the 'type' field is missing or invalid, or if the\n        dictionary cannot be converted to the corresponding Pydantic model.\n\nExample:\n```python\napi_key_data = {\n    \"type\": \"apiKey\",\n    \"in\": \"header\",\n    \"name\": \"X-API-Key\",\n}\napi_key_scheme = dict_to_auth_scheme(api_key_data)\n\nbearer_data = {\n    \"type\": \"http\",\n    \"scheme\": \"bearer\",\n    \"bearerFormat\": \"JWT\",\n}\nbearer_scheme = dict_to_auth_scheme(bearer_data)\n\noauth2_data = {\n    \"type\": \"oauth2\",\n    \"flows\": {\n        \"authorizationCode\": {\n            \"authorizationUrl\": \"https://example.com/auth\",\n            \"tokenUrl\": \"https://example.com/token\",\n        }\n    }\n}\noauth2_scheme = dict_to_auth_scheme(oauth2_data)\n\
      \nopenid_data = {\n    \"type\": \"openIdConnect\",\n    \"openIdConnectUrl\": \"https://example.com/.well-known/openid-configuration\"\n}\nopenid_scheme = dict_to_auth_scheme(openid_data)\n\n```"
  properties:
  - signature: 'INTERNAL_AUTH_PREFIX: str'
- rank: 1718
  id: google.adk.tools.openapi_tool.auth.auth_helpers.OpenIdConfig
  name: OpenIdConfig
  file_path: src/google/adk/tools/openapi_tool/auth/auth_helpers.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "Represents OpenID Connect configuration.\n\nAttributes:\n    client_id: The client ID.\n    auth_uri: The authorization URI.\n    token_uri: The token URI.\n    client_secret: The client secret.\n\nExample:\n    config = OpenIdConfig(\n        client_id=\"your_client_id\",\n        auth_uri=\"https://accounts.google.com/o/oauth2/auth\",\n        token_uri=\"https://oauth2.googleapis.com/token\",\n        client_secret=\"your_client_secret\",\n        redirect\n    )\n\n[Note: Inherited members from pydantic.BaseModel are omitted.]"
  constructor_signature: 'def __init__(self, *, client_id: str, auth_uri: str, token_uri: str, client_secret: str, redirect_uri: typing.Optional[str]):'
  properties:
  - signature: 'client_id: str'
  - signature: 'auth_uri: str'
  - signature: 'token_uri: str'
  - signature: 'client_secret: str'
  - signature: 'redirect_uri: typing.Optional[str]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1719
  id: google.adk.tools.openapi_tool.auth.auth_helpers.credential_to_param
  name: credential_to_param
  file_path: src/google/adk/tools/openapi_tool/auth/auth_helpers.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Converts AuthCredential and AuthScheme to a Parameter and a dictionary for additional kwargs.\n\nThis function now supports all credential types returned by the exchangers:\n- API Key\n- HTTP Bearer (for Bearer tokens, OAuth2, Service Account, OpenID Connect)\n- OAuth2 and OpenID Connect (returns None, None, as the token is now a Bearer\ntoken)\n- Service Account (returns None, None, as the token is now a Bearer token)\n\nArgs:\n    auth_scheme: The AuthScheme object.\n    auth_credential: The AuthCredential object.\n\nReturns:\n    Tuple: (ApiParameter, Dict[str, Any])"
  signature: 'def credential_to_param(auth_scheme: google.adk.auth.auth_schemes.AuthScheme, auth_credential: google.adk.auth.auth_credential.AuthCredential) -> typing.Tuple[typing.Optional[google.adk.tools.openapi_tool.common.common.ApiParameter], typing.Optional[typing.Dict[str, typing.Any]]]:'
- rank: 1720
  id: google.adk.tools.openapi_tool.auth.auth_helpers.dict_to_auth_scheme
  name: dict_to_auth_scheme
  file_path: src/google/adk/tools/openapi_tool/auth/auth_helpers.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Converts a dictionary to a FastAPI AuthScheme object.\n\nArgs:\n    data: The dictionary representing the security scheme.\n\nReturns:\n    A AuthScheme object (APIKey, HTTPBase, OAuth2, OpenIdConnect, or\n    HTTPBearer).\n\nRaises:\n    ValueError: If the 'type' field is missing or invalid, or if the\n        dictionary cannot be converted to the corresponding Pydantic model.\n\nExample:\n```python\napi_key_data = {\n    \"type\": \"apiKey\",\n    \"in\": \"header\",\n    \"name\": \"X-API-Key\",\n}\napi_key_scheme = dict_to_auth_scheme(api_key_data)\n\nbearer_data = {\n    \"type\": \"http\",\n    \"scheme\": \"bearer\",\n    \"bearerFormat\": \"JWT\",\n}\nbearer_scheme = dict_to_auth_scheme(bearer_data)\n\noauth2_data = {\n    \"type\": \"oauth2\",\n    \"flows\": {\n        \"authorizationCode\": {\n            \"authorizationUrl\": \"https://example.com/auth\",\n            \"tokenUrl\": \"https://example.com/token\",\n        }\n    }\n}\noauth2_scheme = dict_to_auth_scheme(oauth2_data)\n\
    \nopenid_data = {\n    \"type\": \"openIdConnect\",\n    \"openIdConnectUrl\": \"https://example.com/.well-known/openid-configuration\"\n}\nopenid_scheme = dict_to_auth_scheme(openid_data)\n\n```"
  signature: 'def dict_to_auth_scheme(data: typing.Dict[str, typing.Any]) -> google.adk.auth.auth_schemes.AuthScheme:'
- rank: 1721
  id: google.adk.tools.openapi_tool.auth.auth_helpers.openid_dict_to_scheme_credential
  name: openid_dict_to_scheme_credential
  file_path: src/google/adk/tools/openapi_tool/auth/auth_helpers.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Constructs OpenID scheme and credential from configuration and credential dictionaries.\n\nArgs:\n    config_dict: Dictionary containing OpenID Connect configuration,  must\n      include at least 'authorization_endpoint' and 'token_endpoint'.\n    scopes: List of scopes to be used.\n    credential_dict: Dictionary containing credential information, must\n      include 'client_id', 'client_secret', and 'scopes'.  May optionally\n      include 'redirect_uri'.\n\nReturns:\n    Tuple: (OpenIdConnectWithConfig, AuthCredential)\n\nRaises:\n    ValueError: If required fields are missing in the input dictionaries."
  signature: 'def openid_dict_to_scheme_credential(config_dict: typing.Dict[str, typing.Any], scopes: typing.List[str], credential_dict: typing.Dict[str, typing.Any]) -> typing.Tuple[google.adk.auth.auth_schemes.OpenIdConnectWithConfig, google.adk.auth.auth_credential.AuthCredential]:'
- rank: 1722
  id: google.adk.tools.openapi_tool.auth.auth_helpers.openid_url_to_scheme_credential
  name: openid_url_to_scheme_credential
  file_path: src/google/adk/tools/openapi_tool/auth/auth_helpers.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Constructs OpenID scheme and credential from OpenID URL, scopes, and credential dictionary.\n\nFetches OpenID configuration from the provided URL.\n\nArgs:\n    openid_url: The OpenID Connect discovery URL.\n    scopes: List of scopes to be used.\n    credential_dict: Dictionary containing credential information, must\n      include at least \"client_id\" and \"client_secret\", may optionally include\n      \"redirect_uri\" and \"scope\"\n\nReturns:\n    Tuple: (AuthScheme, AuthCredential)\n\nRaises:\n    ValueError: If the OpenID URL is invalid, fetching fails, or required\n      fields are missing.\n    httpx.HTTPStatusError or httpx.RequestError: If there's an error during the\n        HTTP request."
  signature: 'def openid_url_to_scheme_credential(openid_url: str, scopes: typing.List[str], credential_dict: typing.Dict[str, typing.Any]) -> typing.Tuple[google.adk.auth.auth_schemes.OpenIdConnectWithConfig, google.adk.auth.auth_credential.AuthCredential]:'
- rank: 1723
  id: google.adk.tools.openapi_tool.auth.auth_helpers.service_account_dict_to_scheme_credential
  name: service_account_dict_to_scheme_credential
  file_path: src/google/adk/tools/openapi_tool/auth/auth_helpers.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Creates AuthScheme and AuthCredential for Google Service Account.\n\nReturns a bearer token scheme, and a service account credential.\n\nArgs:\n    config: A ServiceAccount object containing the Google Service Account\n      configuration.\n    scopes: A list of scopes to be used.\n\nReturns:\n    Tuple: (AuthScheme, AuthCredential)"
  signature: 'def service_account_dict_to_scheme_credential(config: typing.Dict[str, typing.Any], scopes: typing.List[str]) -> typing.Tuple[google.adk.auth.auth_schemes.AuthScheme, google.adk.auth.auth_credential.AuthCredential]:'
- rank: 1724
  id: google.adk.tools.openapi_tool.auth.auth_helpers.service_account_scheme_credential
  name: service_account_scheme_credential
  file_path: src/google/adk/tools/openapi_tool/auth/auth_helpers.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Creates AuthScheme and AuthCredential for Google Service Account.\n\nReturns a bearer token scheme, and a service account credential.\n\nArgs:\n    config: A ServiceAccount object containing the Google Service Account\n      configuration.\n\nReturns:\n    Tuple: (AuthScheme, AuthCredential)"
  signature: 'def service_account_scheme_credential(config: google.adk.auth.auth_credential.ServiceAccount) -> typing.Tuple[google.adk.auth.auth_schemes.AuthScheme, google.adk.auth.auth_credential.AuthCredential]:'
- rank: 1725
  id: google.adk.tools.openapi_tool.auth.auth_helpers.token_to_scheme_credential
  name: token_to_scheme_credential
  file_path: src/google/adk/tools/openapi_tool/auth/auth_helpers.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Creates a AuthScheme and AuthCredential for API key or bearer token.\n\nExamples:\n```\n# API Key in header\nauth_scheme, auth_credential = token_to_scheme_credential(\"apikey\", \"header\",\n\"X-API-Key\", \"your_api_key_value\")\n\n# API Key in query parameter\nauth_scheme, auth_credential = token_to_scheme_credential(\"apikey\", \"query\",\n\"api_key\", \"your_api_key_value\")\n\n# OAuth2 Bearer Token in Authorization header\nauth_scheme, auth_credential = token_to_scheme_credential(\"oauth2Token\",\n\"header\", \"Authorization\", \"your_bearer_token_value\")\n```\n\nArgs:\n    type: 'apikey' or 'oauth2Token'.\n    location: 'header', 'query', or 'cookie' (only 'header' for oauth2Token).\n    name: The name of the header, query parameter, or cookie.\n    credential_value:  The value of the API Key/ Token.\n\nReturns:\n    Tuple: (AuthScheme, AuthCredential)\n\nRaises:\n    ValueError: For invalid type or location."
  signature: 'def token_to_scheme_credential(token_type: typing.Literal[apikey, oauth2Token], location: typing.Optional[typing.Literal[header, query, cookie]], name: typing.Optional[str], credential_value: typing.Optional[str]) -> typing.Tuple[google.adk.auth.auth_schemes.AuthScheme, google.adk.auth.auth_credential.AuthCredential]:'
- rank: 1726
  id: google.adk.tools.openapi_tool.auth.credential_exchangers
  name: credential_exchangers
  file_path: src/google/adk/tools/openapi_tool/auth/credential_exchangers/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: '__all__: Any'
- rank: 1727
  id: google.adk.tools.openapi_tool.auth.credential_exchangers.auto_auth_credential_exchanger
  name: auto_auth_credential_exchanger
  file_path: src/google/adk/tools/openapi_tool/auth/credential_exchangers/auto_auth_credential_exchanger.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1728
  id: google.adk.tools.openapi_tool.auth.credential_exchangers.auto_auth_credential_exchanger.AutoAuthCredentialExchanger
  name: AutoAuthCredentialExchanger
  file_path: src/google/adk/tools/openapi_tool/auth/credential_exchangers/auto_auth_credential_exchanger.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "Automatically selects the appropriate credential exchanger based on the auth scheme.\n\nOptionally, an override can be provided to use a specific exchanger for a\ngiven auth scheme.\n\nExample (common case):\n```\nexchanger = AutoAuthCredentialExchanger()\nauth_credential = exchanger.exchange_credential(\n    auth_scheme=service_account_scheme,\n    auth_credential=service_account_credential,\n)\n# Returns an oauth token in the form of a bearer token.\n```\n\nExample (use CustomAuthExchanger for OAuth2):\n```\nexchanger = AutoAuthCredentialExchanger(\n    custom_exchangers={\n        AuthScheme.OAUTH2: CustomAuthExchanger,\n    }\n)\n```\n\nAttributes:\n  exchangers: A dictionary mapping auth scheme to credential exchanger class."
  constructor_signature: 'def __init__(self, custom_exchangers: typing.Optional[typing.Dict[str, typing.Type[google.adk.tools.openapi_tool.auth.credential_exchangers.base_credential_exchanger.BaseAuthCredentialExchanger]]]):'
  methods:
  - signature: 'def exchange_credential(self, auth_scheme: google.adk.auth.auth_schemes.AuthScheme, auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]) -> typing.Optional[google.adk.auth.auth_credential.AuthCredential]:'
    docstring: "Automatically exchanges for the credential uses the appropriate credential exchanger.\n\nArgs:\n    auth_scheme (AuthScheme): The security scheme.\n    auth_credential (AuthCredential): Optional. The authentication\n      credential.\n\nReturns: (AuthCredential)\n    A new AuthCredential object containing the exchanged credential."
  inherited_methods:
    BaseAuthCredentialExchanger:
    - signature: 'def exchange_credential(self, auth_scheme: google.adk.auth.auth_schemes.AuthScheme, auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]) -> google.adk.auth.auth_credential.AuthCredential:'
      docstring: "Exchanges the provided authentication credential for a usable token/credential.\n\nArgs:\n    auth_scheme: The security scheme.\n    auth_credential: The authentication credential.\n\nReturns:\n    An updated AuthCredential object containing the fetched credential.\n    For simple schemes like API key, it may return the original credential\n    if no exchange is needed.\n\nRaises:\n    NotImplementedError: If the method is not implemented by a subclass."
- rank: 1729
  id: google.adk.tools.openapi_tool.auth.credential_exchangers.auto_auth_credential_exchanger.AutoAuthCredentialExchanger.__init__
  name: __init__
  file_path: src/google/adk/tools/openapi_tool/auth/credential_exchangers/auto_auth_credential_exchanger.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the AutoAuthCredentialExchanger.\n\nArgs:\n  custom_exchangers: Optional dictionary for adding or overriding auth\n    exchangers. The key is the auth scheme, and the value is the credential\n    exchanger class."
  signature: 'def __init__(self, custom_exchangers: typing.Optional[typing.Dict[str, typing.Type[google.adk.tools.openapi_tool.auth.credential_exchangers.base_credential_exchanger.BaseAuthCredentialExchanger]]]):'
- rank: 1730
  id: google.adk.tools.openapi_tool.auth.credential_exchangers.auto_auth_credential_exchanger.AutoAuthCredentialExchanger.exchange_credential
  name: exchange_credential
  file_path: src/google/adk/tools/openapi_tool/auth/credential_exchangers/auto_auth_credential_exchanger.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Automatically exchanges for the credential uses the appropriate credential exchanger.\n\nArgs:\n    auth_scheme (AuthScheme): The security scheme.\n    auth_credential (AuthCredential): Optional. The authentication\n      credential.\n\nReturns: (AuthCredential)\n    A new AuthCredential object containing the exchanged credential."
  signature: 'def exchange_credential(self, auth_scheme: google.adk.auth.auth_schemes.AuthScheme, auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]) -> typing.Optional[google.adk.auth.auth_credential.AuthCredential]:'
- rank: 1731
  id: google.adk.tools.openapi_tool.auth.credential_exchangers.base_credential_exchanger
  name: base_credential_exchanger
  file_path: src/google/adk/tools/openapi_tool/auth/credential_exchangers/base_credential_exchanger.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1732
  id: google.adk.tools.openapi_tool.auth.credential_exchangers.base_credential_exchanger.AuthCredentialMissingError
  name: AuthCredentialMissingError
  file_path: src/google/adk/tools/openapi_tool/auth/credential_exchangers/base_credential_exchanger.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Exception raised when required authentication credentials are missing.


    [Note: Inherited members from Exception are omitted.]'
  constructor_signature: 'def __init__(self, message: str):'
  omitted_inherited_members_from:
  - Exception
- rank: 1733
  id: google.adk.tools.openapi_tool.auth.credential_exchangers.base_credential_exchanger.BaseAuthCredentialExchanger
  name: BaseAuthCredentialExchanger
  file_path: src/google/adk/tools/openapi_tool/auth/credential_exchangers/base_credential_exchanger.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Base class for authentication credential exchangers.
  aliases:
  - google.adk.tools.openapi_tool.auth.credential_exchangers.BaseAuthCredentialExchanger
  methods:
  - signature: 'def exchange_credential(self, auth_scheme: google.adk.auth.auth_schemes.AuthScheme, auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]) -> google.adk.auth.auth_credential.AuthCredential:'
    docstring: "Exchanges the provided authentication credential for a usable token/credential.\n\nArgs:\n    auth_scheme: The security scheme.\n    auth_credential: The authentication credential.\n\nReturns:\n    An updated AuthCredential object containing the fetched credential.\n    For simple schemes like API key, it may return the original credential\n    if no exchange is needed.\n\nRaises:\n    NotImplementedError: If the method is not implemented by a subclass."
- rank: 1734
  id: google.adk.tools.openapi_tool.auth.credential_exchangers.base_credential_exchanger.BaseAuthCredentialExchanger.exchange_credential
  name: exchange_credential
  file_path: src/google/adk/tools/openapi_tool/auth/credential_exchangers/base_credential_exchanger.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Exchanges the provided authentication credential for a usable token/credential.\n\nArgs:\n    auth_scheme: The security scheme.\n    auth_credential: The authentication credential.\n\nReturns:\n    An updated AuthCredential object containing the fetched credential.\n    For simple schemes like API key, it may return the original credential\n    if no exchange is needed.\n\nRaises:\n    NotImplementedError: If the method is not implemented by a subclass."
  signature: 'def exchange_credential(self, auth_scheme: google.adk.auth.auth_schemes.AuthScheme, auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]) -> google.adk.auth.auth_credential.AuthCredential:'
- rank: 1735
  id: google.adk.tools.openapi_tool.auth.credential_exchangers.oauth2_exchanger
  name: oauth2_exchanger
  file_path: src/google/adk/tools/openapi_tool/auth/credential_exchangers/oauth2_exchanger.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1736
  id: google.adk.tools.openapi_tool.auth.credential_exchangers.oauth2_exchanger.OAuth2CredentialExchanger
  name: OAuth2CredentialExchanger
  file_path: src/google/adk/tools/openapi_tool/auth/credential_exchangers/oauth2_exchanger.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Fetches credentials for OAuth2 and OpenID Connect.
  aliases:
  - google.adk.tools.openapi_tool.auth.credential_exchangers.OAuth2CredentialExchanger
  methods:
  - signature: 'def generate_auth_token(self, auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]) -> google.adk.auth.auth_credential.AuthCredential:'
    docstring: "Generates an auth token from the authorization response.\n\nArgs:\n    auth_scheme: The OpenID Connect or OAuth2 auth scheme.\n    auth_credential: The auth credential.\n\nReturns:\n    An AuthCredential object containing the HTTP bearer access token. If the\n    HTTP bearer token cannot be generated, return the original credential."
  - signature: 'def exchange_credential(self, auth_scheme: google.adk.auth.auth_schemes.AuthScheme, auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]) -> google.adk.auth.auth_credential.AuthCredential:'
    docstring: "Exchanges the OpenID Connect auth credential for an access token or an auth URI.\n\nArgs:\n    auth_scheme: The auth scheme.\n    auth_credential: The auth credential.\n\nReturns:\n    An AuthCredential object containing the HTTP Bearer access token.\n\nRaises:\n    ValueError: If the auth scheme or auth credential is invalid."
  inherited_methods:
    BaseAuthCredentialExchanger:
    - signature: 'def exchange_credential(self, auth_scheme: google.adk.auth.auth_schemes.AuthScheme, auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]) -> google.adk.auth.auth_credential.AuthCredential:'
      docstring: "Exchanges the provided authentication credential for a usable token/credential.\n\nArgs:\n    auth_scheme: The security scheme.\n    auth_credential: The authentication credential.\n\nReturns:\n    An updated AuthCredential object containing the fetched credential.\n    For simple schemes like API key, it may return the original credential\n    if no exchange is needed.\n\nRaises:\n    NotImplementedError: If the method is not implemented by a subclass."
- rank: 1737
  id: google.adk.tools.openapi_tool.auth.credential_exchangers.oauth2_exchanger.OAuth2CredentialExchanger.exchange_credential
  name: exchange_credential
  file_path: src/google/adk/tools/openapi_tool/auth/credential_exchangers/oauth2_exchanger.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Exchanges the OpenID Connect auth credential for an access token or an auth URI.\n\nArgs:\n    auth_scheme: The auth scheme.\n    auth_credential: The auth credential.\n\nReturns:\n    An AuthCredential object containing the HTTP Bearer access token.\n\nRaises:\n    ValueError: If the auth scheme or auth credential is invalid."
  signature: 'def exchange_credential(self, auth_scheme: google.adk.auth.auth_schemes.AuthScheme, auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]) -> google.adk.auth.auth_credential.AuthCredential:'
- rank: 1738
  id: google.adk.tools.openapi_tool.auth.credential_exchangers.oauth2_exchanger.OAuth2CredentialExchanger.generate_auth_token
  name: generate_auth_token
  file_path: src/google/adk/tools/openapi_tool/auth/credential_exchangers/oauth2_exchanger.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Generates an auth token from the authorization response.\n\nArgs:\n    auth_scheme: The OpenID Connect or OAuth2 auth scheme.\n    auth_credential: The auth credential.\n\nReturns:\n    An AuthCredential object containing the HTTP bearer access token. If the\n    HTTP bearer token cannot be generated, return the original credential."
  signature: 'def generate_auth_token(self, auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]) -> google.adk.auth.auth_credential.AuthCredential:'
- rank: 1739
  id: google.adk.tools.openapi_tool.auth.credential_exchangers.service_account_exchanger
  name: service_account_exchanger
  file_path: src/google/adk/tools/openapi_tool/auth/credential_exchangers/service_account_exchanger.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Credential fetcher for Google Service Account.
- rank: 1740
  id: google.adk.tools.openapi_tool.auth.credential_exchangers.service_account_exchanger.ServiceAccountCredentialExchanger
  name: ServiceAccountCredentialExchanger
  file_path: src/google/adk/tools/openapi_tool/auth/credential_exchangers/service_account_exchanger.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Fetches credentials for Google Service Account.


    Uses the default service credential if `use_default_credential = True`.

    Otherwise, uses the service account credential provided in the auth

    credential.'
  aliases:
  - google.adk.tools.openapi_tool.auth.credential_exchangers.ServiceAccountCredentialExchanger
  methods:
  - signature: 'def exchange_credential(self, auth_scheme: google.adk.auth.auth_schemes.AuthScheme, auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]) -> google.adk.auth.auth_credential.AuthCredential:'
    docstring: "Exchanges the service account auth credential for an access token.\n\nIf auth_credential contains a service account credential, it will be used\nto fetch an access token. Otherwise, the default service credential will be\nused for fetching an access token.\n\nArgs:\n    auth_scheme: The auth scheme.\n    auth_credential: The auth credential.\n\nReturns:\n    An AuthCredential in HTTPBearer format, containing the access token."
  inherited_methods:
    BaseAuthCredentialExchanger:
    - signature: 'def exchange_credential(self, auth_scheme: google.adk.auth.auth_schemes.AuthScheme, auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]) -> google.adk.auth.auth_credential.AuthCredential:'
      docstring: "Exchanges the provided authentication credential for a usable token/credential.\n\nArgs:\n    auth_scheme: The security scheme.\n    auth_credential: The authentication credential.\n\nReturns:\n    An updated AuthCredential object containing the fetched credential.\n    For simple schemes like API key, it may return the original credential\n    if no exchange is needed.\n\nRaises:\n    NotImplementedError: If the method is not implemented by a subclass."
- rank: 1741
  id: google.adk.tools.openapi_tool.auth.credential_exchangers.service_account_exchanger.ServiceAccountCredentialExchanger.exchange_credential
  name: exchange_credential
  file_path: src/google/adk/tools/openapi_tool/auth/credential_exchangers/service_account_exchanger.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Exchanges the service account auth credential for an access token.\n\nIf auth_credential contains a service account credential, it will be used\nto fetch an access token. Otherwise, the default service credential will be\nused for fetching an access token.\n\nArgs:\n    auth_scheme: The auth scheme.\n    auth_credential: The auth credential.\n\nReturns:\n    An AuthCredential in HTTPBearer format, containing the access token."
  signature: 'def exchange_credential(self, auth_scheme: google.adk.auth.auth_schemes.AuthScheme, auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]) -> google.adk.auth.auth_credential.AuthCredential:'
- rank: 1742
  id: google.adk.tools.openapi_tool.common
  name: common
  file_path: src/google/adk/tools/openapi_tool/common/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: '__all__: Any'
- rank: 1743
  id: google.adk.tools.openapi_tool.common.common
  name: common
  file_path: src/google/adk/tools/openapi_tool/common/common.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def rename_python_keywords(s: str, prefix: str) -> str:'
    docstring: "Renames Python keywords by adding a prefix.\n\nExample:\n```\nrename_python_keywords('if') -> 'param_if'\nrename_python_keywords('for') -> 'param_for'\n```\n\nArgs:\n    s: The input string.\n    prefix: The prefix to add to the keyword.\n\nReturns:\n    The renamed string."
- rank: 1744
  id: google.adk.tools.openapi_tool.common.common.ApiParameter
  name: ApiParameter
  file_path: src/google/adk/tools/openapi_tool/common/common.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Data class representing a function parameter.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, original_name: str, param_location: str, param_schema: typing.Union[str, fastapi.openapi.models.Schema], description: typing.Optional[str] = '''', py_name: typing.Optional[str] = '''', type_value: type[typing.Any] = None, type_hint: str = None, required: bool = False):'
  methods:
  - signature: 'def model_post_init(self, _: typing.Any):'
  - signature: 'def to_arg_string(self):'
    docstring: Converts the parameter to an argument string for function call.
  - signature: 'def to_dict_property(self):'
    docstring: Converts the parameter to a key:value string for dict property.
  - signature: 'def to_pydoc_string(self):'
    docstring: Converts the parameter to a PyDoc parameter docstr.
  properties:
  - signature: 'original_name: str'
  - signature: 'param_location: str'
  - signature: 'param_schema: typing.Union[str, fastapi.openapi.models.Schema]'
  - signature: 'description: typing.Optional[str]'
  - signature: 'py_name: typing.Optional[str]'
  - signature: 'type_value: type[typing.Any]'
  - signature: 'type_hint: str'
  - signature: 'required: bool'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1745
  id: google.adk.tools.openapi_tool.common.common.ApiParameter.model_post_init
  name: model_post_init
  file_path: src/google/adk/tools/openapi_tool/common/common.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def model_post_init(self, _: typing.Any):'
- rank: 1746
  id: google.adk.tools.openapi_tool.common.common.PydocHelper
  name: PydocHelper
  file_path: src/google/adk/tools/openapi_tool/common/common.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Helper class for generating PyDoc strings.
  methods:
  - signature: 'def generate_param_doc(param: google.adk.tools.openapi_tool.common.common.ApiParameter) -> str:'
    docstring: "Generates a parameter documentation string.\n\nArgs:\n  param: ApiParameter - The parameter to generate the documentation for.\n\nReturns:\n  str: The generated parameter Python documentation string."
  - signature: 'def generate_return_doc(responses: typing.Dict[str, fastapi.openapi.models.Response]) -> str:'
    docstring: "Generates a return value documentation string.\n\nArgs:\n  responses: Dict[str, TypedDict[Response]] - Response in an OpenAPI\n    Operation\n\nReturns:\n  str: The generated return value Python documentation string."
- rank: 1747
  id: google.adk.tools.openapi_tool.common.common.PydocHelper.generate_param_doc
  name: generate_param_doc
  file_path: src/google/adk/tools/openapi_tool/common/common.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Generates a parameter documentation string.\n\nArgs:\n  param: ApiParameter - The parameter to generate the documentation for.\n\nReturns:\n  str: The generated parameter Python documentation string."
  signature: 'def generate_param_doc(param: google.adk.tools.openapi_tool.common.common.ApiParameter) -> str:'
- rank: 1748
  id: google.adk.tools.openapi_tool.common.common.PydocHelper.generate_return_doc
  name: generate_return_doc
  file_path: src/google/adk/tools/openapi_tool/common/common.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Generates a return value documentation string.\n\nArgs:\n  responses: Dict[str, TypedDict[Response]] - Response in an OpenAPI\n    Operation\n\nReturns:\n  str: The generated return value Python documentation string."
  signature: 'def generate_return_doc(responses: typing.Dict[str, fastapi.openapi.models.Response]) -> str:'
- rank: 1749
  id: google.adk.tools.openapi_tool.common.common.TypeHintHelper
  name: TypeHintHelper
  file_path: src/google/adk/tools/openapi_tool/common/common.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Helper class for generating type hints.
  methods:
  - signature: 'def get_type_value(schema: fastapi.openapi.models.Schema) -> typing.Any:'
    docstring: Generates the Python type value for a given parameter.
  - signature: 'def get_type_hint(schema: fastapi.openapi.models.Schema) -> str:'
    docstring: Generates the Python type in string for a given parameter.
- rank: 1750
  id: google.adk.tools.openapi_tool.common.common.TypeHintHelper.get_type_hint
  name: get_type_hint
  file_path: src/google/adk/tools/openapi_tool/common/common.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Generates the Python type in string for a given parameter.
  signature: 'def get_type_hint(schema: fastapi.openapi.models.Schema) -> str:'
- rank: 1751
  id: google.adk.tools.openapi_tool.common.common.TypeHintHelper.get_type_value
  name: get_type_value
  file_path: src/google/adk/tools/openapi_tool/common/common.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Generates the Python type value for a given parameter.
  signature: 'def get_type_value(schema: fastapi.openapi.models.Schema) -> typing.Any:'
- rank: 1752
  id: google.adk.tools.openapi_tool.common.common.rename_python_keywords
  name: rename_python_keywords
  file_path: src/google/adk/tools/openapi_tool/common/common.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Renames Python keywords by adding a prefix.\n\nExample:\n```\nrename_python_keywords('if') -> 'param_if'\nrename_python_keywords('for') -> 'param_for'\n```\n\nArgs:\n    s: The input string.\n    prefix: The prefix to add to the keyword.\n\nReturns:\n    The renamed string."
  signature: 'def rename_python_keywords(s: str, prefix: str) -> str:'
- rank: 1753
  id: google.adk.tools.openapi_tool.openapi_spec_parser
  name: openapi_spec_parser
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: '__all__: Any'
- rank: 1754
  id: google.adk.tools.openapi_tool.openapi_spec_parser.openapi_spec_parser
  name: openapi_spec_parser
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/openapi_spec_parser.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: '_VALID_SCHEMA_TYPES: typing.Set[str]'
  - signature: '_SCHEMA_CONTAINER_KEYS: typing.Set[str]'
- rank: 1755
  id: google.adk.tools.openapi_tool.openapi_spec_parser.openapi_spec_parser.OpenApiSpecParser
  name: OpenApiSpecParser
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/openapi_spec_parser.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Generates Python code, JSON schema, and callables for an OpenAPI operation.


    This class takes an OpenApiOperation object and provides methods to generate:

    1. A string representation of a Python function that handles the operation.

    2. A JSON schema representing the input parameters of the operation.

    3. A callable Python object (a function) that can execute the operation.'
  methods:
  - signature: 'def parse(self, openapi_spec_dict: typing.Dict[str, typing.Any]) -> typing.List[google.adk.tools.openapi_tool.openapi_spec_parser.openapi_spec_parser.ParsedOperation]:'
    docstring: "Extracts an OpenAPI spec dict into a list of ParsedOperation objects.\n\nParsedOperation objects are further used for generating RestApiTool.\n\nArgs:\n    openapi_spec_dict: A dictionary representing the OpenAPI specification.\n\nReturns:\n    A list of ParsedOperation objects."
- rank: 1756
  id: google.adk.tools.openapi_tool.openapi_spec_parser.openapi_spec_parser.OpenApiSpecParser.parse
  name: parse
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/openapi_spec_parser.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Extracts an OpenAPI spec dict into a list of ParsedOperation objects.\n\nParsedOperation objects are further used for generating RestApiTool.\n\nArgs:\n    openapi_spec_dict: A dictionary representing the OpenAPI specification.\n\nReturns:\n    A list of ParsedOperation objects."
  signature: 'def parse(self, openapi_spec_dict: typing.Dict[str, typing.Any]) -> typing.List[google.adk.tools.openapi_tool.openapi_spec_parser.openapi_spec_parser.ParsedOperation]:'
- rank: 1757
  id: google.adk.tools.openapi_tool.openapi_spec_parser.openapi_spec_parser.OperationEndpoint
  name: OperationEndpoint
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/openapi_spec_parser.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, base_url: str, path: str, method: str):'
  properties:
  - signature: 'base_url: str'
  - signature: 'path: str'
  - signature: 'method: str'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1758
  id: google.adk.tools.openapi_tool.openapi_spec_parser.openapi_spec_parser.ParsedOperation
  name: ParsedOperation
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/openapi_spec_parser.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, name: str, description: str, endpoint: google.adk.tools.openapi_tool.openapi_spec_parser.openapi_spec_parser.OperationEndpoint, operation: fastapi.openapi.models.Operation, parameters: typing.List[google.adk.tools.openapi_tool.common.common.ApiParameter], return_value: google.adk.tools.openapi_tool.common.common.ApiParameter, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme] = None, auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential] = None, additional_context: typing.Optional[typing.Any] = None):'
  properties:
  - signature: 'name: str'
  - signature: 'description: str'
  - signature: 'endpoint: google.adk.tools.openapi_tool.openapi_spec_parser.openapi_spec_parser.OperationEndpoint'
  - signature: 'operation: fastapi.openapi.models.Operation'
  - signature: 'parameters: typing.List[google.adk.tools.openapi_tool.common.common.ApiParameter]'
  - signature: 'return_value: google.adk.tools.openapi_tool.common.common.ApiParameter'
  - signature: 'auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme]'
  - signature: 'auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]'
  - signature: 'additional_context: typing.Optional[typing.Any]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1759
  id: google.adk.tools.openapi_tool.openapi_spec_parser.openapi_toolset
  name: openapi_toolset
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/openapi_toolset.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 1760
  id: google.adk.tools.openapi_tool.openapi_spec_parser.openapi_toolset.OpenAPIToolset
  name: OpenAPIToolset
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/openapi_toolset.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "Class for parsing OpenAPI spec into a list of RestApiTool.\n\nUsage::\n\n  # Initialize OpenAPI toolset from a spec string.\n  openapi_toolset = OpenAPIToolset(spec_str=openapi_spec_str,\n    spec_str_type=\"json\")\n  # Or, initialize OpenAPI toolset from a spec dictionary.\n  openapi_toolset = OpenAPIToolset(spec_dict=openapi_spec_dict)\n\n  # Add all tools to an agent.\n  agent = Agent(\n    tools=[*openapi_toolset.get_tools()]\n  )\n  # Or, add a single tool to an agent.\n  agent = Agent(\n    tools=[openapi_toolset.get_tool('tool_name')]\n  )\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, *, spec_dict: typing.Optional[typing.Dict[str, typing.Any]]=None, spec_str: typing.Optional[str]=None, spec_str_type: typing.Literal[json, yaml]=''json'', auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme]=None, auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]=None, credential_key: typing.Optional[str]=None, tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]]=None, tool_name_prefix: typing.Optional[str]=None, ssl_verify: typing.Optional[typing.Union[bool, str, ssl.SSLContext]]=None, header_provider: typing.Optional[typing.Callable[[ReadonlyContext], typing.Dict[str, str]]]=None):'
  methods:
  - signature: 'def configure_ssl_verify_all(self, ssl_verify: typing.Optional[typing.Union[bool, str, ssl.SSLContext]]):'
    docstring: "Configure SSL certificate verification for all tools.\n\nThis is useful for enterprise environments where requests go through a\nTLS-intercepting proxy with a custom CA certificate.\n\nArgs:\n    ssl_verify: SSL certificate verification option. Can be:\n      - None: Use default verification (True)\n      - True: Verify SSL certificates using system CA\n      - False: Disable SSL verification (insecure, not recommended)\n      - str: Path to a CA bundle file or directory for custom CA\n      - ssl.SSLContext: Custom SSL context for advanced configuration"
  - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> typing.List[google.adk.tools.openapi_tool.openapi_spec_parser.rest_api_tool.RestApiTool]:'
    docstring: Get all tools in the toolset.
  - signature: 'def get_tool(self, tool_name: str) -> typing.Optional[google.adk.tools.openapi_tool.openapi_spec_parser.rest_api_tool.RestApiTool]:'
    docstring: Get a tool by name.
  - signature: 'def close(self):'
  - signature: 'def get_auth_config(self) -> typing.Optional[google.adk.auth.auth_tool.AuthConfig]:'
    docstring: 'Returns the auth config for this toolset.


      Note: This returns a copy so any exchanged credentials populated by the ADK

      framework do not persist on the toolset instance across invocations.'
  inherited_methods:
    BaseToolset:
    - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools in the toolset based on the provided context.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools available under the specified context."
    - signature: 'def get_tools_with_prefix(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools with optional prefix applied to tool names.\n\nThis method calls get_tools() and applies prefixing if tool_name_prefix is provided.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools with prefixed names if tool_name_prefix is provided."
    - signature: 'def close(self) -> None:'
      docstring: "Performs cleanup and releases resources held by the toolset.\n\nNOTE:\n  This method is invoked, for example, at the end of an agent server's\n  lifecycle or when the toolset is no longer needed. Implementations\n  should ensure that any open connections, files, or other managed\n  resources are properly released to prevent leaks."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_toolset.SelfToolset], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_toolset.SelfToolset:'
      docstring: "Creates a toolset instance from a config.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The toolset instance."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this toolset. This method will be\ncalled before each tool processes the llm request.\n\nUse cases:\n- Instead of let each tool process the llm request, we can let the toolset\n  process the llm request. e.g. ComputerUseToolset can add computer use\n  tool to the llm request.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def get_auth_config(self) -> typing.Optional[google.adk.auth.auth_tool.AuthConfig]:'
      docstring: "Returns the auth config for this toolset. ADK will make sure the\n'exchanged_auth_credential' field in the config is populated with\nready-to-use credential (e.g. oauth token for OAuth flow) before calling\nget_tools method or execute any tools returned by this toolset. Thus toolset\ncan use this credential either for tool listing or tool calling. If tool\ncalling needs a different credential from ADK client, call\ntool_context.request_credential in the tool.\n\nToolsets that support authentication should override this method to return\nan AuthConfig constructed from their auth_scheme, auth_credential, and\noptional credential_key parameters.\n\nReturns:\n  AuthConfig if the toolset has authentication configured, None otherwise."
  omitted_inherited_members_from:
  - ABC
- rank: 1761
  id: google.adk.tools.openapi_tool.openapi_spec_parser.openapi_toolset.OpenAPIToolset.__init__
  name: __init__
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/openapi_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the OpenAPIToolset.\n\nUsage::\n\n  # Initialize OpenAPI toolset from a spec string.\n  openapi_toolset = OpenAPIToolset(spec_str=openapi_spec_str,\n    spec_str_type=\"json\")\n  # Or, initialize OpenAPI toolset from a spec dictionary.\n  openapi_toolset = OpenAPIToolset(spec_dict=openapi_spec_dict)\n\n  # Add all tools to an agent.\n  agent = Agent(\n    tools=[*openapi_toolset.get_tools()]\n  )\n  # Or, add a single tool to an agent.\n  agent = Agent(\n    tools=[openapi_toolset.get_tool('tool_name')]\n  )\n\nArgs:\n  spec_dict: The OpenAPI spec dictionary. If provided, it will be used\n    instead of loading the spec from a string.\n  spec_str: The OpenAPI spec string in JSON or YAML format. It will be used\n    when spec_dict is not provided.\n  spec_str_type: The type of the OpenAPI spec string. Can be \"json\" or\n    \"yaml\".\n  auth_scheme: The auth scheme to use for all tools. Use AuthScheme or use\n    helpers in ``google.adk.tools.openapi_tool.auth.auth_helpers``\n\
    \  auth_credential: The auth credential to use for all tools. Use\n    AuthCredential or use helpers in\n    ``google.adk.tools.openapi_tool.auth.auth_helpers``\n  credential_key: Optional stable key used for interactive auth and\n    credential caching across all tools in this toolset.\n  tool_filter: The filter used to filter the tools in the toolset. It can be\n    either a tool predicate or a list of tool names of the tools to expose.\n  tool_name_prefix: The prefix to prepend to the names of the tools returned\n    by the toolset. Useful when multiple OpenAPI specs have tools with\n    similar names.\n  ssl_verify: SSL certificate verification option for all tools. Can be:\n    - None: Use default verification (True)\n    - True: Verify SSL certificates using system CA\n    - False: Disable SSL verification (insecure, not recommended)\n    - str: Path to a CA bundle file or directory for custom CA\n    - ssl.SSLContext: Custom SSL context for advanced configuration\n    This is\
    \ useful for enterprise environments where requests go through\n    a TLS-intercepting proxy with a custom CA certificate.\n  header_provider: A callable that returns a dictionary of headers to be\n    included in API requests. The callable receives the ReadonlyContext as\n    an argument, allowing dynamic header generation based on the current\n    context. Useful for adding custom headers like correlation IDs,\n    authentication tokens, or other request metadata."
  signature: 'def __init__(self, *, spec_dict: typing.Optional[typing.Dict[str, typing.Any]]=None, spec_str: typing.Optional[str]=None, spec_str_type: typing.Literal[json, yaml]=''json'', auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme]=None, auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]=None, credential_key: typing.Optional[str]=None, tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]]=None, tool_name_prefix: typing.Optional[str]=None, ssl_verify: typing.Optional[typing.Union[bool, str, ssl.SSLContext]]=None, header_provider: typing.Optional[typing.Callable[[ReadonlyContext], typing.Dict[str, str]]]=None):'
- rank: 1762
  id: google.adk.tools.openapi_tool.openapi_spec_parser.openapi_toolset.OpenAPIToolset.configure_ssl_verify_all
  name: configure_ssl_verify_all
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/openapi_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Configure SSL certificate verification for all tools.\n\nThis is useful for enterprise environments where requests go through a\nTLS-intercepting proxy with a custom CA certificate.\n\nArgs:\n    ssl_verify: SSL certificate verification option. Can be:\n      - None: Use default verification (True)\n      - True: Verify SSL certificates using system CA\n      - False: Disable SSL verification (insecure, not recommended)\n      - str: Path to a CA bundle file or directory for custom CA\n      - ssl.SSLContext: Custom SSL context for advanced configuration"
  signature: 'def configure_ssl_verify_all(self, ssl_verify: typing.Optional[typing.Union[bool, str, ssl.SSLContext]]):'
- rank: 1763
  id: google.adk.tools.openapi_tool.openapi_spec_parser.openapi_toolset.OpenAPIToolset.get_auth_config
  name: get_auth_config
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/openapi_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: 'Returns the auth config for this toolset.


    Note: This returns a copy so any exchanged credentials populated by the ADK

    framework do not persist on the toolset instance across invocations.'
  signature: 'def get_auth_config(self) -> typing.Optional[google.adk.auth.auth_tool.AuthConfig]:'
- rank: 1764
  id: google.adk.tools.openapi_tool.openapi_spec_parser.openapi_toolset.OpenAPIToolset.get_tool
  name: get_tool
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/openapi_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Get a tool by name.
  signature: 'def get_tool(self, tool_name: str) -> typing.Optional[google.adk.tools.openapi_tool.openapi_spec_parser.rest_api_tool.RestApiTool]:'
- rank: 1765
  id: google.adk.tools.openapi_tool.openapi_spec_parser.openapi_toolset.OpenAPIToolset.get_tools
  name: get_tools
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/openapi_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Get all tools in the toolset.
  signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> typing.List[google.adk.tools.openapi_tool.openapi_spec_parser.rest_api_tool.RestApiTool]:'
- rank: 1766
  id: google.adk.tools.openapi_tool.openapi_spec_parser.operation_parser
  name: operation_parser
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/operation_parser.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1767
  id: google.adk.tools.openapi_tool.openapi_spec_parser.operation_parser.OperationParser
  name: OperationParser
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/operation_parser.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Generates parameters for Python functions from an OpenAPI operation.


    This class processes an OpenApiOperation object and provides helper methods

    to extract information needed to generate Python function declarations,

    docstrings, signatures, and JSON schemas.  It handles parameter processing,

    name deduplication, and type hint generation.'
  constructor_signature: 'def __init__(self, operation: typing.Union[fastapi.openapi.models.Operation, typing.Dict[str, typing.Any], str], should_parse):'
  aliases:
  - google.adk.tools.openapi_tool.openapi_spec_parser.OperationParser
  methods:
  - signature: 'def load(cls, operation: typing.Union[fastapi.openapi.models.Operation, typing.Dict[str, typing.Any]], params: typing.List[google.adk.tools.openapi_tool.common.common.ApiParameter], return_value: typing.Optional[google.adk.tools.openapi_tool.common.common.ApiParameter]) -> google.adk.tools.openapi_tool.openapi_spec_parser.operation_parser.OperationParser:'
  - signature: 'def get_function_name(self) -> str:'
    docstring: Returns the generated function name.
  - signature: 'def get_return_type_hint(self) -> str:'
    docstring: Returns the return type hint string (like 'str', 'int', etc.).
  - signature: 'def get_return_type_value(self) -> typing.Any:'
    docstring: Returns the return type value (like str, int, List[str], etc.).
  - signature: 'def get_parameters(self) -> typing.List[google.adk.tools.openapi_tool.common.common.ApiParameter]:'
    docstring: Returns the list of Parameter objects.
  - signature: 'def get_return_value(self) -> google.adk.tools.openapi_tool.common.common.ApiParameter:'
    docstring: Returns the list of Parameter objects.
  - signature: 'def get_auth_scheme_name(self) -> str:'
    docstring: Returns the name of the auth scheme for this operation from the spec.
  - signature: 'def get_pydoc_string(self) -> str:'
    docstring: Returns the generated PyDoc string.
  - signature: 'def get_json_schema(self) -> typing.Dict[str, typing.Any]:'
    docstring: Returns the JSON schema for the function arguments.
  - signature: 'def get_signature_parameters(self) -> typing.List[inspect.Parameter]:'
    docstring: Returns a list of inspect.Parameter objects for the function.
  - signature: 'def get_annotations(self) -> typing.Dict[str, typing.Any]:'
    docstring: Returns a dictionary of parameter annotations for the function.
- rank: 1768
  id: google.adk.tools.openapi_tool.openapi_spec_parser.operation_parser.OperationParser.__init__
  name: __init__
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/operation_parser.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the OperationParser with an OpenApiOperation.\n\nArgs:\n    operation: The OpenApiOperation object or a dictionary to process.\n    should_parse: Whether to parse the operation during initialization."
  signature: 'def __init__(self, operation: typing.Union[fastapi.openapi.models.Operation, typing.Dict[str, typing.Any], str], should_parse):'
- rank: 1769
  id: google.adk.tools.openapi_tool.openapi_spec_parser.operation_parser.OperationParser.get_annotations
  name: get_annotations
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/operation_parser.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns a dictionary of parameter annotations for the function.
  signature: 'def get_annotations(self) -> typing.Dict[str, typing.Any]:'
- rank: 1770
  id: google.adk.tools.openapi_tool.openapi_spec_parser.operation_parser.OperationParser.get_auth_scheme_name
  name: get_auth_scheme_name
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/operation_parser.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns the name of the auth scheme for this operation from the spec.
  signature: 'def get_auth_scheme_name(self) -> str:'
- rank: 1771
  id: google.adk.tools.openapi_tool.openapi_spec_parser.operation_parser.OperationParser.get_function_name
  name: get_function_name
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/operation_parser.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns the generated function name.
  signature: 'def get_function_name(self) -> str:'
- rank: 1772
  id: google.adk.tools.openapi_tool.openapi_spec_parser.operation_parser.OperationParser.get_json_schema
  name: get_json_schema
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/operation_parser.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns the JSON schema for the function arguments.
  signature: 'def get_json_schema(self) -> typing.Dict[str, typing.Any]:'
- rank: 1773
  id: google.adk.tools.openapi_tool.openapi_spec_parser.operation_parser.OperationParser.get_pydoc_string
  name: get_pydoc_string
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/operation_parser.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns the generated PyDoc string.
  signature: 'def get_pydoc_string(self) -> str:'
- rank: 1774
  id: google.adk.tools.openapi_tool.openapi_spec_parser.operation_parser.OperationParser.get_signature_parameters
  name: get_signature_parameters
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/operation_parser.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns a list of inspect.Parameter objects for the function.
  signature: 'def get_signature_parameters(self) -> typing.List[inspect.Parameter]:'
- rank: 1775
  id: google.adk.tools.openapi_tool.openapi_spec_parser.operation_parser.OperationParser.load
  name: load
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/operation_parser.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def load(cls, operation: typing.Union[fastapi.openapi.models.Operation, typing.Dict[str, typing.Any]], params: typing.List[google.adk.tools.openapi_tool.common.common.ApiParameter], return_value: typing.Optional[google.adk.tools.openapi_tool.common.common.ApiParameter]) -> google.adk.tools.openapi_tool.openapi_spec_parser.operation_parser.OperationParser:'
- rank: 1776
  id: google.adk.tools.openapi_tool.openapi_spec_parser.rest_api_tool
  name: rest_api_tool
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/rest_api_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def snake_to_lower_camel(snake_case_string: str):'
    docstring: "Converts a snake_case string to a lower_camel_case string.\n\nArgs:\n    snake_case_string: The input snake_case string.\n\nReturns:\n    The lower_camel_case string."
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: 'AuthPreparationState: Any'
- rank: 1777
  id: google.adk.tools.openapi_tool.openapi_spec_parser.rest_api_tool.RestApiTool
  name: RestApiTool
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/rest_api_tool.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "A generic tool that interacts with a REST API.\n\n* Generates request params and body\n* Attaches auth credentials to API call.\n\nExample::\n\n  # Each API operation in the spec will be turned into its own tool\n  # Name of the tool is the operationId of that operation, in snake case\n  operations = OperationGenerator().parse(openapi_spec_dict)\n  tool = [RestApiTool.from_parsed_operation(o) for o in operations]\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, name: str, description: str, endpoint: typing.Union[google.adk.tools.openapi_tool.openapi_spec_parser.openapi_spec_parser.OperationEndpoint, str], operation: typing.Union[fastapi.openapi.models.Operation, str], auth_scheme: typing.Optional[typing.Union[google.adk.auth.auth_schemes.AuthScheme, str]], auth_credential: typing.Optional[typing.Union[google.adk.auth.auth_credential.AuthCredential, str]], should_parse_operation, ssl_verify: typing.Optional[typing.Union[bool, str, ssl.SSLContext]], header_provider: typing.Optional[typing.Callable[[ReadonlyContext], typing.Dict[str, str]]], *, credential_key: typing.Optional[str]=None):'
  aliases:
  - google.adk.tools.openapi_tool.openapi_spec_parser.RestApiTool
  methods:
  - signature: 'def from_parsed_operation(cls, parsed: google.adk.tools.openapi_tool.openapi_spec_parser.openapi_spec_parser.ParsedOperation, ssl_verify: typing.Optional[typing.Union[bool, str, ssl.SSLContext]], header_provider: typing.Optional[typing.Callable[[ReadonlyContext], typing.Dict[str, str]]]) -> google.adk.tools.openapi_tool.openapi_spec_parser.rest_api_tool.RestApiTool:'
    docstring: "Initializes the RestApiTool from a ParsedOperation object.\n\nArgs:\n    parsed: A ParsedOperation object.\n    ssl_verify: SSL certificate verification option.\n    header_provider: A callable that returns a dictionary of headers to be\n      included in API requests. The callable receives the ReadonlyContext as\n      an argument, allowing dynamic header generation based on the current\n      context. Useful for adding custom headers like correlation IDs,\n      authentication tokens, or other request metadata.\n\nReturns:\n    A RestApiTool object."
  - signature: 'def from_parsed_operation_str(cls, parsed_operation_str: str) -> google.adk.tools.openapi_tool.openapi_spec_parser.rest_api_tool.RestApiTool:'
    docstring: "Initializes the RestApiTool from a dict.\n\nArgs:\n    parsed: A dict representation of a ParsedOperation object.\n\nReturns:\n    A RestApiTool object."
  - signature: 'def configure_auth_scheme(self, auth_scheme: typing.Union[google.adk.auth.auth_schemes.AuthScheme, typing.Dict[str, typing.Any]]):'
    docstring: "Configures the authentication scheme for the API call.\n\nArgs:\n    auth_scheme: AuthScheme|dict -: The authentication scheme. The dict is\n      converted to a AuthScheme object."
  - signature: 'def configure_auth_credential(self, auth_credential: typing.Optional[typing.Union[google.adk.auth.auth_credential.AuthCredential, str]]):'
    docstring: "Configures the authentication credential for the API call.\n\nArgs:\n    auth_credential: AuthCredential|dict - The authentication credential.\n      The dict is converted to an AuthCredential object."
  - signature: 'def configure_credential_key(self, credential_key: typing.Optional[str]):'
    docstring: Configures the credential key for interactive auth / caching.
  - signature: 'def configure_ssl_verify(self, ssl_verify: typing.Optional[typing.Union[bool, str, ssl.SSLContext]]):'
    docstring: "Configures SSL certificate verification for the API call.\n\nThis is useful for enterprise environments where requests go through a\nTLS-intercepting proxy with a custom CA certificate.\n\nArgs:\n    ssl_verify: SSL certificate verification option. Can be:\n      - None: Use default verification (True)\n      - True: Verify SSL certificates using system CA\n      - False: Disable SSL verification (insecure, not recommended)\n      - str: Path to a CA bundle file or directory for custom CA\n      - ssl.SSLContext: Custom SSL context for advanced configuration"
  - signature: 'def set_default_headers(self, headers: typing.Dict[str, str]):'
    docstring: Sets default headers that are merged into every request.
  - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: typing.Optional[google.adk.tools.tool_context.ToolContext]) -> typing.Dict[str, typing.Any]:'
  - signature: 'def call(self, *, args: dict[str, typing.Any], tool_context: typing.Optional[google.adk.tools.tool_context.ToolContext]) -> typing.Dict[str, typing.Any]:'
    docstring: "Executes the REST API call.\n\nArgs:\n    args: Keyword arguments representing the operation parameters.\n    tool_context: The tool context (not used here, but required by the\n      interface).\n\nReturns:\n    The API response as a dictionary."
  inherited_methods:
    BaseTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
      docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
      docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  inherited_properties:
    BaseTool:
    - signature: 'name: str'
      docstring: The name of the tool.
    - signature: 'description: str'
      docstring: The description of the tool.
    - signature: 'is_long_running: bool'
      docstring: 'Whether the tool is a long running operation, which typically returns a

        resource id first and finishes the operation later.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the BaseTool.


        An optional key-value pair for storing and retrieving tool-specific metadata,

        such as tool manifests, etc.


        NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 1778
  id: google.adk.tools.openapi_tool.openapi_spec_parser.rest_api_tool.RestApiTool.__init__
  name: __init__
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/rest_api_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the RestApiTool with the given parameters.\n\nTo generate RestApiTool from OpenAPI Specs, use OperationGenerator.\nExample::\n\n  # Each API operation in the spec will be turned into its own tool\n  # Name of the tool is the operationId of that operation, in snake case\n  operations = OperationGenerator().parse(openapi_spec_dict)\n  tool = [RestApiTool.from_parsed_operation(o) for o in operations]\n\nHint: Use google.adk.tools.openapi_tool.auth.auth_helpers to construct\nauth_scheme and auth_credential.\n\nArgs:\n    name: The name of the tool.\n    description: The description of the tool.\n    endpoint: Include the base_url, path, and method of the tool.\n    operation: Pydantic object or a dict. Representing the OpenAPI Operation\n      object\n      (https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#operation-object)\n    auth_scheme: The auth scheme of the tool. Representing the OpenAPI\n      SecurityScheme object\n      (https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#security-scheme-object)\n\
    \    auth_credential: The authentication credential of the tool.\n    should_parse_operation: Whether to parse the operation.\n    ssl_verify: SSL certificate verification option. Can be:\n      - None: Use default verification\n      - True: Verify SSL certificates using system CA\n      - False: Disable SSL verification (insecure, not recommended)\n      - str: Path to a CA bundle file or directory for custom CA\n      - ssl.SSLContext: Custom SSL context for advanced configuration\n    header_provider: A callable that returns a dictionary of headers to be\n      included in API requests. The callable receives the ReadonlyContext as\n      an argument, allowing dynamic header generation based on the current\n      context. Useful for adding custom headers like correlation IDs,\n      authentication tokens, or other request metadata.\n    credential_key: Optional stable key used for interactive auth and\n      credential caching."
  signature: 'def __init__(self, name: str, description: str, endpoint: typing.Union[google.adk.tools.openapi_tool.openapi_spec_parser.openapi_spec_parser.OperationEndpoint, str], operation: typing.Union[fastapi.openapi.models.Operation, str], auth_scheme: typing.Optional[typing.Union[google.adk.auth.auth_schemes.AuthScheme, str]], auth_credential: typing.Optional[typing.Union[google.adk.auth.auth_credential.AuthCredential, str]], should_parse_operation, ssl_verify: typing.Optional[typing.Union[bool, str, ssl.SSLContext]], header_provider: typing.Optional[typing.Callable[[ReadonlyContext], typing.Dict[str, str]]], *, credential_key: typing.Optional[str]=None):'
- rank: 1779
  id: google.adk.tools.openapi_tool.openapi_spec_parser.rest_api_tool.RestApiTool.call
  name: call
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/rest_api_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Executes the REST API call.\n\nArgs:\n    args: Keyword arguments representing the operation parameters.\n    tool_context: The tool context (not used here, but required by the\n      interface).\n\nReturns:\n    The API response as a dictionary."
  signature: 'def call(self, *, args: dict[str, typing.Any], tool_context: typing.Optional[google.adk.tools.tool_context.ToolContext]) -> typing.Dict[str, typing.Any]:'
- rank: 1780
  id: google.adk.tools.openapi_tool.openapi_spec_parser.rest_api_tool.RestApiTool.configure_auth_credential
  name: configure_auth_credential
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/rest_api_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Configures the authentication credential for the API call.\n\nArgs:\n    auth_credential: AuthCredential|dict - The authentication credential.\n      The dict is converted to an AuthCredential object."
  signature: 'def configure_auth_credential(self, auth_credential: typing.Optional[typing.Union[google.adk.auth.auth_credential.AuthCredential, str]]):'
- rank: 1781
  id: google.adk.tools.openapi_tool.openapi_spec_parser.rest_api_tool.RestApiTool.configure_auth_scheme
  name: configure_auth_scheme
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/rest_api_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Configures the authentication scheme for the API call.\n\nArgs:\n    auth_scheme: AuthScheme|dict -: The authentication scheme. The dict is\n      converted to a AuthScheme object."
  signature: 'def configure_auth_scheme(self, auth_scheme: typing.Union[google.adk.auth.auth_schemes.AuthScheme, typing.Dict[str, typing.Any]]):'
- rank: 1782
  id: google.adk.tools.openapi_tool.openapi_spec_parser.rest_api_tool.RestApiTool.configure_ssl_verify
  name: configure_ssl_verify
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/rest_api_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Configures SSL certificate verification for the API call.\n\nThis is useful for enterprise environments where requests go through a\nTLS-intercepting proxy with a custom CA certificate.\n\nArgs:\n    ssl_verify: SSL certificate verification option. Can be:\n      - None: Use default verification (True)\n      - True: Verify SSL certificates using system CA\n      - False: Disable SSL verification (insecure, not recommended)\n      - str: Path to a CA bundle file or directory for custom CA\n      - ssl.SSLContext: Custom SSL context for advanced configuration"
  signature: 'def configure_ssl_verify(self, ssl_verify: typing.Optional[typing.Union[bool, str, ssl.SSLContext]]):'
- rank: 1783
  id: google.adk.tools.openapi_tool.openapi_spec_parser.rest_api_tool.RestApiTool.from_parsed_operation
  name: from_parsed_operation
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/rest_api_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the RestApiTool from a ParsedOperation object.\n\nArgs:\n    parsed: A ParsedOperation object.\n    ssl_verify: SSL certificate verification option.\n    header_provider: A callable that returns a dictionary of headers to be\n      included in API requests. The callable receives the ReadonlyContext as\n      an argument, allowing dynamic header generation based on the current\n      context. Useful for adding custom headers like correlation IDs,\n      authentication tokens, or other request metadata.\n\nReturns:\n    A RestApiTool object."
  signature: 'def from_parsed_operation(cls, parsed: google.adk.tools.openapi_tool.openapi_spec_parser.openapi_spec_parser.ParsedOperation, ssl_verify: typing.Optional[typing.Union[bool, str, ssl.SSLContext]], header_provider: typing.Optional[typing.Callable[[ReadonlyContext], typing.Dict[str, str]]]) -> google.adk.tools.openapi_tool.openapi_spec_parser.rest_api_tool.RestApiTool:'
- rank: 1784
  id: google.adk.tools.openapi_tool.openapi_spec_parser.rest_api_tool.RestApiTool.from_parsed_operation_str
  name: from_parsed_operation_str
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/rest_api_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the RestApiTool from a dict.\n\nArgs:\n    parsed: A dict representation of a ParsedOperation object.\n\nReturns:\n    A RestApiTool object."
  signature: 'def from_parsed_operation_str(cls, parsed_operation_str: str) -> google.adk.tools.openapi_tool.openapi_spec_parser.rest_api_tool.RestApiTool:'
- rank: 1785
  id: google.adk.tools.openapi_tool.openapi_spec_parser.rest_api_tool.RestApiTool.run_async
  name: run_async
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/rest_api_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: typing.Optional[google.adk.tools.tool_context.ToolContext]) -> typing.Dict[str, typing.Any]:'
- rank: 1786
  id: google.adk.tools.openapi_tool.openapi_spec_parser.rest_api_tool.snake_to_lower_camel
  name: snake_to_lower_camel
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/rest_api_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Converts a snake_case string to a lower_camel_case string.\n\nArgs:\n    snake_case_string: The input snake_case string.\n\nReturns:\n    The lower_camel_case string."
  signature: 'def snake_to_lower_camel(snake_case_string: str):'
  aliases:
  - google.adk.tools.openapi_tool.openapi_spec_parser.snake_to_lower_camel
- rank: 1787
  id: google.adk.tools.openapi_tool.openapi_spec_parser.tool_auth_handler
  name: tool_auth_handler
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/tool_auth_handler.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: 'AuthPreparationState: Any'
- rank: 1788
  id: google.adk.tools.openapi_tool.openapi_spec_parser.tool_auth_handler.AuthPreparationResult
  name: AuthPreparationResult
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/tool_auth_handler.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Result of the credential preparation process.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, state: google.adk.tools.openapi_tool.openapi_spec_parser.tool_auth_handler.AuthPreparationState, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme] = None, auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential] = None):'
  properties:
  - signature: 'state: google.adk.tools.openapi_tool.openapi_spec_parser.tool_auth_handler.AuthPreparationState'
  - signature: 'auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme]'
  - signature: 'auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1789
  id: google.adk.tools.openapi_tool.openapi_spec_parser.tool_auth_handler.ToolAuthHandler
  name: ToolAuthHandler
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/tool_auth_handler.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Handles the preparation and exchange of authentication credentials for tools.
  constructor_signature: 'def __init__(self, tool_context: google.adk.tools.tool_context.ToolContext, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme], auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential], credential_exchanger: typing.Optional[google.adk.tools.openapi_tool.auth.credential_exchangers.base_credential_exchanger.BaseAuthCredentialExchanger], credential_store: typing.Optional[google.adk.tools.openapi_tool.openapi_spec_parser.tool_auth_handler.ToolContextCredentialStore], *, credential_key: typing.Optional[str]=None):'
  methods:
  - signature: 'def from_tool_context(cls, tool_context: google.adk.tools.tool_context.ToolContext, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme], auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential], credential_exchanger: typing.Optional[google.adk.tools.openapi_tool.auth.credential_exchangers.base_credential_exchanger.BaseAuthCredentialExchanger], *, credential_key: typing.Optional[str]=None) -> google.adk.tools.openapi_tool.openapi_spec_parser.tool_auth_handler.ToolAuthHandler:'
    docstring: Creates a ToolAuthHandler instance from a ToolContext.
  - signature: 'def prepare_auth_credentials(self) -> google.adk.tools.openapi_tool.openapi_spec_parser.tool_auth_handler.AuthPreparationResult:'
    docstring: Prepares authentication credentials, handling exchange and user interaction.
- rank: 1790
  id: google.adk.tools.openapi_tool.openapi_spec_parser.tool_auth_handler.ToolAuthHandler.__init__
  name: __init__
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/tool_auth_handler.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, tool_context: google.adk.tools.tool_context.ToolContext, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme], auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential], credential_exchanger: typing.Optional[google.adk.tools.openapi_tool.auth.credential_exchangers.base_credential_exchanger.BaseAuthCredentialExchanger], credential_store: typing.Optional[google.adk.tools.openapi_tool.openapi_spec_parser.tool_auth_handler.ToolContextCredentialStore], *, credential_key: typing.Optional[str]=None):'
- rank: 1791
  id: google.adk.tools.openapi_tool.openapi_spec_parser.tool_auth_handler.ToolAuthHandler.from_tool_context
  name: from_tool_context
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/tool_auth_handler.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Creates a ToolAuthHandler instance from a ToolContext.
  signature: 'def from_tool_context(cls, tool_context: google.adk.tools.tool_context.ToolContext, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme], auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential], credential_exchanger: typing.Optional[google.adk.tools.openapi_tool.auth.credential_exchangers.base_credential_exchanger.BaseAuthCredentialExchanger], *, credential_key: typing.Optional[str]=None) -> google.adk.tools.openapi_tool.openapi_spec_parser.tool_auth_handler.ToolAuthHandler:'
- rank: 1792
  id: google.adk.tools.openapi_tool.openapi_spec_parser.tool_auth_handler.ToolAuthHandler.prepare_auth_credentials
  name: prepare_auth_credentials
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/tool_auth_handler.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Prepares authentication credentials, handling exchange and user interaction.
  signature: 'def prepare_auth_credentials(self) -> google.adk.tools.openapi_tool.openapi_spec_parser.tool_auth_handler.AuthPreparationResult:'
- rank: 1793
  id: google.adk.tools.openapi_tool.openapi_spec_parser.tool_auth_handler.ToolContextCredentialStore
  name: ToolContextCredentialStore
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/tool_auth_handler.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: Handles storage and retrieval of credentials within a ToolContext.
  constructor_signature: 'def __init__(self, tool_context: google.adk.tools.tool_context.ToolContext):'
  methods:
  - signature: 'def get_credential_key(self, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme], auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]) -> str:'
    docstring: Generates a unique key for the given auth scheme and credential.
  - signature: 'def get_credential(self, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme], auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]) -> typing.Optional[google.adk.auth.auth_credential.AuthCredential]:'
  - signature: 'def store_credential(self, key: str, auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]):'
  - signature: 'def remove_credential(self, key: str):'
- rank: 1794
  id: google.adk.tools.openapi_tool.openapi_spec_parser.tool_auth_handler.ToolContextCredentialStore.get_credential
  name: get_credential
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/tool_auth_handler.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_credential(self, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme], auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]) -> typing.Optional[google.adk.auth.auth_credential.AuthCredential]:'
- rank: 1795
  id: google.adk.tools.openapi_tool.openapi_spec_parser.tool_auth_handler.ToolContextCredentialStore.get_credential_key
  name: get_credential_key
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/tool_auth_handler.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Generates a unique key for the given auth scheme and credential.
  signature: 'def get_credential_key(self, auth_scheme: typing.Optional[google.adk.auth.auth_schemes.AuthScheme], auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]) -> str:'
- rank: 1796
  id: google.adk.tools.openapi_tool.openapi_spec_parser.tool_auth_handler.ToolContextCredentialStore.store_credential
  name: store_credential
  file_path: src/google/adk/tools/openapi_tool/openapi_spec_parser/tool_auth_handler.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def store_credential(self, key: str, auth_credential: typing.Optional[google.adk.auth.auth_credential.AuthCredential]):'
- rank: 1797
  id: google.adk.tools.preload_memory_tool
  name: preload_memory_tool
  file_path: src/google/adk/tools/preload_memory_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: 'preload_memory_tool: PreloadMemoryTool'
- rank: 1798
  id: google.adk.tools.preload_memory_tool.PreloadMemoryTool
  name: PreloadMemoryTool
  file_path: src/google/adk/tools/preload_memory_tool.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A tool that preloads the memory for the current user.


    This tool will be automatically executed for each llm_request, and it won''t be

    called by the model.


    NOTE: Currently this tool only uses text part from the memory.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self):'
  methods:
  - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.LlmRequest) -> None:'
  inherited_methods:
    BaseTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
      docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
      docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  inherited_properties:
    BaseTool:
    - signature: 'name: str'
      docstring: The name of the tool.
    - signature: 'description: str'
      docstring: The description of the tool.
    - signature: 'is_long_running: bool'
      docstring: 'Whether the tool is a long running operation, which typically returns a

        resource id first and finishes the operation later.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the BaseTool.


        An optional key-value pair for storing and retrieving tool-specific metadata,

        such as tool manifests, etc.


        NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 1799
  id: google.adk.tools.preload_memory_tool.PreloadMemoryTool.__init__
  name: __init__
  file_path: src/google/adk/tools/preload_memory_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self):'
- rank: 1800
  id: google.adk.tools.preload_memory_tool.PreloadMemoryTool.process_llm_request
  name: process_llm_request
  file_path: src/google/adk/tools/preload_memory_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.LlmRequest) -> None:'
- rank: 1801
  id: google.adk.tools.pubsub
  name: pubsub
  file_path: src/google/adk/tools/pubsub/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: "Pub/Sub Tools (Experimental).\n\nPub/Sub Tools under this module are handcrafted and customized while the tools\nunder google.adk.tools.google_api_tool are auto generated based on API\ndefinition. The rationales to have customized tool are:\n\n1. Better handling of base64 encoding for published messages.\n2. A richer subscribe-side API that reflects how users may want to pull/ack\n   messages."
  properties:
  - signature: '__all__: Any'
- rank: 1802
  id: google.adk.tools.pubsub.client
  name: client
  file_path: src/google/adk/tools/pubsub/client.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def get_publisher_client(*, credentials: google.auth.credentials.Credentials, user_agent: str | list[str] | None=None, publisher_options: pubsub_v1.types.PublisherOptions | None=None) -> google.cloud.pubsub_v1.PublisherClient:'
    docstring: "Get a Pub/Sub Publisher client.\n\nArgs:\n  credentials: The credentials to use for the request.\n  user_agent: The user agent to use for the request.\n  publisher_options: The publisher options to use for the request.\n\nReturns:\n  A Pub/Sub Publisher client."
  - signature: 'def get_subscriber_client(*, credentials: google.auth.credentials.Credentials, user_agent: str | list[str] | None=None) -> google.cloud.pubsub_v1.SubscriberClient:'
    docstring: "Get a Pub/Sub Subscriber client.\n\nArgs:\n  credentials: The credentials to use for the request.\n  user_agent: The user agent to use for the request.\n\nReturns:\n  A Pub/Sub Subscriber client."
  - signature: 'def cleanup_clients():'
    docstring: Clean up all cached Pub/Sub clients.
  properties:
  - signature: 'USER_AGENT: Any'
  - signature: '_CACHE_TTL: int'
  - signature: '_publisher_client_cache: Any'
  - signature: '_publisher_client_lock: threading.Lock'
  - signature: '_subscriber_client_cache: Any'
  - signature: '_subscriber_client_lock: threading.Lock'
- rank: 1803
  id: google.adk.tools.pubsub.client.cleanup_clients
  name: cleanup_clients
  file_path: src/google/adk/tools/pubsub/client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Clean up all cached Pub/Sub clients.
  signature: 'def cleanup_clients():'
- rank: 1804
  id: google.adk.tools.pubsub.client.get_publisher_client
  name: get_publisher_client
  file_path: src/google/adk/tools/pubsub/client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Get a Pub/Sub Publisher client.\n\nArgs:\n  credentials: The credentials to use for the request.\n  user_agent: The user agent to use for the request.\n  publisher_options: The publisher options to use for the request.\n\nReturns:\n  A Pub/Sub Publisher client."
  signature: 'def get_publisher_client(*, credentials: google.auth.credentials.Credentials, user_agent: str | list[str] | None=None, publisher_options: pubsub_v1.types.PublisherOptions | None=None) -> google.cloud.pubsub_v1.PublisherClient:'
- rank: 1805
  id: google.adk.tools.pubsub.client.get_subscriber_client
  name: get_subscriber_client
  file_path: src/google/adk/tools/pubsub/client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Get a Pub/Sub Subscriber client.\n\nArgs:\n  credentials: The credentials to use for the request.\n  user_agent: The user agent to use for the request.\n\nReturns:\n  A Pub/Sub Subscriber client."
  signature: 'def get_subscriber_client(*, credentials: google.auth.credentials.Credentials, user_agent: str | list[str] | None=None) -> google.cloud.pubsub_v1.SubscriberClient:'
- rank: 1806
  id: google.adk.tools.pubsub.config
  name: config
  file_path: src/google/adk/tools/pubsub/config.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1807
  id: google.adk.tools.pubsub.config.PubSubToolConfig
  name: PubSubToolConfig
  file_path: src/google/adk/tools/pubsub/config.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Configuration for Pub/Sub tools.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, project_id: str | None = None):'
  aliases:
  - google.adk.tools.pubsub.PubSubToolConfig
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'project_id: str | None'
    docstring: 'GCP project ID to use for the Pub/Sub operations.


      If not set, the project ID will be inferred from the environment or

      credentials.'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1808
  id: google.adk.tools.pubsub.message_tool
  name: message_tool
  file_path: src/google/adk/tools/pubsub/message_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def publish_message(topic_name: str, message: str, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.pubsub.config.PubSubToolConfig, attributes: typing.Optional[dict[str, str]], ordering_key: str) -> dict:'
    docstring: "Publish a message to a Pub/Sub topic.\n\nArgs:\n    topic_name (str): The Pub/Sub topic name (e.g.\n      projects/my-project/topics/my-topic).\n    message (str): The message content to publish.\n    credentials (Credentials): The credentials to use for the request.\n    settings (PubSubToolConfig): The Pub/Sub tool settings.\n    attributes (Optional[dict[str, str]]): Attributes to attach to the message.\n    ordering_key (str): Ordering key for the message.\n\nReturns:\n    dict: Dictionary with the message_id of the published message."
  - signature: 'def pull_messages(subscription_name: str, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.pubsub.config.PubSubToolConfig, *, max_messages: int=1, auto_ack: bool=False) -> dict:'
    docstring: "Pull messages from a Pub/Sub subscription.\n\nArgs:\n    subscription_name (str): The Pub/Sub subscription name (e.g.\n      projects/my-project/subscriptions/my-sub).\n    credentials (Credentials): The credentials to use for the request.\n    settings (PubSubToolConfig): The Pub/Sub tool settings.\n    max_messages (int): The maximum number of messages to pull. Defaults to 1.\n    auto_ack (bool): Whether to automatically acknowledge the messages.\n      Defaults to False.\n\nReturns:\n    dict: Dictionary with the list of pulled messages."
  - signature: 'def acknowledge_messages(subscription_name: str, ack_ids: list[str], credentials: google.auth.credentials.Credentials, settings: google.adk.tools.pubsub.config.PubSubToolConfig) -> dict:'
    docstring: "Acknowledge messages on a Pub/Sub subscription.\n\nArgs:\n    subscription_name (str): The Pub/Sub subscription name (e.g.\n      projects/my-project/subscriptions/my-sub).\n    ack_ids (list[str]): List of acknowledgment IDs to acknowledge.\n    credentials (Credentials): The credentials to use for the request.\n    settings (PubSubToolConfig): The Pub/Sub tool settings.\n\nReturns:\n    dict: Status of the operation."
- rank: 1809
  id: google.adk.tools.pubsub.message_tool.acknowledge_messages
  name: acknowledge_messages
  file_path: src/google/adk/tools/pubsub/message_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Acknowledge messages on a Pub/Sub subscription.\n\nArgs:\n    subscription_name (str): The Pub/Sub subscription name (e.g.\n      projects/my-project/subscriptions/my-sub).\n    ack_ids (list[str]): List of acknowledgment IDs to acknowledge.\n    credentials (Credentials): The credentials to use for the request.\n    settings (PubSubToolConfig): The Pub/Sub tool settings.\n\nReturns:\n    dict: Status of the operation."
  signature: 'def acknowledge_messages(subscription_name: str, ack_ids: list[str], credentials: google.auth.credentials.Credentials, settings: google.adk.tools.pubsub.config.PubSubToolConfig) -> dict:'
- rank: 1810
  id: google.adk.tools.pubsub.message_tool.publish_message
  name: publish_message
  file_path: src/google/adk/tools/pubsub/message_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Publish a message to a Pub/Sub topic.\n\nArgs:\n    topic_name (str): The Pub/Sub topic name (e.g.\n      projects/my-project/topics/my-topic).\n    message (str): The message content to publish.\n    credentials (Credentials): The credentials to use for the request.\n    settings (PubSubToolConfig): The Pub/Sub tool settings.\n    attributes (Optional[dict[str, str]]): Attributes to attach to the message.\n    ordering_key (str): Ordering key for the message.\n\nReturns:\n    dict: Dictionary with the message_id of the published message."
  signature: 'def publish_message(topic_name: str, message: str, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.pubsub.config.PubSubToolConfig, attributes: typing.Optional[dict[str, str]], ordering_key: str) -> dict:'
- rank: 1811
  id: google.adk.tools.pubsub.message_tool.pull_messages
  name: pull_messages
  file_path: src/google/adk/tools/pubsub/message_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Pull messages from a Pub/Sub subscription.\n\nArgs:\n    subscription_name (str): The Pub/Sub subscription name (e.g.\n      projects/my-project/subscriptions/my-sub).\n    credentials (Credentials): The credentials to use for the request.\n    settings (PubSubToolConfig): The Pub/Sub tool settings.\n    max_messages (int): The maximum number of messages to pull. Defaults to 1.\n    auto_ack (bool): Whether to automatically acknowledge the messages.\n      Defaults to False.\n\nReturns:\n    dict: Dictionary with the list of pulled messages."
  signature: 'def pull_messages(subscription_name: str, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.pubsub.config.PubSubToolConfig, *, max_messages: int=1, auto_ack: bool=False) -> dict:'
- rank: 1812
  id: google.adk.tools.pubsub.pubsub_credentials
  name: pubsub_credentials
  file_path: src/google/adk/tools/pubsub/pubsub_credentials.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'PUBSUB_TOKEN_CACHE_KEY: str'
  - signature: 'PUBSUB_DEFAULT_SCOPE: Any'
- rank: 1813
  id: google.adk.tools.pubsub.pubsub_toolset
  name: pubsub_toolset
  file_path: src/google/adk/tools/pubsub/pubsub_toolset.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1814
  id: google.adk.tools.pubsub.pubsub_toolset.PubSubToolset
  name: PubSubToolset
  file_path: src/google/adk/tools/pubsub/pubsub_toolset.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Pub/Sub Toolset contains tools for interacting with Pub/Sub topics and subscriptions.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, *, tool_filter: ToolPredicate | list[str] | None=None, credentials_config: PubSubCredentialsConfig | None=None, pubsub_tool_config: PubSubToolConfig | None=None):'
  aliases:
  - google.adk.tools.pubsub.PubSubToolset
  methods:
  - signature: 'def get_tools(self, readonly_context: ReadonlyContext | None) -> list[google.adk.tools.base_tool.BaseTool]:'
    docstring: Get tools from the toolset.
  - signature: 'def close(self):'
    docstring: Clean up resources used by the toolset.
  inherited_methods:
    BaseToolset:
    - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools in the toolset based on the provided context.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools available under the specified context."
    - signature: 'def get_tools_with_prefix(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools with optional prefix applied to tool names.\n\nThis method calls get_tools() and applies prefixing if tool_name_prefix is provided.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools with prefixed names if tool_name_prefix is provided."
    - signature: 'def close(self) -> None:'
      docstring: "Performs cleanup and releases resources held by the toolset.\n\nNOTE:\n  This method is invoked, for example, at the end of an agent server's\n  lifecycle or when the toolset is no longer needed. Implementations\n  should ensure that any open connections, files, or other managed\n  resources are properly released to prevent leaks."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_toolset.SelfToolset], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_toolset.SelfToolset:'
      docstring: "Creates a toolset instance from a config.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The toolset instance."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this toolset. This method will be\ncalled before each tool processes the llm request.\n\nUse cases:\n- Instead of let each tool process the llm request, we can let the toolset\n  process the llm request. e.g. ComputerUseToolset can add computer use\n  tool to the llm request.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def get_auth_config(self) -> typing.Optional[google.adk.auth.auth_tool.AuthConfig]:'
      docstring: "Returns the auth config for this toolset. ADK will make sure the\n'exchanged_auth_credential' field in the config is populated with\nready-to-use credential (e.g. oauth token for OAuth flow) before calling\nget_tools method or execute any tools returned by this toolset. Thus toolset\ncan use this credential either for tool listing or tool calling. If tool\ncalling needs a different credential from ADK client, call\ntool_context.request_credential in the tool.\n\nToolsets that support authentication should override this method to return\nan AuthConfig constructed from their auth_scheme, auth_credential, and\noptional credential_key parameters.\n\nReturns:\n  AuthConfig if the toolset has authentication configured, None otherwise."
  omitted_inherited_members_from:
  - ABC
- rank: 1815
  id: google.adk.tools.pubsub.pubsub_toolset.PubSubToolset.__init__
  name: __init__
  file_path: src/google/adk/tools/pubsub/pubsub_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the PubSubToolset.\n\nArgs:\n    tool_filter: A predicate or list of tool names to filter the tools in\n      the toolset. If None, all tools are included.\n    credentials_config: The credentials configuration to use for\n      authenticating with Google Cloud.\n    pubsub_tool_config: The configuration for the Pub/Sub tools."
  signature: 'def __init__(self, *, tool_filter: ToolPredicate | list[str] | None=None, credentials_config: PubSubCredentialsConfig | None=None, pubsub_tool_config: PubSubToolConfig | None=None):'
- rank: 1816
  id: google.adk.tools.pubsub.pubsub_toolset.PubSubToolset.get_tools
  name: get_tools
  file_path: src/google/adk/tools/pubsub/pubsub_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Get tools from the toolset.
  signature: 'def get_tools(self, readonly_context: ReadonlyContext | None) -> list[google.adk.tools.base_tool.BaseTool]:'
- rank: 1817
  id: google.adk.tools.retrieval
  name: retrieval
  file_path: src/google/adk/tools/retrieval/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: '__all__: Any'
- rank: 1818
  id: google.adk.tools.retrieval.base_retrieval_tool
  name: base_retrieval_tool
  file_path: src/google/adk/tools/retrieval/base_retrieval_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1819
  id: google.adk.tools.retrieval.base_retrieval_tool.BaseRetrievalTool
  name: BaseRetrievalTool
  file_path: src/google/adk/tools/retrieval/base_retrieval_tool.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, *, name, description, is_long_running: bool=False, custom_metadata: typing.Optional[dict[str, typing.Any]]=None):'
  inherited_methods:
    BaseTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
      docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
      docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  inherited_properties:
    BaseTool:
    - signature: 'name: str'
      docstring: The name of the tool.
    - signature: 'description: str'
      docstring: The description of the tool.
    - signature: 'is_long_running: bool'
      docstring: 'Whether the tool is a long running operation, which typically returns a

        resource id first and finishes the operation later.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the BaseTool.


        An optional key-value pair for storing and retrieving tool-specific metadata,

        such as tool manifests, etc.


        NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 1820
  id: google.adk.tools.retrieval.files_retrieval
  name: files_retrieval
  file_path: src/google/adk/tools/retrieval/files_retrieval.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Provides data for the agent.
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 1821
  id: google.adk.tools.retrieval.files_retrieval.FilesRetrieval
  name: FilesRetrieval
  file_path: src/google/adk/tools/retrieval/files_retrieval.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, *, name: str, description: str, input_dir: str, embedding_model: typing.Optional[llama_index.core.base.embeddings.base.BaseEmbedding]=None):'
  inherited_methods:
    LlamaIndexRetrieval:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
    BaseTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
      docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
      docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  inherited_properties:
    BaseTool:
    - signature: 'name: str'
      docstring: The name of the tool.
    - signature: 'description: str'
      docstring: The description of the tool.
    - signature: 'is_long_running: bool'
      docstring: 'Whether the tool is a long running operation, which typically returns a

        resource id first and finishes the operation later.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the BaseTool.


        An optional key-value pair for storing and retrieving tool-specific metadata,

        such as tool manifests, etc.


        NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 1822
  id: google.adk.tools.retrieval.files_retrieval.FilesRetrieval.__init__
  name: __init__
  file_path: src/google/adk/tools/retrieval/files_retrieval.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initialize FilesRetrieval with optional embedding model.\n\nArgs:\n  name: Name of the tool.\n  description: Description of the tool.\n  input_dir: Directory path containing files to index.\n  embedding_model: Optional custom embedding model. If None, defaults to\n    Google's text-embedding-004 model."
  signature: 'def __init__(self, *, name: str, description: str, input_dir: str, embedding_model: typing.Optional[llama_index.core.base.embeddings.base.BaseEmbedding]=None):'
- rank: 1823
  id: google.adk.tools.retrieval.llama_index_retrieval
  name: llama_index_retrieval
  file_path: src/google/adk/tools/retrieval/llama_index_retrieval.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Provides data for the agent.
- rank: 1824
  id: google.adk.tools.retrieval.llama_index_retrieval.LlamaIndexRetrieval
  name: LlamaIndexRetrieval
  file_path: src/google/adk/tools/retrieval/llama_index_retrieval.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: '[Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, *, name: str, description: str, retriever: llama_index.core.base.base_retriever.BaseRetriever):'
  methods:
  - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
  inherited_methods:
    BaseTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
      docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
      docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  inherited_properties:
    BaseTool:
    - signature: 'name: str'
      docstring: The name of the tool.
    - signature: 'description: str'
      docstring: The description of the tool.
    - signature: 'is_long_running: bool'
      docstring: 'Whether the tool is a long running operation, which typically returns a

        resource id first and finishes the operation later.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the BaseTool.


        An optional key-value pair for storing and retrieving tool-specific metadata,

        such as tool manifests, etc.


        NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 1825
  id: google.adk.tools.retrieval.llama_index_retrieval.LlamaIndexRetrieval.run_async
  name: run_async
  file_path: src/google/adk/tools/retrieval/llama_index_retrieval.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
- rank: 1826
  id: google.adk.tools.retrieval.vertex_ai_rag_retrieval
  name: vertex_ai_rag_retrieval
  file_path: src/google/adk/tools/retrieval/vertex_ai_rag_retrieval.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: A retrieval tool that uses Vertex AI RAG to retrieve data.
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 1827
  id: google.adk.tools.retrieval.vertex_ai_rag_retrieval.VertexAiRagRetrieval.__init__
  name: __init__
  file_path: src/google/adk/tools/retrieval/vertex_ai_rag_retrieval.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, *, name: str, description: str, rag_corpora: list[str]=None, rag_resources: list[google.adk.dependencies.vertexai.rag.RagResource]=None, similarity_top_k: int=None, vector_distance_threshold: float=None):'
- rank: 1828
  id: google.adk.tools.retrieval.vertex_ai_rag_retrieval.VertexAiRagRetrieval.process_llm_request
  name: process_llm_request
  file_path: src/google/adk/tools/retrieval/vertex_ai_rag_retrieval.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.LlmRequest) -> None:'
- rank: 1829
  id: google.adk.tools.retrieval.vertex_ai_rag_retrieval.VertexAiRagRetrieval.run_async
  name: run_async
  file_path: src/google/adk/tools/retrieval/vertex_ai_rag_retrieval.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
- rank: 1830
  id: google.adk.tools.set_model_response_tool
  name: set_model_response_tool
  file_path: src/google/adk/tools/set_model_response_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Tool for setting model response when using output_schema with other tools.
  properties:
  - signature: 'MODEL_JSON_RESPONSE_KEY: str'
- rank: 1831
  id: google.adk.tools.set_model_response_tool.SetModelResponseTool
  name: SetModelResponseTool
  file_path: src/google/adk/tools/set_model_response_tool.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Internal tool used for output schema workaround.


    This tool allows the model to set its final response when output_schema

    is configured alongside other tools. The model should use this tool to

    provide its final structured response instead of outputting text directly.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, output_schema: type[pydantic.BaseModel]):'
  methods:
  - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> dict[str, typing.Any]:'
    docstring: "Process the model's response and return the validated dict.\n\nArgs:\n  args: The structured response data matching the output schema.\n  tool_context: Tool execution context.\n\nReturns:\n  The validated response as dict."
  inherited_methods:
    BaseTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
      docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
      docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  inherited_properties:
    BaseTool:
    - signature: 'name: str'
      docstring: The name of the tool.
    - signature: 'description: str'
      docstring: The description of the tool.
    - signature: 'is_long_running: bool'
      docstring: 'Whether the tool is a long running operation, which typically returns a

        resource id first and finishes the operation later.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the BaseTool.


        An optional key-value pair for storing and retrieving tool-specific metadata,

        such as tool manifests, etc.


        NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 1832
  id: google.adk.tools.set_model_response_tool.SetModelResponseTool.__init__
  name: __init__
  file_path: src/google/adk/tools/set_model_response_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initialize the tool with the expected output schema.\n\nArgs:\n  output_schema: The pydantic model class defining the expected output\n    structure."
  signature: 'def __init__(self, output_schema: type[pydantic.BaseModel]):'
- rank: 1833
  id: google.adk.tools.set_model_response_tool.SetModelResponseTool.run_async
  name: run_async
  file_path: src/google/adk/tools/set_model_response_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Process the model's response and return the validated dict.\n\nArgs:\n  args: The structured response data matching the output schema.\n  tool_context: Tool execution context.\n\nReturns:\n  The validated response as dict."
  signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> dict[str, typing.Any]:'
- rank: 1834
  id: google.adk.tools.spanner
  name: spanner
  file_path: src/google/adk/tools/spanner/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: 'Spanner Tools (Experimental).


    Spanner Tools under this module are hand crafted and customized while the tools

    under google.adk.tools.google_api_tool are auto generated based on API

    definition. The rationales to have customized tool are:


    1. A dedicated Spanner toolset to provide an easier, integrated way to interact

    with Spanner database and tables for building AI Agent applications quickly.

    2. We want to provide more high-level tools like Search, ML.Predict, and Graph

    etc.

    3. We want to provide extra access guardrails and controls in those tools.

    For example, execute_sql can''t arbitrarily mutate existing data.

    4. We want to provide Spanner best practices and knowledge assistants for ad-hoc

    analytics queries.

    5. Use Spanner Toolset for more customization and control to interact with

    Spanner database and tables.'
  properties:
  - signature: 'SpannerCredentialsConfig: Any'
  - signature: '__all__: Any'
- rank: 1835
  id: google.adk.tools.spanner.client
  name: client
  file_path: src/google/adk/tools/spanner/client.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def get_spanner_client(*, project: str, credentials: google.auth.credentials.Credentials) -> google.cloud.spanner.Client:'
    docstring: Get a Spanner client.
  properties:
  - signature: 'USER_AGENT: Any'
- rank: 1836
  id: google.adk.tools.spanner.client.get_spanner_client
  name: get_spanner_client
  file_path: src/google/adk/tools/spanner/client.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Get a Spanner client.
  signature: 'def get_spanner_client(*, project: str, credentials: google.auth.credentials.Credentials) -> google.cloud.spanner.Client:'
- rank: 1837
  id: google.adk.tools.spanner.metadata_tool
  name: metadata_tool
  file_path: src/google/adk/tools/spanner/metadata_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def list_table_names(project_id: str, instance_id: str, database_id: str, credentials: google.auth.credentials.Credentials, named_schema: str) -> dict:'
    docstring: "List tables within the database.\n\nArgs:\n    project_id (str): The Google Cloud project id.\n    instance_id (str): The Spanner instance id.\n    database_id (str): The Spanner database id.\n    credentials (Credentials): The credentials to use for the request.\n    named_schema (str): The named schema to list tables in. Default is empty\n      string \"\" to search for tables in the default schema of the database.\n\nReturns:\n    dict: Dictionary with a list of the Spanner table names.\n\nExamples:\n    >>> list_tables(\"my_project\", \"my_instance\", \"my_database\")\n    {\n      \"status\": \"SUCCESS\",\n      \"results\": [\n        \"table_1\",\n        \"table_2\"\n      ]\n    }"
  - signature: 'def get_table_schema(project_id: str, instance_id: str, database_id: str, table_name: str, credentials: google.auth.credentials.Credentials, named_schema: str) -> dict:'
    docstring: "Get schema and metadata information about a Spanner table.\n\nArgs:\n    project_id (str): The Google Cloud project id.\n    instance_id (str): The Spanner instance id.\n    database_id (str): The Spanner database id.\n    table_id (str): The Spanner table id.\n    credentials (Credentials): The credentials to use for the request.\n    named_schema (str): The named schema to list tables in. Default is empty\n      string \"\" to search for tables in the default schema of the database.\n\nReturns:\n    dict: Dictionary with the Spanner table schema information.\n\nExamples:\n    >>> get_table_schema(\"my_project\", \"my_instance\", \"my_database\",\n    ... \"my_table\")\n    {\n      \"status\": \"SUCCESS\",\n      \"results\":\n        {\n          \"schema\":  {\n            'colA': {\n              'SPANNER_TYPE': 'STRING(1024)',\n              'TABLE_SCHEMA': '',\n              'ORDINAL_POSITION': 1,\n              'COLUMN_DEFAULT': None,\n              'IS_NULLABLE':\
      \ 'NO',\n              'IS_GENERATED': 'NEVER',\n              'GENERATION_EXPRESSION': None,\n              'IS_STORED': None,\n              'KEY_COLUMN_USAGE': [\n                # This part is added if it's a key column\n                {\n                  'CONSTRAINT_NAME': 'PK_Table1',\n                  'ORDINAL_POSITION': 1,\n                  'POSITION_IN_UNIQUE_CONSTRAINT': None\n                }\n              ]\n            },\n            'colB': { ... },\n            ...\n          },\n          \"metadata\": [\n            {\n              'TABLE_SCHEMA': '',\n              'TABLE_NAME': 'MyTable',\n              'TABLE_TYPE': 'BASE TABLE',\n              'PARENT_TABLE_NAME': NULL,\n              'ON_DELETE_ACTION': NULL,\n              'SPANNER_STATE': 'COMMITTED',\n              'INTERLEAVE_TYPE': NULL,\n              'ROW_DELETION_POLICY_EXPRESSION':\n                'OLDER_THAN(CreatedAt, INTERVAL 1 DAY)',\n            }\n          ]\n        }"
  - signature: 'def list_table_indexes(project_id: str, instance_id: str, database_id: str, table_id: str, credentials: google.auth.credentials.Credentials) -> dict:'
    docstring: "Get index information about a Spanner table.\n\nArgs:\n    project_id (str): The Google Cloud project id.\n    instance_id (str): The Spanner instance id.\n    database_id (str): The Spanner database id.\n    table_id (str): The Spanner table id.\n    credentials (Credentials): The credentials to use for the request.\n\nReturns:\n    dict: Dictionary with a list of the Spanner table index information.\n\nExamples:\n    >>> list_table_indexes(\"my_project\", \"my_instance\", \"my_database\",\n    ... \"my_table\")\n    {\n      \"status\": \"SUCCESS\",\n      \"results\": [\n        {\n          'INDEX_NAME': 'IDX_MyTable_Column_FC70CD41F3A5FD3A',\n          'TABLE_SCHEMA': '',\n          'INDEX_TYPE': 'INDEX',\n          'PARENT_TABLE_NAME': '',\n          'IS_UNIQUE': False,\n          'IS_NULL_FILTERED': False,\n          'INDEX_STATE': 'READ_WRITE'\n        },\n        {\n          'INDEX_NAME': 'PRIMARY_KEY',\n          'TABLE_SCHEMA': '',\n          'INDEX_TYPE': 'PRIMARY_KEY',\n\
      \          'PARENT_TABLE_NAME': '',\n          'IS_UNIQUE': True,\n          'IS_NULL_FILTERED': False,\n          'INDEX_STATE': None\n        }\n      ]\n    }"
  - signature: 'def list_table_index_columns(project_id: str, instance_id: str, database_id: str, table_id: str, credentials: google.auth.credentials.Credentials) -> dict:'
    docstring: "Get the columns in each index of a Spanner table.\n\nArgs:\n    project_id (str): The Google Cloud project id.\n    instance_id (str): The Spanner instance id.\n    database_id (str): The Spanner database id.\n    table_id (str): The Spanner table id.\n    credentials (Credentials): The credentials to use for the request.\n\nReturns:\n    dict: Dictionary with a list of Spanner table index column\n    information.\n\nExamples:\n    >>> get_table_index_columns(\"my_project\", \"my_instance\", \"my_database\",\n    ... \"my_table\")\n    {\n      \"status\": \"SUCCESS\",\n      \"results\": [\n        {\n          'INDEX_NAME': 'PRIMARY_KEY',\n          'TABLE_SCHEMA': '',\n          'COLUMN_NAME': 'ColumnKey1',\n          'ORDINAL_POSITION': 1,\n          'IS_NULLABLE': 'NO',\n          'SPANNER_TYPE': 'STRING(MAX)'\n        },\n        {\n          'INDEX_NAME': 'PRIMARY_KEY',\n          'TABLE_SCHEMA': '',\n          'COLUMN_NAME': 'ColumnKey2',\n          'ORDINAL_POSITION':\
      \ 2,\n          'IS_NULLABLE': 'NO',\n          'SPANNER_TYPE': 'INT64'\n        },\n        {\n            'INDEX_NAME': 'IDX_MyTable_Column_FC70CD41F3A5FD3A',\n            'TABLE_SCHEMA': '',\n            'COLUMN_NAME': 'Column',\n            'ORDINAL_POSITION': 3,\n            'IS_NULLABLE': 'NO',\n            'SPANNER_TYPE': 'STRING(MAX)'\n        }\n      ]\n    }"
  - signature: 'def list_named_schemas(project_id: str, instance_id: str, database_id: str, credentials: google.auth.credentials.Credentials) -> dict:'
    docstring: "Get the named schemas in the Spanner database.\n\nArgs:\n    project_id (str): The Google Cloud project id.\n    instance_id (str): The Spanner instance id.\n    database_id (str): The Spanner database id.\n    credentials (Credentials): The credentials to use for the request.\n\nReturns:\n    dict: Dictionary with a list of named schemas information in the Spanner\n    database.\n\nExamples:\n    >>> list_named_schemas(\"my_project\", \"my_instance\", \"my_database\")\n    {\n      \"status\": \"SUCCESS\",\n      \"results\": [\n          \"schema_1\",\n          \"schema_2\"\n        ]\n    }"
- rank: 1838
  id: google.adk.tools.spanner.metadata_tool.get_table_schema
  name: get_table_schema
  file_path: src/google/adk/tools/spanner/metadata_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Get schema and metadata information about a Spanner table.\n\nArgs:\n    project_id (str): The Google Cloud project id.\n    instance_id (str): The Spanner instance id.\n    database_id (str): The Spanner database id.\n    table_id (str): The Spanner table id.\n    credentials (Credentials): The credentials to use for the request.\n    named_schema (str): The named schema to list tables in. Default is empty\n      string \"\" to search for tables in the default schema of the database.\n\nReturns:\n    dict: Dictionary with the Spanner table schema information.\n\nExamples:\n    >>> get_table_schema(\"my_project\", \"my_instance\", \"my_database\",\n    ... \"my_table\")\n    {\n      \"status\": \"SUCCESS\",\n      \"results\":\n        {\n          \"schema\":  {\n            'colA': {\n              'SPANNER_TYPE': 'STRING(1024)',\n              'TABLE_SCHEMA': '',\n              'ORDINAL_POSITION': 1,\n              'COLUMN_DEFAULT': None,\n              'IS_NULLABLE': 'NO',\n\
    \              'IS_GENERATED': 'NEVER',\n              'GENERATION_EXPRESSION': None,\n              'IS_STORED': None,\n              'KEY_COLUMN_USAGE': [\n                # This part is added if it's a key column\n                {\n                  'CONSTRAINT_NAME': 'PK_Table1',\n                  'ORDINAL_POSITION': 1,\n                  'POSITION_IN_UNIQUE_CONSTRAINT': None\n                }\n              ]\n            },\n            'colB': { ... },\n            ...\n          },\n          \"metadata\": [\n            {\n              'TABLE_SCHEMA': '',\n              'TABLE_NAME': 'MyTable',\n              'TABLE_TYPE': 'BASE TABLE',\n              'PARENT_TABLE_NAME': NULL,\n              'ON_DELETE_ACTION': NULL,\n              'SPANNER_STATE': 'COMMITTED',\n              'INTERLEAVE_TYPE': NULL,\n              'ROW_DELETION_POLICY_EXPRESSION':\n                'OLDER_THAN(CreatedAt, INTERVAL 1 DAY)',\n            }\n          ]\n        }"
  signature: 'def get_table_schema(project_id: str, instance_id: str, database_id: str, table_name: str, credentials: google.auth.credentials.Credentials, named_schema: str) -> dict:'
- rank: 1839
  id: google.adk.tools.spanner.metadata_tool.list_named_schemas
  name: list_named_schemas
  file_path: src/google/adk/tools/spanner/metadata_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Get the named schemas in the Spanner database.\n\nArgs:\n    project_id (str): The Google Cloud project id.\n    instance_id (str): The Spanner instance id.\n    database_id (str): The Spanner database id.\n    credentials (Credentials): The credentials to use for the request.\n\nReturns:\n    dict: Dictionary with a list of named schemas information in the Spanner\n    database.\n\nExamples:\n    >>> list_named_schemas(\"my_project\", \"my_instance\", \"my_database\")\n    {\n      \"status\": \"SUCCESS\",\n      \"results\": [\n          \"schema_1\",\n          \"schema_2\"\n        ]\n    }"
  signature: 'def list_named_schemas(project_id: str, instance_id: str, database_id: str, credentials: google.auth.credentials.Credentials) -> dict:'
- rank: 1840
  id: google.adk.tools.spanner.metadata_tool.list_table_index_columns
  name: list_table_index_columns
  file_path: src/google/adk/tools/spanner/metadata_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Get the columns in each index of a Spanner table.\n\nArgs:\n    project_id (str): The Google Cloud project id.\n    instance_id (str): The Spanner instance id.\n    database_id (str): The Spanner database id.\n    table_id (str): The Spanner table id.\n    credentials (Credentials): The credentials to use for the request.\n\nReturns:\n    dict: Dictionary with a list of Spanner table index column\n    information.\n\nExamples:\n    >>> get_table_index_columns(\"my_project\", \"my_instance\", \"my_database\",\n    ... \"my_table\")\n    {\n      \"status\": \"SUCCESS\",\n      \"results\": [\n        {\n          'INDEX_NAME': 'PRIMARY_KEY',\n          'TABLE_SCHEMA': '',\n          'COLUMN_NAME': 'ColumnKey1',\n          'ORDINAL_POSITION': 1,\n          'IS_NULLABLE': 'NO',\n          'SPANNER_TYPE': 'STRING(MAX)'\n        },\n        {\n          'INDEX_NAME': 'PRIMARY_KEY',\n          'TABLE_SCHEMA': '',\n          'COLUMN_NAME': 'ColumnKey2',\n          'ORDINAL_POSITION':\
    \ 2,\n          'IS_NULLABLE': 'NO',\n          'SPANNER_TYPE': 'INT64'\n        },\n        {\n            'INDEX_NAME': 'IDX_MyTable_Column_FC70CD41F3A5FD3A',\n            'TABLE_SCHEMA': '',\n            'COLUMN_NAME': 'Column',\n            'ORDINAL_POSITION': 3,\n            'IS_NULLABLE': 'NO',\n            'SPANNER_TYPE': 'STRING(MAX)'\n        }\n      ]\n    }"
  signature: 'def list_table_index_columns(project_id: str, instance_id: str, database_id: str, table_id: str, credentials: google.auth.credentials.Credentials) -> dict:'
- rank: 1841
  id: google.adk.tools.spanner.metadata_tool.list_table_indexes
  name: list_table_indexes
  file_path: src/google/adk/tools/spanner/metadata_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Get index information about a Spanner table.\n\nArgs:\n    project_id (str): The Google Cloud project id.\n    instance_id (str): The Spanner instance id.\n    database_id (str): The Spanner database id.\n    table_id (str): The Spanner table id.\n    credentials (Credentials): The credentials to use for the request.\n\nReturns:\n    dict: Dictionary with a list of the Spanner table index information.\n\nExamples:\n    >>> list_table_indexes(\"my_project\", \"my_instance\", \"my_database\",\n    ... \"my_table\")\n    {\n      \"status\": \"SUCCESS\",\n      \"results\": [\n        {\n          'INDEX_NAME': 'IDX_MyTable_Column_FC70CD41F3A5FD3A',\n          'TABLE_SCHEMA': '',\n          'INDEX_TYPE': 'INDEX',\n          'PARENT_TABLE_NAME': '',\n          'IS_UNIQUE': False,\n          'IS_NULL_FILTERED': False,\n          'INDEX_STATE': 'READ_WRITE'\n        },\n        {\n          'INDEX_NAME': 'PRIMARY_KEY',\n          'TABLE_SCHEMA': '',\n          'INDEX_TYPE': 'PRIMARY_KEY',\n\
    \          'PARENT_TABLE_NAME': '',\n          'IS_UNIQUE': True,\n          'IS_NULL_FILTERED': False,\n          'INDEX_STATE': None\n        }\n      ]\n    }"
  signature: 'def list_table_indexes(project_id: str, instance_id: str, database_id: str, table_id: str, credentials: google.auth.credentials.Credentials) -> dict:'
- rank: 1842
  id: google.adk.tools.spanner.metadata_tool.list_table_names
  name: list_table_names
  file_path: src/google/adk/tools/spanner/metadata_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "List tables within the database.\n\nArgs:\n    project_id (str): The Google Cloud project id.\n    instance_id (str): The Spanner instance id.\n    database_id (str): The Spanner database id.\n    credentials (Credentials): The credentials to use for the request.\n    named_schema (str): The named schema to list tables in. Default is empty\n      string \"\" to search for tables in the default schema of the database.\n\nReturns:\n    dict: Dictionary with a list of the Spanner table names.\n\nExamples:\n    >>> list_tables(\"my_project\", \"my_instance\", \"my_database\")\n    {\n      \"status\": \"SUCCESS\",\n      \"results\": [\n        \"table_1\",\n        \"table_2\"\n      ]\n    }"
  signature: 'def list_table_names(project_id: str, instance_id: str, database_id: str, credentials: google.auth.credentials.Credentials, named_schema: str) -> dict:'
- rank: 1843
  id: google.adk.tools.spanner.query_tool
  name: query_tool
  file_path: src/google/adk/tools/spanner/query_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def execute_sql(project_id: str, instance_id: str, database_id: str, query: str, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.spanner.settings.SpannerToolSettings, tool_context: google.adk.tools.tool_context.ToolContext) -> dict:'
    docstring: "Run a Spanner Read-Only query in the spanner database and return the result.\n\nArgs:\n    project_id (str): The GCP project id in which the spanner database\n      resides.\n    instance_id (str): The instance id of the spanner database.\n    database_id (str): The database id of the spanner database.\n    query (str): The Spanner SQL query to be executed.\n    credentials (Credentials): The credentials to use for the request.\n    settings (SpannerToolSettings): The settings for the tool.\n    tool_context (ToolContext): The context for the tool.\n\nReturns:\n    dict: Dictionary with the result of the query.\n          If the result contains the key \"result_is_likely_truncated\" with\n          value True, it means that there may be additional rows matching the\n          query not returned in the result.\n\nExamples:\n    <Example>\n      >>> execute_sql(\"my_project\", \"my_instance\", \"my_database\",\n      ... \"SELECT COUNT(*) AS count FROM my_table\")\n      {\n\
      \        \"status\": \"SUCCESS\",\n        \"rows\": [\n          [100]\n        ]\n      }\n    </Example>\n\n    <Example>\n      >>> execute_sql(\"my_project\", \"my_instance\", \"my_database\",\n      ... \"SELECT name, rating, description FROM hotels_table\")\n      {\n        \"status\": \"SUCCESS\",\n        \"rows\": [\n          [\"The Hotel\", 4.1, \"Modern hotel.\"],\n          [\"Park Inn\", 4.5, \"Cozy hotel.\"],\n          ...\n        ]\n      }\n    </Example>\n\nNote:\n  This is running with Read-Only Transaction for query that only read data."
  - signature: 'def get_execute_sql(settings: google.adk.tools.spanner.settings.SpannerToolSettings) -> typing.Callable[Ellipsis, dict]:'
    docstring: "Get the execute_sql tool customized as per the given tool settings.\n\nArgs:\n    settings: Spanner tool settings indicating the behavior of the execute_sql\n      tool.\n\nReturns:\n    callable[..., dict]: A version of the execute_sql tool respecting the tool\n    settings."
  properties:
  - signature: '_EXECUTE_SQL_DICT_LIST_MODE_DOCSTRING: textwrap.dedent'
- rank: 1844
  id: google.adk.tools.spanner.query_tool.execute_sql
  name: execute_sql
  file_path: src/google/adk/tools/spanner/query_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Run a Spanner Read-Only query in the spanner database and return the result.\n\nArgs:\n    project_id (str): The GCP project id in which the spanner database\n      resides.\n    instance_id (str): The instance id of the spanner database.\n    database_id (str): The database id of the spanner database.\n    query (str): The Spanner SQL query to be executed.\n    credentials (Credentials): The credentials to use for the request.\n    settings (SpannerToolSettings): The settings for the tool.\n    tool_context (ToolContext): The context for the tool.\n\nReturns:\n    dict: Dictionary with the result of the query.\n          If the result contains the key \"result_is_likely_truncated\" with\n          value True, it means that there may be additional rows matching the\n          query not returned in the result.\n\nExamples:\n    <Example>\n      >>> execute_sql(\"my_project\", \"my_instance\", \"my_database\",\n      ... \"SELECT COUNT(*) AS count FROM my_table\")\n      {\n\
    \        \"status\": \"SUCCESS\",\n        \"rows\": [\n          [100]\n        ]\n      }\n    </Example>\n\n    <Example>\n      >>> execute_sql(\"my_project\", \"my_instance\", \"my_database\",\n      ... \"SELECT name, rating, description FROM hotels_table\")\n      {\n        \"status\": \"SUCCESS\",\n        \"rows\": [\n          [\"The Hotel\", 4.1, \"Modern hotel.\"],\n          [\"Park Inn\", 4.5, \"Cozy hotel.\"],\n          ...\n        ]\n      }\n    </Example>\n\nNote:\n  This is running with Read-Only Transaction for query that only read data."
  signature: 'def execute_sql(project_id: str, instance_id: str, database_id: str, query: str, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.spanner.settings.SpannerToolSettings, tool_context: google.adk.tools.tool_context.ToolContext) -> dict:'
- rank: 1845
  id: google.adk.tools.spanner.query_tool.get_execute_sql
  name: get_execute_sql
  file_path: src/google/adk/tools/spanner/query_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Get the execute_sql tool customized as per the given tool settings.\n\nArgs:\n    settings: Spanner tool settings indicating the behavior of the execute_sql\n      tool.\n\nReturns:\n    callable[..., dict]: A version of the execute_sql tool respecting the tool\n    settings."
  signature: 'def get_execute_sql(settings: google.adk.tools.spanner.settings.SpannerToolSettings) -> typing.Callable[Ellipsis, dict]:'
- rank: 1846
  id: google.adk.tools.spanner.search_tool
  name: search_tool
  file_path: src/google/adk/tools/spanner/search_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def similarity_search(project_id: str, instance_id: str, database_id: str, table_name: str, query: str, embedding_column_to_search: str, columns: typing.List[str], embedding_options: typing.Dict[str, str], credentials: google.auth.credentials.Credentials, additional_filter: typing.Optional[str], search_options: typing.Optional[typing.Dict[str, typing.Any]]) -> typing.Dict[str, typing.Any]:'
    docstring: "Similarity search in Spanner using a text query.\n\nThe function will use embedding service (provided from options) to embed\nthe text query automatically, then use the embedding vector to do similarity\nsearch and to return requested data. This is suitable when the Spanner table\ncontains a column that stores the embeddings of the data that we want to\nsearch the `query` against.\n\nArgs:\n    project_id (str): The GCP project id in which the spanner database\n      resides.\n    instance_id (str): The instance id of the spanner database.\n    database_id (str): The database id of the spanner database.\n    table_name (str): The name of the table used for vector search.\n    query (str): The user query for which the tool will find the top similar\n      content. The query will be embedded and used for vector search.\n    embedding_column_to_search (str): The name of the column that contains the\n      embeddings of the documents. The tool will do similarity search on this\n\
      \      column.\n    columns (List[str]): A list of column names, representing the additional\n      columns to return in the search results.\n    embedding_options (Dict[str, str]): A dictionary of options to use for\n      the embedding service. **Exactly one of the following three keys\n      MUST be present in this dictionary**:\n      `vertex_ai_embedding_model_name`, `spanner_googlesql_embedding_model_name`,\n      or `spanner_postgresql_vertex_ai_embedding_model_endpoint`.\n      - vertex_ai_embedding_model_name (str): (Supported both **GoogleSQL and\n          PostgreSQL** dialects Spanner database) The name of a\n          public Vertex AI embedding model (e.g., `'text-embedding-005'`).\n          If specified, the tool generates embeddings client-side using the\n          Vertex AI embedding model.\n      - spanner_googlesql_embedding_model_name (str): (For GoogleSQL dialect) The\n        name of the embedding model that is registered in Spanner via a\n        `CREATE MODEL`\
      \ statement. For more details, see\n        https://cloud.google.com/spanner/docs/ml-tutorial-embeddings#generate_and_store_text_embeddings\n        If specified, embedding generation is performed using Spanner's\n        `ML.PREDICT` function.\n      - spanner_postgresql_vertex_ai_embedding_model_endpoint (str):\n        (For PostgreSQL dialect) The fully qualified endpoint of the Vertex AI\n        embedding model, in the format of\n        `projects/$project/locations/$location/publishers/google/models/$model_name`,\n        where $project is the project hosting the Vertex AI endpoint,\n        $location is the location of the endpoint, and $model_name is\n        the name of the text embedding model.\n        If specified, embedding generation is performed using Spanner's\n        `spanner.ML_PREDICT_ROW` function.\n      - output_dimensionality: Optional. The output dimensionality of the\n        embedding. If not specified, the embedding model's default output\n        dimensionality\
      \ will be used.\n    credentials (Credentials): The credentials to use for the request.\n    additional_filter (Optional[str]): An optional filter to apply to the\n      search query. If provided, this will be added to the WHERE clause of the\n      final query.\n    search_options (Optional[Dict[str, Any]]): A dictionary of options to use\n      for the similarity search. The following options are supported:\n      - top_k: The number of most similar documents to return. The\n        default value is 4.\n      - distance_type: The distance type to use to perform the\n        similarity search. Valid values include \"COSINE\",\n        \"EUCLIDEAN\", and \"DOT_PRODUCT\". Default value is\n        \"COSINE\".\n      - nearest_neighbors_algorithm: The nearest neighbors search\n        algorithm to use. Valid values include \"EXACT_NEAREST_NEIGHBORS\"\n        and \"APPROXIMATE_NEAREST_NEIGHBORS\". Default value is\n        \"EXACT_NEAREST_NEIGHBORS\".\n      - num_leaves_to_search: (Only\
      \ applies when the\n        nearest_neighbors_algorithm is APPROXIMATE_NEAREST_NEIGHBORS.)\n        The number of leaves to search in the vector index.\n\nReturns:\n    Dict[str, Any]: A dictionary representing the result of the search.\n      On success, it contains {\"status\": \"SUCCESS\", \"rows\": [...]}. The last\n      column of each row is the distance between the query and the column\n      embedding (i.e. the embedding_column_to_search).\n      On error, it contains {\"status\": \"ERROR\", \"error_details\": \"...\"}.\n\nExamples:\n    Search for relevant products given a user's text description and a filter\n    on the price:\n      >>> similarity_search(\n      ...   project_id=\"my-project\",\n      ...   instance_id=\"my-instance\",\n      ...   database_id=\"my-database\",\n      ...   table_name=\"my-product-table\",\n      ...   query=\"Tools that can help me clean my house.\",\n      ...   embedding_column_to_search=\"product_description_embedding\",\n      ...  \
      \ columns=[\"product_name\", \"product_description\", \"price_in_cents\"],\n      ...   credentials=credentials,\n      ...   additional_filter=\"price_in_cents < 100000\",\n      ...   embedding_options={\n      ...     \"vertex_ai_embedding_model_name\": \"text-embedding-005\"\n      ...   },\n      ...   search_options={\n      ...     \"top_k\": 2,\n      ...     \"distance_type\": \"COSINE\"\n      ...   }\n      ... )\n      {\n        \"status\": \"SUCCESS\",\n        \"rows\": [\n          (\n            \"Powerful Robot Vacuum\",\n            \"This is a powerful robot vacuum that can clean carpets and wood floors.\",\n            99999,\n            0.31,\n          ),\n          (\n            \"Nice Mop\",\n            \"Great for cleaning different surfaces.\",\n            5099,\n            0.45,\n          ),\n        ],\n      }"
  - signature: 'def vector_store_similarity_search(query: str, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.spanner.settings.SpannerToolSettings) -> typing.Dict[str, typing.Any]:'
    docstring: "Performs a semantic similarity search to retrieve relevant context from the Spanner vector store.\n\nThis function performs vector similarity search directly on a vector store\ntable in Spanner database and returns the relevant data.\n\nArgs:\n    query (str): The search string based on the user's question.\n    credentials (Credentials): The credentials to use for the request.\n    settings (SpannerToolSettings): The configuration for the tool.\n\nReturns:\n    Dict[str, Any]: A dictionary representing the result of the search.\n      On success, it contains {\"status\": \"SUCCESS\", \"rows\": [...]}. The last\n      column of each row is the distance between the query and the row result.\n      On error, it contains {\"status\": \"ERROR\", \"error_details\": \"...\"}.\n\nExamples:\n      >>> vector_store_similarity_search(\n      ...   query=\"Spanner database optimization techniques for high QPS\",\n      ...   credentials=credentials,\n      ...   settings=settings\n\
      \      ... )\n      {\n        \"status\": \"SUCCESS\",\n        \"rows\": [\n          (\n            \"Optimizing Query Performance\",\n            0.12,\n          ),\n          (\n            \"Schema Design Best Practices\",\n            0.25,\n          ),\n          (\n            \"Using Secondary Indexes Effectively\",\n            0.31,\n          ),\n          ...\n        ],\n      }"
  properties:
  - signature: '_SPANNER_GSQL_EMBEDDING_MODEL_NAME: str'
  - signature: '_SPANNER_PG_VERTEX_AI_EMBEDDING_MODEL_ENDPOINT: str'
  - signature: '_VERTEX_AI_EMBEDDING_MODEL_NAME: str'
  - signature: '_OUTPUT_DIMENSIONALITY: str'
  - signature: '_TOP_K: str'
  - signature: '_DISTANCE_TYPE: str'
  - signature: '_NEAREST_NEIGHBORS_ALGORITHM: str'
  - signature: '_NUM_LEAVES_TO_SEARCH: str'
  - signature: '_DISTANCE_ALIAS: str'
  - signature: '_GOOGLESQL_PARAMETER_TEXT_QUERY: str'
  - signature: '_POSTGRESQL_PARAMETER_TEXT_QUERY: str'
  - signature: '_GOOGLESQL_PARAMETER_QUERY_EMBEDDING: str'
  - signature: '_POSTGRESQL_PARAMETER_QUERY_EMBEDDING: str'
- rank: 1847
  id: google.adk.tools.spanner.search_tool.similarity_search
  name: similarity_search
  file_path: src/google/adk/tools/spanner/search_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Similarity search in Spanner using a text query.\n\nThe function will use embedding service (provided from options) to embed\nthe text query automatically, then use the embedding vector to do similarity\nsearch and to return requested data. This is suitable when the Spanner table\ncontains a column that stores the embeddings of the data that we want to\nsearch the `query` against.\n\nArgs:\n    project_id (str): The GCP project id in which the spanner database\n      resides.\n    instance_id (str): The instance id of the spanner database.\n    database_id (str): The database id of the spanner database.\n    table_name (str): The name of the table used for vector search.\n    query (str): The user query for which the tool will find the top similar\n      content. The query will be embedded and used for vector search.\n    embedding_column_to_search (str): The name of the column that contains the\n      embeddings of the documents. The tool will do similarity search on this\n\
    \      column.\n    columns (List[str]): A list of column names, representing the additional\n      columns to return in the search results.\n    embedding_options (Dict[str, str]): A dictionary of options to use for\n      the embedding service. **Exactly one of the following three keys\n      MUST be present in this dictionary**:\n      `vertex_ai_embedding_model_name`, `spanner_googlesql_embedding_model_name`,\n      or `spanner_postgresql_vertex_ai_embedding_model_endpoint`.\n      - vertex_ai_embedding_model_name (str): (Supported both **GoogleSQL and\n          PostgreSQL** dialects Spanner database) The name of a\n          public Vertex AI embedding model (e.g., `'text-embedding-005'`).\n          If specified, the tool generates embeddings client-side using the\n          Vertex AI embedding model.\n      - spanner_googlesql_embedding_model_name (str): (For GoogleSQL dialect) The\n        name of the embedding model that is registered in Spanner via a\n        `CREATE MODEL`\
    \ statement. For more details, see\n        https://cloud.google.com/spanner/docs/ml-tutorial-embeddings#generate_and_store_text_embeddings\n        If specified, embedding generation is performed using Spanner's\n        `ML.PREDICT` function.\n      - spanner_postgresql_vertex_ai_embedding_model_endpoint (str):\n        (For PostgreSQL dialect) The fully qualified endpoint of the Vertex AI\n        embedding model, in the format of\n        `projects/$project/locations/$location/publishers/google/models/$model_name`,\n        where $project is the project hosting the Vertex AI endpoint,\n        $location is the location of the endpoint, and $model_name is\n        the name of the text embedding model.\n        If specified, embedding generation is performed using Spanner's\n        `spanner.ML_PREDICT_ROW` function.\n      - output_dimensionality: Optional. The output dimensionality of the\n        embedding. If not specified, the embedding model's default output\n        dimensionality\
    \ will be used.\n    credentials (Credentials): The credentials to use for the request.\n    additional_filter (Optional[str]): An optional filter to apply to the\n      search query. If provided, this will be added to the WHERE clause of the\n      final query.\n    search_options (Optional[Dict[str, Any]]): A dictionary of options to use\n      for the similarity search. The following options are supported:\n      - top_k: The number of most similar documents to return. The\n        default value is 4.\n      - distance_type: The distance type to use to perform the\n        similarity search. Valid values include \"COSINE\",\n        \"EUCLIDEAN\", and \"DOT_PRODUCT\". Default value is\n        \"COSINE\".\n      - nearest_neighbors_algorithm: The nearest neighbors search\n        algorithm to use. Valid values include \"EXACT_NEAREST_NEIGHBORS\"\n        and \"APPROXIMATE_NEAREST_NEIGHBORS\". Default value is\n        \"EXACT_NEAREST_NEIGHBORS\".\n      - num_leaves_to_search: (Only\
    \ applies when the\n        nearest_neighbors_algorithm is APPROXIMATE_NEAREST_NEIGHBORS.)\n        The number of leaves to search in the vector index.\n\nReturns:\n    Dict[str, Any]: A dictionary representing the result of the search.\n      On success, it contains {\"status\": \"SUCCESS\", \"rows\": [...]}. The last\n      column of each row is the distance between the query and the column\n      embedding (i.e. the embedding_column_to_search).\n      On error, it contains {\"status\": \"ERROR\", \"error_details\": \"...\"}.\n\nExamples:\n    Search for relevant products given a user's text description and a filter\n    on the price:\n      >>> similarity_search(\n      ...   project_id=\"my-project\",\n      ...   instance_id=\"my-instance\",\n      ...   database_id=\"my-database\",\n      ...   table_name=\"my-product-table\",\n      ...   query=\"Tools that can help me clean my house.\",\n      ...   embedding_column_to_search=\"product_description_embedding\",\n      ...   columns=[\"\
    product_name\", \"product_description\", \"price_in_cents\"],\n      ...   credentials=credentials,\n      ...   additional_filter=\"price_in_cents < 100000\",\n      ...   embedding_options={\n      ...     \"vertex_ai_embedding_model_name\": \"text-embedding-005\"\n      ...   },\n      ...   search_options={\n      ...     \"top_k\": 2,\n      ...     \"distance_type\": \"COSINE\"\n      ...   }\n      ... )\n      {\n        \"status\": \"SUCCESS\",\n        \"rows\": [\n          (\n            \"Powerful Robot Vacuum\",\n            \"This is a powerful robot vacuum that can clean carpets and wood floors.\",\n            99999,\n            0.31,\n          ),\n          (\n            \"Nice Mop\",\n            \"Great for cleaning different surfaces.\",\n            5099,\n            0.45,\n          ),\n        ],\n      }"
  signature: 'def similarity_search(project_id: str, instance_id: str, database_id: str, table_name: str, query: str, embedding_column_to_search: str, columns: typing.List[str], embedding_options: typing.Dict[str, str], credentials: google.auth.credentials.Credentials, additional_filter: typing.Optional[str], search_options: typing.Optional[typing.Dict[str, typing.Any]]) -> typing.Dict[str, typing.Any]:'
- rank: 1848
  id: google.adk.tools.spanner.search_tool.vector_store_similarity_search
  name: vector_store_similarity_search
  file_path: src/google/adk/tools/spanner/search_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Performs a semantic similarity search to retrieve relevant context from the Spanner vector store.\n\nThis function performs vector similarity search directly on a vector store\ntable in Spanner database and returns the relevant data.\n\nArgs:\n    query (str): The search string based on the user's question.\n    credentials (Credentials): The credentials to use for the request.\n    settings (SpannerToolSettings): The configuration for the tool.\n\nReturns:\n    Dict[str, Any]: A dictionary representing the result of the search.\n      On success, it contains {\"status\": \"SUCCESS\", \"rows\": [...]}. The last\n      column of each row is the distance between the query and the row result.\n      On error, it contains {\"status\": \"ERROR\", \"error_details\": \"...\"}.\n\nExamples:\n      >>> vector_store_similarity_search(\n      ...   query=\"Spanner database optimization techniques for high QPS\",\n      ...   credentials=credentials,\n      ...   settings=settings\n  \
    \    ... )\n      {\n        \"status\": \"SUCCESS\",\n        \"rows\": [\n          (\n            \"Optimizing Query Performance\",\n            0.12,\n          ),\n          (\n            \"Schema Design Best Practices\",\n            0.25,\n          ),\n          (\n            \"Using Secondary Indexes Effectively\",\n            0.31,\n          ),\n          ...\n        ],\n      }"
  signature: 'def vector_store_similarity_search(query: str, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.spanner.settings.SpannerToolSettings) -> typing.Dict[str, typing.Any]:'
- rank: 1849
  id: google.adk.tools.spanner.settings
  name: settings
  file_path: src/google/adk/tools/spanner/settings.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'EXACT_NEAREST_NEIGHBORS: str'
  - signature: 'APPROXIMATE_NEAREST_NEIGHBORS: str'
  - signature: 'NearestNeighborsAlgorithm: Any'
- rank: 1850
  id: google.adk.tools.spanner.settings.Capabilities
  name: Capabilities
  file_path: src/google/adk/tools/spanner/settings.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Capabilities indicating what type of operation tools are allowed to be performed on Spanner.


    [Note: Inherited members from Enum are omitted.]'
  properties:
  - signature: 'DATA_READ: str'
    docstring: Read only data operations tools are allowed.
  omitted_inherited_members_from:
  - Enum
- rank: 1851
  id: google.adk.tools.spanner.settings.QueryResultMode
  name: QueryResultMode
  file_path: src/google/adk/tools/spanner/settings.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Settings for Spanner execute sql query result.


    [Note: Inherited members from Enum are omitted.]'
  properties:
  - signature: 'DEFAULT: str'
    docstring: Return the result of a query as a list of rows data.
  - signature: 'DICT_LIST: str'
    docstring: 'Return the result of a query as a list of dictionaries.


      In each dictionary the key is the column name and the value is the value of

      the that column in a given row.'
  omitted_inherited_members_from:
  - Enum
- rank: 1852
  id: google.adk.tools.spanner.settings.SpannerVectorStoreSettings
  name: SpannerVectorStoreSettings
  file_path: src/google/adk/tools/spanner/settings.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Settings for Spanner Vector Store.


    This is used for vector similarity search in a Spanner vector store table.

    Provide the vector store table and the embedding model settings to use with

    the `vector_store_similarity_search` tool.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, project_id: str, instance_id: str, database_id: str, table_name: str, content_column: str, embedding_column: str, vector_length: int, vertex_ai_embedding_model_name: str, selected_columns: list[str] = [], nearest_neighbors_algorithm: google.adk.tools.spanner.settings.NearestNeighborsAlgorithm = ''EXACT_NEAREST_NEIGHBORS'', top_k: int = 4, distance_type: str = ''COSINE'', num_leaves_to_search: typing.Optional[int] = None, additional_filter: typing.Optional[str] = None, vector_search_index_settings: typing.Optional[google.adk.tools.spanner.settings.VectorSearchIndexSettings] = None, additional_columns_to_setup: typing.Optional[list[google.adk.tools.spanner.settings.TableColumn]] = None, primary_key_columns: typing.Optional[list[str]] = None):'
  properties:
  - signature: 'project_id: str'
    docstring: Required. The GCP project id in which the Spanner database resides.
  - signature: 'instance_id: str'
    docstring: Required. The instance id of the Spanner database.
  - signature: 'database_id: str'
    docstring: Required. The database id of the Spanner database.
  - signature: 'table_name: str'
    docstring: Required. The name of the vector store table to use for vector similarity search.
  - signature: 'content_column: str'
    docstring: Required. The name of the content column in the vector store table. By default, this column value is also returned as part of the vector similarity search result.
  - signature: 'embedding_column: str'
    docstring: Required. The name of the embedding column to search in the vector store table.
  - signature: 'vector_length: int'
    docstring: Required. The dimension of the vectors in the `embedding_column`.
  - signature: 'vertex_ai_embedding_model_name: str'
    docstring: 'Required. The Vertex AI embedding model name, which is used to generate embeddings for vector store and vector similarity search.


      For example, ''text-embedding-005''.


      Note: the output dimensionality of the embedding model should be the same as the value specified in the `vector_length` field.

      Otherwise, a runtime error might be raised during a query.'
  - signature: 'selected_columns: list[str]'
    docstring: 'Required. The vector store table columns to return in the vector similarity search result.


      By default, only the `content_column` value and the distance value are returned.

      If specified, the list of selected columns and the distance value are returned.

      For example, if `selected_columns` is [''col1'', ''col2''], then the result will contain the values of ''col1'' and ''col2'' columns and the distance value.'
  - signature: 'nearest_neighbors_algorithm: google.adk.tools.spanner.settings.NearestNeighborsAlgorithm'
    docstring: 'The algorithm used to perform vector similarity search. This value can be EXACT_NEAREST_NEIGHBORS or APPROXIMATE_NEAREST_NEIGHBORS.


      For more details about EXACT_NEAREST_NEIGHBORS, see https://docs.cloud.google.com/spanner/docs/find-k-nearest-neighbors

      For more details about APPROXIMATE_NEAREST_NEIGHBORS, see https://docs.cloud.google.com/spanner/docs/find-approximate-nearest-neighbors'
  - signature: 'top_k: int'
    docstring: Required. The number of neighbors to return for each vector similarity search query. The default value is 4.
  - signature: 'distance_type: str'
    docstring: Required. The distance metric used to build the vector index or perform vector similarity search. This value can be COSINE, DOT_PRODUCT, or EUCLIDEAN.
  - signature: 'num_leaves_to_search: typing.Optional[int]'
    docstring: 'Optional. This option specifies how many leaf nodes of the index are searched.


      Note: This option is only used when the nearest neighbors search algorithm (`nearest_neighbors_algorithm`) is APPROXIMATE_NEAREST_NEIGHBORS.

      For more details, see https://docs.cloud.google.com/spanner/docs/vector-index-best-practices'
  - signature: 'additional_filter: typing.Optional[str]'
    docstring: Optional. An optional filter to apply to the search query. If provided, this will be added to the WHERE clause of the final query.
  - signature: 'vector_search_index_settings: typing.Optional[google.adk.tools.spanner.settings.VectorSearchIndexSettings]'
    docstring: 'Optional. Settings for the index for use with Approximate Nearest Neighbor (ANN) in the vector store.


      Note: This option is only required when the nearest neighbors search algorithm (`nearest_neighbors_algorithm`) is APPROXIMATE_NEAREST_NEIGHBORS.

      For more details, see https://docs.cloud.google.com/spanner/docs/vector-indexes'
  - signature: 'additional_columns_to_setup: typing.Optional[list[google.adk.tools.spanner.settings.TableColumn]]'
    docstring: 'Optional. A list of supplemental columns to be created when initializing a new vector store table or inserting content rows.


      Note: This configuration is only utilized during the initial table setup

      or when inserting content rows.'
  - signature: 'primary_key_columns: typing.Optional[list[str]]'
    docstring: 'Optional. Specifies the column names to be used as the primary key for a new vector store table.


      If provided, every column name listed here must be defined within

      `additional_columns_to_setup`. If this field is omitted (set to `None`),

      defaults to a single primary key column named `id` which automatically

      generates UUIDs for each entry.


      Note: This field is only used during the creation phase of a new vector store.'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1853
  id: google.adk.tools.spanner.settings.TableColumn
  name: TableColumn
  file_path: src/google/adk/tools/spanner/settings.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Represents column configuration, to be used as part of create DDL statement for a new vector store table set up.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, name: str, type: str, is_nullable: bool = True):'
  properties:
  - signature: 'name: str'
    docstring: Required. The name of the column.
  - signature: 'type: str'
    docstring: 'Required. The type of the column.


      For example,


      - GoogleSQL: ''STRING(MAX)'', ''INT64'', ''FLOAT64'', ''BOOL'', etc.

      - PostgreSQL: ''text'', ''int8'', ''float8'', ''boolean'', etc.'
  - signature: 'is_nullable: bool'
    docstring: Optional. Whether the column is nullable. By default, the column is nullable.
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1854
  id: google.adk.tools.spanner.settings.VectorSearchIndexSettings
  name: VectorSearchIndexSettings
  file_path: src/google/adk/tools/spanner/settings.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Settings for the index for use with Approximate Nearest Neighbor (ANN) vector similarity search.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, index_name: str, additional_key_columns: typing.Optional[list[str]] = None, additional_storing_columns: typing.Optional[list[str]] = None, tree_depth: int = 2, num_leaves: int = 1000, num_branches: typing.Optional[int] = None):'
  properties:
  - signature: 'index_name: str'
    docstring: Required. The name of the vector similarity search index.
  - signature: 'additional_key_columns: typing.Optional[list[str]]'
    docstring: 'Optional. The list of the additional key column names in the vector similarity search index.


      To further speed up filtering for highly selective filtering columns, organize

      them as additional keys in the vector index after the embedding column.

      For example: `category` as additional key column.

      `CREATE VECTOR INDEX ON documents(embedding, category);`'
  - signature: 'additional_storing_columns: typing.Optional[list[str]]'
    docstring: 'Optional. The list of the storing column names in the vector similarity search index.


      This enables filtering while walking the vector index, removing unqualified

      rows early.

      For example: `category` as storing column.

      `CREATE VECTOR INDEX ON documents(embedding) STORING (category);`'
  - signature: 'tree_depth: int'
    docstring: 'Required. The tree depth (level). This value can be either 2 or 3.


      A tree with 2 levels only has leaves (num_leaves) as nodes.

      If the dataset has more than 100 million rows,

      then you can use a tree with 3 levels and add branches (num_branches) to

      further partition the dataset.'
  - signature: 'num_leaves: int'
    docstring: 'Required. The number of leaves (i.e. potential partitions) for the vector data.


      You can designate num_leaves for trees with 2 or 3 levels.

      We recommend that the number of leaves is number_of_rows_in_dataset/1000.'
  - signature: 'num_branches: typing.Optional[int]'
    docstring: 'Optional. The number of branches to further partition the vector data.


      You can only designate num_branches for trees with 3 levels.

      The number of branches must be fewer than the number of leaves

      We recommend that the number of leaves is between 1000 and sqrt(number_of_rows_in_dataset).'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1855
  id: google.adk.tools.spanner.spanner_credentials
  name: spanner_credentials
  file_path: src/google/adk/tools/spanner/spanner_credentials.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'SPANNER_TOKEN_CACHE_KEY: str'
  - signature: 'SPANNER_DEFAULT_SCOPE: Any'
- rank: 1856
  id: google.adk.tools.spanner.spanner_toolset
  name: spanner_toolset
  file_path: src/google/adk/tools/spanner/spanner_toolset.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'DEFAULT_SPANNER_TOOL_NAME_PREFIX: str'
- rank: 1857
  id: google.adk.tools.spanner.spanner_toolset.SpannerToolset.__init__
  name: __init__
  file_path: src/google/adk/tools/spanner/spanner_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, *, tool_filter: typing.Optional[typing.Union[google.adk.tools.base_toolset.ToolPredicate, typing.List[str]]]=None, credentials_config: typing.Optional[google.adk.tools.spanner.spanner_credentials.SpannerCredentialsConfig]=None, spanner_tool_settings: typing.Optional[google.adk.tools.spanner.settings.SpannerToolSettings]=None):'
- rank: 1858
  id: google.adk.tools.spanner.spanner_toolset.SpannerToolset.get_tools
  name: get_tools
  file_path: src/google/adk/tools/spanner/spanner_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Get tools from the toolset.
  signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> typing.List[google.adk.tools.base_tool.BaseTool]:'
- rank: 1859
  id: google.adk.tools.spanner.utils
  name: utils
  file_path: src/google/adk/tools/spanner/utils.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def execute_sql(project_id: str, instance_id: str, database_id: str, query: str, credentials: google.auth.credentials.Credentials, settings: google.adk.tools.spanner.settings.SpannerToolSettings, tool_context: google.adk.tools.tool_context.ToolContext, params: typing.Optional[dict], params_types: typing.Optional[dict]) -> dict:'
    docstring: "Utility function to run a Spanner Read-Only query in the spanner database and return the result.\n\nArgs:\n    project_id (str): The GCP project id in which the spanner database\n      resides.\n    instance_id (str): The instance id of the spanner database.\n    database_id (str): The database id of the spanner database.\n    query (str): The Spanner SQL query to be executed.\n    credentials (Credentials): The credentials to use for the request.\n    settings (SpannerToolSettings): The settings for the tool.\n    tool_context (ToolContext): The context for the tool.\n    params (dict): values for parameter replacement.  Keys must match the\n      names used in ``query``.\n    params_types (dict): maps explicit types for one or more param values.\n\nReturns:\n    dict: Dictionary with the result of the query.\n          If the result contains the key \"result_is_likely_truncated\" with\n          value True, it means that there may be additional rows matching the\n     \
      \     query not returned in the result."
  - signature: 'def embed_contents(vertex_ai_embedding_model_name: str, contents: list[str], output_dimensionality: typing.Optional[int], genai_client: Client | None) -> list[list[float]]:'
    docstring: Embed the given contents into list of vectors using the Vertex AI embedding model endpoint.
  - signature: 'def embed_contents_async(vertex_ai_embedding_model_name: str, contents: list[str], output_dimensionality: typing.Optional[int], genai_client: Client | None) -> list[list[float]]:'
    docstring: Embed the given contents into list of vectors using the Vertex AI embedding model endpoint.
  properties:
  - signature: 'logger: logging.getLogger'
  - signature: 'DEFAULT_MAX_EXECUTED_QUERY_RESULT_ROWS: int'
- rank: 1860
  id: google.adk.tools.spanner.utils.SpannerVectorStore
  name: SpannerVectorStore
  file_path: src/google/adk/tools/spanner/utils.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A class for orchestrating and providing utility functions for a Spanner vector store.


    This class provides utility functions for setting up and adding contents to a

    vector store table in a Google Cloud Spanner database, based on the given

    Spanner tool settings.'
  constructor_signature: 'def __init__(self, settings: google.adk.tools.spanner.settings.SpannerToolSettings, credentials: Credentials | None, spanner_client: spanner.Client | None, genai_client: Client | None):'
  methods:
  - signature: 'def create_vector_store(self):'
    docstring: "Creates a new vector store within the Google Cloud Spanner database.\n\nRaises:\n    RuntimeError: If the DDL statement execution against Spanner fails."
  - signature: 'def create_vector_search_index(self):'
    docstring: "Creates a vector search index within the Google Cloud Spanner database.\n\nRaises:\n    RuntimeError: If the DDL statement execution against Spanner fails."
  - signature: 'def create_vector_store_async(self):'
    docstring: "Asynchronously creates a new vector store within the Google Cloud Spanner database.\n\nRaises:\n    RuntimeError: If the DDL statement execution against Spanner fails."
  - signature: 'def create_vector_search_index_async(self):'
    docstring: "Asynchronously creates a vector search index within the Google Cloud Spanner database.\n\nRaises:\n    RuntimeError: If the DDL statement execution against Spanner fails."
  - signature: 'def add_contents(self, contents: typing.Iterable[str], *, additional_columns_values: Iterable[dict] | None=None, batch_size: int=200):'
    docstring: "Adds text contents to the vector store.\n\nPerforms batch embedding generation and subsequent insertion of the contents\ninto the vector store table in the Google Cloud Spanner database.\n\nArgs:\n    contents (Iterable[str]): An iterable collection of string contents to\n      be added to the vector store.\n    additional_columns_values (Iterable[dict] | None): An optional iterable\n      of dictionary containing values for additional columns to be stored\n      with the content row. Keys must match column names.\n    batch_size (int): The maximum number of items to process and insert in a\n      single batch. Defaults to 200."
  - signature: 'def add_contents_async(self, contents: typing.Iterable[str], *, additional_columns_values: Iterable[dict] | None=None, batch_size: int=200):'
    docstring: "Asynchronously adds text contents to the vector store.\n\nPerforms batch embedding generation and subsequent insertion of the contents\ninto the vector store table in the Google Cloud Spanner database.\n\nArgs:\n    contents (Iterable[str]): An iterable collection of string contents to\n      be added to the vector store.\n    additional_columns_values (Iterable[dict] | None): An optional iterable\n      of dictionary containing values for additional columns to be stored\n      with the content row. Keys must match column names.\n    batch_size (int): The maximum number of items to process and insert in a\n      single batch. Defaults to 200."
  properties:
  - signature: 'DEFAULT_VECTOR_STORE_ID_COLUMN_NAME: str'
  - signature: 'SPANNER_VECTOR_STORE_USER_AGENT: str'
- rank: 1861
  id: google.adk.tools.spanner.utils.SpannerVectorStore.__init__
  name: __init__
  file_path: src/google/adk/tools/spanner/utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the SpannerVectorStore with validated settings and clients.\n\nThis constructor sets up the connection to a specific Spanner database and\nconfigures the necessary clients for vector operations.\n\nArgs:\n  settings (SpannerToolSettings): The settings for the tool.\n  credentials (Credentials | None): Credentials for Spanner operations. This\n    is used to initialize a new Spanner client only if `spanner_client`\n    is not explicitly provided.\n  spanner_client (spanner.Client | None): An pre-configured `spanner.Client`\n    instance. If not provided, a new client will be created.\n  genai_client (Client | None): Google GenAI client used for\n    generating vector embeddings."
  signature: 'def __init__(self, settings: google.adk.tools.spanner.settings.SpannerToolSettings, credentials: Credentials | None, spanner_client: spanner.Client | None, genai_client: Client | None):'
- rank: 1862
  id: google.adk.tools.spanner.utils.SpannerVectorStore.add_contents
  name: add_contents
  file_path: src/google/adk/tools/spanner/utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Adds text contents to the vector store.\n\nPerforms batch embedding generation and subsequent insertion of the contents\ninto the vector store table in the Google Cloud Spanner database.\n\nArgs:\n    contents (Iterable[str]): An iterable collection of string contents to\n      be added to the vector store.\n    additional_columns_values (Iterable[dict] | None): An optional iterable\n      of dictionary containing values for additional columns to be stored\n      with the content row. Keys must match column names.\n    batch_size (int): The maximum number of items to process and insert in a\n      single batch. Defaults to 200."
  signature: 'def add_contents(self, contents: typing.Iterable[str], *, additional_columns_values: Iterable[dict] | None=None, batch_size: int=200):'
- rank: 1863
  id: google.adk.tools.spanner.utils.SpannerVectorStore.add_contents_async
  name: add_contents_async
  file_path: src/google/adk/tools/spanner/utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Asynchronously adds text contents to the vector store.\n\nPerforms batch embedding generation and subsequent insertion of the contents\ninto the vector store table in the Google Cloud Spanner database.\n\nArgs:\n    contents (Iterable[str]): An iterable collection of string contents to\n      be added to the vector store.\n    additional_columns_values (Iterable[dict] | None): An optional iterable\n      of dictionary containing values for additional columns to be stored\n      with the content row. Keys must match column names.\n    batch_size (int): The maximum number of items to process and insert in a\n      single batch. Defaults to 200."
  signature: 'def add_contents_async(self, contents: typing.Iterable[str], *, additional_columns_values: Iterable[dict] | None=None, batch_size: int=200):'
- rank: 1864
  id: google.adk.tools.spanner.utils.SpannerVectorStore.create_vector_search_index
  name: create_vector_search_index
  file_path: src/google/adk/tools/spanner/utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Creates a vector search index within the Google Cloud Spanner database.\n\nRaises:\n    RuntimeError: If the DDL statement execution against Spanner fails."
  signature: 'def create_vector_search_index(self):'
- rank: 1865
  id: google.adk.tools.spanner.utils.SpannerVectorStore.create_vector_search_index_async
  name: create_vector_search_index_async
  file_path: src/google/adk/tools/spanner/utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Asynchronously creates a vector search index within the Google Cloud Spanner database.\n\nRaises:\n    RuntimeError: If the DDL statement execution against Spanner fails."
  signature: 'def create_vector_search_index_async(self):'
- rank: 1866
  id: google.adk.tools.spanner.utils.SpannerVectorStore.create_vector_store
  name: create_vector_store
  file_path: src/google/adk/tools/spanner/utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Creates a new vector store within the Google Cloud Spanner database.\n\nRaises:\n    RuntimeError: If the DDL statement execution against Spanner fails."
  signature: 'def create_vector_store(self):'
- rank: 1867
  id: google.adk.tools.spanner.utils.SpannerVectorStore.create_vector_store_async
  name: create_vector_store_async
  file_path: src/google/adk/tools/spanner/utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Asynchronously creates a new vector store within the Google Cloud Spanner database.\n\nRaises:\n    RuntimeError: If the DDL statement execution against Spanner fails."
  signature: 'def create_vector_store_async(self):'
- rank: 1868
  id: google.adk.tools.spanner.utils.embed_contents
  name: embed_contents
  file_path: src/google/adk/tools/spanner/utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Embed the given contents into list of vectors using the Vertex AI embedding model endpoint.
  signature: 'def embed_contents(vertex_ai_embedding_model_name: str, contents: list[str], output_dimensionality: typing.Optional[int], genai_client: Client | None) -> list[list[float]]:'
- rank: 1869
  id: google.adk.tools.spanner.utils.embed_contents_async
  name: embed_contents_async
  file_path: src/google/adk/tools/spanner/utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Embed the given contents into list of vectors using the Vertex AI embedding model endpoint.
  signature: 'def embed_contents_async(vertex_ai_embedding_model_name: str, contents: list[str], output_dimensionality: typing.Optional[int], genai_client: Client | None) -> list[list[float]]:'
- rank: 1870
  id: google.adk.tools.tool_configs
  name: tool_configs
  file_path: src/google/adk/tools/tool_configs.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1871
  id: google.adk.tools.tool_configs.BaseToolConfig
  name: BaseToolConfig
  file_path: src/google/adk/tools/tool_configs.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'The base class for all tool configs.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1872
  id: google.adk.tools.tool_configs.ToolArgsConfig
  name: ToolArgsConfig
  file_path: src/google/adk/tools/tool_configs.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Config to host free key-value pairs for the args in ToolConfig.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1873
  id: google.adk.tools.tool_configs.ToolConfig
  name: ToolConfig
  file_path: src/google/adk/tools/tool_configs.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "The configuration for a tool.\n\nThe config supports these types of tools:\n1. ADK built-in tools\n2. User-defined tool instances\n3. User-defined tool classes\n4. User-defined functions that generate tool instances\n5. User-defined function tools\n\nFor examples:\n\n  1. For ADK built-in tool instances or classes in `google.adk.tools` package,\n  they can be referenced directly with the `name` and optionally with\n  `args`.\n\n  ```\n  tools:\n    - name: google_search\n    - name: AgentTool\n      args:\n        agent: ./another_agent.yaml\n        skip_summarization: true\n  ```\n\n  2. For user-defined tool instances, the `name` is the fully qualified path\n  to the tool instance.\n\n  ```\n  tools:\n    - name: my_package.my_module.my_tool\n  ```\n\n  3. For user-defined tool classes (custom tools), the `name` is the fully\n  qualified path to the tool class and `args` is the arguments for the tool.\n\n  ```\n  tools:\n    - name: my_package.my_module.my_tool_class\n \
    \     args:\n        my_tool_arg1: value1\n        my_tool_arg2: value2\n  ```\n\n  4. For user-defined functions that generate tool instances, the `name` is\n  the fully qualified path to the function and `args` is passed to the\n  function as arguments.\n\n  ```\n  tools:\n    - name: my_package.my_module.my_tool_function\n      args:\n        my_function_arg1: value1\n        my_function_arg2: value2\n  ```\n\n  The function must have the following signature:\n  ```\n  def my_function(args: ToolArgsConfig) -> BaseTool:\n    ...\n  ```\n\n  5. For user-defined function tools, the `name` is the fully qualified path\n  to the function.\n\n  ```\n  tools:\n    - name: my_package.my_module.my_function_tool\n  ```\n\n  If the above use cases don't suffice, users can define a custom tool config\n  by extending BaseToolConfig and override from_config() in the custom tool.\n\n[Note: Inherited members from pydantic.BaseModel are omitted.]"
  constructor_signature: 'def __init__(self, *, name: str, args: typing.Optional[google.adk.tools.tool_configs.ToolArgsConfig] = None):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
  - signature: 'name: str'
  - signature: 'args: typing.Optional[google.adk.tools.tool_configs.ToolArgsConfig]'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1874
  id: google.adk.tools.tool_confirmation
  name: tool_confirmation
  file_path: src/google/adk/tools/tool_confirmation.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1875
  id: google.adk.tools.tool_confirmation.ToolConfirmation
  name: ToolConfirmation
  file_path: src/google/adk/tools/tool_confirmation.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Represents a tool confirmation configuration.


    [Note: Inherited members from pydantic.BaseModel are omitted.]'
  constructor_signature: 'def __init__(self, *, hint: str = '''', confirmed: bool = False, payload: typing.Optional[typing.Any] = None):'
  properties:
  - signature: 'model_config: pydantic.ConfigDict'
    docstring: The pydantic model config.
  - signature: 'hint: str'
    docstring: The hint text for why the input is needed.
  - signature: 'confirmed: bool'
    docstring: Whether the tool execution is confirmed.
  - signature: 'payload: typing.Optional[typing.Any]'
    docstring: 'The custom data payload needed from the user to continue the flow.

      It should be JSON serializable.'
  inherited_properties:
    BaseModel:
    - signature: 'model_config: pydantic.ConfigDict'
  omitted_inherited_members_from:
  - pydantic.BaseModel
- rank: 1876
  id: google.adk.tools.tool_context
  name: tool_context
  file_path: src/google/adk/tools/tool_context.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1877
  id: google.adk.tools.tool_context.ToolContext
  name: ToolContext
  file_path: src/google/adk/tools/tool_context.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "The context of the tool.\n\nThis class provides the context for a tool invocation, including access to\nthe invocation context, function call ID, event actions, and authentication\nresponse. It also provides methods for requesting credentials, retrieving\nauthentication responses, listing artifacts, and searching memory.\n\nAttributes:\n  invocation_context: The invocation context of the tool.\n  function_call_id: The function call id of the current tool call. This id was\n    returned in the function call event from LLM to identify a function call.\n    If LLM didn't return this id, ADK will assign one to it. This id is used\n    to map function call response to the original function call.\n  event_actions: The event actions of the current tool call.\n  tool_confirmation: The tool confirmation of the current tool call."
  constructor_signature: 'def __init__(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, *, function_call_id: typing.Optional[str]=None, event_actions: typing.Optional[google.adk.events.event_actions.EventActions]=None, tool_confirmation: typing.Optional[google.adk.tools.tool_confirmation.ToolConfirmation]=None):'
  aliases:
  - google.adk.tools.ToolContext
  methods:
  - signature: 'def actions(self) -> google.adk.events.event_actions.EventActions:'
  - signature: 'def request_credential(self, auth_config: google.adk.auth.auth_tool.AuthConfig) -> None:'
  - signature: 'def get_auth_response(self, auth_config: google.adk.auth.auth_tool.AuthConfig) -> google.adk.auth.auth_credential.AuthCredential:'
  - signature: 'def request_confirmation(self, *, hint: typing.Optional[str]=None, payload: typing.Optional[typing.Any]=None) -> None:'
    docstring: "Requests confirmation for the given function call.\n\nArgs:\n  hint: A hint to the user on how to confirm the tool call.\n  payload: The payload used to confirm the tool call."
  - signature: 'def search_memory(self, query: str) -> google.adk.memory.base_memory_service.SearchMemoryResponse:'
    docstring: Searches the memory of the current user.
  inherited_methods:
    CallbackContext:
    - signature: 'def state(self) -> google.adk.sessions.state.State:'
      docstring: 'The delta-aware state of the current session.


        For any state change, you can mutate this object directly,

        e.g. `ctx.state[''foo''] = ''bar''`'
    - signature: 'def load_artifact(self, filename: str, version: typing.Optional[int]) -> typing.Optional[google.genai.types.Part]:'
      docstring: "Loads an artifact attached to the current session.\n\nArgs:\n  filename: The filename of the artifact.\n  version: The version of the artifact. If None, the latest version will be\n    returned.\n\nReturns:\n  The artifact."
    - signature: 'def save_artifact(self, filename: str, artifact: google.genai.types.Part, custom_metadata: typing.Optional[dict[str, typing.Any]]) -> int:'
      docstring: "Saves an artifact and records it as delta for the current session.\n\nArgs:\n  filename: The filename of the artifact.\n  artifact: The artifact to save.\n  custom_metadata: Custom metadata to associate with the artifact.\n\nReturns:\n The version of the artifact."
    - signature: 'def get_artifact_version(self, filename: str, version: typing.Optional[int]) -> typing.Optional[google.adk.artifacts.base_artifact_service.ArtifactVersion]:'
      docstring: "Gets artifact version info.\n\nArgs:\n  filename: The filename of the artifact.\n  version: The version of the artifact. If None, the latest version will be\n    returned.\n\nReturns:\n  The artifact version info."
    - signature: 'def list_artifacts(self) -> list[str]:'
      docstring: Lists the filenames of the artifacts attached to the current session.
    - signature: 'def save_credential(self, auth_config: google.adk.auth.auth_tool.AuthConfig) -> None:'
      docstring: "Saves a credential to the credential service.\n\nArgs:\n  auth_config: The authentication configuration containing the credential."
    - signature: 'def load_credential(self, auth_config: google.adk.auth.auth_tool.AuthConfig) -> typing.Optional[google.adk.auth.auth_credential.AuthCredential]:'
      docstring: "Loads a credential from the credential service.\n\nArgs:\n  auth_config: The authentication configuration for the credential.\n\nReturns:\n  The loaded credential, or None if not found."
    - signature: 'def get_auth_response(self, auth_config: google.adk.auth.auth_tool.AuthConfig) -> typing.Optional[google.adk.auth.auth_credential.AuthCredential]:'
      docstring: "Gets the auth response credential from session state.\n\nThis method retrieves an authentication credential that was previously\nstored in session state after a user completed an OAuth flow or other\nauthentication process.\n\nArgs:\n  auth_config: The authentication configuration for the credential.\n\nReturns:\n  The auth credential from the auth response, or None if not found."
    - signature: 'def add_session_to_memory(self) -> None:'
      docstring: "Triggers memory generation for the current session.\n\nThis method saves the current session's events to the memory service,\nenabling the agent to recall information from past interactions.\n\nRaises:\n  ValueError: If memory service is not available.\n\nExample:\n  ```python\n  async def my_after_agent_callback(callback_context: CallbackContext):\n      # Save conversation to memory at the end of each interaction\n      await callback_context.add_session_to_memory()\n  ```"
    ReadonlyContext:
    - signature: 'def user_content(self) -> typing.Optional[google.genai.types.Content]:'
      docstring: The user content that started this invocation. READONLY field.
    - signature: 'def invocation_id(self) -> str:'
      docstring: The current invocation id.
    - signature: 'def agent_name(self) -> str:'
      docstring: The name of the agent that is currently running.
    - signature: 'def state(self) -> types.MappingProxyType[str, typing.Any]:'
      docstring: The state of the current session. READONLY field.
    - signature: 'def session(self) -> google.adk.sessions.session.Session:'
      docstring: The current session for this invocation.
    - signature: 'def user_id(self) -> str:'
      docstring: The id of the user. READONLY field.
    - signature: 'def run_config(self) -> typing.Optional[google.adk.agents.run_config.RunConfig]:'
      docstring: The run config of the current invocation. READONLY field.
- rank: 1878
  id: google.adk.tools.tool_context.ToolContext.__init__
  name: __init__
  file_path: src/google/adk/tools/tool_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self, invocation_context: google.adk.agents.invocation_context.InvocationContext, *, function_call_id: typing.Optional[str]=None, event_actions: typing.Optional[google.adk.events.event_actions.EventActions]=None, tool_confirmation: typing.Optional[google.adk.tools.tool_confirmation.ToolConfirmation]=None):'
- rank: 1879
  id: google.adk.tools.tool_context.ToolContext.request_confirmation
  name: request_confirmation
  file_path: src/google/adk/tools/tool_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Requests confirmation for the given function call.\n\nArgs:\n  hint: A hint to the user on how to confirm the tool call.\n  payload: The payload used to confirm the tool call."
  signature: 'def request_confirmation(self, *, hint: typing.Optional[str]=None, payload: typing.Optional[typing.Any]=None) -> None:'
- rank: 1880
  id: google.adk.tools.tool_context.ToolContext.request_credential
  name: request_credential
  file_path: src/google/adk/tools/tool_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def request_credential(self, auth_config: google.adk.auth.auth_tool.AuthConfig) -> None:'
- rank: 1881
  id: google.adk.tools.tool_context.ToolContext.search_memory
  name: search_memory
  file_path: src/google/adk/tools/tool_context.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Searches the memory of the current user.
  signature: 'def search_memory(self, query: str) -> google.adk.memory.base_memory_service.SearchMemoryResponse:'
- rank: 1882
  id: google.adk.tools.toolbox_toolset
  name: toolbox_toolset
  file_path: src/google/adk/tools/toolbox_toolset.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1883
  id: google.adk.tools.toolbox_toolset.ToolboxToolset
  name: ToolboxToolset
  file_path: src/google/adk/tools/toolbox_toolset.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A class that provides access to toolbox toolsets.


    Example:

    ```python

    toolbox_toolset = ToolboxToolset("http://127.0.0.1:5000")

    ```


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self, server_url: str, toolset_name: typing.Optional[str], tool_names: typing.Optional[typing.List[str]], auth_token_getters: typing.Optional[typing.Mapping[str, typing.Callable[[], str]]], bound_params: typing.Optional[typing.Mapping[str, typing.Union[typing.Callable[[], typing.Any], typing.Any]]], credentials: typing.Optional[toolbox_adk.CredentialConfig], additional_headers: typing.Optional[typing.Mapping[str, str]]):'
  methods:
  - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
  - signature: 'def close(self):'
  inherited_methods:
    BaseToolset:
    - signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools in the toolset based on the provided context.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools available under the specified context."
    - signature: 'def get_tools_with_prefix(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
      docstring: "Return all tools with optional prefix applied to tool names.\n\nThis method calls get_tools() and applies prefixing if tool_name_prefix is provided.\n\nArgs:\n  readonly_context (ReadonlyContext, optional): Context used to filter tools\n    available to the agent. If None, all tools in the toolset are returned.\n\nReturns:\n  list[BaseTool]: A list of tools with prefixed names if tool_name_prefix is provided."
    - signature: 'def close(self) -> None:'
      docstring: "Performs cleanup and releases resources held by the toolset.\n\nNOTE:\n  This method is invoked, for example, at the end of an agent server's\n  lifecycle or when the toolset is no longer needed. Implementations\n  should ensure that any open connections, files, or other managed\n  resources are properly released to prevent leaks."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_toolset.SelfToolset], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_toolset.SelfToolset:'
      docstring: "Creates a toolset instance from a config.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The toolset instance."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this toolset. This method will be\ncalled before each tool processes the llm request.\n\nUse cases:\n- Instead of let each tool process the llm request, we can let the toolset\n  process the llm request. e.g. ComputerUseToolset can add computer use\n  tool to the llm request.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def get_auth_config(self) -> typing.Optional[google.adk.auth.auth_tool.AuthConfig]:'
      docstring: "Returns the auth config for this toolset. ADK will make sure the\n'exchanged_auth_credential' field in the config is populated with\nready-to-use credential (e.g. oauth token for OAuth flow) before calling\nget_tools method or execute any tools returned by this toolset. Thus toolset\ncan use this credential either for tool listing or tool calling. If tool\ncalling needs a different credential from ADK client, call\ntool_context.request_credential in the tool.\n\nToolsets that support authentication should override this method to return\nan AuthConfig constructed from their auth_scheme, auth_credential, and\noptional credential_key parameters.\n\nReturns:\n  AuthConfig if the toolset has authentication configured, None otherwise."
  omitted_inherited_members_from:
  - ABC
- rank: 1884
  id: google.adk.tools.toolbox_toolset.ToolboxToolset.__init__
  name: __init__
  file_path: src/google/adk/tools/toolbox_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the ToolboxToolset.\n\nArgs:\n  server_url: The URL of the toolbox server.\n  toolset_name: (Optional) The name of the toolbox toolset to load.\n  tool_names: (Optional) The names of the tools to load.\n  auth_token_getters: (Optional) A mapping of authentication service names\n    to callables that return the corresponding authentication token. see:\n    https://github.com/googleapis/mcp-toolbox-sdk-python/tree/main/packages/toolbox-core#authenticating-tools\n      for details.\n  bound_params: (Optional) A mapping of parameter names to bind to specific\n    values or callables that are called to produce values as needed. see:\n    https://github.com/googleapis/mcp-toolbox-sdk-python/tree/main/packages/toolbox-core#binding-parameter-values\n      for details.\n  credentials: (Optional) toolbox_adk.CredentialConfig object.\n  additional_headers: (Optional) Static headers mapping.\n  **kwargs: Additional arguments passed to the underlying\n    toolbox_adk.ToolboxToolset.\n\
    \nThe resulting ToolboxToolset will contain both tools loaded by tool_names\nand toolset_name.\n\nNote: toolset_name and tool_names are optional.\nIf both are omitted, all tools are loaded."
  signature: 'def __init__(self, server_url: str, toolset_name: typing.Optional[str], tool_names: typing.Optional[typing.List[str]], auth_token_getters: typing.Optional[typing.Mapping[str, typing.Callable[[], str]]], bound_params: typing.Optional[typing.Mapping[str, typing.Union[typing.Callable[[], typing.Any], typing.Any]]], credentials: typing.Optional[toolbox_adk.CredentialConfig], additional_headers: typing.Optional[typing.Mapping[str, str]]):'
- rank: 1885
  id: google.adk.tools.toolbox_toolset.ToolboxToolset.get_tools
  name: get_tools
  file_path: src/google/adk/tools/toolbox_toolset.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def get_tools(self, readonly_context: typing.Optional[google.adk.agents.readonly_context.ReadonlyContext]) -> list[google.adk.tools.base_tool.BaseTool]:'
- rank: 1886
  id: google.adk.tools.transfer_to_agent_tool
  name: transfer_to_agent_tool
  file_path: src/google/adk/tools/transfer_to_agent_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def transfer_to_agent(agent_name: str, tool_context: google.adk.tools.tool_context.ToolContext) -> None:'
    docstring: "Transfer the question to another agent.\n\nThis tool hands off control to another agent when it's more suitable to\nanswer the user's question according to the agent's description.\n\nNote:\n  For most use cases, you should use TransferToAgentTool instead of this\n  function directly. TransferToAgentTool provides additional enum constraints\n  that prevent LLMs from hallucinating invalid agent names.\n\nArgs:\n  agent_name: the agent name to transfer to."
- rank: 1887
  id: google.adk.tools.transfer_to_agent_tool.TransferToAgentTool
  name: TransferToAgentTool
  file_path: src/google/adk/tools/transfer_to_agent_tool.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: "A specialized FunctionTool for agent transfer with enum constraints.\n\nThis tool enhances the base transfer_to_agent function by adding JSON Schema\nenum constraints to the agent_name parameter. This prevents LLMs from\nhallucinating invalid agent names by restricting choices to only valid agents.\n\nAttributes:\n  agent_names: List of valid agent names that can be transferred to.\n\n[Note: Inherited members from ABC are omitted.]"
  constructor_signature: 'def __init__(self, agent_names: list[str]):'
  aliases:
  - google.adk.tools.TransferToAgentTool
  inherited_methods:
    FunctionTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
    BaseTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
      docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
      docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  inherited_properties:
    BaseTool:
    - signature: 'name: str'
      docstring: The name of the tool.
    - signature: 'description: str'
      docstring: The description of the tool.
    - signature: 'is_long_running: bool'
      docstring: 'Whether the tool is a long running operation, which typically returns a

        resource id first and finishes the operation later.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the BaseTool.


        An optional key-value pair for storing and retrieving tool-specific metadata,

        such as tool manifests, etc.


        NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 1888
  id: google.adk.tools.transfer_to_agent_tool.TransferToAgentTool.__init__
  name: __init__
  file_path: src/google/adk/tools/transfer_to_agent_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initialize the TransferToAgentTool.\n\nArgs:\n  agent_names: List of valid agent names that can be transferred to."
  signature: 'def __init__(self, agent_names: list[str]):'
- rank: 1889
  id: google.adk.tools.transfer_to_agent_tool.transfer_to_agent
  name: transfer_to_agent
  file_path: src/google/adk/tools/transfer_to_agent_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Transfer the question to another agent.\n\nThis tool hands off control to another agent when it's more suitable to\nanswer the user's question according to the agent's description.\n\nNote:\n  For most use cases, you should use TransferToAgentTool instead of this\n  function directly. TransferToAgentTool provides additional enum constraints\n  that prevent LLMs from hallucinating invalid agent names.\n\nArgs:\n  agent_name: the agent name to transfer to."
  signature: 'def transfer_to_agent(agent_name: str, tool_context: google.adk.tools.tool_context.ToolContext) -> None:'
  aliases:
  - google.adk.tools.transfer_to_agent
- rank: 1890
  id: google.adk.tools.url_context_tool
  name: url_context_tool
  file_path: src/google/adk/tools/url_context_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'url_context: UrlContextTool'
- rank: 1891
  id: google.adk.tools.url_context_tool.UrlContextTool
  name: UrlContextTool
  file_path: src/google/adk/tools/url_context_tool.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'A built-in tool that is automatically invoked by Gemini 2 models to retrieve content from the URLs and use that content to inform and shape its response.


    This tool operates internally within the model and does not require or perform

    local code execution.


    [Note: Inherited members from ABC are omitted.]'
  constructor_signature: 'def __init__(self):'
  methods:
  - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.LlmRequest) -> None:'
  inherited_methods:
    BaseTool:
    - signature: 'def run_async(self, *, args: dict[str, typing.Any], tool_context: google.adk.tools.tool_context.ToolContext) -> typing.Any:'
      docstring: "Runs the tool with the given arguments and context.\n\nNOTE:\n  - Required if this tool needs to run at the client side.\n  - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n    Gemini.\n\nArgs:\n  args: The LLM-filled arguments.\n  tool_context: The context of the tool.\n\nReturns:\n  The result of running the tool."
    - signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.llm_request.LlmRequest) -> None:'
      docstring: "Processes the outgoing LLM request for this tool.\n\nUse cases:\n- Most common use case is adding this tool to the LLM request.\n- Some tools may just preprocess the LLM request before it's sent out.\n\nArgs:\n  tool_context: The context of the tool.\n  llm_request: The outgoing LLM request, mutable this method."
    - signature: 'def from_config(cls: typing.Type[google.adk.tools.base_tool.SelfTool], config: google.adk.tools.tool_configs.ToolArgsConfig, config_abs_path: str) -> google.adk.tools.base_tool.SelfTool:'
      docstring: "Creates a tool instance from a config.\n\nThis default implementation uses inspect to automatically map config values\nto constructor arguments based on their type hints. Subclasses should\noverride this method for custom initialization logic.\n\nArgs:\n  config: The config for the tool.\n  config_abs_path: The absolute path to the config file that contains the\n    tool config.\n\nReturns:\n  The tool instance."
  inherited_properties:
    BaseTool:
    - signature: 'name: str'
      docstring: The name of the tool.
    - signature: 'description: str'
      docstring: The description of the tool.
    - signature: 'is_long_running: bool'
      docstring: 'Whether the tool is a long running operation, which typically returns a

        resource id first and finishes the operation later.'
    - signature: 'custom_metadata: typing.Optional[dict[str, typing.Any]]'
      docstring: 'The custom metadata of the BaseTool.


        An optional key-value pair for storing and retrieving tool-specific metadata,

        such as tool manifests, etc.


        NOTE: the entire dict must be JSON serializable.'
  omitted_inherited_members_from:
  - ABC
- rank: 1892
  id: google.adk.tools.url_context_tool.UrlContextTool.process_llm_request
  name: process_llm_request
  file_path: src/google/adk/tools/url_context_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.LlmRequest) -> None:'
- rank: 1893
  id: google.adk.tools.vertex_ai_search_tool
  name: vertex_ai_search_tool
  file_path: src/google/adk/tools/vertex_ai_search_tool.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'logger: logging.getLogger'
- rank: 1894
  id: google.adk.tools.vertex_ai_search_tool.VertexAiSearchTool.__init__
  name: __init__
  file_path: src/google/adk/tools/vertex_ai_search_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Initializes the Vertex AI Search tool.\n\nArgs:\n  data_store_id: The Vertex AI search data store resource ID in the format\n    of\n    \"projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}\".\n  data_store_specs: Specifications that define the specific DataStores to be\n    searched. It should only be set if engine is used.\n  search_engine_id: The Vertex AI search engine resource ID in the format of\n    \"projects/{project}/locations/{location}/collections/{collection}/engines/{engine}\".\n  filter: The filter to apply to the search results.\n  max_results: The maximum number of results to return.\n  bypass_multi_tools_limit: Whether to bypass the multi tools limitation,\n    so that the tool can be used with other tools in the same agent.\n\nRaises:\n  ValueError: If both data_store_id and search_engine_id are not specified\n  or both are specified."
  signature: 'def __init__(self, *, data_store_id: typing.Optional[str]=None, data_store_specs: typing.Optional[list[google.genai.types.VertexAISearchDataStoreSpec]]=None, search_engine_id: typing.Optional[str]=None, filter: typing.Optional[str]=None, max_results: typing.Optional[int]=None, bypass_multi_tools_limit: bool=False):'
- rank: 1895
  id: google.adk.tools.vertex_ai_search_tool.VertexAiSearchTool.process_llm_request
  name: process_llm_request
  file_path: src/google/adk/tools/vertex_ai_search_tool.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def process_llm_request(self, *, tool_context: google.adk.tools.tool_context.ToolContext, llm_request: google.adk.models.LlmRequest) -> None:'
- rank: 1896
  id: google.adk.utils
  name: utils
  file_path: src/google/adk/utils/__init__.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1897
  id: google.adk.utils.cache_performance_analyzer
  name: cache_performance_analyzer
  file_path: src/google/adk/utils/cache_performance_analyzer.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: 'Cache performance analysis utilities for ADK context caching system.


    This module provides tools to analyze cache performance metrics from event

    history, including hit ratios, cost savings, and cache refresh patterns.'
- rank: 1898
  id: google.adk.utils.cache_performance_analyzer.CachePerformanceAnalyzer.analyze_agent_cache_performance
  name: analyze_agent_cache_performance
  file_path: src/google/adk/utils/cache_performance_analyzer.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Analyze cache performance for agent.\n\nArgs:\n    session_id: Session to analyze\n    user_id: User ID for session lookup\n    app_name: App name for session lookup\n    agent_name: Agent to analyze\n\nReturns:\n    Performance analysis dictionary containing:\n    - status: \"active\" if cache data found, \"no_cache_data\" if none\n    - requests_with_cache: Number of requests that used caching\n    - avg_invocations_used: Average number of invocations each cache was used\n    - latest_cache: Resource name of most recent cache used\n    - cache_refreshes: Number of unique cache instances created\n    - total_invocations: Total number of invocations across all caches\n    - total_prompt_tokens: Total prompt tokens across all requests\n    - total_cached_tokens: Total cached content tokens across all requests\n    - cache_hit_ratio_percent: Percentage of tokens served from cache\n    - cache_utilization_ratio_percent: Percentage of requests with cache hits\n    - avg_cached_tokens_per_request:\
    \ Average cached tokens per request\n    - total_requests: Total number of requests processed\n    - requests_with_cache_hits: Number of requests that had cache hits"
  signature: 'def analyze_agent_cache_performance(self, session_id: str, user_id: str, app_name: str, agent_name: str) -> typing.Dict[str, typing.Any]:'
- rank: 1899
  id: google.adk.utils.content_utils
  name: content_utils
  file_path: src/google/adk/utils/content_utils.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def is_audio_part(part: google.genai.types.Part) -> bool:'
  - signature: 'def filter_audio_parts(content: google.genai.types.Content) -> types.Content | None:'
- rank: 1900
  id: google.adk.utils.content_utils.filter_audio_parts
  name: filter_audio_parts
  file_path: src/google/adk/utils/content_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def filter_audio_parts(content: google.genai.types.Content) -> types.Content | None:'
- rank: 1901
  id: google.adk.utils.content_utils.is_audio_part
  name: is_audio_part
  file_path: src/google/adk/utils/content_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def is_audio_part(part: google.genai.types.Part) -> bool:'
- rank: 1902
  id: google.adk.utils.context_utils
  name: context_utils
  file_path: src/google/adk/utils/context_utils.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: 'Utilities for ADK context management.


    This module is for ADK internal use only.

    Please do not rely on the implementation details.'
  properties:
  - signature: 'Aclosing: Any'
- rank: 1903
  id: google.adk.utils.env_utils
  name: env_utils
  file_path: src/google/adk/utils/env_utils.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: 'Utilities for environment variable handling.


    This module is for ADK internal use only.

    Please do not rely on the implementation details.'
  methods:
  - signature: 'def is_env_enabled(env_var_name: str, default: str) -> bool:'
    docstring: "Check if an environment variable is enabled.\n\nAn environment variable is considered enabled if its value (case-insensitive)\nis 'true' or '1'.\n\nArgs:\n  env_var_name: The name of the environment variable to check.\n  default: The default value to use if the environment variable is not set.\n    Defaults to '0'.\n\nReturns:\n  True if the environment variable is enabled, False otherwise.\n\nExamples:\n  >>> os.environ['MY_FLAG'] = 'true'\n  >>> is_env_enabled('MY_FLAG')\n  True\n\n  >>> os.environ['MY_FLAG'] = '1'\n  >>> is_env_enabled('MY_FLAG')\n  True\n\n  >>> os.environ['MY_FLAG'] = 'false'\n  >>> is_env_enabled('MY_FLAG')\n  False\n\n  >>> is_env_enabled('NONEXISTENT_FLAG')\n  False\n\n  >>> is_env_enabled('NONEXISTENT_FLAG', default='1')\n  True"
- rank: 1904
  id: google.adk.utils.env_utils.is_env_enabled
  name: is_env_enabled
  file_path: src/google/adk/utils/env_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Check if an environment variable is enabled.\n\nAn environment variable is considered enabled if its value (case-insensitive)\nis 'true' or '1'.\n\nArgs:\n  env_var_name: The name of the environment variable to check.\n  default: The default value to use if the environment variable is not set.\n    Defaults to '0'.\n\nReturns:\n  True if the environment variable is enabled, False otherwise.\n\nExamples:\n  >>> os.environ['MY_FLAG'] = 'true'\n  >>> is_env_enabled('MY_FLAG')\n  True\n\n  >>> os.environ['MY_FLAG'] = '1'\n  >>> is_env_enabled('MY_FLAG')\n  True\n\n  >>> os.environ['MY_FLAG'] = 'false'\n  >>> is_env_enabled('MY_FLAG')\n  False\n\n  >>> is_env_enabled('NONEXISTENT_FLAG')\n  False\n\n  >>> is_env_enabled('NONEXISTENT_FLAG', default='1')\n  True"
  signature: 'def is_env_enabled(env_var_name: str, default: str) -> bool:'
- rank: 1905
  id: google.adk.utils.feature_decorator
  name: feature_decorator
  file_path: src/google/adk/utils/feature_decorator.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: 'T: typing.TypeVar'
  - signature: 'working_in_progress: _make_feature_decorator'
  - signature: 'experimental: _make_feature_decorator'
- rank: 1906
  id: google.adk.utils.instructions_utils
  name: instructions_utils
  file_path: src/google/adk/utils/instructions_utils.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def inject_session_state(template: str, readonly_context: google.adk.agents.readonly_context.ReadonlyContext) -> str:'
    docstring: "Populates values in the instruction template, e.g. state, artifact, etc.\n\nThis method is intended to be used in InstructionProvider based instruction\nand global_instruction which are called with readonly_context.\n\ne.g.\n```\n...\nfrom google.adk.utils.instructions_utils import inject_session_state\n\nasync def build_instruction(\n    readonly_context: ReadonlyContext,\n) -> str:\n  return await inject_session_state(\n      'You can inject a state variable like {var_name} or an artifact '\n      '{artifact.file_name} into the instruction template.',\n      readonly_context,\n  )\n\nagent = Agent(\n    model=\"gemini-2.0-flash\",\n    name=\"agent\",\n    instruction=build_instruction,\n)\n```\n\nArgs:\n  template: The instruction template.\n  readonly_context: The read-only context\n\nReturns:\n  The instruction template with values populated."
  properties:
  - signature: '__all__: Any'
  - signature: 'logger: logging.getLogger'
- rank: 1907
  id: google.adk.utils.instructions_utils.inject_session_state
  name: inject_session_state
  file_path: src/google/adk/utils/instructions_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Populates values in the instruction template, e.g. state, artifact, etc.\n\nThis method is intended to be used in InstructionProvider based instruction\nand global_instruction which are called with readonly_context.\n\ne.g.\n```\n...\nfrom google.adk.utils.instructions_utils import inject_session_state\n\nasync def build_instruction(\n    readonly_context: ReadonlyContext,\n) -> str:\n  return await inject_session_state(\n      'You can inject a state variable like {var_name} or an artifact '\n      '{artifact.file_name} into the instruction template.',\n      readonly_context,\n  )\n\nagent = Agent(\n    model=\"gemini-2.0-flash\",\n    name=\"agent\",\n    instruction=build_instruction,\n)\n```\n\nArgs:\n  template: The instruction template.\n  readonly_context: The read-only context\n\nReturns:\n  The instruction template with values populated."
  signature: 'def inject_session_state(template: str, readonly_context: google.adk.agents.readonly_context.ReadonlyContext) -> str:'
- rank: 1908
  id: google.adk.utils.model_name_utils
  name: model_name_utils
  file_path: src/google/adk/utils/model_name_utils.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: Utilities for model name validation and parsing.
  methods:
  - signature: 'def extract_model_name(model_string: str) -> str:'
    docstring: "Extract the actual model name from either simple or path-based format.\n\nArgs:\n  model_string: Either a simple model name like \"gemini-2.5-pro\" or a\n    path-based model name like \"projects/.../models/gemini-2.0-flash-001\"\n\nReturns:\n  The extracted model name (e.g., \"gemini-2.5-pro\")"
  - signature: 'def is_gemini_model(model_string: typing.Optional[str]) -> bool:'
    docstring: "Check if the model is a Gemini model using regex patterns.\n\nArgs:\n  model_string: Either a simple model name or path-based model name\n\nReturns:\n  True if it's a Gemini model, False otherwise"
  - signature: 'def is_gemini_1_model(model_string: typing.Optional[str]) -> bool:'
    docstring: "Check if the model is a Gemini 1.x model using regex patterns.\n\nArgs:\n  model_string: Either a simple model name or path-based model name\n\nReturns:\n  True if it's a Gemini 1.x model, False otherwise"
  - signature: 'def is_gemini_2_or_above(model_string: typing.Optional[str]) -> bool:'
    docstring: "Check if the model is a Gemini 2.0 or newer model using semantic versions.\n\nArgs:\n  model_string: Either a simple model name or path-based model name\n\nReturns:\n  True if it's a Gemini 2.0+ model, False otherwise"
- rank: 1909
  id: google.adk.utils.model_name_utils.extract_model_name
  name: extract_model_name
  file_path: src/google/adk/utils/model_name_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Extract the actual model name from either simple or path-based format.\n\nArgs:\n  model_string: Either a simple model name like \"gemini-2.5-pro\" or a\n    path-based model name like \"projects/.../models/gemini-2.0-flash-001\"\n\nReturns:\n  The extracted model name (e.g., \"gemini-2.5-pro\")"
  signature: 'def extract_model_name(model_string: str) -> str:'
- rank: 1910
  id: google.adk.utils.model_name_utils.is_gemini_1_model
  name: is_gemini_1_model
  file_path: src/google/adk/utils/model_name_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Check if the model is a Gemini 1.x model using regex patterns.\n\nArgs:\n  model_string: Either a simple model name or path-based model name\n\nReturns:\n  True if it's a Gemini 1.x model, False otherwise"
  signature: 'def is_gemini_1_model(model_string: typing.Optional[str]) -> bool:'
- rank: 1911
  id: google.adk.utils.model_name_utils.is_gemini_2_or_above
  name: is_gemini_2_or_above
  file_path: src/google/adk/utils/model_name_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Check if the model is a Gemini 2.0 or newer model using semantic versions.\n\nArgs:\n  model_string: Either a simple model name or path-based model name\n\nReturns:\n  True if it's a Gemini 2.0+ model, False otherwise"
  signature: 'def is_gemini_2_or_above(model_string: typing.Optional[str]) -> bool:'
- rank: 1912
  id: google.adk.utils.model_name_utils.is_gemini_model
  name: is_gemini_model
  file_path: src/google/adk/utils/model_name_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Check if the model is a Gemini model using regex patterns.\n\nArgs:\n  model_string: Either a simple model name or path-based model name\n\nReturns:\n  True if it's a Gemini model, False otherwise"
  signature: 'def is_gemini_model(model_string: typing.Optional[str]) -> bool:'
- rank: 1913
  id: google.adk.utils.output_schema_utils
  name: output_schema_utils
  file_path: src/google/adk/utils/output_schema_utils.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: 'Utilities for Output Schema.


    This module is for ADK internal use only.

    Please do not rely on the implementation details.'
  methods:
  - signature: 'def can_use_output_schema_with_tools(model: typing.Union[str, google.adk.models.base_llm.BaseLlm]) -> bool:'
    docstring: Returns True if output schema with tools is supported.
- rank: 1914
  id: google.adk.utils.output_schema_utils.can_use_output_schema_with_tools
  name: can_use_output_schema_with_tools
  file_path: src/google/adk/utils/output_schema_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Returns True if output schema with tools is supported.
  signature: 'def can_use_output_schema_with_tools(model: typing.Union[str, google.adk.models.base_llm.BaseLlm]) -> bool:'
- rank: 1915
  id: google.adk.utils.streaming_utils
  name: streaming_utils
  file_path: src/google/adk/utils/streaming_utils.py
  type: MODULE
  group: Orphan
  usage_score: 0
- rank: 1916
  id: google.adk.utils.streaming_utils.StreamingResponseAggregator
  name: StreamingResponseAggregator
  file_path: src/google/adk/utils/streaming_utils.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'Aggregates partial streaming responses.


    It aggregates content from partial responses, and generates LlmResponses for

    individual (partial) model responses, as well as for aggregated content.'
  constructor_signature: 'def __init__(self) -> None:'
  methods:
  - signature: 'def process_response(self, response: google.genai.types.GenerateContentResponse) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
    docstring: "Processes a single model response.\n\nArgs:\n  response: The response to process.\n\nYields:\n  The generated LlmResponse(s), for the partial response, and the aggregated\n  response if needed."
  - signature: 'def close(self) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
    docstring: "Generate an aggregated response at the end, if needed.\n\nThis should be called after all the model responses are processed.\n\nReturns:\n  The aggregated LlmResponse."
- rank: 1917
  id: google.adk.utils.streaming_utils.StreamingResponseAggregator.__init__
  name: __init__
  file_path: src/google/adk/utils/streaming_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  signature: 'def __init__(self) -> None:'
- rank: 1918
  id: google.adk.utils.streaming_utils.StreamingResponseAggregator.close
  name: close
  file_path: src/google/adk/utils/streaming_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Generate an aggregated response at the end, if needed.\n\nThis should be called after all the model responses are processed.\n\nReturns:\n  The aggregated LlmResponse."
  signature: 'def close(self) -> typing.Optional[google.adk.models.llm_response.LlmResponse]:'
- rank: 1919
  id: google.adk.utils.streaming_utils.StreamingResponseAggregator.process_response
  name: process_response
  file_path: src/google/adk/utils/streaming_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Processes a single model response.\n\nArgs:\n  response: The response to process.\n\nYields:\n  The generated LlmResponse(s), for the partial response, and the aggregated\n  response if needed."
  signature: 'def process_response(self, response: google.genai.types.GenerateContentResponse) -> typing.AsyncGenerator[google.adk.models.llm_response.LlmResponse, None]:'
- rank: 1920
  id: google.adk.utils.variant_utils
  name: variant_utils
  file_path: src/google/adk/utils/variant_utils.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: 'Utilities for Google LLM variants.


    This module is for ADK internal use only.

    Please do not rely on the implementation details.'
  methods:
  - signature: 'def get_google_llm_variant() -> google.adk.utils.variant_utils.GoogleLLMVariant:'
  properties:
  - signature: '_GOOGLE_LLM_VARIANT_VERTEX_AI: str'
  - signature: '_GOOGLE_LLM_VARIANT_GEMINI_API: str'
- rank: 1921
  id: google.adk.utils.variant_utils.GoogleLLMVariant
  name: GoogleLLMVariant
  file_path: src/google/adk/utils/variant_utils.py
  type: CLASS
  group: Orphan
  usage_score: 0
  docstring: 'The Google LLM variant to use.

    see https://google.github.io/adk-docs/get-started/quickstart/#set-up-the-model


    [Note: Inherited members from Enum are omitted.]'
  properties:
  - signature: 'VERTEX_AI: Any'
    docstring: For using credentials from Google Vertex AI
  - signature: 'GEMINI_API: Any'
    docstring: For using API Key from Google AI Studio
  omitted_inherited_members_from:
  - Enum
- rank: 1922
  id: google.adk.utils.vertex_ai_utils
  name: vertex_ai_utils
  file_path: src/google/adk/utils/vertex_ai_utils.py
  type: MODULE
  group: Orphan
  usage_score: 0
  docstring: 'Utilities for Vertex AI. Includes helper functions for Express Mode.


    This module is for ADK internal use only.

    Please do not rely on the implementation details.'
  methods:
  - signature: 'def get_express_mode_api_key(project: typing.Optional[str], location: typing.Optional[str], express_mode_api_key: typing.Optional[str]) -> typing.Optional[str]:'
    docstring: Validates and returns the API key for Express Mode.
- rank: 1923
  id: google.adk.utils.vertex_ai_utils.get_express_mode_api_key
  name: get_express_mode_api_key
  file_path: src/google/adk/utils/vertex_ai_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: Validates and returns the API key for Express Mode.
  signature: 'def get_express_mode_api_key(project: typing.Optional[str], location: typing.Optional[str], express_mode_api_key: typing.Optional[str]) -> typing.Optional[str]:'
- rank: 1924
  id: google.adk.utils.yaml_utils
  name: yaml_utils
  file_path: src/google/adk/utils/yaml_utils.py
  type: MODULE
  group: Orphan
  usage_score: 0
  methods:
  - signature: 'def load_yaml_file(file_path: typing.Union[str, pathlib.Path]) -> typing.Any:'
    docstring: "Loads a YAML file and returns its content.\n\nArgs:\n  file_path: Path to the YAML file.\n\nReturns:\n  The content of the YAML file.\n\nRaises:\n  FileNotFoundError: If the file_path does not exist."
  - signature: 'def dump_pydantic_to_yaml(model: pydantic.BaseModel, file_path: typing.Union[str, pathlib.Path], *, indent: int=2, sort_keys: bool=True, exclude_none: bool=True, exclude_defaults: bool=True, exclude: typing.Optional[pydantic.main.IncEx]=None) -> None:'
    docstring: "Dump a Pydantic model to a YAML file with multiline strings using | style.\n\nArgs:\n  model: The Pydantic model instance to dump.\n  file_path: Path to the output YAML file.\n  indent: Number of spaces for indentation (default: 2).\n  sort_keys: Whether to sort dictionary keys (default: True).\n  exclude_none: Exclude fields with None values (default: True).\n  exclude_defaults: Exclude fields with default values (default: True).\n  exclude: Fields to exclude from the output. Can be a set of field names or\n    a nested dict for fine-grained exclusion (default: None)."
- rank: 1925
  id: google.adk.utils.yaml_utils.dump_pydantic_to_yaml
  name: dump_pydantic_to_yaml
  file_path: src/google/adk/utils/yaml_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Dump a Pydantic model to a YAML file with multiline strings using | style.\n\nArgs:\n  model: The Pydantic model instance to dump.\n  file_path: Path to the output YAML file.\n  indent: Number of spaces for indentation (default: 2).\n  sort_keys: Whether to sort dictionary keys (default: True).\n  exclude_none: Exclude fields with None values (default: True).\n  exclude_defaults: Exclude fields with default values (default: True).\n  exclude: Fields to exclude from the output. Can be a set of field names or\n    a nested dict for fine-grained exclusion (default: None)."
  signature: 'def dump_pydantic_to_yaml(model: pydantic.BaseModel, file_path: typing.Union[str, pathlib.Path], *, indent: int=2, sort_keys: bool=True, exclude_none: bool=True, exclude_defaults: bool=True, exclude: typing.Optional[pydantic.main.IncEx]=None) -> None:'
- rank: 1926
  id: google.adk.utils.yaml_utils.load_yaml_file
  name: load_yaml_file
  file_path: src/google/adk/utils/yaml_utils.py
  type: METHOD
  group: Orphan
  usage_score: 0
  docstring: "Loads a YAML file and returns its content.\n\nArgs:\n  file_path: Path to the YAML file.\n\nReturns:\n  The content of the YAML file.\n\nRaises:\n  FileNotFoundError: If the file_path does not exist."
  signature: 'def load_yaml_file(file_path: typing.Union[str, pathlib.Path]) -> typing.Any:'
- rank: 1927
  id: google.adk.version
  name: version
  file_path: src/google/adk/version.py
  type: MODULE
  group: Orphan
  usage_score: 0
  properties:
  - signature: '__version__: str'
