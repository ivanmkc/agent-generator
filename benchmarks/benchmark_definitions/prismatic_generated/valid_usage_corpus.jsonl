{"target_id": "google.adk.tools.agent_tool.AgentTool", "code": "import sys\nimport asyncio\nfrom unittest.mock import MagicMock, patch\n\n# We need to mock dependencies that are not easily available or we want to control\n# google.adk.types is likely available, we will try to use it.\n# If not, we will mock it.\n\nclass StubAgent:\n    def __init__(self, name=\"stub_agent\", description=\"A stub agent\"):\n        self.name = name\n        self.description = description\n        self.input_schema = None \n        self.output_schema = None\n\nclass StubEvent:\n    def __init__(self, content=None, actions=None):\n        self.content = content\n        self.actions = actions or StubActions()\n\nclass StubActions:\n    def __init__(self):\n        self.state_delta = {}\n        self.skip_summarization = False\n\nclass StubSession:\n    def __init__(self, user_id):\n        self.id = \"session_123\"\n        self.user_id = user_id\n\nclass StubSessionService:\n    async def create_session(self, app_name, user_id, state):\n        return StubSession(user_id)\n\nclass StubRunner:\n    def __init__(self, *args, **kwargs):\n        self.session_service = StubSessionService()\n\n    async def run_async(self, user_id, session_id, new_message):\n        # We need to construct types.Content. \n        # We'll import types inside to be sure we use the real one if possible\n        from google.adk import types\n        \n        # Simulate a response\n        content = types.Content(\n            role=\"model\",\n            parts=[types.Part.from_text(text=\"Stubbed response from runner\")]\n        )\n        yield StubEvent(content=content)\n\n    async def close(self):\n        pass\n\nclass StubInvocationContext:\n    def __init__(self):\n        self.app_name = \"test_app\"\n        self.plugin_manager = MagicMock()\n        self.plugin_manager.plugins = []\n        self.credential_service = MagicMock()\n        self.user_id = \"test_user\"\n\nclass StubState:\n    def __init__(self):\n        self._data = {}\n    def to_dict(self):\n        return self._data\n    def update(self, delta):\n        self._data.update(delta)\n\nclass StubToolContext:\n    def __init__(self):\n        self._invocation_context = StubInvocationContext()\n        self.state = StubState()\n        self.actions = StubActions()\n\nasync def run_test():\n    print(\"Starting test...\")\n    try:\n        from google.adk.tools.agent_tool import AgentTool\n        \n        # Patch dependencies\n        # We patch Runner where it is imported in agent_tool if possible, \n        # but the import is inside the function.\n        # \"from ..runners import Runner\" inside run_async means it loads google.adk.runners.Runner\n        # So we patch 'google.adk.runners.Runner'\n        \n        runner_patcher = patch('google.adk.runners.Runner', side_effect=StubRunner)\n        # We also need to patch ForwardingArtifactService which is expected to be in agent_tool module scope\n        # but likely imported/defined there. \n        # Since we don't know where it comes from exactly (it might be imported), we patch it in agent_tool.\n        artifact_patcher = patch('google.adk.tools.agent_tool.ForwardingArtifactService')\n        \n        # Patch services used in run_async\n        session_service_patcher = patch('google.adk.tools.agent_tool.InMemorySessionService')\n        memory_service_patcher = patch('google.adk.tools.agent_tool.InMemoryMemoryService')\n\n        with runner_patcher, artifact_patcher, session_service_patcher, memory_service_patcher:\n            agent = StubAgent()\n            tool = AgentTool(agent=agent)\n            \n            context = StubToolContext()\n            args = {\"request\": \"Hello Agent\"}\n            \n            print(\"Calling run_async...\")\n            result = await tool.run_async(args=args, tool_context=context)\n            print(f\"Tool execution result: {result}\")\n            \n    except Exception as e:\n        print(f\"Test failed with error: {e}\")\n        import traceback\n        traceback.print_exc()\n\nif __name__ == \"__main__\":\n    asyncio.run(run_test())\n", "stdout": "", "timestamp": 1768173559.9037051}
{"target_id": "google.adk.tools.agent_tool.AgentTool", "code": "print(\"Hello World\")\n", "stdout": "Hello World\n", "timestamp": 1768173824.195918}
{"target_id": "google.adk.tools.agent_tool.AgentTool", "code": "try:\n    import nest_asyncio\n    nest_asyncio.apply()\n    print(\"nest_asyncio applied\")\nexcept ImportError:\n    print(\"nest_asyncio not found\")\n\nimport asyncio\n# ... reuse previous logic ...\nasync def main():\n    print(\"Main running\")\n\nif __name__ == \"__main__\":\n    try:\n        asyncio.run(main())\n    except Exception as e:\n        print(f\"Error: {e}\")\n", "stdout": "nest_asyncio applied\n", "timestamp": 1768174211.518665}
